<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Knowledge Management Base</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class=""><a href="mytopic/index.html"><strong aria-hidden="true">1.</strong> My Topic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="mytopic/rust_trait_topic.html"><strong aria-hidden="true">1.1.</strong> Rust trait topic</a></li><li class=""><a href="mytopic/rust_copy_clone.html"><strong aria-hidden="true">1.2.</strong> Rust difference between copy and clone</a></li><li class=""><a href="mytopic/ownership_borrow_move_reference.html"><strong aria-hidden="true">1.3.</strong> Rust ownership borrow and move reference</a></li><li class=""><a href="mytopic/str_string.html"><strong aria-hidden="true">1.4.</strong> Rust &amp;str and String</a></li><li class=""><a href="mytopic/closure.html"><strong aria-hidden="true">1.5.</strong> Rust closure</a></li></ol></li><li class=""><a href="algorithm/index.html"><strong aria-hidden="true">2.</strong> Algorithm</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="algorithm/geektimealgorithm/index.html"><strong aria-hidden="true">2.1.</strong> 极客时间 数据结构与算法之美 geeitime algorithm</a></li><li class=""><a href="algorithm/algorithmbook/index.html"><strong aria-hidden="true">2.2.</strong> Algorithm Book</a></li><li class=""><a href="algorithm/geektimemath/index.html"><strong aria-hidden="true">2.3.</strong> 极客时间 程序员的数学基础课 geektime math</a></li></ol></li><li class=""><a href="frontend/index.html"><strong aria-hidden="true">3.</strong> Frontend</a></li><li class=""><a href="tao/index.html"><strong aria-hidden="true">4.</strong> 编程之道 Tao of Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="tao/typesystem/index.html"><strong aria-hidden="true">4.1.</strong> 类型系统</a></li><li class=""><a href="tao/memory/index.html"><strong aria-hidden="true">4.2.</strong> 内存管理</a></li><li class=""><a href="tao/ownership/index.html"><strong aria-hidden="true">4.3.</strong> 所有权系统</a></li><li class=""><a href="tao/functionclosure/index.html"><strong aria-hidden="true">4.4.</strong> 函数 闭包与迭代器</a></li><li class=""><a href="tao/jiegouhua/index.html"><strong aria-hidden="true">4.5.</strong> 结构化编程</a></li><li class=""><a href="tao/stringcollection/index.html"><strong aria-hidden="true">4.6.</strong> 字符串与集合类型</a></li><li class=""><a href="tao/jianzhuang/index.html"><strong aria-hidden="true">4.7.</strong> 构建健壮的程序</a></li><li class=""><a href="tao/module/index.html"><strong aria-hidden="true">4.8.</strong> 模块化编程</a></li><li class=""><a href="tao/bingfa/index.html"><strong aria-hidden="true">4.9.</strong> 安全并发</a></li><li class=""><a href="tao/macro/index.html"><strong aria-hidden="true">4.10.</strong> 元编程</a></li><li class=""><a href="tao/unsafe/index.html"><strong aria-hidden="true">4.11.</strong> 超越安全的边界</a></li></ol></li><li class=""><a href="rustexample/index.html"><strong aria-hidden="true">5.</strong> Rust by Example</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/hello.html"><strong aria-hidden="true">5.1.</strong> Hello World</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/hello/comment.html"><strong aria-hidden="true">5.1.1.</strong> Comments</a></li><li class=""><a href="rustexample/hello/print.html"><strong aria-hidden="true">5.1.2.</strong> Formatted print</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/hello/print/print_debug.html"><strong aria-hidden="true">5.1.2.1.</strong> Debug</a></li><li class=""><a href="rustexample/hello/print/print_display.html"><strong aria-hidden="true">5.1.2.2.</strong> Display</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/hello/print/print_display/testcase_list.html"><strong aria-hidden="true">5.1.2.2.1.</strong> Testcase: List</a></li></ol></li><li class=""><a href="rustexample/hello/print/fmt.html"><strong aria-hidden="true">5.1.2.3.</strong> Formatting</a></li></ol></li></ol></li><li class=""><a href="rustexample/primitives.html"><strong aria-hidden="true">5.2.</strong> Primitives</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/primitives/literals.html"><strong aria-hidden="true">5.2.1.</strong> Literals and operators</a></li><li class=""><a href="rustexample/primitives/tuples.html"><strong aria-hidden="true">5.2.2.</strong> Tuples</a></li><li class=""><a href="rustexample/primitives/array.html"><strong aria-hidden="true">5.2.3.</strong> Arrays and Slices</a></li></ol></li><li class=""><a href="rustexample/custom_types.html"><strong aria-hidden="true">5.3.</strong> Custom Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/custom_types/structs.html"><strong aria-hidden="true">5.3.1.</strong> Structures</a></li><li class=""><a href="rustexample/custom_types/enum.html"><strong aria-hidden="true">5.3.2.</strong> Enums</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/custom_types/enum/enum_use.html"><strong aria-hidden="true">5.3.2.1.</strong> use</a></li><li class=""><a href="rustexample/custom_types/enum/c_like.html"><strong aria-hidden="true">5.3.2.2.</strong> C-like</a></li><li class=""><a href="rustexample/custom_types/enum/testcase_linked_list.html"><strong aria-hidden="true">5.3.2.3.</strong> Testcase: linked-list</a></li></ol></li><li class=""><a href="rustexample/custom_types/constants.html"><strong aria-hidden="true">5.3.3.</strong> constants</a></li></ol></li><li class=""><a href="rustexample/variable_bindings.html"><strong aria-hidden="true">5.4.</strong> Variable Bindings</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/variable_bindings/mut.html"><strong aria-hidden="true">5.4.1.</strong> Mutability</a></li><li class=""><a href="rustexample/variable_bindings/scope.html"><strong aria-hidden="true">5.4.2.</strong> Scope and Shadowing</a></li><li class=""><a href="rustexample/variable_bindings/declare.html"><strong aria-hidden="true">5.4.3.</strong> Declare first</a></li></ol></li><li class=""><a href="rustexample/types.html"><strong aria-hidden="true">5.5.</strong> Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/types/cast.html"><strong aria-hidden="true">5.5.1.</strong> Casting</a></li><li class=""><a href="rustexample/types/literals.html"><strong aria-hidden="true">5.5.2.</strong> Literals</a></li><li class=""><a href="rustexample/types/inference.html"><strong aria-hidden="true">5.5.3.</strong> Inference</a></li><li class=""><a href="rustexample/types/alias.html"><strong aria-hidden="true">5.5.4.</strong> Aliasing</a></li></ol></li><li class=""><a href="rustexample/conversion.html"><strong aria-hidden="true">5.6.</strong> Conversion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/conversion/from_into.html"><strong aria-hidden="true">5.6.1.</strong> From and Into</a></li><li class=""><a href="rustexample/conversion/string.html"><strong aria-hidden="true">5.6.2.</strong> To and from Strings</a></li></ol></li><li class=""><a href="rustexample/expression.html"><strong aria-hidden="true">5.7.</strong> Expressions</a></li><li class=""><a href="rustexample/flow_control.html"><strong aria-hidden="true">5.8.</strong> Flow of Control</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/flow_control/if_else.html"><strong aria-hidden="true">5.8.1.</strong> if/else</a></li><li class=""><a href="rustexample/flow_control/loop.html"><strong aria-hidden="true">5.8.2.</strong> loop</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/flow_control/loop/nested.html"><strong aria-hidden="true">5.8.2.1.</strong> Nesting and labels</a></li><li class=""><a href="rustexample/flow_control/loop/return.html"><strong aria-hidden="true">5.8.2.2.</strong> Returning from loops</a></li></ol></li><li class=""><a href="rustexample/flow_control/while.html"><strong aria-hidden="true">5.8.3.</strong> while</a></li><li class=""><a href="rustexample/flow_control/for.html"><strong aria-hidden="true">5.8.4.</strong> for and range</a></li><li class=""><a href="rustexample/flow_control/match.html"><strong aria-hidden="true">5.8.5.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/flow_control/match/destructuring.html"><strong aria-hidden="true">5.8.5.1.</strong> Destructuring</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/flow_control/match/destructuring/destructure_tuple.html"><strong aria-hidden="true">5.8.5.1.1.</strong> tuples</a></li><li class=""><a href="rustexample/flow_control/match/destructuring/destructure_enum.html"><strong aria-hidden="true">5.8.5.1.2.</strong> enums</a></li><li class=""><a href="rustexample/flow_control/match/destructuring/destructure_pointers.html"><strong aria-hidden="true">5.8.5.1.3.</strong> pointers/ref</a></li><li class=""><a href="rustexample/flow_control/match/destructuring/destructure_structures.html"><strong aria-hidden="true">5.8.5.1.4.</strong> structs</a></li></ol></li><li class=""><a href="rustexample/flow_control/match/guard.html"><strong aria-hidden="true">5.8.5.2.</strong> Guards</a></li><li class=""><a href="rustexample/flow_control/match/binding.html"><strong aria-hidden="true">5.8.5.3.</strong> Binding</a></li></ol></li><li class=""><a href="rustexample/flow_control/if_let.html"><strong aria-hidden="true">5.8.6.</strong> if let</a></li><li class=""><a href="rustexample/flow_control/while_let.html"><strong aria-hidden="true">5.8.7.</strong> while let</a></li></ol></li><li class=""><a href="rustexample/fn.html"><strong aria-hidden="true">5.9.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/fn/methods.html"><strong aria-hidden="true">5.9.1.</strong> Methods</a></li><li class=""><a href="rustexample/fn/closures.html"><strong aria-hidden="true">5.9.2.</strong> Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/fn/closures/capture.html"><strong aria-hidden="true">5.9.2.1.</strong> Capturing</a></li><li class=""><a href="rustexample/fn/closures/input_parameters.html"><strong aria-hidden="true">5.9.2.2.</strong> As input parameters</a></li><li class=""><a href="rustexample/fn/closures/anonymity.html"><strong aria-hidden="true">5.9.2.3.</strong> Type anonymity</a></li><li class=""><a href="rustexample/fn/closures/input_functions.html"><strong aria-hidden="true">5.9.2.4.</strong> Input functions</a></li><li class=""><a href="rustexample/fn/closures/output_parameters.html"><strong aria-hidden="true">5.9.2.5.</strong> As output parameters</a></li><li class=""><a href="rustexample/fn/closures/closure_examples.html"><strong aria-hidden="true">5.9.2.6.</strong> Examples in std</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/fn/closures/closure_examples/iter_any.html"><strong aria-hidden="true">5.9.2.6.1.</strong> Iterator::any</a></li><li class=""><a href="rustexample/fn/closures/closure_examples/iter_find.html"><strong aria-hidden="true">5.9.2.6.2.</strong> Iterator::find</a></li></ol></li></ol></li><li class=""><a href="rustexample/fn/hof.html"><strong aria-hidden="true">5.9.3.</strong> Higher Order Functions</a></li><li class=""><a href="rustexample/fn/diverging.html"><strong aria-hidden="true">5.9.4.</strong> Diverging functions</a></li></ol></li><li class=""><a href="rustexample/mod.html"><strong aria-hidden="true">5.10.</strong> Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/mod/visibility.html"><strong aria-hidden="true">5.10.1.</strong> Visibility</a></li><li class=""><a href="rustexample/mod/struct_visibility.html"><strong aria-hidden="true">5.10.2.</strong> Struct visibility</a></li><li class=""><a href="rustexample/mod/use.html"><strong aria-hidden="true">5.10.3.</strong> The use declaration</a></li><li class=""><a href="rustexample/mod/super.html"><strong aria-hidden="true">5.10.4.</strong> super and self</a></li><li class=""><a href="rustexample/mod/split.html"><strong aria-hidden="true">5.10.5.</strong> File hierarchy</a></li></ol></li><li class=""><a href="rustexample/crates.html"><strong aria-hidden="true">5.11.</strong> Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/crates/lib.html"><strong aria-hidden="true">5.11.1.</strong> Library</a></li><li class=""><a href="rustexample/crates/link.html"><strong aria-hidden="true">5.11.2.</strong> extern crate</a></li></ol></li><li class=""><a href="rustexample/cargo.html"><strong aria-hidden="true">5.12.</strong> Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/cargo/deps.html"><strong aria-hidden="true">5.12.1.</strong> Dependencies</a></li><li class=""><a href="rustexample/cargo/conventions.html"><strong aria-hidden="true">5.12.2.</strong> Conventions</a></li><li class=""><a href="rustexample/cargo/test.html"><strong aria-hidden="true">5.12.3.</strong> Tests</a></li><li class=""><a href="rustexample/cargo/build_scripts.html"><strong aria-hidden="true">5.12.4.</strong> Build Scripts</a></li></ol></li><li class=""><a href="rustexample/attribute.html"><strong aria-hidden="true">5.13.</strong> Attributes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/attribute/unused.html"><strong aria-hidden="true">5.13.1.</strong> dead_code</a></li><li class=""><a href="rustexample/attribute/crate.html"><strong aria-hidden="true">5.13.2.</strong> Crates</a></li><li class=""><a href="rustexample/attribute/cfg.html"><strong aria-hidden="true">5.13.3.</strong> cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/attribute/cfg/custom.html"><strong aria-hidden="true">5.13.3.1.</strong> Custom</a></li></ol></li></ol></li><li class=""><a href="rustexample/generics.html"><strong aria-hidden="true">5.14.</strong> Generics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/generics/gen_fn.html"><strong aria-hidden="true">5.14.1.</strong> Functions</a></li><li class=""><a href="rustexample/generics/impl.html"><strong aria-hidden="true">5.14.2.</strong> Implementation</a></li><li class=""><a href="rustexample/generics/gen_trait.html"><strong aria-hidden="true">5.14.3.</strong> Traits</a></li><li class=""><a href="rustexample/generics/bounds.html"><strong aria-hidden="true">5.14.4.</strong> Bounds</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/generics/bounds/testcase_empty.html"><strong aria-hidden="true">5.14.4.1.</strong> Testcase: empty bounds</a></li></ol></li><li class=""><a href="rustexample/generics/multi_bounds.html"><strong aria-hidden="true">5.14.5.</strong> Multiple bounds</a></li><li class=""><a href="rustexample/generics/where.html"><strong aria-hidden="true">5.14.6.</strong> Where clauses</a></li><li class=""><a href="rustexample/generics/new_types.html"><strong aria-hidden="true">5.14.7.</strong> New Type Idiom</a></li><li class=""><a href="rustexample/generics/assoc_items.html"><strong aria-hidden="true">5.14.8.</strong> Associated items</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/generics/assoc_items/the_problem.html"><strong aria-hidden="true">5.14.8.1.</strong> The Problem</a></li><li class=""><a href="rustexample/generics/assoc_items/types.html"><strong aria-hidden="true">5.14.8.2.</strong> Associated types</a></li></ol></li><li class=""><a href="rustexample/generics/phantom.html"><strong aria-hidden="true">5.14.9.</strong> Phantom type parameters</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/generics/phantom/testcase_units.html"><strong aria-hidden="true">5.14.9.1.</strong> Testcase: unit clarification</a></li></ol></li></ol></li><li class=""><a href="rustexample/scope.html"><strong aria-hidden="true">5.15.</strong> Scoping rules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/scope/raii.html"><strong aria-hidden="true">5.15.1.</strong> RAII</a></li><li class=""><a href="rustexample/scope/move.html"><strong aria-hidden="true">5.15.2.</strong> Ownership and moves</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/scope/move/mut.html"><strong aria-hidden="true">5.15.2.1.</strong> Mutability</a></li></ol></li><li class=""><a href="rustexample/scope/borrow.html"><strong aria-hidden="true">5.15.3.</strong> Borrowing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/scope/borrow/mut.html"><strong aria-hidden="true">5.15.3.1.</strong> Mutability</a></li><li class=""><a href="rustexample/scope/borrow/freeze.html"><strong aria-hidden="true">5.15.3.2.</strong> Freezing</a></li><li class=""><a href="rustexample/scope/borrow/alias.html"><strong aria-hidden="true">5.15.3.3.</strong> Aliasing</a></li><li class=""><a href="rustexample/scope/borrow/ref.html"><strong aria-hidden="true">5.15.3.4.</strong> The ref pattern</a></li></ol></li><li class=""><a href="rustexample/scope/lifetime.html"><strong aria-hidden="true">5.15.4.</strong> Lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/scope/lifetime/explicit.html"><strong aria-hidden="true">5.15.4.1.</strong> Explicit annotation</a></li><li class=""><a href="rustexample/scope/lifetime/fn.html"><strong aria-hidden="true">5.15.4.2.</strong> Functions</a></li><li class=""><a href="rustexample/scope/lifetime/methods.html"><strong aria-hidden="true">5.15.4.3.</strong> Methods</a></li><li class=""><a href="rustexample/scope/lifetime/struct.html"><strong aria-hidden="true">5.15.4.4.</strong> Structs</a></li><li class=""><a href="rustexample/scope/lifetime/trait.html"><strong aria-hidden="true">5.15.4.5.</strong> Traits</a></li><li class=""><a href="rustexample/scope/lifetime/lifetime_bounds.html"><strong aria-hidden="true">5.15.4.6.</strong> Bounds</a></li><li class=""><a href="rustexample/scope/lifetime/lifetime_coercion.html"><strong aria-hidden="true">5.15.4.7.</strong> Coercion</a></li><li class=""><a href="rustexample/scope/lifetime/static_lifetime.html"><strong aria-hidden="true">5.15.4.8.</strong> Static</a></li><li class=""><a href="rustexample/scope/lifetime/elision.html"><strong aria-hidden="true">5.15.4.9.</strong> Elision</a></li></ol></li></ol></li><li class=""><a href="rustexample/trait.html"><strong aria-hidden="true">5.16.</strong> Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/trait/derive.html"><strong aria-hidden="true">5.16.1.</strong> Derive</a></li><li class=""><a href="rustexample/trait/ops.html"><strong aria-hidden="true">5.16.2.</strong> Operator Overloading</a></li><li class=""><a href="rustexample/trait/drop.html"><strong aria-hidden="true">5.16.3.</strong> Drop</a></li><li class=""><a href="rustexample/trait/iter.html"><strong aria-hidden="true">5.16.4.</strong> Iterators</a></li><li class=""><a href="rustexample/trait/clone.html"><strong aria-hidden="true">5.16.5.</strong> Clone</a></li></ol></li><li class=""><a href="rustexample/macros.html"><strong aria-hidden="true">5.17.</strong> macro_rules!</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/macros/syntax.html"><strong aria-hidden="true">5.17.1.</strong> Syntax</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/macros/designators.html"><strong aria-hidden="true">5.17.1.1.</strong> Designators</a></li><li class=""><a href="rustexample/macros/overload.html"><strong aria-hidden="true">5.17.1.2.</strong> Overload</a></li><li class=""><a href="rustexample/macros/repeat.html"><strong aria-hidden="true">5.17.1.3.</strong> Repeat</a></li></ol></li><li class=""><a href="rustexample/macros/dry.html"><strong aria-hidden="true">5.17.2.</strong> DRY (Don't Repeat Yourself)</a></li><li class=""><a href="rustexample/macros/dsl.html"><strong aria-hidden="true">5.17.3.</strong> DSL (Domain Specific Languages)</a></li><li class=""><a href="rustexample/macros/variadics.html"><strong aria-hidden="true">5.17.4.</strong> Variadics</a></li></ol></li><li class=""><a href="rustexample/error.html"><strong aria-hidden="true">5.18.</strong> Error handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/error/panic.html"><strong aria-hidden="true">5.18.1.</strong> panic</a></li><li class=""><a href="rustexample/error/option_unwrap.html"><strong aria-hidden="true">5.18.2.</strong> Option &amp; unwrap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/error/option_unwrap/map.html"><strong aria-hidden="true">5.18.2.1.</strong> Combinators: map</a></li><li class=""><a href="rustexample/error/option_unwrap/and_then.html"><strong aria-hidden="true">5.18.2.2.</strong> Combinators: and_then</a></li></ol></li><li class=""><a href="rustexample/error/result.html"><strong aria-hidden="true">5.18.3.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/error/result/result_map.html"><strong aria-hidden="true">5.18.3.1.</strong> map for Result</a></li><li class=""><a href="rustexample/error/result/result_alias.html"><strong aria-hidden="true">5.18.3.2.</strong> aliases for Result</a></li><li class=""><a href="rustexample/error/result/early_returns.html"><strong aria-hidden="true">5.18.3.3.</strong> Early returns</a></li><li class=""><a href="rustexample/error/result/enter_question_mark.html"><strong aria-hidden="true">5.18.3.4.</strong> Introducing ?</a></li></ol></li><li class=""><a href="rustexample/error/multiple_error_types.html"><strong aria-hidden="true">5.18.4.</strong> Multiple error types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/error/multiple_error_types/option_result.html"><strong aria-hidden="true">5.18.4.1.</strong> Pulling Results out of Options</a></li><li class=""><a href="rustexample/error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">5.18.4.2.</strong> Defining an error type</a></li><li class=""><a href="rustexample/error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">5.18.4.3.</strong> Boxing errors</a></li><li class=""><a href="rustexample/error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">5.18.4.4.</strong> Other uses of ?</a></li><li class=""><a href="rustexample/error/multiple_error_types/wrap_error.html"><strong aria-hidden="true">5.18.4.5.</strong> Wrapping errors</a></li></ol></li><li class=""><a href="rustexample/error/iter_result.html"><strong aria-hidden="true">5.18.5.</strong> Iterating over Results</a></li></ol></li><li class=""><a href="rustexample/std.html"><strong aria-hidden="true">5.19.</strong> Std library types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/std/box.html"><strong aria-hidden="true">5.19.1.</strong> Box, stack and heap</a></li><li class=""><a href="rustexample/std/vec.html"><strong aria-hidden="true">5.19.2.</strong> Vectors</a></li><li class=""><a href="rustexample/std/str.html"><strong aria-hidden="true">5.19.3.</strong> Strings</a></li><li class=""><a href="rustexample/std/option.html"><strong aria-hidden="true">5.19.4.</strong> Option</a></li><li class=""><a href="rustexample/std/result.html"><strong aria-hidden="true">5.19.5.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/std/result/question_mark.html"><strong aria-hidden="true">5.19.5.1.</strong> ?</a></li></ol></li><li class=""><a href="rustexample/std/panic.html"><strong aria-hidden="true">5.19.6.</strong> panic!</a></li><li class=""><a href="rustexample/std/hash.html"><strong aria-hidden="true">5.19.7.</strong> HashMap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/std/hash/alt_key_types.html"><strong aria-hidden="true">5.19.7.1.</strong> Alternate/custom key types</a></li><li class=""><a href="rustexample/std/hash/hashset.html"><strong aria-hidden="true">5.19.7.2.</strong> HashSet</a></li></ol></li></ol></li><li class=""><a href="rustexample/std_misc.html"><strong aria-hidden="true">5.20.</strong> Std misc</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/std_misc/threads.html"><strong aria-hidden="true">5.20.1.</strong> Threads</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/std_misc/threads/testcase_mapreduce.html"><strong aria-hidden="true">5.20.1.1.</strong> Testcase: map-reduce</a></li></ol></li><li class=""><a href="rustexample/std_misc/channels.html"><strong aria-hidden="true">5.20.2.</strong> Channels</a></li><li class=""><a href="rustexample/std_misc/path.html"><strong aria-hidden="true">5.20.3.</strong> Path</a></li><li class=""><a href="rustexample/std_misc/file.html"><strong aria-hidden="true">5.20.4.</strong> File I/O</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/std_misc/file/open.html"><strong aria-hidden="true">5.20.4.1.</strong> open</a></li><li class=""><a href="rustexample/std_misc/file/create.html"><strong aria-hidden="true">5.20.4.2.</strong> create</a></li><li class=""><a href="rustexample/std_misc/file/read_lines.html"><strong aria-hidden="true">5.20.4.3.</strong> read lines</a></li></ol></li><li class=""><a href="rustexample/std_misc/process.html"><strong aria-hidden="true">5.20.5.</strong> Child processes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/std_misc/process/pipe.html"><strong aria-hidden="true">5.20.5.1.</strong> Pipes</a></li><li class=""><a href="rustexample/std_misc/process/wait.html"><strong aria-hidden="true">5.20.5.2.</strong> Wait</a></li></ol></li><li class=""><a href="rustexample/std_misc/fs.html"><strong aria-hidden="true">5.20.6.</strong> Filesystem Operations</a></li><li class=""><a href="rustexample/std_misc/arg.html"><strong aria-hidden="true">5.20.7.</strong> Program arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/std_misc/arg/matching.html"><strong aria-hidden="true">5.20.7.1.</strong> Argument parsing</a></li></ol></li><li class=""><a href="rustexample/std_misc/ffi.html"><strong aria-hidden="true">5.20.8.</strong> Foreign Function Interface</a></li></ol></li><li class=""><a href="rustexample/testing.html"><strong aria-hidden="true">5.21.</strong> Testing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/testing/unit_testing.html"><strong aria-hidden="true">5.21.1.</strong> Unit testing</a></li><li class=""><a href="rustexample/testing/doc_testing.html"><strong aria-hidden="true">5.21.2.</strong> Documentation testing</a></li><li class=""><a href="rustexample/testing/integration_testing.html"><strong aria-hidden="true">5.21.3.</strong> Integration testing</a></li><li class=""><a href="rustexample/testing/dev_dependencies.html"><strong aria-hidden="true">5.21.4.</strong> Dev-dependencies</a></li></ol></li><li class=""><a href="rustexample/unsafe.html"><strong aria-hidden="true">5.22.</strong> Unsafe Operations</a></li><li class=""><a href="rustexample/compatibility.html"><strong aria-hidden="true">5.23.</strong> Compatibility</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/compatibility/raw_identifiers.html"><strong aria-hidden="true">5.23.1.</strong> Raw identifiers</a></li></ol></li><li class=""><a href="rustexample/meta.html"><strong aria-hidden="true">5.24.</strong> Meta</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustexample/meta/doc.html"><strong aria-hidden="true">5.24.1.</strong> Documentation</a></li></ol></li></ol></li><li class=""><a href="rustbook/ch00-00-introduction.html"><strong aria-hidden="true">6.</strong> Rust Programming Language Book</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch01-00-getting-started.html"><strong aria-hidden="true">6.1.</strong> Getting Started</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch01-01-installation.html"><strong aria-hidden="true">6.1.1.</strong> Installation</a></li><li class=""><a href="rustbook/ch01-02-hello-world.html"><strong aria-hidden="true">6.1.2.</strong> Hello, World!</a></li><li class=""><a href="rustbook/ch01-03-hello-cargo.html"><strong aria-hidden="true">6.1.3.</strong> Hello, Cargo!</a></li></ol></li><li class=""><a href="rustbook/ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">6.2.</strong> Programming a Guessing Game</a></li><li class=""><a href="rustbook/ch03-00-common-programming-concepts.html"><strong aria-hidden="true">6.3.</strong> Common Programming Concepts</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch03-01-variables-and-mutability.html"><strong aria-hidden="true">6.3.1.</strong> Variables and Mutability</a></li><li class=""><a href="rustbook/ch03-02-data-types.html"><strong aria-hidden="true">6.3.2.</strong> Data Types</a></li><li class=""><a href="rustbook/ch03-03-how-functions-work.html"><strong aria-hidden="true">6.3.3.</strong> Functions</a></li><li class=""><a href="rustbook/ch03-04-comments.html"><strong aria-hidden="true">6.3.4.</strong> Comments</a></li><li class=""><a href="rustbook/ch03-05-control-flow.html"><strong aria-hidden="true">6.3.5.</strong> Control Flow</a></li></ol></li><li class=""><a href="rustbook/ch04-00-understanding-ownership.html"><strong aria-hidden="true">6.4.</strong> Understanding Ownership</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch04-01-what-is-ownership.html"><strong aria-hidden="true">6.4.1.</strong> What is Ownership?</a></li><li class=""><a href="rustbook/ch04-02-references-and-borrowing.html"><strong aria-hidden="true">6.4.2.</strong> References and Borrowing</a></li><li class=""><a href="rustbook/ch04-03-slices.html"><strong aria-hidden="true">6.4.3.</strong> The Slice Type</a></li></ol></li><li class=""><a href="rustbook/ch05-00-structs.html"><strong aria-hidden="true">6.5.</strong> Using Structs to Structure Related Data</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch05-01-defining-structs.html"><strong aria-hidden="true">6.5.1.</strong> Defining and Instantiating Structs</a></li><li class=""><a href="rustbook/ch05-02-example-structs.html"><strong aria-hidden="true">6.5.2.</strong> An Example Program Using Structs</a></li><li class=""><a href="rustbook/ch05-03-method-syntax.html"><strong aria-hidden="true">6.5.3.</strong> Method Syntax</a></li></ol></li><li class=""><a href="rustbook/ch06-00-enums.html"><strong aria-hidden="true">6.6.</strong> Enums and Pattern Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.6.1.</strong> Defining an Enum</a></li><li class=""><a href="rustbook/ch06-02-match.html"><strong aria-hidden="true">6.6.2.</strong> The match Control Flow Operator</a></li><li class=""><a href="rustbook/ch06-03-if-let.html"><strong aria-hidden="true">6.6.3.</strong> Concise Control Flow with if let</a></li></ol></li><li class=""><a href="rustbook/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">6.7.</strong> Managing Growing Projects with Packages Crates and Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch07-01-packages-and-crates.html"><strong aria-hidden="true">6.7.1.</strong> Packages and Crates</a></li><li class=""><a href="rustbook/ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">6.7.2.</strong> Defining Modules to Control Scope and Privacy</a></li><li class=""><a href="rustbook/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">6.7.3.</strong> Paths for Referring to an Item in the Module Tree</a></li><li class=""><a href="rustbook/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">6.7.4.</strong> Bringing Paths Into Scope with the use Keyword</a></li><li class=""><a href="rustbook/ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">6.7.5.</strong> Separating Modules into Different Files</a></li></ol></li><li class=""><a href="rustbook/ch08-00-common-collections.html"><strong aria-hidden="true">6.8.</strong> Common Collections</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch08-01-vectors.html"><strong aria-hidden="true">6.8.1.</strong> Storing Lists of Values with Vectors</a></li><li class=""><a href="rustbook/ch08-02-strings.html"><strong aria-hidden="true">6.8.2.</strong> Storing UTF-8 Encoded Text with Strings</a></li><li class=""><a href="rustbook/ch08-03-hash-maps.html"><strong aria-hidden="true">6.8.3.</strong> Storing Keys with Associated Values in Hash Maps</a></li></ol></li><li class=""><a href="rustbook/ch09-00-error-handling.html"><strong aria-hidden="true">6.9.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">6.9.1.</strong> Unrecoverable Errors with panic!</a></li><li class=""><a href="rustbook/ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">6.9.2.</strong> Recoverable Errors with Result</a></li><li class=""><a href="rustbook/ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">6.9.3.</strong> To panic! or Not To panic!</a></li></ol></li><li class=""><a href="rustbook/ch10-00-generics.html"><strong aria-hidden="true">6.10.</strong> Generic Types, Traits, and Lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch10-01-syntax.html"><strong aria-hidden="true">6.10.1.</strong> Generic Data Types</a></li><li class=""><a href="rustbook/ch10-02-traits.html"><strong aria-hidden="true">6.10.2.</strong> Traits: Defining Shared Behavior</a></li><li class=""><a href="rustbook/ch10-03-lifetime-syntax.html"><strong aria-hidden="true">6.10.3.</strong> Validating References with Lifetimes</a></li></ol></li><li class=""><a href="rustbook/ch11-00-testing.html"><strong aria-hidden="true">6.11.</strong> Writing Automated Tests</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch11-01-writing-tests.html"><strong aria-hidden="true">6.11.1.</strong> How to Write Tests</a></li><li class=""><a href="rustbook/ch11-02-running-tests.html"><strong aria-hidden="true">6.11.2.</strong> Controlling How Tests Are Run</a></li><li class=""><a href="rustbook/ch11-03-test-organization.html"><strong aria-hidden="true">6.11.3.</strong> Test Organization</a></li></ol></li><li class=""><a href="rustbook/ch12-00-an-io-project.html"><strong aria-hidden="true">6.12.</strong> An I/O Project: Building a Command Line Program</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">6.12.1.</strong> Accepting Command Line Arguments</a></li><li class=""><a href="rustbook/ch12-02-reading-a-file.html"><strong aria-hidden="true">6.12.2.</strong> Reading a File</a></li><li class=""><a href="rustbook/ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">6.12.3.</strong> Refactoring to Improve Modularity and Error Handling</a></li><li class=""><a href="rustbook/ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">6.12.4.</strong> Developing the Library’s Functionality with Test Driven Development</a></li><li class=""><a href="rustbook/ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">6.12.5.</strong> Working with Environment Variables</a></li><li class=""><a href="rustbook/ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">6.12.6.</strong> Writing Error Messages to Standard Error Instead of Standard Output</a></li></ol></li><li class=""><a href="rustbook/ch13-00-functional-features.html"><strong aria-hidden="true">6.13.</strong> Functional Language Features  Iterators and Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch13-01-closures.html"><strong aria-hidden="true">6.13.1.</strong> Closures: Anonymous Functions that Can Capture Their Environment</a></li><li class=""><a href="rustbook/ch13-02-iterators.html"><strong aria-hidden="true">6.13.2.</strong> Processing a Series of Items with Iterators</a></li><li class=""><a href="rustbook/ch13-03-improving-our-io-project.html"><strong aria-hidden="true">6.13.3.</strong> Improving Our I/O Project</a></li><li class=""><a href="rustbook/ch13-04-performance.html"><strong aria-hidden="true">6.13.4.</strong> Comparing Performance: Loops vs. Iterators</a></li></ol></li><li class=""><a href="rustbook/ch14-00-more-about-cargo.html"><strong aria-hidden="true">6.14.</strong> More about Cargo and Crates.io</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch14-01-release-profiles.html"><strong aria-hidden="true">6.14.1.</strong> Customizing Builds with Release Profiles</a></li><li class=""><a href="rustbook/ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">6.14.2.</strong> Publishing a Crate to Crates.io</a></li><li class=""><a href="rustbook/ch14-03-cargo-workspaces.html"><strong aria-hidden="true">6.14.3.</strong> Cargo Workspaces</a></li><li class=""><a href="rustbook/ch14-04-installing-binaries.html"><strong aria-hidden="true">6.14.4.</strong> Installing Binaries from Crates.io with cargo install</a></li><li class=""><a href="rustbook/ch14-05-extending-cargo.html"><strong aria-hidden="true">6.14.5.</strong> Extending Cargo with Custom Commands</a></li></ol></li><li class=""><a href="rustbook/ch15-00-smart-pointers.html"><strong aria-hidden="true">6.15.</strong> Smart Pointers</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch15-01-box.html"><strong aria-hidden="true">6.15.1.</strong> Using Box<T> to Point to Data on the Heap</a></li><li class=""><a href="rustbook/ch15-02-deref.html"><strong aria-hidden="true">6.15.2.</strong> Treating Smart Pointers Like Regular References with the Deref Trait</a></li><li class=""><a href="rustbook/ch15-03-drop.html"><strong aria-hidden="true">6.15.3.</strong> Running Code on Cleanup with the Drop Trait</a></li><li class=""><a href="rustbook/ch15-04-rc.html"><strong aria-hidden="true">6.15.4.</strong> Rc<T>, the Reference Counted Smart Pointer</a></li><li class=""><a href="rustbook/ch15-05-interior-mutability.html"><strong aria-hidden="true">6.15.5.</strong> RefCell<T> and the Interior Mutability Pattern</a></li><li class=""><a href="rustbook/ch15-06-reference-cycles.html"><strong aria-hidden="true">6.15.6.</strong> Reference Cycles Can Leak Memory</a></li></ol></li><li class=""><a href="rustbook/ch16-00-concurrency.html"><strong aria-hidden="true">6.16.</strong> Fearless Concurrency</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch16-01-threads.html"><strong aria-hidden="true">6.16.1.</strong> Using Threads to Run Code Simultaneously</a></li><li class=""><a href="rustbook/ch16-02-message-passing.html"><strong aria-hidden="true">6.16.2.</strong> Using Message Passing to Transfer Data Between Threads</a></li><li class=""><a href="rustbook/ch16-03-shared-state.html"><strong aria-hidden="true">6.16.3.</strong> Shared-State Concurrency</a></li><li class=""><a href="rustbook/ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">6.16.4.</strong> Extensible Concurrency with the Sync and Send Traits</a></li></ol></li><li class=""><a href="rustbook/ch17-00-oop.html"><strong aria-hidden="true">6.17.</strong> Object Oriented Programming Features of Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch17-01-what-is-oo.html"><strong aria-hidden="true">6.17.1.</strong> Characteristics of Object-Oriented Languages</a></li><li class=""><a href="rustbook/ch17-02-trait-objects.html"><strong aria-hidden="true">6.17.2.</strong> Using Trait Objects That Allow for Values of Different Types</a></li><li class=""><a href="rustbook/ch17-03-oo-design-patterns.html"><strong aria-hidden="true">6.17.3.</strong> Implementing an Object-Oriented Design Pattern</a></li></ol></li><li class=""><a href="rustbook/ch18-00-patterns.html"><strong aria-hidden="true">6.18.</strong> Patterns and Matching</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">6.18.1.</strong> All the Places Patterns Can Be Used</a></li><li class=""><a href="rustbook/ch18-02-refutability.html"><strong aria-hidden="true">6.18.2.</strong> Refutability: Whether a Pattern Might Fail to Match</a></li><li class=""><a href="rustbook/ch18-03-pattern-syntax.html"><strong aria-hidden="true">6.18.3.</strong> Pattern Syntax</a></li></ol></li><li class=""><a href="rustbook/ch19-00-advanced-features.html"><strong aria-hidden="true">6.19.</strong> Advanced Features</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch19-01-unsafe-rust.html"><strong aria-hidden="true">6.19.1.</strong> Unsafe Rust</a></li><li class=""><a href="rustbook/ch19-03-advanced-traits.html"><strong aria-hidden="true">6.19.2.</strong> Advanced Traits</a></li><li class=""><a href="rustbook/ch19-04-advanced-types.html"><strong aria-hidden="true">6.19.3.</strong> Advanced Types</a></li><li class=""><a href="rustbook/ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">6.19.4.</strong> Advanced Functions and Closures</a></li><li class=""><a href="rustbook/ch19-06-macros.html"><strong aria-hidden="true">6.19.5.</strong> Macros</a></li></ol></li><li class=""><a href="rustbook/ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">6.20.</strong> Final Project: Building a Multithreaded Web Server</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/ch20-01-single-threaded.html"><strong aria-hidden="true">6.20.1.</strong> Building a Single-Threaded Web Server</a></li><li class=""><a href="rustbook/ch20-02-multithreaded.html"><strong aria-hidden="true">6.20.2.</strong> Turning Our Single-Threaded Server into a Multithreaded Server</a></li><li class=""><a href="rustbook/ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">6.20.3.</strong> Graceful Shutdown and Cleanup</a></li></ol></li><li class=""><a href="rustbook/appendix-00.html"><strong aria-hidden="true">6.21.</strong> Appendix</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustbook/appendix-01-keywords.html"><strong aria-hidden="true">6.21.1.</strong> A - Keywords</a></li><li class=""><a href="rustbook/appendix-02-operators.html"><strong aria-hidden="true">6.21.2.</strong> B - Operators and Symbols</a></li><li class=""><a href="rustbook/appendix-03-derivable-traits.html"><strong aria-hidden="true">6.21.3.</strong> C - Derivable Traits</a></li><li class=""><a href="rustbook/appendix-04-useful-development-tools.html"><strong aria-hidden="true">6.21.4.</strong> D - Useful Development Tools</a></li><li class=""><a href="rustbook/appendix-05-editions.html"><strong aria-hidden="true">6.21.5.</strong> E - Editions</a></li><li class=""><a href="rustbook/appendix-06-translation.html"><strong aria-hidden="true">6.21.6.</strong> F - Translations of the Book</a></li><li class=""><a href="rustbook/appendix-07-nightly-rust.html"><strong aria-hidden="true">6.21.7.</strong> G - How Rust is Made and “Nightly Rust”</a></li></ol></li></ol></li><li class=""><a href="rustdoc-2018/index.html"><strong aria-hidden="true">7.</strong> Rust Doc 2018</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/edition-changes.html"><strong aria-hidden="true">7.1.</strong> 2018-Specific Changes</a></li><li class=""><a href="rustdoc-2018/module-system/index.html"><strong aria-hidden="true">7.2.</strong> Module system</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/module-system/raw-identifiers.html"><strong aria-hidden="true">7.2.1.</strong> Raw identifiers</a></li><li class=""><a href="rustdoc-2018/module-system/path-clarity.html"><strong aria-hidden="true">7.2.2.</strong> Path clarity</a></li><li class=""><a href="rustdoc-2018/module-system/more-visibility-modifiers.html"><strong aria-hidden="true">7.2.3.</strong> More visibility modifiers</a></li><li class=""><a href="rustdoc-2018/module-system/nested-imports-with-use.html"><strong aria-hidden="true">7.2.4.</strong> Nested imports with use</a></li></ol></li><li class=""><a href="rustdoc-2018/error-handling-and-panics/index.html"><strong aria-hidden="true">7.3.</strong> Error handling and panics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html"><strong aria-hidden="true">7.3.1.</strong> The ? operator for easier error handling</a></li><li class=""><a href="rustdoc-2018/error-handling-and-panics/question-mark-in-main-and-tests.html"><strong aria-hidden="true">7.3.2.</strong> ? in main and tests</a></li><li class=""><a href="rustdoc-2018/error-handling-and-panics/controlling-panics-with-std-panic.html"><strong aria-hidden="true">7.3.3.</strong> Controlling panics with std::panic</a></li><li class=""><a href="rustdoc-2018/error-handling-and-panics/aborting-on-panic.html"><strong aria-hidden="true">7.3.4.</strong> Aborting on panic</a></li></ol></li><li class=""><a href="rustdoc-2018/control-flow/index.html"><strong aria-hidden="true">7.4.</strong> Control flow</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/control-flow/loops-can-break-with-a-value.html"><strong aria-hidden="true">7.4.1.</strong> Loops can break with a value</a></li><li class=""><a href="rustdoc-2018/control-flow/async-await-for-easier-concurrency.html"><strong aria-hidden="true">7.4.2.</strong> async/await for easier concurrency</a></li></ol></li><li class=""><a href="rustdoc-2018/trait-system/index.html"><strong aria-hidden="true">7.5.</strong> Trait system</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html"><strong aria-hidden="true">7.5.1.</strong> impl Trait for returning complex types with ease</a></li><li class=""><a href="rustdoc-2018/trait-system/dyn-trait-for-trait-objects.html"><strong aria-hidden="true">7.5.2.</strong> dyn Trait for trait objects</a></li><li class=""><a href="rustdoc-2018/trait-system/more-container-types-support-trait-objects.html"><strong aria-hidden="true">7.5.3.</strong> More container types support trait objects</a></li><li class=""><a href="rustdoc-2018/trait-system/associated-constants.html"><strong aria-hidden="true">7.5.4.</strong> Associated constants</a></li><li class=""><a href="rustdoc-2018/trait-system/no-anon-params.html"><strong aria-hidden="true">7.5.5.</strong> No more anonymous parameters</a></li></ol></li><li class=""><a href="rustdoc-2018/slice-patterns.html"><strong aria-hidden="true">7.6.</strong> Slice patterns</a></li><li class=""><a href="rustdoc-2018/ownership-and-lifetimes/index.html"><strong aria-hidden="true">7.7.</strong> Ownership and lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/ownership-and-lifetimes/non-lexical-lifetimes.html"><strong aria-hidden="true">7.7.1.</strong> Non-lexical lifetimes</a></li><li class=""><a href="rustdoc-2018/ownership-and-lifetimes/default-match-bindings.html"><strong aria-hidden="true">7.7.2.</strong> Default match bindings</a></li><li class=""><a href="rustdoc-2018/ownership-and-lifetimes/the-anonymous-lifetime.html"><strong aria-hidden="true">7.7.3.</strong> '_, the anonymous lifetime</a></li><li class=""><a href="rustdoc-2018/ownership-and-lifetimes/lifetime-elision-in-impl.html"><strong aria-hidden="true">7.7.4.</strong> Lifetime elision in impl</a></li><li class=""><a href="rustdoc-2018/ownership-and-lifetimes/inference-in-structs.html"><strong aria-hidden="true">7.7.5.</strong> T: 'a inference in structs</a></li><li class=""><a href="rustdoc-2018/ownership-and-lifetimes/simpler-lifetimes-in-static-and-const.html"><strong aria-hidden="true">7.7.6.</strong> Simpler lifetimes in static and const</a></li></ol></li><li class=""><a href="rustdoc-2018/data-types/index.html"><strong aria-hidden="true">7.8.</strong> Data types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/data-types/field-init-shorthand.html"><strong aria-hidden="true">7.8.1.</strong> Field init shorthand</a></li><li class=""><a href="rustdoc-2018/data-types/inclusive-ranges.html"><strong aria-hidden="true">7.8.2.</strong> ..= for inclusive ranges</a></li><li class=""><a href="rustdoc-2018/data-types/128-bit-integers.html"><strong aria-hidden="true">7.8.3.</strong> 128 bit integers</a></li><li class=""><a href="rustdoc-2018/data-types/operator-equals-are-now-implementable.html"><strong aria-hidden="true">7.8.4.</strong> &quot;Operator-equals&quot; are now implementable</a></li><li class=""><a href="rustdoc-2018/data-types/union-for-an-unsafe-form-of-enum.html"><strong aria-hidden="true">7.8.5.</strong> union for an unsafe form of enum</a></li><li class=""><a href="rustdoc-2018/data-types/choosing-alignment-with-the-repr-attribute.html"><strong aria-hidden="true">7.8.6.</strong> Choosing alignment with the repr attribute</a></li></ol></li><li class=""><a href="rustdoc-2018/simd-for-faster-computing.html"><strong aria-hidden="true">7.9.</strong> SIMD for faster computing</a></li><li class=""><a href="rustdoc-2018/macros/index.html"><strong aria-hidden="true">7.10.</strong> Macros</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/macros/custom-derive.html"><strong aria-hidden="true">7.10.1.</strong> Custom Derive</a></li><li class=""><a href="rustdoc-2018/macros/macro-changes.html"><strong aria-hidden="true">7.10.2.</strong> Macro changes</a></li><li class=""><a href="rustdoc-2018/macros/at-most-once.html"><strong aria-hidden="true">7.10.3.</strong> At most one repetition</a></li></ol></li><li class=""><a href="rustdoc-2018/the-compiler/index.html"><strong aria-hidden="true">7.11.</strong> The compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/the-compiler/improved-error-messages.html"><strong aria-hidden="true">7.11.1.</strong> Improved error messages</a></li><li class=""><a href="rustdoc-2018/the-compiler/incremental-compilation-for-faster-compiles.html"><strong aria-hidden="true">7.11.2.</strong> Incremental Compilation for faster compiles</a></li><li class=""><a href="rustdoc-2018/the-compiler/an-attribute-for-deprecation.html"><strong aria-hidden="true">7.11.3.</strong> An attribute for deprecation</a></li></ol></li><li class=""><a href="rustdoc-2018/rustup-for-managing-rust-versions.html"><strong aria-hidden="true">7.12.</strong> Rustup for managing Rust versions</a></li><li class=""><a href="rustdoc-2018/cargo-and-crates-io/index.html"><strong aria-hidden="true">7.13.</strong> Cargo and crates.io</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/cargo-and-crates-io/cargo-check-for-faster-checking.html"><strong aria-hidden="true">7.13.1.</strong> cargo check for faster checking</a></li><li class=""><a href="rustdoc-2018/cargo-and-crates-io/cargo-install-for-easy-installation-of-tools.html"><strong aria-hidden="true">7.13.2.</strong> cargo install for easy installation of tools</a></li><li class=""><a href="rustdoc-2018/cargo-and-crates-io/cargo-new-defaults-to-a-binary-project.html"><strong aria-hidden="true">7.13.3.</strong> cargo new defaults to a binary project</a></li><li class=""><a href="rustdoc-2018/cargo-and-crates-io/cargo-rustc-for-passing-arbitrary-flags-to-rustc.html"><strong aria-hidden="true">7.13.4.</strong> cargo rustc for passing arbitrary flags to rustc</a></li><li class=""><a href="rustdoc-2018/cargo-and-crates-io/cargo-workspaces-for-multi-package-projects.html"><strong aria-hidden="true">7.13.5.</strong> Cargo workspaces for multi-package projects</a></li><li class=""><a href="rustdoc-2018/cargo-and-crates-io/multi-file-examples.html"><strong aria-hidden="true">7.13.6.</strong> Multi-file examples</a></li><li class=""><a href="rustdoc-2018/cargo-and-crates-io/replacing-dependencies-with-patch.html"><strong aria-hidden="true">7.13.7.</strong> Replacing dependencies with patch</a></li><li class=""><a href="rustdoc-2018/cargo-and-crates-io/cargo-can-use-a-local-registry-replacement.html"><strong aria-hidden="true">7.13.8.</strong> Cargo can use a local registry replacement</a></li><li class=""><a href="rustdoc-2018/cargo-and-crates-io/crates-io-disallows-wildcard-dependencies.html"><strong aria-hidden="true">7.13.9.</strong> Crates.io disallows wildcard dependencies</a></li></ol></li><li class=""><a href="rustdoc-2018/documentation/index.html"><strong aria-hidden="true">7.14.</strong> Documentation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/documentation/new-editions-of-the-book.html"><strong aria-hidden="true">7.14.1.</strong> New editions of the &quot;the book&quot;</a></li><li class=""><a href="rustdoc-2018/documentation/the-rust-bookshelf.html"><strong aria-hidden="true">7.14.2.</strong> The Rust Bookshelf</a></li><li class=""><a href="rustdoc-2018/documentation/the-rustonomicon.html"><strong aria-hidden="true">7.14.3.</strong> The Rustonomicon</a></li><li class=""><a href="rustdoc-2018/documentation/std-os-has-documentation-for-all-platforms.html"><strong aria-hidden="true">7.14.4.</strong> Full documentation for std::os</a></li></ol></li><li class=""><a href="rustdoc-2018/rustdoc/index.html"><strong aria-hidden="true">7.15.</strong> rustdoc</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/rustdoc/documentation-tests-can-now-compile-fail.html"><strong aria-hidden="true">7.15.1.</strong> Documentation tests can now compile-fail</a></li><li class=""><a href="rustdoc-2018/rustdoc/rustdoc-uses-commonmark.html"><strong aria-hidden="true">7.15.2.</strong> Rustdoc uses CommonMark</a></li></ol></li><li class=""><a href="rustdoc-2018/platform-and-target-support/index.html"><strong aria-hidden="true">7.16.</strong> Platform and target support</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustdoc-2018/platform-and-target-support/libcore-for-low-level-rust.html"><strong aria-hidden="true">7.16.1.</strong> libcore for low-level Rust</a></li><li class=""><a href="rustdoc-2018/platform-and-target-support/webassembly-support.html"><strong aria-hidden="true">7.16.2.</strong> WebAssembly support</a></li><li class=""><a href="rustdoc-2018/platform-and-target-support/global-allocators.html"><strong aria-hidden="true">7.16.3.</strong> Global allocators</a></li><li class=""><a href="rustdoc-2018/platform-and-target-support/msvc-toolchain-support.html"><strong aria-hidden="true">7.16.4.</strong> MSVC toolchain support</a></li><li class=""><a href="rustdoc-2018/platform-and-target-support/musl-support-for-fully-static-binaries.html"><strong aria-hidden="true">7.16.5.</strong> MUSL support for fully static binaries</a></li><li class=""><a href="rustdoc-2018/platform-and-target-support/cdylib-crates-for-c-interoperability.html"><strong aria-hidden="true">7.16.6.</strong> cdylib crates for C interoperability</a></li></ol></li></ol></li><li class=""><a href="rustc-guide/about-this-guide.html"><strong aria-hidden="true">8.</strong> rustc guide</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/part-1-intro.html"><strong aria-hidden="true">8.1.</strong> Part 1: Building, debugging, and contributing to Rustc</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/compiler-team.html"><strong aria-hidden="true">8.1.1.</strong> About the compiler team</a></li><li class=""><a href="rustc-guide/how-to-build-and-run.html"><strong aria-hidden="true">8.1.2.</strong> How to Build and Run the Compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/build-install-distribution-artifacts.html"><strong aria-hidden="true">8.1.2.1.</strong> Build and Install distribution artifacts</a></li><li class=""><a href="rustc-guide/compiler-documenting.html"><strong aria-hidden="true">8.1.2.2.</strong> Documenting Compiler</a></li></ol></li><li class=""><a href="rustc-guide/tests/intro.html"><strong aria-hidden="true">8.1.3.</strong> The compiler testing framework</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/tests/running.html"><strong aria-hidden="true">8.1.3.1.</strong> Running tests</a></li><li class=""><a href="rustc-guide/tests/adding.html"><strong aria-hidden="true">8.1.3.2.</strong> Adding new tests</a></li><li class=""><a href="rustc-guide/compiletest.html"><strong aria-hidden="true">8.1.3.3.</strong> Using compiletest + commands to control test execution</a></li></ol></li><li class=""><a href="rustc-guide/walkthrough.html"><strong aria-hidden="true">8.1.4.</strong> Walkthrough: a typical contribution</a></li><li class=""><a href="rustc-guide/implementing_new_features.html"><strong aria-hidden="true">8.1.5.</strong> Implementing new features</a></li><li class=""><a href="rustc-guide/stabilization_guide.html"><strong aria-hidden="true">8.1.6.</strong> Stabilizing Features</a></li><li class=""><a href="rustc-guide/compiler-debugging.html"><strong aria-hidden="true">8.1.7.</strong> Debugging the Compiler</a></li><li class=""><a href="rustc-guide/profiling.html"><strong aria-hidden="true">8.1.8.</strong> Profiling the compiler</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/profiling/with_perf.html"><strong aria-hidden="true">8.1.8.1.</strong> with the linux perf tool</a></li></ol></li><li class=""><a href="rustc-guide/conventions.html"><strong aria-hidden="true">8.1.9.</strong> Coding conventions</a></li><li class=""><a href="rustc-guide/crates-io.html"><strong aria-hidden="true">8.1.10.</strong> crates.io Dependencies</a></li><li class=""><a href="rustc-guide/diagnostics.html"><strong aria-hidden="true">8.1.11.</strong> Emitting Errors and other Diagnostics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/diagnostics/json-format.html"><strong aria-hidden="true">8.1.11.1.</strong> JSON diagnostic format</a></li></ol></li></ol></li><li class=""><a href="rustc-guide/part-2-intro.html"><strong aria-hidden="true">8.2.</strong> Part 2: How rustc works</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/high-level-overview.html"><strong aria-hidden="true">8.2.1.</strong> High-level overview of the compiler source</a></li><li class=""><a href="rustc-guide/rustc-driver.html"><strong aria-hidden="true">8.2.2.</strong> The Rustc Driver and Interface</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/rustdoc.html"><strong aria-hidden="true">8.2.2.1.</strong> Rustdoc</a></li></ol></li><li class=""><a href="rustc-guide/query.html"><strong aria-hidden="true">8.2.3.</strong> Queries: demand-driven compilation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/queries/query-evaluation-model-in-detail.html"><strong aria-hidden="true">8.2.3.1.</strong> The Query Evaluation Model in Detail</a></li><li class=""><a href="rustc-guide/queries/incremental-compilation.html"><strong aria-hidden="true">8.2.3.2.</strong> Incremental compilation</a></li><li class=""><a href="rustc-guide/queries/incremental-compilation-in-detail.html"><strong aria-hidden="true">8.2.3.3.</strong> Incremental compilation In Detail</a></li><li class=""><a href="rustc-guide/incrcomp-debugging.html"><strong aria-hidden="true">8.2.3.4.</strong> Debugging and Testing</a></li></ol></li><li class=""><a href="rustc-guide/the-parser.html"><strong aria-hidden="true">8.2.4.</strong> The parser</a></li><li class=""><a href="rustc-guide/test-implementation.html"><strong aria-hidden="true">8.2.5.</strong> #[test] Implementation</a></li><li class=""><a href="rustc-guide/macro-expansion.html"><strong aria-hidden="true">8.2.6.</strong> Macro expansion</a></li><li class=""><a href="rustc-guide/name-resolution.html"><strong aria-hidden="true">8.2.7.</strong> Name resolution</a></li><li class=""><a href="rustc-guide/hir.html"><strong aria-hidden="true">8.2.8.</strong> The HIR (High-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/lowering.html"><strong aria-hidden="true">8.2.8.1.</strong> Lowering AST to HIR</a></li><li class=""><a href="rustc-guide/hir-debugging.html"><strong aria-hidden="true">8.2.8.2.</strong> Debugging</a></li></ol></li><li class=""><a href="rustc-guide/closure.html"><strong aria-hidden="true">8.2.9.</strong> Closure expansion</a></li><li class=""><a href="rustc-guide/ty.html"><strong aria-hidden="true">8.2.10.</strong> The ty module: representing types</a></li><li class=""><a href="rustc-guide/kinds.html"><strong aria-hidden="true">8.2.11.</strong> Kinds</a></li><li class=""><a href="rustc-guide/type-inference.html"><strong aria-hidden="true">8.2.12.</strong> Type inference</a></li><li class=""><a href="rustc-guide/traits/resolution.html"><strong aria-hidden="true">8.2.13.</strong> Trait solving (old-style)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/traits/hrtb.html"><strong aria-hidden="true">8.2.13.1.</strong> Higher-ranked trait bounds</a></li><li class=""><a href="rustc-guide/traits/caching.html"><strong aria-hidden="true">8.2.13.2.</strong> Caching subtleties</a></li><li class=""><a href="rustc-guide/traits/specialization.html"><strong aria-hidden="true">8.2.13.3.</strong> Specialization</a></li></ol></li><li class=""><a href="rustc-guide/traits/index.html"><strong aria-hidden="true">8.2.14.</strong> Trait solving (new-style)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/traits/lowering-to-logic.html"><strong aria-hidden="true">8.2.14.1.</strong> Lowering to logic</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/traits/goals-and-clauses.html"><strong aria-hidden="true">8.2.14.1.1.</strong> Goals and clauses</a></li><li class=""><a href="rustc-guide/traits/associated-types.html"><strong aria-hidden="true">8.2.14.1.2.</strong> Equality and associated types</a></li><li class=""><a href="rustc-guide/traits/implied-bounds.html"><strong aria-hidden="true">8.2.14.1.3.</strong> Implied bounds</a></li><li class=""><a href="rustc-guide/traits/regions.html"><strong aria-hidden="true">8.2.14.1.4.</strong> Region constraints</a></li><li class=""><a href="rustc-guide/traits/lowering-module.html"><strong aria-hidden="true">8.2.14.1.5.</strong> The lowering module in rustc</a></li><li class=""><a href="rustc-guide/traits/lowering-rules.html"><strong aria-hidden="true">8.2.14.1.6.</strong> Lowering rules</a></li><li class=""><a href="rustc-guide/traits/wf.html"><strong aria-hidden="true">8.2.14.1.7.</strong> Well-formedness checking</a></li></ol></li><li class=""><a href="rustc-guide/traits/canonical-queries.html"><strong aria-hidden="true">8.2.14.2.</strong> Canonical queries</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/traits/canonicalization.html"><strong aria-hidden="true">8.2.14.2.1.</strong> Canonicalization</a></li></ol></li><li class=""><a href="rustc-guide/traits/slg.html"><strong aria-hidden="true">8.2.14.3.</strong> The SLG solver</a></li><li class=""><a href="rustc-guide/traits/chalk-overview.html"><strong aria-hidden="true">8.2.14.4.</strong> An Overview of Chalk</a></li><li class=""><a href="rustc-guide/traits/bibliography.html"><strong aria-hidden="true">8.2.14.5.</strong> Bibliography</a></li></ol></li><li class=""><a href="rustc-guide/type-checking.html"><strong aria-hidden="true">8.2.15.</strong> Type checking</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/method-lookup.html"><strong aria-hidden="true">8.2.15.1.</strong> Method Lookup</a></li><li class=""><a href="rustc-guide/variance.html"><strong aria-hidden="true">8.2.15.2.</strong> Variance</a></li><li class=""><a href="rustc-guide/existential-types.html"><strong aria-hidden="true">8.2.15.3.</strong> Existential Types</a></li></ol></li><li class=""><a href="rustc-guide/mir/index.html"><strong aria-hidden="true">8.2.16.</strong> The MIR (Mid-level IR)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/mir/construction.html"><strong aria-hidden="true">8.2.16.1.</strong> MIR construction</a></li><li class=""><a href="rustc-guide/mir/visitor.html"><strong aria-hidden="true">8.2.16.2.</strong> MIR visitor and traversal</a></li><li class=""><a href="rustc-guide/mir/passes.html"><strong aria-hidden="true">8.2.16.3.</strong> MIR passes: getting the MIR for a function</a></li><li class=""><a href="rustc-guide/mir/optimizations.html"><strong aria-hidden="true">8.2.16.4.</strong> MIR optimizations</a></li><li class=""><a href="rustc-guide/mir/debugging.html"><strong aria-hidden="true">8.2.16.5.</strong> Debugging</a></li></ol></li><li class=""><a href="rustc-guide/borrow_check.html"><strong aria-hidden="true">8.2.17.</strong> The borrow checker</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/borrow_check/moves_and_initialization.html"><strong aria-hidden="true">8.2.17.1.</strong> Tracking moves and initialization</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/borrow_check/moves_and_initialization/move_paths.html"><strong aria-hidden="true">8.2.17.1.1.</strong> Move paths</a></li></ol></li><li class=""><a href="rustc-guide/borrow_check/type_check.html"><strong aria-hidden="true">8.2.17.2.</strong> MIR type checker</a></li><li class=""><a href="rustc-guide/borrow_check/region_inference.html"><strong aria-hidden="true">8.2.17.3.</strong> Region inference</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/borrow_check/region_inference/constraint_propagation.html"><strong aria-hidden="true">8.2.17.3.1.</strong> Constraint propagation</a></li><li class=""><a href="rustc-guide/borrow_check/region_inference/lifetime_parameters.html"><strong aria-hidden="true">8.2.17.3.2.</strong> Lifetime parameters</a></li><li class=""><a href="rustc-guide/borrow_check/region_inference/member_constraints.html"><strong aria-hidden="true">8.2.17.3.3.</strong> Member constraints</a></li><li class=""><a href="rustc-guide/borrow_check/region_inference/placeholders_and_universes.html"><strong aria-hidden="true">8.2.17.3.4.</strong> Placeholders and universes</a></li><li class=""><a href="rustc-guide/borrow_check/region_inference/closure_constraints.html"><strong aria-hidden="true">8.2.17.3.5.</strong> Closure constraints</a></li><li class=""><a href="rustc-guide/borrow_check/region_inference/error_reporting.html"><strong aria-hidden="true">8.2.17.3.6.</strong> Errror reporting</a></li></ol></li><li class=""><a href="rustc-guide/borrow_check/two_phase_borrows.html"><strong aria-hidden="true">8.2.17.4.</strong> Two-phase-borrows</a></li></ol></li><li class=""><a href="rustc-guide/const-eval.html"><strong aria-hidden="true">8.2.18.</strong> Constant evaluation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/miri.html"><strong aria-hidden="true">8.2.18.1.</strong> miri const evaluator</a></li></ol></li><li class=""><a href="rustc-guide/param_env.html"><strong aria-hidden="true">8.2.19.</strong> Parameter Environments</a></li><li class=""><a href="rustc-guide/codegen.html"><strong aria-hidden="true">8.2.20.</strong> Code Generation</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustc-guide/codegen/updating-llvm.html"><strong aria-hidden="true">8.2.20.1.</strong> Updating LLVM</a></li><li class=""><a href="rustc-guide/codegen/debugging.html"><strong aria-hidden="true">8.2.20.2.</strong> Debugging LLVM</a></li></ol></li><li class=""><a href="rustc-guide/profile-guided-optimization.html"><strong aria-hidden="true">8.2.21.</strong> Profile-guided Optimization</a></li><li class=""><a href="rustc-guide/debugging-support-in-rustc.html"><strong aria-hidden="true">8.2.22.</strong> Debugging Support in Rust Compiler</a></li></ol></li><li class=""><a href="rustc-guide/appendix/stupid-stats.html"><strong aria-hidden="true">8.3.</strong> Appendix A: Stupid Stats</a></li><li class=""><a href="rustc-guide/appendix/background.html"><strong aria-hidden="true">8.4.</strong> Appendix B: Background material</a></li><li class=""><a href="rustc-guide/appendix/glossary.html"><strong aria-hidden="true">8.5.</strong> Appendix C: Glossary</a></li><li class=""><a href="rustc-guide/appendix/code-index.html"><strong aria-hidden="true">8.6.</strong> Appendix D: Code Index</a></li><li class=""><a href="rustc-guide/appendix/bibliography.html"><strong aria-hidden="true">8.7.</strong> Appendix E: Bibliography</a></li><li class=""><a href="rustc-guide/important-links.html"><strong aria-hidden="true">8.8.</strong> important links</a></li></ol></li><li class=""><a href="learningrust/index.html"><strong aria-hidden="true">9.</strong> Learning Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="learningrust/a1.why_rust.html"><strong aria-hidden="true">9.1.</strong> Why Rust</a></li><li class=""><a href="learningrust/a2.installation.html"><strong aria-hidden="true">9.2.</strong> Installation</a></li><li class=""><a href="learningrust/a3.hello_world.html"><strong aria-hidden="true">9.3.</strong> Hello World</a></li><li class=""><a href="learningrust/a4.cargo,crates_and_basic_project_structure.html"><strong aria-hidden="true">9.4.</strong> Cargo,crates and basic project structure</a></li><li class=""><a href="learningrust/a5.comments_and_documenting_the_code.html"><strong aria-hidden="true">9.5.</strong> Comments and documenting the code</a></li><li class=""><a href="learningrust/a6.variable_bindings,constants_and_statics.html"><strong aria-hidden="true">9.6.</strong> Variable bindings, constants and statics</a></li><li class=""><a href="learningrust/a7.functions.html"><strong aria-hidden="true">9.7.</strong> Functions</a></li><li class=""><a href="learningrust/a8.primitive_data_types.html"><strong aria-hidden="true">9.8.</strong> Primitive data types</a></li><li class=""><a href="learningrust/a9.operators.html"><strong aria-hidden="true">9.9.</strong> Operators</a></li><li class=""><a href="learningrust/a10.control_flows.html"><strong aria-hidden="true">9.10.</strong> Control flows</a></li><li class=""><a href="learningrust/b1.vectors.html"><strong aria-hidden="true">9.11.</strong> Vectors</a></li><li class=""><a href="learningrust/b2.structs.html"><strong aria-hidden="true">9.12.</strong> Structs</a></li><li class=""><a href="learningrust/b3.enums.html"><strong aria-hidden="true">9.13.</strong> Enums</a></li><li class=""><a href="learningrust/b4.generics.html"><strong aria-hidden="true">9.14.</strong> Generics</a></li><li class=""><a href="learningrust/b5.impls_and_traits.html"><strong aria-hidden="true">9.15.</strong> Impls and traits</a></li><li class=""><a href="learningrust/c1.ownership.html"><strong aria-hidden="true">9.16.</strong> Ownership</a></li><li class=""><a href="learningrust/c2.borrowing.html"><strong aria-hidden="true">9.17.</strong> Borrowing</a></li><li class=""><a href="learningrust/c3.lifetimes.html"><strong aria-hidden="true">9.18.</strong> Lifetimes</a></li><li class=""><a href="learningrust/d1.code_organization.html"><strong aria-hidden="true">9.19.</strong> Code organization</a></li><li class=""><a href="learningrust/d2.functions.html"><strong aria-hidden="true">9.20.</strong> Functions</a></li><li class=""><a href="learningrust/d3.modules.html"><strong aria-hidden="true">9.21.</strong> Modules</a></li><li class=""><a href="learningrust/d4.crates.html"><strong aria-hidden="true">9.22.</strong> Crates</a></li><li class=""><a href="learningrust/d5.workspaces.html"><strong aria-hidden="true">9.23.</strong> Workspaces</a></li><li class=""><a href="learningrust/d6.use.html"><strong aria-hidden="true">9.24.</strong> use</a></li><li class=""><a href="learningrust/d7.std_primitives_and_preludes.html"><strong aria-hidden="true">9.25.</strong> std, primitives and preludes</a></li><li class=""><a href="learningrust/e1.smart_compiler.html"><strong aria-hidden="true">9.26.</strong> Smart Compiler</a></li><li class=""><a href="learningrust/e2.panicking.html"><strong aria-hidden="true">9.27.</strong> Panicking</a></li><li class=""><a href="learningrust/e3.option_and_result.html"><strong aria-hidden="true">9.28.</strong> Option and Result</a></li><li class=""><a href="learningrust/e4.unwrap_and_expect.html"><strong aria-hidden="true">9.29.</strong> Unwrap and Expect</a></li><li class=""><a href="learningrust/e5.error_and_none_propagation.html"><strong aria-hidden="true">9.30.</strong> Error and None Propagation</a></li><li class=""><a href="learningrust/e6.combinators.html"><strong aria-hidden="true">9.31.</strong> Combinators</a></li><li class=""><a href="learningrust/e7.custom_error_types.html"><strong aria-hidden="true">9.32.</strong> Custom Error Types</a></li></ol></li><li class=""><a href="rustcookbook/intro.html"><strong aria-hidden="true">10.</strong> Rust Cook Book</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/algorithms.html"><strong aria-hidden="true">10.1.</strong> Algorithms</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/algorithms/randomness.html"><strong aria-hidden="true">10.1.1.</strong> Generate Random Values</a></li><li class=""><a href="rustcookbook/algorithms/sorting.html"><strong aria-hidden="true">10.1.2.</strong> Sort a Vector</a></li></ol></li><li class=""><a href="rustcookbook/cli.html"><strong aria-hidden="true">10.2.</strong> Command Line</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/cli/arguments.html"><strong aria-hidden="true">10.2.1.</strong> Argument Parsing</a></li><li class=""><a href="rustcookbook/cli/ansi_terminal.html"><strong aria-hidden="true">10.2.2.</strong> ANSI Terminal</a></li></ol></li><li class=""><a href="rustcookbook/compression.html"><strong aria-hidden="true">10.3.</strong> Compression</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/compression/tar.html"><strong aria-hidden="true">10.3.1.</strong> Working with Tarballs</a></li></ol></li><li class=""><a href="rustcookbook/concurrency.html"><strong aria-hidden="true">10.4.</strong> Concurrency</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/concurrency/threads.html"><strong aria-hidden="true">10.4.1.</strong> Explicit Threads</a></li><li class=""><a href="rustcookbook/concurrency/parallel.html"><strong aria-hidden="true">10.4.2.</strong> Data Parallelism</a></li></ol></li><li class=""><a href="rustcookbook/cryptography.html"><strong aria-hidden="true">10.5.</strong> Cryptography</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/cryptography/hashing.html"><strong aria-hidden="true">10.5.1.</strong> Hashing</a></li><li class=""><a href="rustcookbook/cryptography/encryption.html"><strong aria-hidden="true">10.5.2.</strong> Encryption</a></li></ol></li><li class=""><a href="rustcookbook/data_structures.html"><strong aria-hidden="true">10.6.</strong> Data Structures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/data_structures/bitfield.html"><strong aria-hidden="true">10.6.1.</strong> Bitfield</a></li></ol></li><li class=""><a href="rustcookbook/database.html"><strong aria-hidden="true">10.7.</strong> Database</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/database/sqlite.html"><strong aria-hidden="true">10.7.1.</strong> SQLite</a></li><li class=""><a href="rustcookbook/database/postgres.html"><strong aria-hidden="true">10.7.2.</strong> Postgres</a></li></ol></li><li class=""><a href="rustcookbook/datetime.html"><strong aria-hidden="true">10.8.</strong> Date and Time</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/datetime/duration.html"><strong aria-hidden="true">10.8.1.</strong> Duration and Calculation</a></li><li class=""><a href="rustcookbook/datetime/parse.html"><strong aria-hidden="true">10.8.2.</strong> Parsing and Displaying</a></li></ol></li><li class=""><a href="rustcookbook/development_tools.html"><strong aria-hidden="true">10.9.</strong> Development Tools</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/development_tools/debugging.html"><strong aria-hidden="true">10.9.1.</strong> Debugging</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/development_tools/debugging/log.html"><strong aria-hidden="true">10.9.1.1.</strong> Log Messages</a></li><li class=""><a href="rustcookbook/development_tools/debugging/config_log.html"><strong aria-hidden="true">10.9.1.2.</strong> Configure Logging</a></li></ol></li><li class=""><a href="rustcookbook/development_tools/versioning.html"><strong aria-hidden="true">10.9.2.</strong> Versioning</a></li><li class=""><a href="rustcookbook/development_tools/build_tools.html"><strong aria-hidden="true">10.9.3.</strong> Build Time Tooling</a></li></ol></li><li class=""><a href="rustcookbook/encoding.html"><strong aria-hidden="true">10.10.</strong> Encoding</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/encoding/strings.html"><strong aria-hidden="true">10.10.1.</strong> Character Sets</a></li><li class=""><a href="rustcookbook/encoding/csv.html"><strong aria-hidden="true">10.10.2.</strong> CSV processing</a></li><li class=""><a href="rustcookbook/encoding/complex.html"><strong aria-hidden="true">10.10.3.</strong> Structured Data</a></li></ol></li><li class=""><a href="rustcookbook/errors.html"><strong aria-hidden="true">10.11.</strong> Error Handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/errors/handle.html"><strong aria-hidden="true">10.11.1.</strong> Handle Error Variants</a></li></ol></li><li class=""><a href="rustcookbook/file.html"><strong aria-hidden="true">10.12.</strong> File System</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/file/read-write.html"><strong aria-hidden="true">10.12.1.</strong> Read &amp; Write</a></li><li class=""><a href="rustcookbook/file/dir.html"><strong aria-hidden="true">10.12.2.</strong> Directory Traversal</a></li></ol></li><li class=""><a href="rustcookbook/hardware.html"><strong aria-hidden="true">10.13.</strong> Hardware Support</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/hardware/processor.html"><strong aria-hidden="true">10.13.1.</strong> Processor</a></li></ol></li><li class=""><a href="rustcookbook/mem.html"><strong aria-hidden="true">10.14.</strong> Memory Management</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/mem/global_static.html"><strong aria-hidden="true">10.14.1.</strong> Global Static</a></li></ol></li><li class=""><a href="rustcookbook/net.html"><strong aria-hidden="true">10.15.</strong> Network</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/net/server.html"><strong aria-hidden="true">10.15.1.</strong> Server</a></li></ol></li><li class=""><a href="rustcookbook/os.html"><strong aria-hidden="true">10.16.</strong> Operating System</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/os/external.html"><strong aria-hidden="true">10.16.1.</strong> External Command</a></li></ol></li><li class=""><a href="rustcookbook/science.html"><strong aria-hidden="true">10.17.</strong> Science</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/science/mathematics.html"><strong aria-hidden="true">10.17.1.</strong> Mathematics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/science/mathematics/linear_algebra.html"><strong aria-hidden="true">10.17.1.1.</strong> Linear Algebra</a></li><li class=""><a href="rustcookbook/science/mathematics/trigonometry.html"><strong aria-hidden="true">10.17.1.2.</strong> Trigonometry</a></li><li class=""><a href="rustcookbook/science/mathematics/complex_numbers.html"><strong aria-hidden="true">10.17.1.3.</strong> Complex Numbers</a></li><li class=""><a href="rustcookbook/science/mathematics/statistics.html"><strong aria-hidden="true">10.17.1.4.</strong> Statistics</a></li><li class=""><a href="rustcookbook/science/mathematics/miscellaneous.html"><strong aria-hidden="true">10.17.1.5.</strong> Miscellaneous</a></li></ol></li></ol></li><li class=""><a href="rustcookbook/text.html"><strong aria-hidden="true">10.18.</strong> Text Processing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/text/regex.html"><strong aria-hidden="true">10.18.1.</strong> Regular Expressions</a></li><li class=""><a href="rustcookbook/text/string_parsing.html"><strong aria-hidden="true">10.18.2.</strong> String Parsing</a></li></ol></li><li class=""><a href="rustcookbook/web.html"><strong aria-hidden="true">10.19.</strong> Web Programming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/web/scraping.html"><strong aria-hidden="true">10.19.1.</strong> Extracting Links</a></li><li class=""><a href="rustcookbook/web/url.html"><strong aria-hidden="true">10.19.2.</strong> URL</a></li><li class=""><a href="rustcookbook/web/mime.html"><strong aria-hidden="true">10.19.3.</strong> Media Types</a></li><li class=""><a href="rustcookbook/web/clients.html"><strong aria-hidden="true">10.19.4.</strong> Clients</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class=""><a href="rustcookbook/web/clients/requests.html"><strong aria-hidden="true">10.19.4.1.</strong> Making Requests</a></li><li class=""><a href="rustcookbook/web/clients/apis.html"><strong aria-hidden="true">10.19.4.2.</strong> Calling a Web API</a></li><li class=""><a href="rustcookbook/web/clients/download.html"><strong aria-hidden="true">10.19.4.3.</strong> Downloads</a></li></ol></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Knowledge Management Base</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#demo" id="demo">demo</a></h1>
<h1><a class="header" href="#rust-trait-topic" id="rust-trait-topic">Rust trait topic</a></h1>
<h2><a class="header" href="#traits-from-the-ground-up" id="traits-from-the-ground-up">Traits from the Ground Up</a></h2>
<blockquote>
<p>from: https://killercup.github.io/presentation-traits-from-the-ground-up</p>
</blockquote>
<p>data and behavior:</p>
<blockquote>
<p>大多数时间你是在处理data and doing some stuff with it.</p>
</blockquote>
<p>Let's do the stuff</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn make_true(input: &amp;str) -&gt; String {
  format!(&quot;{}!!&quot;, input)
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>一个普通的方法， 为一个字符串末尾加上感叹号</p>
</blockquote>
<p>wrap data:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Fact { text: String }

fn make_true(input: &amp;Fact) -&gt; Fact {
  Fact { text: format!(&quot;{}!!&quot;, input.text) }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>方法里返回Data</p>
</blockquote>
<p>add behavior to data:</p>
<p>make_true as a method:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Fact { text: String }

impl Fact {
  fn make_true(&amp;self) -&gt; Fact {
    Fact { text: format!(&quot;{}!!&quot;, self.text) }
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>直接给Object增加method</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let fact = Fact { text: String::from(&quot;Lorem ipsum&quot;) };
let true_fact = fact.make_true();
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>调用方法</p>
</blockquote>
<p>another make_true:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Fact { text: String }

impl Fact {
  fn make_true(&amp;mut self) {
    self.text.push_str(&quot;!!&quot;);
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>使用mut引用， 可以直接修改</p>
</blockquote>
<p>Or:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Fact { text: String }

impl Fact {
  fn make_true(mut self) -&gt; Fact {
    self.text.push_str(&quot;!!&quot;);
    self
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>mut move， 修改完后要显式返回self， 否则默认是销毁的.</p>
</blockquote>
<p>Let's give it a name:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Truth {
  fn make_true(&amp;self) -&gt; Self
}
<span class="boring">}
</span></code></pre></pre>
<p>Now we can implement it:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Truth for Fact {
  fn make_true(&amp;self) -&gt; Self {
    Fact { text: format!(&quot;{}!!&quot;, self.text) }
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>为data实现trait中的方法</p>
</blockquote>
<p>Implement it for everything!：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Truth for i32 {
  fn make_true(&amp;self) -&gt; Self {
    42
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>可以给所有的目标type实现某个trait</p>
</blockquote>
<p>Abstract over behavior：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn print_news&lt;T: Truth&gt;(facts: &amp;[T]) {
  for fact in facts {
    let fact = fact.make_true();
    println!(&quot;{}&quot;, fact);
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>参数用trait来限定， 即要求只有符合某类特征的才允许传入</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt;

fn print_news&lt;T: Truth + fmt::Display&gt;(facts: &amp;[T]) {
  for fact in facts {
    let fact = fact.make_true();
    println!(&quot;{}&quot;, fact);
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>T泛型可以要求多个trait， 使用加号 +</p>
</blockquote>
<p>also need:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl fmt::Display for Fact {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{}&quot;, self.text)
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Fact还需要实现Display这个trait</p>
</blockquote>
<p>where syntax:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn print_news&lt;T: Truth + fmt::Display&gt;(facts: &amp;[T]) {}

fn print_news&lt;T&gt;(facts: &amp;[T]) where T: Truth + fmt::Display {}

<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>使用where语法简化</p>
</blockquote>
<p>Using Generics in impls</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Debug&gt; Foo for Vec&lt;T&gt; {
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>在impl的时候使用泛型约束， 即规定T是什么样子的 (前面是方法的反省， 这里是在impl上约束)</p>
</blockquote>
<p>Associated items：</p>
<p>Associated functions
That’s what we’ve been writing all this time</p>
<blockquote>
<p>关联函数是什么？</p>
</blockquote>
<p>Associated types
specify types you need to refer to that are specific to each impl block</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Iterator {
  type Item;
  fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}

impl Iterator for FourIntegers {
  type Item = i32;
  fn next(&amp;mut self) -&gt; Option&lt;i32&gt; {}
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>关联类型的好处是不需要额外的泛型参数， 有点像模板模式</p>
<p>但是有一个问题， 感觉这里Option<i32>和type Item = i32有点重复的感觉。 </p>
</blockquote>
<p>Associated constants：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait SuperLog {
  const LABEL: Display;

  fn log(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>没看懂代码， 这里constant是什么？</p>
</blockquote>
<p>Unambiguous function call syntax：</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fact.make_true()

//expands to

&lt;Fact as Truth&gt;::make_true(fact)
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>基于trait的方法调用， 实际是展开的， 即  <Data as Trait>:: method(data)</p>
</blockquote>
<p>Operators are traits:</p>
<p>a + b expands to std::ops::Add::add(a, b)</p>
<p>because of:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>impl Add&lt;i32&gt; for i32 {
  type Output = i32;
  // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Marker traits:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Fancy {}

impl Fancy for Vec&lt;String&gt; {}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>没有任何方法， 仅仅作为标记， 比如Send和Sync标记也是如此</p>
</blockquote>
<h1><a class="header" href="#demo-1" id="demo-1">demo</a></h1>
<h1><a class="header" href="#demo-2" id="demo-2">demo</a></h1>
<h1><a class="header" href="#demo-3" id="demo-3">demo</a></h1>
<h1><a class="header" href="#demo-4" id="demo-4">demo</a></h1>
<h1><a class="header" href="#demo-5" id="demo-5">demo</a></h1>
<h1><a class="header" href="#极客时间-数据结构与算法之美" id="极客时间-数据结构与算法之美">极客时间 数据结构与算法之美</a></h1>
<h1><a class="header" href="#algorithm-book" id="algorithm-book">Algorithm Book</a></h1>
<h1><a class="header" href="#极客时间-程序员的数学基础课" id="极客时间-程序员的数学基础课">极客时间 程序员的数学基础课</a></h1>
<h1><a class="header" href="#demo-6" id="demo-6">demo</a></h1>
<h1><a class="header" href="#编程之道-tao-of-rust" id="编程之道-tao-of-rust">编程之道 Tao of Rust</a></h1>
<p><img src="tao//images/2019-07-11-11-37-42.png" alt="" /></p>
<h1><a class="header" href="#类型系统" id="类型系统">类型系统</a></h1>
<h1><a class="header" href="#内存管理" id="内存管理">内存管理</a></h1>
<h1><a class="header" href="#所有权系统" id="所有权系统">所有权系统</a></h1>
<h1><a class="header" href="#函数-闭包与迭代器" id="函数-闭包与迭代器">函数 闭包与迭代器</a></h1>
<h1><a class="header" href="#结构化编程" id="结构化编程">结构化编程</a></h1>
<h1><a class="header" href="#字符串与集合类型" id="字符串与集合类型">字符串与集合类型</a></h1>
<h1><a class="header" href="#构建健壮的程序" id="构建健壮的程序">构建健壮的程序</a></h1>
<h1><a class="header" href="#模块化编程" id="模块化编程">模块化编程</a></h1>
<h1><a class="header" href="#安全并发" id="安全并发">安全并发</a></h1>
<h1><a class="header" href="#元编程" id="元编程">元编程</a></h1>
<h1><a class="header" href="#超越安全的边界" id="超越安全的边界">超越安全的边界</a></h1>
<h1><a class="header" href="#rust-by-example" id="rust-by-example">Rust by Example</a></h1>
<p><a href="https://www.rust-lang.org/">Rust</a> is a modern systems programming language focusing on safety, speed,
and concurrency. It accomplishes these goals by being memory safe without using 
garbage collection.</p>
<p>Rust by Example (RBE) is a collection of runnable examples that illustrate various Rust
concepts and standard libraries. To get even more out of these examples, don't forget
to <a href="https://www.rust-lang.org/tools/install">install Rust locally</a> and check out the <a href="https://doc.rust-lang.org/std/">official docs</a>. 
Additionally for the curious, you can also <a href="https://github.com/rust-lang/rust-by-example">check out the source code for this site</a>.</p>
<p>Now let's begin!</p>
<ul>
<li>
<p><a href="rustexample/hello.html">Hello World</a> - Start with a traditional Hello World program.</p>
</li>
<li>
<p><a href="rustexample/primitives.html">Primitives</a> - Learn about signed integers, unsigned integers and other primitives.</p>
</li>
<li>
<p><a href="rustexample/custom_types.html">Custom Types</a> - <code>struct</code> and <code>enum</code>.</p>
</li>
<li>
<p><a href="rustexample/variable_bindings.html">Variable Bindings</a> - mutable bindings, scope, shadowing.</p>
</li>
<li>
<p><a href="rustexample/types.html">Types</a> - Learn about changing and defining types.</p>
</li>
<li>
<p><a href="rustexample/conversion.html">Conversion</a></p>
</li>
<li>
<p><a href="rustexample/expression.html">Expressions</a></p>
</li>
<li>
<p><a href="rustexample/flow_control.html">Flow of Control</a> - <code>if</code>/<code>else</code>, <code>for</code>, and others.</p>
</li>
<li>
<p><a href="rustexample/fn.html">Functions</a> - Learn about Methods, Closures and High Order Functions.</p>
</li>
<li>
<p><a href="rustexample/mod.html">Modules</a> - Organize code using modules</p>
</li>
<li>
<p><a href="rustexample/crates.html">Crates</a> - A crate is a compilation unit in Rust. Learn to create a library.</p>
</li>
<li>
<p><a href="rustexample/cargo.html">Cargo</a> - Go through some basic features of the official Rust package management tool.</p>
</li>
<li>
<p><a href="rustexample/attribute.html">Attributes</a> - An attribute is metadata applied to some module, crate or item.</p>
</li>
<li>
<p><a href="rustexample/generics.html">Generics</a> - Learn about writing a function or data type which can work for multiple types of arguments.</p>
</li>
<li>
<p><a href="rustexample/scope.html">Scoping rules</a> - Scopes play an important part in ownership, borrowing, and lifetimes.</p>
</li>
<li>
<p><a href="rustexample/trait.html">Traits</a> - A trait is a collection of methods defined for an unknown type: <code>Self</code></p>
</li>
<li>
<p><a href="rustexample/macros.html">Macros</a></p>
</li>
<li>
<p><a href="rustexample/error.html">Error handling</a> - Learn Rust way of handling failures.</p>
</li>
<li>
<p><a href="rustexample/std.html">Std library types</a> - Learn about some custom types provided by <code>std</code> library.</p>
</li>
<li>
<p><a href="rustexample/std_misc.html">Std misc</a> - More custom types for file handling, threads.</p>
</li>
<li>
<p><a href="rustexample/testing.html">Testing</a> - All sorts of testing in Rust.</p>
</li>
<li>
<p><a href="rustexample/unsafe.html">Unsafe Operations</a></p>
</li>
<li>
<p><a href="rustexample/compatibility.html">Compatibility</a></p>
</li>
<li>
<p><a href="rustexample/meta.html">Meta</a> - Documentation, Benchmarking.</p>
</li>
</ul>
<h1><a class="header" href="#hello-world" id="hello-world">Hello World</a></h1>
<p>This is the source code of the traditional Hello World program.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This is a comment, and is ignored by the compiler
// You can test this code by clicking the &quot;Run&quot; button over there -&gt;
// or if you prefer to use your keyboard, you can use the &quot;Ctrl + Enter&quot; shortcut

// This code is editable, feel free to hack it!
// You can always return to the original code by clicking the &quot;Reset&quot; button -&gt;

// This is the main function
fn main() {
    // Statements here are executed when the compiled binary is called

    // Print text to the console
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p><code>println!</code> is a <a href="rustexample/macros.html"><em>macro</em></a> that prints text to the
console.</p>
<p>A binary can be generated using the Rust compiler: <code>rustc</code>.</p>
<pre><code class="language-bash">$ rustc hello.rs
</code></pre>
<p><code>rustc</code> will produce a <code>hello</code> binary that can be executed.</p>
<pre><code class="language-bash">$ ./hello
Hello World!
</code></pre>
<h3><a class="header" href="#activity" id="activity">Activity</a></h3>
<p>Click 'Run' above to see the expected output. Next, add a new
line with a second <code>println!</code> macro so that the output
shows:</p>
<pre><code class="language-text">Hello World!
I'm a Rustacean!
</code></pre>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<p>Any program requires comments, and Rust supports
a few different varieties:</p>
<ul>
<li><em>Regular comments</em> which are ignored by the compiler:
<ul>
<li><code>// Line comments which go to the end of the line.</code></li>
<li><code>/* Block comments which go to the closing delimiter. */</code></li>
</ul>
</li>
<li><em>Doc comments</em> which are parsed into HTML library
<a href="rustexample/hello/../meta/doc.html">documentation</a>:
<ul>
<li><code>/// Generate library docs for the following item.</code></li>
<li><code>//! Generate library docs for the enclosing item.</code></li>
</ul>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // This is an example of a line comment
    // There are two slashes at the beginning of the line
    // And nothing written inside these will be read by the compiler

    // println!(&quot;Hello, world!&quot;);

    // Run it. See? Now try deleting the two slashes, and run it again.

    /* 
     * This is another type of comment, a block comment. In general,
     * line comments are the recommended comment style. But
     * block comments are extremely useful for temporarily disabling
     * chunks of code. /* Block comments can be /* nested, */ */
     * so it takes only a few keystrokes to comment out everything
     * in this main() function. /*/*/* Try it yourself! */*/*/
     */

    /*
    Note: The previous column of `*` was entirely for style. There's
    no actual need for it.
    */

    // You can manipulate expressions more easily with block comments
    // than with line comments. Try deleting the comment delimiters
    // to change the result:
    let x = 5 + /* 90 + */ 5;
    println!(&quot;Is `x` 10 or 100? x = {}&quot;, x);
}

</code></pre></pre>
<h3><a class="header" href="#see-also" id="see-also">See also:</a></h3>
<p><a href="rustexample/hello/../meta/doc.html">Library documentation</a></p>
<h1><a class="header" href="#formatted-print" id="formatted-print">Formatted print</a></h1>
<p>Printing is handled by a series of <a href="rustexample/hello/../macros.html"><code>macros</code></a> defined in <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>
some of which include:</p>
<ul>
<li><code>format!</code>: write formatted text to <a href="rustexample/hello/../std/str.html"><code>String</code></a></li>
<li><code>print!</code>: same as <code>format!</code> but the text is printed to the console (io::stdout).</li>
<li><code>println!</code>: same as <code>print!</code> but a newline is appended.</li>
<li><code>eprint!</code>: same as <code>format!</code> but the text is printed to the standard error (io::stderr).</li>
<li><code>eprintln!</code>: same as <code>eprint!</code>but a newline is appended.</li>
</ul>
<p>All parse text in the same fashion. As a plus, Rust checks formatting 
correctness at compile time.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // In general, the `{}` will be automatically replaced with any
    // arguments. These will be stringified.
    println!(&quot;{} days&quot;, 31);

    // Without a suffix, 31 becomes an i32. You can change what type 31 is
    // by providing a suffix.

    // There are various optional patterns this works with. Positional
    // arguments can be used.
    println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Alice&quot;, &quot;Bob&quot;);

    // As can named arguments.
    println!(&quot;{subject} {verb} {object}&quot;,
             object=&quot;the lazy dog&quot;,
             subject=&quot;the quick brown fox&quot;,
             verb=&quot;jumps over&quot;);

    // Special formatting can be specified after a `:`.
    println!(&quot;{} of {:b} people know binary, the other half doesn't&quot;, 1, 2);

    // You can right-align text with a specified width. This will output
    // &quot;     1&quot;. 5 white spaces and a &quot;1&quot;.
    println!(&quot;{number:&gt;width$}&quot;, number=1, width=6);

    // You can pad numbers with extra zeroes. This will output &quot;000001&quot;.
    println!(&quot;{number:&gt;0width$}&quot;, number=1, width=6);

    // Rust even checks to make sure the correct number of arguments are
    // used.
    println!(&quot;My name is {0}, {1} {0}&quot;, &quot;Bond&quot;);
    // FIXME ^ Add the missing argument: &quot;James&quot;

    // Create a structure named `Structure` which contains an `i32`.
    #[allow(dead_code)]
    struct Structure(i32);

    // However, custom types such as this structure require more complicated
    // handling. This will not work.
    println!(&quot;This struct `{}` won't print...&quot;, Structure(3));
    // FIXME ^ Comment out this line.
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> contains many <a href="rustexample/hello/../trait.html"><code>traits</code></a> which govern the display
of text. The base form of two important ones are listed below:</p>
<ul>
<li><code>fmt::Debug</code>: Uses the <code>{:?}</code> marker. Format text for debugging purposes.</li>
<li><code>fmt::Display</code>: Uses the <code>{}</code> marker. Format text in a more elegant, user
friendly fashion.</li>
</ul>
<p>Here, we used <code>fmt::Display </code>because the std library provides implementations
for these types. To print text for custom types, more steps are required.</p>
<p>Implementing the <code>fmt::Display</code> trait automagically implements the
<a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> trait which allows us to <a href="rustexample/hello/../conversion/string.html">convert</a> the type to <a href="rustexample/hello/../std/str.html"><code>String</code></a>.</p>
<h3><a class="header" href="#activities" id="activities">Activities</a></h3>
<ul>
<li>Fix the two issues in the above code (see FIXME) so that it runs without
error.</li>
<li>Add a <code>println!</code> macro that prints: <code>Pi is roughly 3.142</code> by controlling
the number of decimal places shown. For the purposes of this exercise,
use <code>let pi = 3.141592</code> as an estimate for pi. (Hint: you may need to
check the <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> documentation for setting the number of
decimals to display)</li>
</ul>
<h3><a class="header" href="#see-also-1" id="see-also-1">See also</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="rustexample/hello/../macros.html"><code>macros</code></a>, <a href="rustexample/hello/../custom_types/structs.html"><code>struct</code></a>,
and <a href="rustexample/hello/../trait.html"><code>traits</code></a></p>
<h1><a class="header" href="#debug" id="debug">Debug</a></h1>
<p>All types which want to use <code>std::fmt</code> formatting <code>traits</code> require an
implementation to be printable. Automatic implementations are only provided
for types such as in the <code>std</code> library. All others <em>must</em> be manually
implemented somehow.</p>
<p>The <code>fmt::Debug</code> <code>trait</code> makes this very straightforward. <em>All</em> types can
<code>derive</code> (automatically create) the <code>fmt::Debug</code> implementation. This is
not true for <code>fmt::Display</code> which must be manually implemented.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// This structure cannot be printed either with `fmt::Display` or
// with `fmt::Debug`.
struct UnPrintable(i32);

// The `derive` attribute automatically creates the implementation
// required to make this `struct` printable with `fmt::Debug`.
#[derive(Debug)]
struct DebugPrintable(i32);
<span class="boring">}
</span></code></pre></pre>
<p>All <code>std</code> library types automatically are printable with <code>{:?}</code> too:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Derive the `fmt::Debug` implementation for `Structure`. `Structure`
// is a structure which contains a single `i32`.
#[derive(Debug)]
struct Structure(i32);

// Put a `Structure` inside of the structure `Deep`. Make it printable
// also.
#[derive(Debug)]
struct Deep(Structure);

fn main() {
    // Printing with `{:?}` is similar to with `{}`.
    println!(&quot;{:?} months in a year.&quot;, 12);
    println!(&quot;{1:?} {0:?} is the {actor:?} name.&quot;,
             &quot;Slater&quot;,
             &quot;Christian&quot;,
             actor=&quot;actor's&quot;);

    // `Structure` is printable!
    println!(&quot;Now {:?} will print!&quot;, Structure(3));
    
    // The problem with `derive` is there is no control over how
    // the results look. What if I want this to just show a `7`?
    println!(&quot;Now {:?} will print!&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<p>So <code>fmt::Debug</code> definitely makes this printable but sacrifices some
elegance. Rust also provides &quot;pretty printing&quot; with <code>{:#?}</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // Pretty print
    println!(&quot;{:#?}&quot;, peter);
}
</code></pre></pre>
<p>One can manually implement <code>fmt::Display</code> to control the display.</p>
<h3><a class="header" href="#see-also-2" id="see-also-2">See also</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html">attributes</a>, <a href="rustexample/hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>,
and <a href="rustexample/hello/print/../../custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#display" id="display">Display</a></h1>
<p><code>fmt::Debug</code> hardly looks compact and clean, so it is often advantageous to
customize the output appearance. This is done by manually implementing
<a href="https://doc.rust-lang.org/std/fmt/"><code>fmt::Display</code></a>, which uses the <code>{}</code> print marker. Implementing it
looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Import (via `use`) the `fmt` module to make it available.
use std::fmt;

// Define a structure for which `fmt::Display` will be implemented. This is
// a tuple struct named `Structure` that contains an `i32`.
struct Structure(i32);

// To use the `{}` marker, the trait `fmt::Display` must be implemented
// manually for the type.
impl fmt::Display for Structure {
    // This trait requires `fmt` with this exact signature.
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Write strictly the first element into the supplied output
        // stream: `f`. Returns `fmt::Result` which indicates whether the
        // operation succeeded or failed. Note that `write!` uses syntax which
        // is very similar to `println!`.
        write!(f, &quot;{}&quot;, self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fmt::Display</code> may be cleaner than <code>fmt::Debug</code> but this presents
a problem for the <code>std</code> library. How should ambiguous types be displayed?
For example, if the <code>std</code> library implemented a single style for all
<code>Vec&lt;T&gt;</code>, what style should it be? Would it be either of these two?</p>
<ul>
<li><code>Vec&lt;path&gt;</code>: <code>/:/etc:/home/username:/bin</code> (split on <code>:</code>)</li>
<li><code>Vec&lt;number&gt;</code>: <code>1,2,3</code> (split on <code>,</code>)</li>
</ul>
<p>No, because there is no ideal style for all types and the <code>std</code> library
doesn't presume to dictate one. <code>fmt::Display</code> is not implemented for <code>Vec&lt;T&gt;</code>
or for any other generic containers. <code>fmt::Debug</code> must then be used for these
generic cases.</p>
<p>This is not a problem though because for any new <em>container</em> type which is
<em>not</em> generic,<code>fmt::Display</code> can be implemented.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // Import `fmt`

// A structure holding two numbers. `Debug` will be derived so the results can
// be contrasted with `Display`.
#[derive(Debug)]
struct MinMax(i64, i64);

// Implement `Display` for `MinMax`.
impl fmt::Display for MinMax {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Use `self.number` to refer to each positional data point.
        write!(f, &quot;({}, {})&quot;, self.0, self.1)
    }
}

// Define a structure where the fields are nameable for comparison.
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

// Similarly, implement `Display` for `Point2D`
impl fmt::Display for Point2D {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Customize so only `x` and `y` are denoted.
        write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
    }
}

fn main() {
    let minmax = MinMax(0, 14);

    println!(&quot;Compare structures:&quot;);
    println!(&quot;Display: {}&quot;, minmax);
    println!(&quot;Debug: {:?}&quot;, minmax);

    let big_range =   MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(&quot;The big range is {big} and the small is {small}&quot;,
             small = small_range,
             big = big_range);

    let point = Point2D { x: 3.3, y: 7.2 };

    println!(&quot;Compare points:&quot;);
    println!(&quot;Display: {}&quot;, point);
    println!(&quot;Debug: {:?}&quot;, point);

    // Error. Both `Debug` and `Display` were implemented, but `{:b}`
    // requires `fmt::Binary` to be implemented. This will not work.
    // println!(&quot;What does Point2D look like in binary: {:b}?&quot;, point);
}
</code></pre></pre>
<p>So, <code>fmt::Display</code> has been implemented but <code>fmt::Binary</code> has not, and
therefore cannot be used. <code>std::fmt</code> has many such <a href="rustexample/hello/print/../../trait.html"><code>traits</code></a> and
each requires its own implementation. This is detailed further in
<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>.</p>
<h3><a class="header" href="#activity-1" id="activity-1">Activity</a></h3>
<p>After checking the output of the above example, use the <code>Point2D</code> struct as a
guide to add a Complex struct to the example. When printed in the same
way, the output should be:</p>
<pre><code class="language-txt">Display: 3.3 + 7.2i
Debug: Complex { real: 3.3, imag: 7.2 }
</code></pre>
<h3><a class="header" href="#see-also-3" id="see-also-3">See also</a></h3>
<p><a href="rustexample/hello/print/../../trait/derive.html"><code>derive</code></a>, <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a>, <a href="rustexample/hello/print/../../macros.html">macros</a>, <a href="rustexample/hello/print/../../custom_types/structs.html"><code>struct</code></a>,
<a href="rustexample/hello/print/../../trait.html"><code>trait</code></a>, and <a href="rustexample/hello/print/../../mod/use.html">use</a></p>
<h1><a class="header" href="#testcase-list" id="testcase-list">Testcase: List</a></h1>
<p>Implementing <code>fmt::Display</code> for a structure where the elements must each be
handled sequentially is tricky. The problem is that each <code>write!</code> generates a
<code>fmt::Result</code>. Proper handling of this requires dealing with <em>all</em> the
results. Rust provides the <code>?</code> operator for exactly this purpose.</p>
<p>Using <code>?</code> on <code>write!</code> looks like this:</p>
<pre><code class="language-rust ignore">// Try `write!` to see if it errors. If it errors, return
// the error. Otherwise continue.
write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p>Alternatively, you can also use the <code>try!</code> macro, which works the same way. 
This is a bit more verbose and no longer recommended, but you may still see it in
older Rust code. Using <code>try!</code> looks like this:</p>
<pre><code class="language-rust ignore">try!(write!(f, &quot;{}&quot;, value));
</code></pre>
<p>With <code>?</code> available, implementing <code>fmt::Display</code> for a <code>Vec</code> is
straightforward:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt; // Import the `fmt` module.

// Define a structure named `List` containing a `Vec`.
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        // Extract the value using tuple indexing,
        // and create a reference to `vec`.
        let vec = &amp;self.0;

        write!(f, &quot;[&quot;)?;

        // Iterate over `v` in `vec` while enumerating the iteration
        // count in `count`.
        for (count, v) in vec.iter().enumerate() {
            // For every element except the first, add a comma.
            // Use the ? operator, or try!, to return on errors.
            if count != 0 { write!(f, &quot;, &quot;)?; }
            write!(f, &quot;{}&quot;, v)?;
        }

        // Close the opened bracket and return a fmt::Result value.
        write!(f, &quot;]&quot;)
    }
}

fn main() {
    let v = List(vec![1, 2, 3]);
    println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<h3><a class="header" href="#activity-2" id="activity-2">Activity</a></h3>
<p>Try changing the program so that the index of each element in the vector is also printed. The new output should look like this:</p>
<pre><code class="language-rust ignore">[0: 1, 1: 2, 2: 3]
</code></pre>
<h3><a class="header" href="#see-also-4" id="see-also-4">See also</a></h3>
<p><a href="rustexample/hello/print/print_display/../../../flow_control/for.html"><code>for</code></a>, <a href="rustexample/hello/print/print_display/../../../scope/borrow/ref.html"><code>ref</code></a>, <a href="rustexample/hello/print/print_display/../../../std/result.html"><code>Result</code></a>, <a href="rustexample/hello/print/print_display/../../../custom_types/structs.html"><code>struct</code></a>,
<a href="rustexample/hello/print/print_display/../../../std/result/question_mark.html"><code>?</code></a>, and <a href="rustexample/hello/print/print_display/../../../std/vec.html"><code>vec!</code></a></p>
<h1><a class="header" href="#formatting" id="formatting">Formatting</a></h1>
<p>We've seen that formatting is specified via a <em>format string</em>:</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt;
<a href="https://en.wikipedia.org/wiki/Deadbeef#Magic_debug_values"><code>&quot;0xDEADBEEF&quot;</code></a></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; <code>&quot;0o33653337357&quot;</code></li>
</ul>
<p>The same variable (<code>foo</code>) can be formatted differently depending on which
<em>argument type</em> is used: <code>X</code> vs <code>o</code> vs <em>unspecified</em>.</p>
<p>This formatting functionality is implemented via traits, and there is one trait
for each argument type. The most common formatting trait is <code>Display</code>, which
handles cases where the argument type is left unspecified: <code>{}</code> for instance.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{self, Formatter, Display};

struct City {
    name: &amp;'static str,
    // Latitude
    lat: f32,
    // Longitude
    lon: f32,
}

impl Display for City {
    // `f` is a buffer, and this method must write the formatted string into it
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

        // `write!` is like `format!`, but it will write the formatted string
        // into a buffer (the first argument)
        write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
               self.name, self.lat.abs(), lat_c, self.lon.abs(), lon_c)
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

fn main() {
    for city in [
        City { name: &quot;Dublin&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;Oslo&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;Vancouver&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        // Switch this to use {} once you've added an implementation
        // for fmt::Display.
        println!(&quot;{:?}&quot;, *color);
    }
}
</code></pre></pre>
<p>You can view a <a href="https://doc.rust-lang.org/std/fmt/#formatting-traits">full list of formatting traits</a> and their argument
types in the <a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> documentation.</p>
<h3><a class="header" href="#activity-3" id="activity-3">Activity</a></h3>
<p>Add an implementation of the <code>fmt::Display</code> trait for the <code>Color</code> struct above
so that the output displays as:</p>
<pre><code class="language-text">RGB (128, 255, 90) 0x80FF5A
RGB (0, 3, 254) 0x0003FE
RGB (0, 0, 0) 0x000000
</code></pre>
<p>Two hints if you get stuck:</p>
<ul>
<li>You <a href="https://doc.rust-lang.org/std/fmt/#named-parameters">may need to list each color more than once</a>,</li>
<li>You can <a href="https://doc.rust-lang.org/std/fmt/#width">pad with zeros to a width of 2</a> with <code>:02</code>.</li>
</ul>
<h3><a class="header" href="#see-also-5" id="see-also-5">See also</a></h3>
<p><a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a></p>
<h1><a class="header" href="#primitives" id="primitives">Primitives</a></h1>
<p>Rust provides access to a wide variety of <code>primitives</code>. A sample includes:</p>
<h3><a class="header" href="#scalar-types" id="scalar-types">Scalar Types</a></h3>
<ul>
<li>signed integers: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code> and <code>isize</code> (pointer size)</li>
<li>unsigned integers: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> and <code>usize</code> (pointer
size)</li>
<li>floating point: <code>f32</code>, <code>f64</code></li>
<li><code>char</code> Unicode scalar values like <code>'a'</code>, <code>'α'</code> and <code>'∞'</code> (4 bytes each)</li>
<li><code>bool</code> either <code>true</code> or <code>false</code></li>
<li>and the unit type <code>()</code>, whose only possible value is an empty tuple: <code>()</code></li>
</ul>
<p>Despite the value of a unit type being a tuple, it is not considered a
compound type because it does not contain multiple values. </p>
<h3><a class="header" href="#compound-types" id="compound-types">Compound Types</a></h3>
<ul>
<li>arrays like <code>[1, 2, 3]</code></li>
<li>tuples like <code>(1, true)</code></li>
</ul>
<p>Variables can always be <em>type annotated</em>. Numbers may additionally be
annotated via a <em>suffix</em> or <em>by default</em>. Integers default to <code>i32</code> and
floats to <code>f64</code>. Note that Rust can also infer types from context.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Variables can be type annotated.
    let logical: bool = true;

    let a_float: f64 = 1.0;  // Regular annotation
    let an_integer   = 5i32; // Suffix annotation

    // Or a default will be used.
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`
    
    // A type can also be inferred from context 
    let mut inferred_type = 12; // Type i64 is inferred from another line
    inferred_type = 4294967296i64;
    
    // A mutable variable's value can be changed.
    let mut mutable = 12; // Mutable `i32`
    mutable = 21;
    
    // Error! The type of a variable can't be changed.
    mutable = true;
    
    // Variables can be overwritten with shadowing.
    let mutable = true;
}
</code></pre></pre>
<h3><a class="header" href="#see-also-6" id="see-also-6">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/">the <code>std</code> library</a>, <a href="rustexample/variable_bindings/mut.html"><code>mut</code></a>, <a href="rustexample/types/inference.html">inference</a>, and <a href="rustexample/variable_bindings/scope.html">shadowing</a></p>
<h1><a class="header" href="#literals-and-operators" id="literals-and-operators">Literals and operators</a></h1>
<p>Integers <code>1</code>, floats <code>1.2</code>, characters <code>'a'</code>, strings <code>&quot;abc&quot;</code>, booleans <code>true</code>
and the unit type <code>()</code> can be expressed using literals.</p>
<p>Integers can, alternatively, be expressed using hexadecimal, octal or binary
notation using these prefixes respectively: <code>0x</code>, <code>0o</code> or <code>0b</code>.</p>
<p>Underscores can be inserted in numeric literals to improve readability, e.g.
<code>1_000</code> is the same as <code>1000</code>, and <code>0.000_001</code> is the same as <code>0.000001</code>.</p>
<p>We need to tell the compiler the type of the literals we use. For now,
we'll use the <code>u32</code> suffix to indicate that the literal is an unsigned 32-bit
integer, and the <code>i32</code> suffix to indicate that it's a signed 32-bit integer.</p>
<p>The operators available and their precedence <a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">in Rust</a> are similar to other
<a href="https://en.wikipedia.org/wiki/Operator_precedence#Programming_languages">C-like languages</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Integer addition
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // Integer subtraction
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);
    // TODO ^ Try changing `1i32` to `1u32` to see why the type is important

    // Short-circuiting boolean logic
    println!(&quot;true AND false is {}&quot;, true &amp;&amp; false);
    println!(&quot;true OR false is {}&quot;, true || false);
    println!(&quot;NOT true is {}&quot;, !true);

    // Bitwise operations
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // Use underscores to improve readability!
    println!(&quot;One million is written as {}&quot;, 1_000_000u32);
}
</code></pre></pre>
<h1><a class="header" href="#tuples" id="tuples">Tuples</a></h1>
<p>A tuple is a collection of values of different types. Tuples are constructed
using parentheses <code>()</code>, and each tuple itself is a value with type signature
<code>(T1, T2, ...)</code>, where <code>T1</code>, <code>T2</code> are the types of its members. Functions can
use tuples to return multiple values, as tuples can hold any number of values.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Tuples can be used as function arguments and as return values
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
    // `let` can be used to bind the members of a tuple to variables
    let (integer, boolean) = pair;

    (boolean, integer)
}

// The following struct is for the activity.
#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

fn main() {
    // A tuple with a bunch of different types
    let long_tuple = (1u8, 2u16, 3u32, 4u64,
                      -1i8, -2i16, -3i32, -4i64,
                      0.1f32, 0.2f64,
                      'a', true);

    // Values can be extracted from the tuple using tuple indexing
    println!(&quot;long tuple first value: {}&quot;, long_tuple.0);
    println!(&quot;long tuple second value: {}&quot;, long_tuple.1);

    // Tuples can be tuple members
    let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

    // Tuples are printable
    println!(&quot;tuple of tuples: {:?}&quot;, tuple_of_tuples);
    
    // But long Tuples cannot be printed
    // let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    // println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
    // TODO ^ Uncomment the above 2 lines to see the compiler error

    let pair = (1, true);
    println!(&quot;pair is {:?}&quot;, pair);

    println!(&quot;the reversed pair is {:?}&quot;, reverse(pair));

    // To create one element tuples, the comma is required to tell them apart
    // from a literal surrounded by parentheses
    println!(&quot;one element tuple: {:?}&quot;, (5u32,));
    println!(&quot;just an integer: {:?}&quot;, (5u32));

    //tuples can be destructured to create bindings
    let tuple = (1, &quot;hello&quot;, 4.5, true);

    let (a, b, c, d) = tuple;
    println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!(&quot;{:?}&quot;, matrix);

}
</code></pre></pre>
<h3><a class="header" href="#activity-4" id="activity-4">Activity</a></h3>
<ol>
<li>
<p><em>Recap</em>: Add the <code>fmt::Display</code> trait to the Matrix <code>struct</code> in the above example,
so that if you switch from printing the debug format <code>{:?}</code> to the display
format <code>{}</code>, you see the following output:</p>
<pre><code class="language-text">( 1.1 1.2 )
( 2.1 2.2 )
</code></pre>
<p>You may want to refer back to the example for <a href="rustexample/primitives/../hello/print/print_display.html">print display</a>.</p>
</li>
<li>
<p>Add a <code>transpose</code> function using the <code>reverse</code> function as a template, which
accepts a matrix as an argument, and returns a matrix in which two elements
have been swapped. For example:</p>
<pre><code class="language-rust ignore">println!(&quot;Matrix:\n{}&quot;, matrix);
println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
</code></pre>
<p>results in the output:</p>
<pre><code class="language-text">Matrix:
( 1.1 1.2 )
( 2.1 2.2 )
Transpose:
( 1.1 2.1 )
( 1.2 2.2 )
</code></pre>
</li>
</ol>
<h1><a class="header" href="#arrays-and-slices" id="arrays-and-slices">Arrays and Slices</a></h1>
<p>An array is a collection of objects of the same type <code>T</code>, stored in contiguous
memory. Arrays are created using brackets <code>[]</code>, and their size, which is known
at compile time, is part of their type signature <code>[T; size]</code>.</p>
<p>Slices are similar to arrays, but their size is not known at compile time.
Instead, a slice is a two-word object, the first word is a pointer to the data,
and the second word is the length of the slice. The word size is the same as 
usize, determined by the processor architecture eg 64 bits on an x86-64. 
Slices can be used to borrow a section of an array, and have the type signature 
<code>&amp;[T]</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::mem;

// This function borrows a slice
fn analyze_slice(slice: &amp;[i32]) {
    println!(&quot;first element of the slice: {}&quot;, slice[0]);
    println!(&quot;the slice has {} elements&quot;, slice.len());
}

fn main() {
    // Fixed-size array (type signature is superfluous)
    let xs: [i32; 5] = [1, 2, 3, 4, 5];

    // All elements can be initialized to the same value
    let ys: [i32; 500] = [0; 500];

    // Indexing starts at 0
    println!(&quot;first element of the array: {}&quot;, xs[0]);
    println!(&quot;second element of the array: {}&quot;, xs[1]);

    // `len` returns the size of the array
    println!(&quot;array size: {}&quot;, xs.len());

    // Arrays are stack allocated
    println!(&quot;array occupies {} bytes&quot;, mem::size_of_val(&amp;xs));

    // Arrays can be automatically borrowed as slices
    println!(&quot;borrow the whole array as a slice&quot;);
    analyze_slice(&amp;xs);

    // Slices can point to a section of an array
    println!(&quot;borrow a section of the array as a slice&quot;);
    analyze_slice(&amp;ys[1 .. 4]);

    // Out of bound indexing causes compile error
    println!(&quot;{}&quot;, xs[5]);
}
</code></pre></pre>
<h1><a class="header" href="#custom-types" id="custom-types">Custom Types</a></h1>
<p>Rust custom data types are formed mainly through the two keywords:</p>
<ul>
<li><code>struct</code>: define a structure</li>
<li><code>enum</code>: define an enumeration</li>
</ul>
<p>Constants can also be created via the <code>const</code> and <code>static</code> keywords.</p>
<h1><a class="header" href="#structures" id="structures">Structures</a></h1>
<p>There are three types of structures (&quot;structs&quot;) that can be created using the
<code>struct</code> keyword:</p>
<ul>
<li>Tuple structs, which are, basically, named tuples.</li>
<li>The classic <a href="https://en.wikipedia.org/wiki/Struct_(C_programming_language)">C structs</a></li>
<li>Unit structs, which are field-less, are useful for generics.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8,
}

// A unit struct
struct Nil;

// A tuple struct
struct Pair(i32, f32);

// A struct with two fields
struct Point {
    x: f32,
    y: f32,
}

// Structs can be reused as fields of another struct
#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn main() {
    // Create struct with field init shorthand
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // Print debug struct
    println!(&quot;{:?}&quot;, peter);


    // Instantiate a `Point`
    let point: Point = Point { x: 0.3, y: 0.4 };

    // Access the fields of the point
    println!(&quot;point coordinates: ({}, {})&quot;, point.x, point.y);

    // Make a new point by using struct update syntax to use the fields of our other one
    let new_point = Point { x: 0.1, ..point };
    // `new_point.y` will be the same as `point.y` because we used that field from `point`
    println!(&quot;second point: ({}, {})&quot;, new_point.x, new_point.y);

    // Destructure the point using a `let` binding
    let Point { x: my_x, y: my_y } = point;

    let _rectangle = Rectangle {
        // struct instantiation is an expression too
        p1: Point { x: my_y, y: my_x },
        p2: point,
    };

    // Instantiate a unit struct
    let _nil = Nil;

    // Instantiate a tuple struct
    let pair = Pair(1, 0.1);

    // Access the fields of a tuple struct
    println!(&quot;pair contains {:?} and {:?}&quot;, pair.0, pair.1);

    // Destructure a tuple struct
    let Pair(integer, decimal) = pair;

    println!(&quot;pair contains {:?} and {:?}&quot;, integer, decimal);
}
</code></pre></pre>
<h3><a class="header" href="#activity-5" id="activity-5">Activity</a></h3>
<ol>
<li>Add a function <code>rect_area</code> which calculates the area of a rectangle (try 
using nested destructuring). </li>
<li>Add a function <code>square</code> which takes a <code>Point</code> and a <code>f32</code> as arguments, and returns a <code>Rectangle</code> with its lower left corner on the point, and a width and height corresponding to the <code>f32</code>.</li>
</ol>
<h3><a class="header" href="#see-also-7" id="see-also-7">See also:</a></h3>
<p><a href="rustexample/custom_types/../attribute.html"><code>attributes</code></a> and <a href="rustexample/custom_types/../flow_control/match/destructuring.html">destructuring</a></p>
<h1><a class="header" href="#enums" id="enums">Enums</a></h1>
<p>The <code>enum</code> keyword allows the creation of a type which may be one of a few
different variants. Any variant which is valid as a <code>struct</code> is also valid as
an <code>enum</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Create an `enum` to classify a web event. Note how both
// names and type information together specify the variant:
// `PageLoad != PageUnload` and `KeyPress(char) != Paste(String)`.
// Each is different and independent.
enum WebEvent {
    // An `enum` may either be `unit-like`,
    PageLoad,
    PageUnload,
    // like tuple structs,
    KeyPress(char),
    Paste(String),
    // or c-like structures.
    Click { x: i64, y: i64 },
}

// A function which takes a `WebEvent` enum as an argument and
// returns nothing.
fn inspect(event: WebEvent) {
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;page loaded&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;page unloaded&quot;),
        // Destructure `c` from inside the `enum`.
        WebEvent::KeyPress(c) =&gt; println!(&quot;pressed '{}'.&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;pasted \&quot;{}\&quot;.&quot;, s),
        // Destructure `Click` into `x` and `y`.
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;clicked at x={}, y={}.&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` creates an owned `String` from a string slice.
    let pasted  = WebEvent::Paste(&quot;my text&quot;.to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}

</code></pre></pre>
<h3><a class="header" href="#see-also-8" id="see-also-8">See also:</a></h3>
<p><a href="rustexample/custom_types/../flow_control/match.html"><code>match</code></a>, <a href="rustexample/custom_types/../fn.html"><code>fn</code></a>, and <a href="rustexample/custom_types/../std/str.html"><code>String</code></a></p>
<h1><a class="header" href="#use" id="use">use</a></h1>
<p>The <code>use</code> declaration can be used so manual scoping isn't needed:</p>
<pre><pre class="playpen"><code class="language-rust editable">// An attribute to hide warnings for unused code.
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // Explicitly `use` each name so they are available without
    // manual scoping.
    use crate::Status::{Poor, Rich};
    // Automatically `use` each name inside `Work`.
    use crate::Work::*;

    // Equivalent to `Status::Poor`.
    let status = Poor;
    // Equivalent to `Work::Civilian`.
    let work = Civilian;

    match status {
        // Note the lack of scoping because of the explicit `use` above.
        Rich =&gt; println!(&quot;The rich have lots of money!&quot;),
        Poor =&gt; println!(&quot;The poor have no money...&quot;),
    }

    match work {
        // Note again the lack of scoping.
        Civilian =&gt; println!(&quot;Civilians work!&quot;),
        Soldier  =&gt; println!(&quot;Soldiers fight!&quot;),
    }
}
</code></pre></pre>
<h3><a class="header" href="#see-also-9" id="see-also-9">See also:</a></h3>
<p><a href="rustexample/custom_types/enum/../../flow_control/match.html"><code>match</code></a> and <a href="rustexample/custom_types/enum/../../mod/use.html"><code>use</code></a> </p>
<h1><a class="header" href="#c-like" id="c-like">C-like</a></h1>
<p><code>enum</code> can also be used as C-like enums.</p>
<pre><pre class="playpen"><code class="language-rust editable">// An attribute to hide warnings for unused code.
#![allow(dead_code)]

// enum with implicit discriminator (starts at 0)
enum Number {
    Zero,
    One,
    Two,
}

// enum with explicit discriminator
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // `enums` can be cast as integers.
    println!(&quot;zero is {}&quot;, Number::Zero as i32);
    println!(&quot;one is {}&quot;, Number::One as i32);

    println!(&quot;roses are #{:06x}&quot;, Color::Red as i32);
    println!(&quot;violets are #{:06x}&quot;, Color::Blue as i32);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-10" id="see-also-10">See also:</a></h3>
<p><a href="rustexample/custom_types/enum/../../types/cast.html">casting</a></p>
<h1><a class="header" href="#testcase-linked-list" id="testcase-linked-list">Testcase: linked-list</a></h1>
<p>A common use for <code>enums</code> is to create a linked-list:</p>
<pre><pre class="playpen"><code class="language-rust editable">use crate::List::*;

enum List {
    // Cons: Tuple struct that wraps an element and a pointer to the next node
    Cons(u32, Box&lt;List&gt;),
    // Nil: A node that signifies the end of the linked list
    Nil,
}

// Methods can be attached to an enum
impl List {
    // Create an empty list
    fn new() -&gt; List {
        // `Nil` has type `List`
        Nil
    }

    // Consume a list, and return the same list with a new element at its front
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons` also has type List
        Cons(elem, Box::new(self))
    }

    // Return the length of the list
    fn len(&amp;self) -&gt; u32 {
        // `self` has to be matched, because the behavior of this method
        // depends on the variant of `self`
        // `self` has type `&amp;List`, and `*self` has type `List`, matching on a
        // concrete type `T` is preferred over a match on a reference `&amp;T`
        match *self {
            // Can't take ownership of the tail, because `self` is borrowed;
            // instead take a reference to the tail
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // Base Case: An empty list has zero length
            Nil =&gt; 0
        }
    }

    // Return representation of the list as a (heap allocated) string
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!` is similar to `print!`, but returns a heap
                // allocated string instead of printing to the console
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // Create an empty linked list
    let mut list = List::new();

    // Prepend some elements
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Show the final state of the list
    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<h3><a class="header" href="#see-also-11" id="see-also-11">See also:</a></h3>
<p><a href="rustexample/custom_types/enum/../../std/box.html"><code>Box</code></a> and <a href="rustexample/custom_types/enum/../../fn/methods.html">methods</a></p>
<h1><a class="header" href="#constants" id="constants">constants</a></h1>
<p>Rust has two different types of constants which can be declared in any scope
including global. Both require explicit type annotation:</p>
<ul>
<li><code>const</code>: An unchangeable value (the common case).</li>
<li><code>static</code>: A possibly <code>mut</code>able variable with <a href="rustexample/custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code></a> lifetime.
The static lifetime is inferred and does not have to be specified.
Accessing or modifying a mutable static variable is <a href="rustexample/custom_types/../unsafe.html"><code>unsafe</code></a>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Globals are declared outside all other scopes.
static LANGUAGE: &amp;str = &quot;Rust&quot;;
const THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // Access constant in some function
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // Access constant in the main thread
    println!(&quot;This is {}&quot;, LANGUAGE);
    println!(&quot;The threshold is {}&quot;, THRESHOLD);
    println!(&quot;{} is {}&quot;, n, if is_big(n) { &quot;big&quot; } else { &quot;small&quot; });

    // Error! Cannot modify a `const`.
    THRESHOLD = 5;
    // FIXME ^ Comment out this line
}
</code></pre></pre>
<h3><a class="header" href="#see-also-12" id="see-also-12">See also:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0246-const-vs-static.md">The <code>const</code>/<code>static</code> RFC</a>,
<a href="rustexample/custom_types/../scope/lifetime/static_lifetime.html"><code>'static</code> lifetime</a></p>
<h1><a class="header" href="#variable-bindings" id="variable-bindings">Variable Bindings</a></h1>
<p>Rust provides type safety via static typing. Variable bindings can be type
annotated when declared. However, in most cases, the compiler will be able
to infer the type of the variable from the context, heavily reducing the
annotation burden.</p>
<p>Values (like literals) can be bound to variables, using the <code>let</code> binding.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // copy `an_integer` into `copied_integer`
    let copied_integer = an_integer;

    println!(&quot;An integer: {:?}&quot;, copied_integer);
    println!(&quot;A boolean: {:?}&quot;, a_boolean);
    println!(&quot;Meet the unit value: {:?}&quot;, unit);

    // The compiler warns about unused variable bindings; these warnings can
    // be silenced by prefixing the variable name with an underscore
    let _unused_variable = 3u32;

    let noisy_unused_variable = 2u32;
    // FIXME ^ Prefix with an underscore to suppress the warning
}
</code></pre></pre>
<h1><a class="header" href="#mutability" id="mutability">Mutability</a></h1>
<p>Variable bindings are immutable by default, but this can be overridden using
the <code>mut</code> modifier.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;Before mutation: {}&quot;, mutable_binding);

    // Ok
    mutable_binding += 1;

    println!(&quot;After mutation: {}&quot;, mutable_binding);

    // Error!
    _immutable_binding += 1;
    // FIXME ^ Comment out this line
}
</code></pre></pre>
<p>The compiler will throw a detailed diagnostic about mutability errors.</p>
<h1><a class="header" href="#scope-and-shadowing" id="scope-and-shadowing">Scope and Shadowing</a></h1>
<p>Variable bindings have a scope, and are constrained to live in a <em>block</em>. A
block is a collection of statements enclosed by braces <code>{}</code>. Also, <a href="https://en.wikipedia.org/wiki/Variable_shadowing">variable
shadowing</a> is allowed.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // This binding lives in the main function
    let long_lived_binding = 1;

    // This is a block, and has a smaller scope than the main function
    {
        // This binding only exists in this block
        let short_lived_binding = 2;

        println!(&quot;inner short: {}&quot;, short_lived_binding);

        // This binding *shadows* the outer one
        let long_lived_binding = 5_f32;

        println!(&quot;inner long: {}&quot;, long_lived_binding);
    }
    // End of the block

    // Error! `short_lived_binding` doesn't exist in this scope
    println!(&quot;outer short: {}&quot;, short_lived_binding);
    // FIXME ^ Comment out this line

    println!(&quot;outer long: {}&quot;, long_lived_binding);
    
    // This binding also *shadows* the previous binding
    let long_lived_binding = 'a';
    
    println!(&quot;outer long: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<h1><a class="header" href="#declare-first" id="declare-first">Declare first</a></h1>
<p>It's possible to declare variable bindings first, and initialize them later.
However, this form is seldom used, as it may lead to the use of uninitialized
variables.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Declare a variable binding
    let a_binding;

    {
        let x = 2;

        // Initialize the binding
        a_binding = x * x;
    }

    println!(&quot;a binding: {}&quot;, a_binding);

    let another_binding;

    // Error! Use of uninitialized binding
    println!(&quot;another binding: {}&quot;, another_binding);
    // FIXME ^ Comment out this line

    another_binding = 1;

    println!(&quot;another binding: {}&quot;, another_binding);
}
</code></pre></pre>
<p>The compiler forbids use of uninitialized variables, as this would lead to
undefined behavior.</p>
<h1><a class="header" href="#types" id="types">Types</a></h1>
<p>Rust provides several mechanisms to change or define the type of primitive and
user defined types. The following sections cover:</p>
<ul>
<li><a href="rustexample/types/cast.html">Casting</a> between primitive types</li>
<li>Specifying the desired type of <a href="rustexample/types/literals.html">literals</a></li>
<li>Using <a href="rustexample/types/inference.html">type inference</a></li>
<li><a href="rustexample/types/alias.html">Aliasing</a> types</li>
</ul>
<h1><a class="header" href="#casting" id="casting">Casting</a></h1>
<p>Rust provides no implicit type conversion (coercion) between primitive types.
But, explicit type conversion (casting) can be performed using the <code>as</code> keyword.</p>
<p>Rules for converting between integral types follow C conventions generally,
except in cases where C has undefined behavior. The behavior of all casts
between integral types is well defined in Rust.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Suppress all warnings from casts which overflow.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // Error! No implicit conversion
    let integer: u8 = decimal;
    // FIXME ^ Comment out this line

    // Explicit conversion
    let integer = decimal as u8;
    let character = integer as char;

    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // when casting any value to an unsigned type, T,
    // std::T::MAX + 1 is added or subtracted until the value
    // fits into the new type

    // 1000 already fits in a u16
    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);

    // 1000 - 256 - 256 - 256 = 232
    // Under the hood, the first 8 least significant bits (LSB) are kept,
    // while the rest towards the most significant bit (MSB) get truncated.
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // -1 + 256 = 255
    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);

    // For positive numbers, this is the same as the modulus
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    // When casting to a signed type, the (bitwise) result is the same as
    // first casting to the corresponding unsigned type. If the most significant
    // bit of that value is 1, then the value is negative.

    // Unless it already fits, of course.
    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);
    // 128 as u8 -&gt; 128, whose two's complement in eight bits is:
    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);

    // repeating the example above
    // 1000 as u8 -&gt; 232
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    // and the two's complement of 232 is -24
    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);
}
</code></pre></pre>
<h1><a class="header" href="#literals" id="literals">Literals</a></h1>
<p>Numeric literals can be type annotated by adding the type as a suffix. As an example, 
to specify that the literal <code>42</code> should have the type <code>i32</code>, write <code>42i32</code>.</p>
<p>The type of unsuffixed numeric literals will depend on how they are used. If no
constraint exists, the compiler will use <code>i32</code> for integers, and <code>f64</code> for
floating-point numbers.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Suffixed literals, their types are known at initialization
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // Unsuffixed literal, their types depend on how they are used
    let i = 1;
    let f = 1.0;

    // `size_of_val` returns the size of a variable in bytes
    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>There are some concepts used in the previous code that haven't been explained
yet, here's a brief explanation for the impatient readers:</p>
<ul>
<li><code>fun(&amp;foo)</code> is used to pass an argument to a function <em>by reference</em>, rather
than by value (<code>fun(foo)</code>). For more details see <a href="rustexample/types/../scope/borrow.html">borrowing</a>.</li>
<li><code>std::mem::size_of_val</code> is a function, but called with its <em>full path</em>. Code
can be split in logical units called <em>modules</em>. In this case, the
<code>size_of_val</code> function is defined in the <code>mem</code> module, and the <code>mem</code> module
is defined in the <code>std</code> <em>crate</em>. For more details, see
<a href="rustexample/types/../mod.html">modules</a> and <a href="rustexample/types/../crates.html">crates</a>.</li>
</ul>
<h1><a class="header" href="#inference" id="inference">Inference</a></h1>
<p>The type inference engine is pretty smart. It does more than looking at the
type of the value expression
during an initialization. It also looks at how the variable is used afterwards 
to infer its type. Here's an advanced example of type inference:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Because of the annotation, the compiler knows that `elem` has type u8.
    let elem = 5u8;

    // Create an empty vector (a growable array).
    let mut vec = Vec::new();
    // At this point the compiler doesn't know the exact type of `vec`, it
    // just knows that it's a vector of something (`Vec&lt;_&gt;`).

    // Insert `elem` in the vector.
    vec.push(elem);
    // Aha! Now the compiler knows that `vec` is a vector of `u8`s (`Vec&lt;u8&gt;`)
    // TODO ^ Try commenting out the `vec.push(elem)` line

    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<p>No type annotation of variables was needed, the compiler is happy and so is the
programmer!</p>
<h1><a class="header" href="#aliasing" id="aliasing">Aliasing</a></h1>
<p>The <code>type</code> statement can be used to give a new name to an existing type. Types
must have <code>CamelCase</code> names, or the compiler will raise a warning. The
exception to this rule are the primitive types: <code>usize</code>, <code>f32</code>, etc.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `NanoSecond` is a new name for `u64`.
type NanoSecond = u64;
type Inch = u64;

// Use an attribute to silence warning.
#[allow(non_camel_case_types)]
type u64_t = u64;
// TODO ^ Try removing the attribute

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // Note that type aliases *don't* provide any extra type safety, because
    // aliases are *not* new types
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<p>The main use of aliases is to reduce boilerplate; for example the <code>IoResult&lt;T&gt;</code> type
is an alias for the <code>Result&lt;T, IoError&gt;</code> type.</p>
<h3><a class="header" href="#see-also-13" id="see-also-13">See also:</a></h3>
<p><a href="rustexample/types/../attribute.html">Attributes</a></p>
<h1><a class="header" href="#conversion" id="conversion">Conversion</a></h1>
<p>Rust addresses conversion between types by the use of <a href="rustexample/trait.html">traits</a>. The generic
conversions will use the <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> traits. However there are more
specific ones for the more common cases, in particular when converting to and
from <code>String</code>s.</p>
<h1><a class="header" href="#from-and-into" id="from-and-into"><code>From</code> and <code>Into</code></a></h1>
<p>The <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> and <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> traits are inherently linked, and this is actually part of
its implementation. If you are able to convert type A from type B, then it
should be easy to believe that we should be able to convert type B to type A.</p>
<h2><a class="header" href="#from" id="from"><code>From</code></a></h2>
<p>The <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a> trait allows for a type to define how to create itself from another
type, hence providing a very simple mechanism for converting between several
types. There are numerous implementations of this trait within the standard
library for conversion of primitive and common types.</p>
<p>For example we can easily convert a <code>str</code> into a <code>String</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let my_str = &quot;hello&quot;;
let my_string = String::from(my_str);
<span class="boring">}
</span></code></pre></pre>
<p>We can do similar for defining a conversion for our own type.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h2><a class="header" href="#into" id="into"><code>Into</code></a></h2>
<p>The <a href="https://doc.rust-lang.org/std/convert/trait.Into.html"><code>Into</code></a> trait is simply the reciprocal of the <code>From</code> trait. That is, if you
have implemented the <code>From</code> trait for your type you get the <code>Into</code>
implementation for free.</p>
<p>Using the <code>Into</code> trait will typically require specification of the type to
convert into as the compiler is unable to determine this most of the time.
However this is a small trade-off considering we get the functionality for free.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // Try removing the type declaration
    let num: Number = int.into();
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h1><a class="header" href="#to-and-from-strings" id="to-and-from-strings">To and from Strings</a></h1>
<h2><a class="header" href="#converting-to-string" id="converting-to-string">Converting to String</a></h2>
<p>To convert any type to a <code>String</code> is as simple as implementing the <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a>
trait for the type. Rather than doing so directly, you should implement the
<a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>fmt::Display</code></a> trait which automagically provides <a href="https://doc.rust-lang.org/std/string/trait.ToString.html"><code>ToString</code></a> and
also allows printing the type as discussed in the section on <a href="rustexample/conversion/../hello/print.html"><code>print!</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt;

struct Circle {
    radius: i32
}

impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;Circle of radius {}&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<h2><a class="header" href="#parsing-a-string" id="parsing-a-string">Parsing a String</a></h2>
<p>One of the more common types to convert a string into is a number. The idiomatic
approach to this is to use the <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse</code></a> function and provide the type for the
function to parse the string value into, this can be done either without type
inference or using the 'turbofish' syntax.</p>
<p>This will convert the string into the type specified so long as the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a>
trait is implemented for that type. This is implemented for numerous types
within the standard library. To obtain this functionality on a user defined type
simply implement the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait for that type.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!(&quot;Sum: {:?}&quot;, sum);
}
</code></pre></pre>
<h1><a class="header" href="#expressions" id="expressions">Expressions</a></h1>
<p>A Rust program is (mostly) made up of a series of statements:</p>
<pre><code>fn main() {
    // statement
    // statement
    // statement
}
</code></pre>
<p>There are a few kinds of statements in Rust. The most common two are declaring
a variable binding, and using a <code>;</code> with an expression:</p>
<pre><code>fn main() {
    // variable binding
    let x = 5;

    // expression;
    x;
    x + 1;
    15;
}
</code></pre>
<p>Blocks are expressions too, so they can be used as values in
assignments. The last expression in the block will be assigned to the
place expression such as a local variable. However, if the last expression of the block ends with a
semicolon, the return value will be <code>()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        x_cube + x_squared + x
    };

    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<h1><a class="header" href="#flow-of-control" id="flow-of-control">Flow of Control</a></h1>
<p>An essential part of any programming languages are ways to modify control flow:
<code>if</code>/<code>else</code>, <code>for</code>, and others. Let's talk about them in Rust.</p>
<h1><a class="header" href="#ifelse" id="ifelse">if/else</a></h1>
<p>Branching with <code>if</code>-<code>else</code> is similar to other languages. Unlike many of them,
the boolean condition doesn't need to be surrounded by parentheses, and each
condition is followed by a block. <code>if</code>-<code>else</code> conditionals are expressions,
and, all branches must return the same type.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{} is negative&quot;, n);
    } else if n &gt; 0 {
        print!(&quot;{} is positive&quot;, n);
    } else {
        print!(&quot;{} is zero&quot;, n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);

            // This expression returns an `i32`.
            10 * n
        } else {
            println!(&quot;, and is a big number, halve the number&quot;);

            // This expression must return an `i32` as well.
            n / 2
            // TODO ^ Try suppressing this expression with a semicolon.
        };
    //   ^ Don't forget to put a semicolon here! All `let` bindings need it.

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<h1><a class="header" href="#loop" id="loop">loop</a></h1>
<p>Rust provides a <code>loop</code> keyword to indicate an infinite loop.</p>
<p>The <code>break</code> statement can be used to exit a loop at anytime, whereas the
<code>continue</code> statement can be used to skip the rest of the iteration and start a
new one.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    // Infinite loop
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // Skip the rest of this iteration
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            // Exit this loop
            break;
        }
    }
}
</code></pre></pre>
<h1><a class="header" href="#nesting-and-labels" id="nesting-and-labels">Nesting and labels</a></h1>
<p>It's possible to <code>break</code> or <code>continue</code> outer loops when dealing with nested
loops. In these cases, the loops must be annotated with some <code>'label</code>, and the
label must be passed to the <code>break</code>/<code>continue</code> statement.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;Entered the outer loop&quot;);

        'inner: loop {
            println!(&quot;Entered the inner loop&quot;);

            // This would break only the inner loop
            //break;

            // This breaks the outer loop
            break 'outer;
        }

        println!(&quot;This point will never be reached&quot;);
    }

    println!(&quot;Exited the outer loop&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#returning-from-loops" id="returning-from-loops">Returning from loops</a></h1>
<p>One of the uses of a <code>loop</code> is to retry an operation until it succeeds. If the
operation returns a value though, you might need to pass it to the rest of the
code: put it after the <code>break</code>, and it will be returned by the <code>loop</code>
expression.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<h1><a class="header" href="#while" id="while">while</a></h1>
<p>The <code>while</code> keyword can be used to run a loop while a condition is true.</p>
<p>Let's write the infamous <a href="https://en.wikipedia.org/wiki/Fizz_buzz">FizzBuzz</a> using a <code>while</code> loop.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // A counter variable
    let mut n = 1;

    // Loop while `n` is less than 101
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // Increment counter
        n += 1;
    }
}
</code></pre></pre>
<h1><a class="header" href="#for-loops" id="for-loops">for loops</a></h1>
<h2><a class="header" href="#for-and-range" id="for-and-range">for and range</a></h2>
<p>The <code>for in</code> construct can be used to iterate through an <code>Iterator</code>.
One of the easiest ways to create an iterator is to use the range
notation <code>a..b</code>. This yields values from <code>a</code> (inclusive) to <code>b</code>
(exclusive) in steps of one.</p>
<p>Let's write FizzBuzz using <code>for</code> instead of <code>while</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `n` will take the values: 1, 2, ..., 100 in each iteration
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<p>Alternatively, <code>a..=b</code> can be used for a range that is inclusive on both ends.
The above can be written as:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `n` will take the values: 1, 2, ..., 100 in each iteration
    for n in 1..=100 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#for-and-iterators" id="for-and-iterators">for and iterators</a></h2>
<p>The <code>for in</code> construct is able to interact with an <code>Iterator</code> in several ways.
As discussed in with the <a href="rustexample/flow_control/../trait/iter.html">Iterator</a> trait, if not specified, the <code>for</code>
loop will apply the <code>into_iter</code> function on the collection provided to convert
the collection into an iterator. This is not the only means to convert a
collection into an iterator however, the other functions available include
<code>iter</code> and <code>iter_mut</code>.</p>
<p>These 3 functions will return different views of the data within your
collection.</p>
<ul>
<li><code>iter</code> - This borrows each element of the collection through each iteration.
Thus leaving the collection untouched and available for reuse after the loop.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter() {
        match name {
            &amp;&quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>into_iter</code> - This consumes the collection so that on each iteration the exact
data is provided. Once the collection has been consumed it is no longer
available for reuse as it has been 'moved' within the loop.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.into_iter() {
        match name {
            &quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
}
</code></pre></pre>
<ul>
<li><code>iter_mut</code> - This mutably borrows each element of the collection, allowing for
the collection to be modified in place.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut &quot;Ferris&quot; =&gt; &quot;There is a rustacean among us!&quot;,
            _ =&gt; &quot;Hello&quot;,
        }
    }

    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<p>In the above snippets note the type of <code>match</code> branch, that is the key
difference in the types of iteration. The difference in type then of course
implies differing actions that are able to be performed.</p>
<h3><a class="header" href="#see-also-14" id="see-also-14">See also</a></h3>
<p><a href="rustexample/flow_control/../trait/iter.html">Iterator</a></p>
<h1><a class="header" href="#match" id="match">match</a></h1>
<p>Rust provides pattern matching via the <code>match</code> keyword, which can be used like
a C <code>switch</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let number = 13;
    // TODO ^ Try different values for `number`

    println!(&quot;Tell me about {}&quot;, number);
    match number {
        // Match a single value
        1 =&gt; println!(&quot;One!&quot;),
        // Match several values
        2 | 3 | 5 | 7 | 11 =&gt; println!(&quot;This is a prime&quot;),
        // Match an inclusive range
        13...19 =&gt; println!(&quot;A teen&quot;),
        // Handle the rest of cases
        _ =&gt; println!(&quot;Ain't special&quot;),
    }

    let boolean = true;
    // Match is an expression too
    let binary = match boolean {
        // The arms of a match must cover all the possible values
        false =&gt; 0,
        true =&gt; 1,
        // TODO ^ Try commenting out one of these arms
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}
</code></pre></pre>
<h1><a class="header" href="#destructuring" id="destructuring">Destructuring</a></h1>
<p>A <code>match</code> block can destructure items in a variety of ways.</p>
<ul>
<li><a href="rustexample/flow_control/match/destructuring/destructure_enum.html">Destructuring Enums</a></li>
<li><a href="rustexample/flow_control/match/destructuring/destructure_pointers.html">Destructuring Pointers</a></li>
<li><a href="rustexample/flow_control/match/destructuring/destructure_structures.html">Destructuring Structures</a></li>
<li><a href="rustexample/flow_control/match/destructuring/destructure_tuple.html">Destructuring Tuples</a></li>
</ul>
<h1><a class="header" href="#tuples-1" id="tuples-1">tuples</a></h1>
<p>Tuples can be destructured in a <code>match</code> as follows:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (0, -2);
    // TODO ^ Try different values for `pair`

    println!(&quot;Tell me about {:?}&quot;, pair);
    // Match can be used to destructure a tuple
    match pair {
        // Destructure the second
        (0, y) =&gt; println!(&quot;First is `0` and `y` is `{:?}`&quot;, y),
        (x, 0) =&gt; println!(&quot;`x` is `{:?}` and last is `0`&quot;, x),
        _      =&gt; println!(&quot;It doesn't matter what they are&quot;),
        // `_` means don't bind the value to a variable
    }
}
</code></pre></pre>
<h3><a class="header" href="#see-also-15" id="see-also-15">See also:</a></h3>
<p><a href="rustexample/flow_control/match/destructuring/../../../primitives/tuples.html">Tuples</a></p>
<h1><a class="header" href="#enums-1" id="enums-1">enums</a></h1>
<p>An <code>enum</code> is destructured similarly:</p>
<pre><pre class="playpen"><code class="language-rust editable">// `allow` required to silence warnings because only
// one variant is used.
#[allow(dead_code)]
enum Color {
    // These 3 are specified solely by their name.
    Red,
    Blue,
    Green,
    // These likewise tie `u32` tuples to different names: color models.
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    let color = Color::RGB(122, 17, 40);
    // TODO ^ Try different variants for `color`

    println!(&quot;What color is it?&quot;);
    // An `enum` can be destructured using a `match`.
    match color {
        Color::Red   =&gt; println!(&quot;The color is Red!&quot;),
        Color::Blue  =&gt; println!(&quot;The color is Blue!&quot;),
        Color::Green =&gt; println!(&quot;The color is Green!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;Hue: {}, saturation: {}, value: {}!&quot;, h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!(&quot;Hue: {}, saturation: {}, lightness: {}!&quot;, h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
                c, m, y, k),
        // Don't need another arm because all variants have been examined
    }
}
</code></pre></pre>
<h3><a class="header" href="#see-also-16" id="see-also-16">See also:</a></h3>
<p><a href="rustexample/flow_control/match/destructuring/../../../attribute/unused.html"><code>#[allow(...)]</code></a>, <a href="https://en.wikipedia.org/wiki/Color_model">color models</a> and <a href="rustexample/flow_control/match/destructuring/../../../custom_types/enum.html"><code>enum</code></a></p>
<h1><a class="header" href="#pointersref" id="pointersref">pointers/ref</a></h1>
<p>For pointers, a distinction needs to be made between destructuring
and dereferencing as they are different concepts which are used
differently from a language like <code>C</code>.</p>
<ul>
<li>Dereferencing uses <code>*</code></li>
<li>Destructuring uses <code>&amp;</code>, <code>ref</code>, and <code>ref mut</code></li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Assign a reference of type `i32`. The `&amp;` signifies there
    // is a reference being assigned.
    let reference = &amp;4;

    match reference {
        // If `reference` is pattern matched against `&amp;val`, it results
        // in a comparison like:
        // `&amp;i32`
        // `&amp;val`
        // ^ We see that if the matching `&amp;`s are dropped, then the `i32`
        // should be assigned to `val`.
        &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),
    }

    // To avoid the `&amp;`, you dereference before matching.
    match *reference {
        val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),
    }

    // What if you don't start with a reference? `reference` was a `&amp;`
    // because the right side was already a reference. This is not
    // a reference because the right side is not one.
    let _not_a_reference = 3;

    // Rust provides `ref` for exactly this purpose. It modifies the
    // assignment so that a reference is created for the element; this
    // reference is assigned.
    let ref _is_a_reference = 3;

    // Accordingly, by defining 2 values without references, references
    // can be retrieved via `ref` and `ref mut`.
    let value = 5;
    let mut mut_value = 6;

    // Use `ref` keyword to create a reference.
    match value {
        ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),
    }

    // Use `ref mut` similarly.
    match mut_value {
        ref mut m =&gt; {
            // Got a reference. Gotta dereference it before we can
            // add anything to it.
            *m += 10;
            println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);
        },
    }
}
</code></pre></pre>
<h1><a class="header" href="#structs" id="structs">structs</a></h1>
<p>Similarly, a <code>struct</code> can be destructured as shown:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    // Try changing the values in the struct to see what happens
    let foo = Foo { x: (1, 2), y: 3 };

    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;First of x is 1, b = {},  y = {} &quot;, b, y),

        // you can destructure structs and rename the variables,
        // the order is not important
        Foo { y: 2, x: i } =&gt; println!(&quot;y is 2, i = {:?}&quot;, i),

        // and you can also ignore some variables:
        Foo { y, .. } =&gt; println!(&quot;y = {}, we don't care about x&quot;, y),
        // this will give an error: pattern does not mention field `x`
        //Foo { y } =&gt; println!(&quot;y = {}&quot;, y);
    }
}
</code></pre></pre>
<h3><a class="header" href="#see-also-17" id="see-also-17">See also:</a></h3>
<p><a href="rustexample/flow_control/match/destructuring/../../../custom_types/structs.html">Structs</a>, <a href="rustexample/flow_control/match/destructuring/../../../scope/borrow/ref.html">The ref pattern</a></p>
<h1><a class="header" href="#guards" id="guards">Guards</a></h1>
<p>A <code>match</code> <em>guard</em> can be added to filter the arm.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let pair = (2, -2);
    // TODO ^ Try different values for `pair`

    println!(&quot;Tell me about {:?}&quot;, pair);
    match pair {
        (x, y) if x == y =&gt; println!(&quot;These are twins&quot;),
        // The ^ `if condition` part is a guard
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _ =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<h3><a class="header" href="#see-also-18" id="see-also-18">See also:</a></h3>
<p><a href="rustexample/flow_control/match/../../primitives/tuples.html">Tuples</a></p>
<h1><a class="header" href="#binding" id="binding">Binding</a></h1>
<p>Indirectly accessing a variable makes it impossible to branch and use that
variable without re-binding. <code>match</code> provides the <code>@</code> sigil for binding values to
names:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A function `age` which returns a `u32`.
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;Tell me what type of person you are&quot;);

    match age() {
        0             =&gt; println!(&quot;I'm not born yet I guess&quot;),
        // Could `match` 1 ... 12 directly but then what age
        // would the child be? Instead, bind to `n` for the
        // sequence of 1 .. 12. Now the age can be reported.
        n @ 1  ... 12 =&gt; println!(&quot;I'm a child of age {:?}&quot;, n),
        n @ 13 ... 19 =&gt; println!(&quot;I'm a teen of age {:?}&quot;, n),
        // Nothing bound. Return the result.
        n             =&gt; println!(&quot;I'm an old person of age {:?}&quot;, n),
    }
}
</code></pre></pre>
<h3><a class="header" href="#see-also-19" id="see-also-19">See also:</a></h3>
<p><a href="rustexample/flow_control/match/../../fn.html">functions</a></p>
<h1><a class="header" href="#if-let" id="if-let">if let</a></h1>
<p>For some use cases, when matching enums, <code>match</code> is awkward. For example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Make `optional` of type `Option&lt;i32&gt;`
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);
        // ^ Needed 2 indentations just so we could destructure
        // `i` from the option.
    },
    _ =&gt; {},
    // ^ Required because `match` is exhaustive. Doesn't it seem
    // like wasted space?
};

<span class="boring">}
</span></code></pre></pre>
<p><code>if let</code> is cleaner for this use case and in addition allows various
failure options to be specified:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // All have type `Option&lt;i32&gt;`
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // The `if let` construct reads: &quot;if `let` destructures `number` into
    // `Some(i)`, evaluate the block (`{}`).
    if let Some(i) = number {
        println!(&quot;Matched {:?}!&quot;, i);
    }

    // If you need to specify a failure, use an else:
    if let Some(i) = letter {
        println!(&quot;Matched {:?}!&quot;, i);
    } else {
        // Destructure failed. Change to the failure case.
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    };

    // Provide an altered failing condition.
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;Matched {:?}!&quot;, i);
    // Destructure failed. Evaluate an `else if` condition to see if the
    // alternate failure branch should be taken:
    } else if i_like_letters {
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    } else {
        // The condition evaluated false. This branch is the default:
        println!(&quot;I don't like letters. Let's go with an emoticon :)!&quot;);
    };
}
</code></pre></pre>
<p>In the same way, <code>if let</code> can be used to match any enum value:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Our example enum
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // Create example variables
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);
    
    // Variable a matches Foo::Bar
    if let Foo::Bar = a {
        println!(&quot;a is foobar&quot;);
    }
    
    // Variable b does not match Foo::Bar
    // So this will print nothing
    if let Foo::Bar = b {
        println!(&quot;b is foobar&quot;);
    }
    
    // Variable c matches Foo::Qux which has a value
    // Similar to Some() in the previous example
    if let Foo::Qux(value) = c {
        println!(&quot;c is {}&quot;, value);
    }
}
</code></pre></pre>
<p>Another benefit: <code>if let</code> allows to match enum non-parameterized variants, even if the enum doesn't <code>#[derive(PartialEq)]</code>, neither we implement <code>PartialEq</code> for it. In such case, classic <code>if Foo::Bar==a</code> fails, because instances of such enum are not comparable for equality. However, <code>if let</code> works.</p>
<p>Would you like a challenge? Fix the following example to use <code>if let</code>:</p>
<pre><code class="language-rust editable ignore">// This enum purposely doesn't #[derive(PartialEq)],
// neither we implement PartialEq for it. That's why comparing Foo::Bar==a fails below.
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // Variable a matches Foo::Bar
    if Foo::Bar == a {
    // ^-- this causes a compile-time error. Use `if let` instead.
        println!(&quot;a is foobar&quot;);
    }
}
</code></pre>
<h3><a class="header" href="#see-also-20" id="see-also-20">See also:</a></h3>
<p><a href="rustexample/flow_control/../custom_types/enum.html"><code>enum</code></a>, <a href="rustexample/flow_control/../std/option.html"><code>Option</code></a>, and the <a href="https://github.com/rust-lang/rfcs/pull/160">RFC</a></p>
<h1><a class="header" href="#while-let" id="while-let">while let</a></h1>
<p>Similar to <code>if let</code>, <code>while let</code> can make awkward <code>match</code> sequences
more tolerable. Consider the following sequence that increments <code>i</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Make `optional` of type `Option&lt;i32&gt;`
let mut optional = Some(0);

// Repeatedly try this test.
loop {
    match optional {
        // If `optional` destructures, evaluate the block.
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;Greater than 9, quit!&quot;);
                optional = None;
            } else {
                println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
                optional = Some(i + 1);
            }
            // ^ Requires 3 indentations!
        },
        // Quit the loop when the destructure fails:
        _ =&gt; { break; }
        // ^ Why should this be required? There must be a better way!
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Using <code>while let</code> makes this sequence much nicer:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Make `optional` of type `Option&lt;i32&gt;`
    let mut optional = Some(0);

    // This reads: &quot;while `let` destructures `optional` into
    // `Some(i)`, evaluate the block (`{}`). Else `break`.
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;Greater than 9, quit!&quot;);
            optional = None;
        } else {
            println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
            optional = Some(i + 1);
        }
        // ^ Less rightward drift and doesn't require
        // explicitly handling the failing case.
    }
    // ^ `if let` had additional optional `else`/`else if`
    // clauses. `while let` does not have these.
}
</code></pre></pre>
<h3><a class="header" href="#see-also-21" id="see-also-21">See also:</a></h3>
<p><a href="rustexample/flow_control/../custom_types/enum.html"><code>enum</code></a>, <a href="rustexample/flow_control/../std/option.html"><code>Option</code></a>, and the <a href="https://github.com/rust-lang/rfcs/pull/214">RFC</a></p>
<h1><a class="header" href="#functions" id="functions">Functions</a></h1>
<p>Functions are declared using the <code>fn</code> keyword. Its arguments are type
annotated, just like variables, and, if the function returns a value, the
return type must be specified after an arrow <code>-&gt;</code>.</p>
<p>The final expression in the function will be used as return value.
Alternatively, the <code>return</code> statement can be used to return a value earlier
from within the function, even from inside loops or <code>if</code>s.</p>
<p>Let's rewrite FizzBuzz using functions!</p>
<pre><pre class="playpen"><code class="language-rust editable">// Unlike C/C++, there's no restriction on the order of function definitions
fn main() {
    // We can use this function here, and define it somewhere later
    fizzbuzz_to(100);
}

// Function that returns a boolean value
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // Corner case, early return
    if rhs == 0 {
        return false;
    }

    // This is an expression, the `return` keyword is not necessary here
    lhs % rhs == 0
}

// Functions that &quot;don't&quot; return a value, actually return the unit type `()`
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// When a function returns `()`, the return type can be omitted from the
// signature
fn fizzbuzz_to(n: u32) {
    for n in 1..n + 1 {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<h1><a class="header" href="#methods" id="methods">Methods</a></h1>
<p>Methods are functions attached to objects. These methods have access to the
data of the object and its other methods via the <code>self</code> keyword. Methods are
defined under an <code>impl</code> block.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point {
    x: f64,
    y: f64,
}

// Implementation block, all `Point` methods go in here
impl Point {
    // This is a static method
    // Static methods don't need to be called by an instance
    // These methods are generally used as constructors
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // Another static method, taking two arguments:
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // This is an instance method
    // `&amp;self` is sugar for `self: &amp;Self`, where `Self` is the type of the
    // caller object. In this case `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` gives access to the struct fields via the dot operator
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` is a `f64` method that returns the absolute value of the
        // caller
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // This method requires the caller object to be mutable
    // `&amp;mut self` desugars to `self: &amp;mut Self`
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` owns resources: two heap allocated integers
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // This method &quot;consumes&quot; the resources of the caller object
    // `self` desugars to `self: Self`
    fn destroy(self) {
        // Destructure `self`
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` and `second` go out of scope and get freed
    }
}

fn main() {
    let rectangle = Rectangle {
        // Static methods are called using double colons
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Instance methods are called using the dot operator
    // Note that the first argument `&amp;self` is implicitly passed, i.e.
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Error! `rectangle` is immutable, but this method requires a mutable
    // object
    //rectangle.translate(1.0, 0.0);
    // TODO ^ Try uncommenting this line

    // Okay! Mutable objects can call mutable methods
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! Previous `destroy` call &quot;consumed&quot; `pair`
    //pair.destroy();
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<h1><a class="header" href="#closures" id="closures">Closures</a></h1>
<p>Closures in Rust, also called lambda expressions or lambdas, are functions that can capture 
the enclosing environment. For example, a closure that captures the x 
variable:</p>
<pre><code class="language-Rust">|val| val + x
</code></pre>
<p>The syntax and capabilities of closures make them very convenient for 
on the fly usage. Calling a closure is exactly like calling a function.
However, both input and return types <em>can</em> be inferred and input 
variable names <em>must</em> be specified.</p>
<p>Other characteristics of closures include:</p>
<ul>
<li>using <code>||</code> instead of <code>()</code> around input variables.</li>
<li>optional body delimination (<code>{}</code>) for a single expression (mandatory otherwise).</li>
<li>the ability to capture the outer environment variables.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // Increment via closures and functions.
    fn  function            (i: i32) -&gt; i32 { i + 1 }

    // Closures are anonymous, here we are binding them to references
    // Annotation is identical to function annotation but is optional
    // as are the `{}` wrapping the body. These nameless functions
    // are assigned to appropriately named variables.
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    let i = 1;
    // Call the function and closures.
    println!(&quot;function: {}&quot;, function(i));
    println!(&quot;closure_annotated: {}&quot;, closure_annotated(i));
    println!(&quot;closure_inferred: {}&quot;, closure_inferred(i));

    // A closure taking no arguments which returns an `i32`.
    // The return type is inferred.
    let one = || 1;
    println!(&quot;closure returning one: {}&quot;, one());

}
</code></pre></pre>
<h1><a class="header" href="#capturing" id="capturing">Capturing</a></h1>
<p>Closures are inherently flexible and will do what the functionality requires
to make the closure work without annotation. This allows capturing to
flexibly adapt to the use case, sometimes moving and sometimes borrowing.
Closures can capture variables:</p>
<ul>
<li>by reference: <code>&amp;T</code></li>
<li>by mutable reference: <code>&amp;mut T</code></li>
<li>by value: <code>T</code></li>
</ul>
<p>They preferentially capture variables by reference and only go lower when
required.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    use std::mem;
    
    let color = &quot;green&quot;;

    // A closure to print `color` which immediately borrows (`&amp;`)
    // `color` and stores the borrow and closure in the `print`
    // variable. It will remain borrowed until `print` goes out of
    // scope. `println!` only requires `by reference` so it doesn't
    // impose anything more restrictive.
    let print = || println!(&quot;`color`: {}&quot;, color);

    // Call the closure using the borrow.
    print();
    print();

    let mut count = 0;

    // A closure to increment `count` could take either `&amp;mut count`
    // or `count` but `&amp;mut count` is less restrictive so it takes
    // that. Immediately borrows `count`.
    //
    // A `mut` is required on `inc` because a `&amp;mut` is stored inside.
    // Thus, calling the closure mutates the closure which requires
    // a `mut`.
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // Call the closure.
    inc();
    inc();

    //let _reborrow = &amp;mut count;
    // ^ TODO: try uncommenting this line.
    
    // A non-copy type.
    let movable = Box::new(3);

    // `mem::drop` requires `T` so this must take by value. A copy type
    // would copy into the closure leaving the original untouched.
    // A non-copy must move and so `movable` immediately moves into
    // the closure.
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume` consumes the variable so this can only be called once.
    consume();
    //consume();
    // ^ TODO: Try uncommenting this line.
}
</code></pre></pre>
<p>Using <code>move</code> before vertical pipes forces closure
to take ownership of captured variables:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // `Vec` has non-copy semantics.
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
    println!(&quot;{}&quot;, contains(&amp;4));

    // `println!(&quot;There're {} elements in vec&quot;, haystack.len());`
    // ^ Uncommenting above line will result in compile-time error
    // because borrow checker doesn't allow re-using variable after it
    // has been moved.
    
    // Removing `move` from closure's signature will cause closure
    // to borrow _haystack_ variable immutably, hence _haystack_ is still
    // available and uncommenting above line will not cause an error.
}
</code></pre></pre>
<h3><a class="header" href="#see-also-22" id="see-also-22">See also:</a></h3>
<p><a href="rustexample/fn/closures/../../std/box.html"><code>Box</code></a> and <a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a></p>
<h1><a class="header" href="#as-input-parameters" id="as-input-parameters">As input parameters</a></h1>
<p>While Rust chooses how to capture variables on the fly mostly without type 
annotation, this ambiguity is not allowed when writing functions. When 
taking a closure as an input parameter, the closure's complete type must be 
annotated using one of a few <code>traits</code>. In order of decreasing restriction, 
they are:</p>
<ul>
<li><code>Fn</code>: the closure captures by reference (<code>&amp;T</code>)</li>
<li><code>FnMut</code>: the closure captures by mutable reference (<code>&amp;mut T</code>)</li>
<li><code>FnOnce</code>: the closure captures by value (<code>T</code>)</li>
</ul>
<p>On a variable-by-variable basis, the compiler will capture variables in the 
least restrictive manner possible. </p>
<p>For instance, consider a parameter annotated as <code>FnOnce</code>. This specifies 
that the closure <em>may</em> capture by <code>&amp;T</code>, <code>&amp;mut T</code>, or <code>T</code>, but the compiler 
will ultimately choose based on how the captured variables are used in the 
closure.</p>
<p>This is because if a move is possible, then any type of borrow should also 
be possible. Note that the reverse is not true. If the parameter is 
annotated as <code>Fn</code>, then capturing variables by <code>&amp;mut T</code> or <code>T</code> are not 
allowed.</p>
<p>In the following example, try swapping the usage of <code>Fn</code>, <code>FnMut</code>, and 
<code>FnOnce</code> to see what happens:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A function which takes a closure as an argument and calls it.
fn apply&lt;F&gt;(f: F) where
    // The closure takes no input and returns nothing.
    F: FnOnce() {
    // ^ TODO: Try changing this to `Fn` or `FnMut`.

    f();
}

// A function which takes a closure and returns an `i32`.
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // The closure takes an `i32` and returns an `i32`.
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;hello&quot;;
    // A non-copy type.
    // `to_owned` creates owned data from borrowed one
    let mut farewell = &quot;goodbye&quot;.to_owned();

    // Capture 2 variables: `greeting` by reference and
    // `farewell` by value.
    let diary = || {
        // `greeting` is by reference: requires `Fn`.
        println!(&quot;I said {}.&quot;, greeting);

        // Mutation forces `farewell` to be captured by
        // mutable reference. Now requires `FnMut`.
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);
        println!(&quot;Now I can sleep. zzzzz&quot;);

        // Manually calling drop forces `farewell` to
        // be captured by value. Now requires `FnOnce`.
        mem::drop(farewell);
    };

    // Call the function which applies the closure.
    apply(diary);

    // `double` satisfies `apply_to_3`'s trait bound
    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-23" id="see-also-23">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/mem/fn.drop.html"><code>std::mem::drop</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#type-anonymity" id="type-anonymity">Type anonymity</a></h1>
<p>Closures succinctly capture variables from enclosing scopes. Does this have
any consequences? It surely does. Observe how using a closure as a function
parameter requires <a href="rustexample/fn/closures/../../generics.html">generics</a>, which is necessary because of how they are
defined:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// `F` must be generic.
fn apply&lt;F&gt;(f: F) where
    F: FnOnce() {
    f();
}
<span class="boring">}
</span></code></pre></pre>
<p>When a closure is defined, the compiler implicitly creates a new
anonymous structure to store the captured variables inside, meanwhile
implementing the functionality via one of the <code>traits</code>: <code>Fn</code>, <code>FnMut</code>, or
<code>FnOnce</code> for this unknown type. This type is assigned to the variable which
is stored until calling.</p>
<p>Since this new type is of unknown type, any usage in a function will require
generics. However, an unbounded type parameter <code>&lt;T&gt;</code> would still be ambiguous
and not be allowed. Thus, bounding by one of the <code>traits</code>: <code>Fn</code>, <code>FnMut</code>, or
<code>FnOnce</code> (which it implements) is sufficient to specify its type.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `F` must implement `Fn` for a closure which takes no
// inputs and returns nothing - exactly what is required
// for `print`.
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // Capture `x` into an anonymous type and implement
    // `Fn` for it. Store it in `print`.
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-24" id="see-also-24">See also:</a></h3>
<p><a href="https://huonw.github.io/blog/2015/05/finding-closure-in-rust/">A thorough analysis</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>,
and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#input-functions" id="input-functions">Input functions</a></h1>
<p>Since closures may be used as arguments, you might wonder if the same can be said
about functions. And indeed they can! If you declare a function that takes a
closure as parameter, then any function that satisfies the trait bound of that
closure can be passed as a parameter.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Define a function which takes a generic `F` argument
// bounded by `Fn`, and calls it
fn call_me&lt;F: Fn()&gt;(f: F) {
    f();
}

// Define a wrapper function satisfying the `Fn` bound
fn function() {
    println!(&quot;I'm a function!&quot;);
}

fn main() {
    // Define a closure satisfying the `Fn` bound
    let closure = || println!(&quot;I'm a closure!&quot;);

    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>As an additional note, the <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code> <code>traits</code> dictate how
a closure captures variables from the enclosing scope.</p>
<h3><a class="header" href="#see-also-25" id="see-also-25">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a></p>
<h1><a class="header" href="#as-output-parameters" id="as-output-parameters">As output parameters</a></h1>
<p>Closures as input parameters are possible, so returning closures as 
output parameters should also be possible. However, returning closure types 
are problematic because Rust currently only supports returning concrete 
(non-generic) types. Anonymous closure types are, by definition, unknown 
and so returning a closure is only possible by making it concrete. This 
can be done via boxing.</p>
<p>The valid traits for returns are slightly different than before:</p>
<ul>
<li><code>Fn</code>: normal</li>
<li><code>FnMut</code>: normal</li>
<li><code>FnOnce</code>: There are some unusual things at play here, so the <a href="https://doc.rust-lang.org/std/boxed/trait.FnBox.html"><code>FnBox</code></a>
type is currently needed, and is unstable. This is expected to change in
the future.</li>
</ul>
<p>Beyond this, the <code>move</code> keyword must be used, which signals that all captures
occur by value. This is required because any captures by reference would be
dropped as soon as the function exited, leaving invalid references in the
closure.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn create_fn() -&gt; Box&lt;Fn()&gt; {
    let text = &quot;Fn&quot;.to_owned();

    Box::new(move || println!(&quot;This is a: {}&quot;, text))
}

fn create_fnmut() -&gt; Box&lt;FnMut()&gt; {
    let text = &quot;FnMut&quot;.to_owned();

    Box::new(move || println!(&quot;This is a: {}&quot;, text))
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();

    fn_plain();
    fn_mut();
}
</code></pre></pre>
<h3><a class="header" href="#see-also-26" id="see-also-26">See also:</a></h3>
<p><a href="rustexample/fn/closures/../../std/box.html">Boxing</a>, <a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>, <a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, and <a href="rustexample/fn/closures/../../generics.html">Generics</a>.</p>
<h1><a class="header" href="#examples-in-std" id="examples-in-std">Examples in <code>std</code></a></h1>
<p>This section contains a few examples of using closures from the <code>std</code> library.</p>
<h1><a class="header" href="#iteratorany" id="iteratorany">Iterator::any</a></h1>
<p><code>Iterator::any</code> is a function which when passed an iterator, will return
<code>true</code> if any element satisfies the predicate. Otherwise <code>false</code>. Its
signature:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // The type being iterated over.
    type Item;

    // `any` takes `&amp;mut self` meaning the caller may be borrowed
    // and modified, but not consumed.
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut` meaning any captured variable may at most be
        // modified, not consumed. `Self::Item` states it takes
        // arguments to the closure by value.
        F: FnMut(Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` for vecs yields `&amp;i32`. Destructure to `i32`.
    println!(&quot;2 in vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` for vecs yields `i32`. No destructuring required.
    println!(&quot;2 in vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` for arrays yields `&amp;i32`.
    println!(&quot;2 in array1: {}&quot;, array1.iter()     .any(|&amp;x| x == 2));
    // `into_iter()` for arrays unusually yields `&amp;i32`.
    println!(&quot;2 in array2: {}&quot;, array2.into_iter().any(|&amp;x| x == 2));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-27" id="see-also-27">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::iter::Iterator::any</code></a></p>
<h1><a class="header" href="#iteratorfind" id="iteratorfind">Iterator::find</a></h1>
<p><code>Iterator::find</code> is a function which when passed an iterator, will return
the first element which satisfies the predicate as an <code>Option</code>. Its
signature:</p>
<pre><code class="language-rust ignore">pub trait Iterator {
    // The type being iterated over.
    type Item;

    // `find` takes `&amp;mut self` meaning the caller may be borrowed
    // and modified, but not consumed.
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut` meaning any captured variable may at most be
        // modified, not consumed. `&amp;Self::Item` states it takes
        // arguments to the closure by reference.
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
</code></pre>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `iter()` for vecs yields `&amp;i32`.
    let mut iter = vec1.iter();
    // `into_iter()` for vecs yields `i32`.
    let mut into_iter = vec2.into_iter();

    // A reference to what is yielded is `&amp;&amp;i32`. Destructure to `i32`.
    println!(&quot;Find 2 in vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));
    // A reference to what is yielded is `&amp;i32`. Destructure to `i32`.
    println!(&quot;Find 2 in vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `iter()` for arrays yields `&amp;i32`
    println!(&quot;Find 2 in array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // `into_iter()` for arrays unusually yields `&amp;i32`
    println!(&quot;Find 2 in array2: {:?}&quot;, array2.into_iter().find(|&amp;&amp;x| x == 2));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-28" id="see-also-28">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::iter::Iterator::find</code></a></p>
<h1><a class="header" href="#higher-order-functions" id="higher-order-functions">Higher Order Functions</a></h1>
<p>Rust provides Higher Order Functions (HOF). These are functions that
take one or more functions and/or produce a more useful function. HOFs
and lazy iterators give Rust its functional flavor.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!(&quot;Find the sum of all the squared odd numbers under 1000&quot;);
    let upper = 1000;

    // Imperative approach
    // Declare accumulator variable
    let mut acc = 0;
    // Iterate: 0, 1, 2, ... to infinity
    for n in 0.. {
        // Square the number
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // Break loop if exceeded the upper limit
            break;
        } else if is_odd(n_squared) {
            // Accumulate value, if it's odd
            acc += n_squared;
        }
    }
    println!(&quot;imperative style: {}&quot;, acc);

    // Functional approach
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n)                             // All natural numbers squared
             .take_while(|&amp;n_squared| n_squared &lt; upper) // Below upper limit
             .filter(|&amp;n_squared| is_odd(n_squared))     // That are odd
             .fold(0, |acc, n_squared| acc + n_squared); // Sum them
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
}
</code></pre></pre>
<p><a href="https://doc.rust-lang.org/core/option/enum.Option.html">Option</a>
and
<a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator</a>
implement their fair share of HOFs.</p>
<h1><a class="header" href="#diverging-functions" id="diverging-functions">Diverging functions</a></h1>
<p>Diverging functions never return. They are marked using <code>!</code>, which is an empty type.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo() -&gt; ! {
    panic!(&quot;This call never returns.&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>As opposed to all the other types, this one cannot be instantiated, because the
set of all possible values this type can have is empty. Note that, it is
different from the <code>()</code> type, which has exactly one possible value.</p>
<p>For example, this function returns as usual, although there is no information
in the return value.</p>
<pre><pre class="playpen"><code class="language-rust">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!(&quot;This function returns and you can see this line.&quot;)
}
</code></pre></pre>
<p>As opposed to this function, which will never return the control back to the caller.</p>
<pre><code class="language-rust ignore">#![feature(never_type)]

fn main() {
    let x: ! = panic!(&quot;This call never returns.&quot;);
    println!(&quot;You will never see this line!&quot;);
}
</code></pre>
<p>Although this might seem like an abstract concept, it is in fact very useful and
often handy. The main advantage of this type is that it can be cast to any other
one and therefore used at places where an exact type is required, for instance
in <code>match</code> branches. This allows us to write code like this:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // Notice that the return type of this match expression must be u32
            // because of the type of the &quot;addition&quot; variable.
            let addition: u32 = match i%2 == 1 {
                // The &quot;i&quot; variable is of type u32, which is perfectly fine.
                true =&gt; i,
                // On the other hand, the &quot;continue&quot; expression does not return
                // u32, but it is still fine, because it never returns and therefore
                // does not violate the type requirements of the match expression.
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!(&quot;Sum of odd numbers up to 9 (excluding): {}&quot;, sum_odd_numbers(9));
}
</code></pre></pre>
<p>It is also the return type of functions that loop forever (e.g. <code>loop {}</code>) like
network servers or functions that terminates the process (e.g. <code>exit()</code>).</p>
<h1><a class="header" href="#modules" id="modules">Modules</a></h1>
<p>Rust provides a powerful module system that can be used to hierarchically split
code in logical units (modules), and manage visibility (public/private) between
them.</p>
<p>A module is a collection of items: functions, structs, traits, <code>impl</code> blocks,
and even other modules.</p>
<h1><a class="header" href="#visibility" id="visibility">Visibility</a></h1>
<p>By default, the items in a module have private visibility, but this can be
overridden with the <code>pub</code> modifier. Only the public items of a module can be
accessed from outside the module scope.</p>
<pre><pre class="playpen"><code class="language-rust editable">// A module named `my_mod`
mod my_mod {
    // Items in modules default to private visibility.
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // Use the `pub` modifier to override default visibility.
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // Items can access other items in the same module,
    // even when private.
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // Modules can also be nested
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // Functions declared using `pub(in path)` syntax are only visible
        // within the given path. `path` must be a parent or ancestor module
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n &gt; &quot;);
            public_function_in_nested()
        }

        // Functions declared using `pub(self)` syntax are only visible within
        // the current module, which is the same as leaving them private
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested&quot;);
        }

        // Functions declared using `pub(super)` syntax are only visible within
        // the parent module
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called my_mod::nested::public_function_in_super_mod&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_function_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // pub(crate) makes functions visible only within the current crate
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()&quot;);
    }

    // Nested modules follow the same rules for visibility
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }

        // Private parent items will still restrict the visibility of a child item,
        // even if it is declared as visible within a bigger scope.
        #[allow(dead_code)]
        pub(crate) fn restricted_function() {
            println!(&quot;called `my_mod::private_nested::restricted_function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    // Modules allow disambiguation between items that have the same name.
    function();
    my_mod::function();

    // Public items, including those inside nested modules, can be
    // accessed from outside the parent module.
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) items can be called from anywhere in the same crate
    my_mod::public_function_in_crate();

    // pub(in path) items can only be called from within the mode specified
    // Error! function `public_function_in_my_mod` is private
    //my_mod::nested::public_function_in_my_mod();
    // TODO ^ Try uncommenting this line

    // Private items of a module cannot be directly accessed, even if
    // nested in a public module:

    // Error! `private_function` is private
    //my_mod::private_function();
    // TODO ^ Try uncommenting this line

    // Error! `private_function` is private
    //my_mod::nested::private_function();
    // TODO ^ Try uncommenting this line

    // Error! `private_nested` is a private module
    //my_mod::private_nested::function();
    // TODO ^ Try uncommenting this line

    // Error! `private_nested` is a private module
    //my_mod::private_nested::restricted_function();
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<h1><a class="header" href="#struct-visibility" id="struct-visibility">Struct visibility</a></h1>
<p>Structs have an extra level of visibility with their fields. The visibility 
defaults to private, and can be overridden with the <code>pub</code> modifier. This 
visibility only matters when a struct is accessed from outside the module 
where it is defined, and has the goal of hiding information (encapsulation).</p>
<pre><pre class="playpen"><code class="language-rust editable">mod my {
    // A public struct with a public field of generic type `T`
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // A public struct with a private field of generic type `T`
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // A public constructor method
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // Public structs with public fields can be constructed as usual
    let open_box = my::OpenBox { contents: &quot;public information&quot; };

    // and their fields can be normally accessed.
    println!(&quot;The open box contains: {}&quot;, open_box.contents);

    // Public structs with private fields cannot be constructed using field names.
    // Error! `ClosedBox` has private fields
    //let closed_box = my::ClosedBox { contents: &quot;classified information&quot; };
    // TODO ^ Try uncommenting this line

    // However, structs with private fields can be created using
    // public constructors
    let _closed_box = my::ClosedBox::new(&quot;classified information&quot;);

    // and the private fields of a public struct cannot be accessed.
    // Error! The `contents` field is private
    //println!(&quot;The closed box contains: {}&quot;, _closed_box.contents);
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<h3><a class="header" href="#see-also-29" id="see-also-29">See also:</a></h3>
<p><a href="rustexample/mod/../generics.html">generics</a> and <a href="rustexample/mod/../fn/methods.html">methods</a></p>
<h1><a class="header" href="#the-use-declaration" id="the-use-declaration">The <code>use</code> declaration</a></h1>
<p>The <code>use</code> declaration can be used to bind a full path to a new name, for easier
access. It is often used like this:</p>
<pre><code class="language-rust editable ignore">// extern crate deeply; // normally, this would exist and not be commented out!

use crate::deeply::nested::{
    my_first_function,
    my_second_function,
    AndATraitType
};

fn main() {
    my_first_function();
}
</code></pre>
<p>You can use the <code>as</code> keyword to bind imports to a different name:</p>
<pre><code class="language-rust editable ignore">// Bind the `deeply::nested::function` path to `other_function`.
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;called `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;called `deeply::nested::function()`&quot;);
        }
    }
}

fn main() {
    // Easier access to `deeply::nested::function`
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // This is equivalent to `use deeply::nested::function as function`.
        // This `function()` will shadow the outer one.
        use crate::deeply::nested::function;
        function();

        // `use` bindings have a local scope. In this case, the
        // shadowing of `function()` is only in this block.
        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre>
<h1><a class="header" href="#super-and-self" id="super-and-self"><code>super</code> and <code>self</code></a></h1>
<p>The <code>super</code> and <code>self</code> keywords can be used in the path to remove ambiguity
when accessing items and to prevent unnecessary hardcoding of paths.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn function() {
    println!(&quot;called `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;called `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;called `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // Let's access all the functions named `function` from this scope!
        print!(&quot;called `my::indirect_call()`, that\n&gt; &quot;);
        
        // The `self` keyword refers to the current module scope - in this case `my`.
        // Calling `self::function()` and calling `function()` directly both give
        // the same result, because they refer to the same function.
        self::function();
        function();
        
        // We can also use `self` to access another module inside `my`:
        self::cool::function();
        
        // The `super` keyword refers to the parent scope (outside the `my` module).
        super::function();
        
        // This will bind to the `cool::function` in the *crate* scope.
        // In this case the crate scope is the outermost scope.
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<h1><a class="header" href="#file-hierarchy" id="file-hierarchy">File hierarchy</a></h1>
<p>Modules can be mapped to a file/directory hierarchy. Let's break down the
<a href="rustexample/mod/visibility.html">visibility example</a> in files:</p>
<pre><code class="language-bash">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p>In <code>split.rs</code>:</p>
<pre><code class="language-rust ignore">// This declaration will look for a file named `my.rs` or `my/mod.rs` and will
// insert its contents inside a module named `my` under this scope
mod my;

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}

</code></pre>
<p>In <code>my/mod.rs</code>:</p>
<pre><code class="language-rust ignore">// Similarly `mod inaccessible` and `mod nested` will locate the `nested.rs`
// and `inaccessible.rs` files and insert them here under their respective
// modules
mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;called `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;called `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called `my::indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<p>In <code>my/nested.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn function() {
    println!(&quot;called `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;called `my::nested::private_function()`&quot;);
}
</code></pre>
<p>In <code>my/inaccessible.rs</code>:</p>
<pre><code class="language-rust ignore">#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;called `my::inaccessible::public_function()`&quot;);
}
</code></pre>
<p>Let's check that things still work as before:</p>
<pre><code class="language-bash">$ rustc split.rs &amp;&amp; ./split
called `my::function()`
called `function()`
called `my::indirect_access()`, that
&gt; called `my::private_function()`
called `my::nested::function()`
</code></pre>
<h1><a class="header" href="#crates" id="crates">Crates</a></h1>
<p>A crate is a compilation unit in Rust. Whenever <code>rustc some_file.rs</code> is called,
<code>some_file.rs</code> is treated as the <em>crate file</em>. If <code>some_file.rs</code> has <code>mod</code>
declarations in it, then the contents of the module files would be inserted in
places where <code>mod</code> declarations in the crate file are found, <em>before</em> running
the compiler over it. In other words, modules do <em>not</em> get compiled
individually, only crates get compiled.</p>
<p>A crate can be compiled into a binary or into a library. By default, <code>rustc</code>
will produce a binary from a crate. This behavior can be overridden by passing
the <code>--crate-type</code> flag to <code>rustc</code>.</p>
<h1><a class="header" href="#library" id="library">Library</a></h1>
<p>Let's create a library, and then see how to link it to another crate.</p>
<pre><code class="language-rust ignore">pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre>
<pre><code class="language-bash">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>Libraries get prefixed with &quot;lib&quot;, and by default they get named after their
crate file, but this default name can be overridden using the <a href="rustexample/crates/../attribute/crate.html"><code>crate_name</code>
attribute</a>.</p>
<h1><a class="header" href="#extern-crate" id="extern-crate"><code>extern crate</code></a></h1>
<p>To link a crate to this new library, the <code>extern crate</code> declaration must be
used. This will not only link the library, but also import all its items under
a module named the same as the library. The visibility rules that apply to
modules also apply to libraries.</p>
<pre><code class="language-rust ignore">// Link to `library`, import items under the `rary` module
extern crate rary;

fn main() {
    rary::public_function();

    // Error! `private_function` is private
    //rary::private_function();

    rary::indirect_access();
}
</code></pre>
<pre><code class="language-bash"># Where library.rlib is the path to the compiled library, assumed that it's
# in the same directory here:
$ rustc executable.rs --extern rary=library.rlib &amp;&amp; ./executable
called rary's `public_function()`
called rary's `indirect_access()`, that
&gt; called rary's `private_function()`
</code></pre>
<h1><a class="header" href="#cargo" id="cargo">Cargo</a></h1>
<p><code>cargo</code> is the official Rust package management tool. It has lots of really
useful features to improve code quality and developer velocity! These include</p>
<ul>
<li>Dependency management and integration with <a href="https://crates.io">crates.io</a> (the
official Rust package registry)</li>
<li>Awareness of unit tests</li>
<li>Awareness of benchmarks</li>
</ul>
<p>This chapter will go through some quick basics, but you can find the
comprehensive docs in <a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a>.</p>
<h1><a class="header" href="#dependencies" id="dependencies">Dependencies</a></h1>
<p>Most programs have dependencies on some libraries. If you have ever managed
dependencies by hand, you know how much of a pain this can be. Luckily, the Rust
ecosystem comes standard with <code>cargo</code>! <code>cargo</code> can manage dependencies for a
project.</p>
<p>To create a new Rust project,</p>
<pre><code class="language-sh"># A binary
cargo new foo

# OR A library
cargo new --lib foo
</code></pre>
<p>For the rest of this chapter, I will assume we are making a binary, rather than
a library, but all of the concepts are the same.</p>
<p>After the above commands, you should see something like this:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>The <code>main.rs</code> is the root source file for your new project -- nothing new there.
The <code>Cargo.toml</code> is the config file for <code>cargo</code> for this project (<code>foo</code>). If you
look inside it, you should see something like this:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
</code></pre>
<p>The <code>name</code> field under <code>package</code> determines the name of the project. This is
used by <code>crates.io</code> if you publish the crate (more later). It is also the name
of the output binary when you compile.</p>
<p>The <code>version</code> field is a crate version number using <a href="http://semver.org/">Semantic
Versioning</a>.</p>
<p>The <code>authors</code> field is a list of authors used when publishing the crate.</p>
<p>The <code>dependencies</code> section lets you add a dependency for your project.</p>
<p>For example, suppose that I want my program to have a great CLI. You can find
lots of great packages on <a href="https://crates.io">crates.io</a> (the official Rust
package registry). One popular choice is <a href="https://crates.io/crates/clap">clap</a>.
As of this writing, the most recent published version of <code>clap</code> is <code>2.27.1</code>. To
add a dependency to our program, we can simply add the following to our
<code>Cargo.toml</code> under <code>dependencies</code>: <code>clap = &quot;2.27.1&quot;</code>.  And of course, <code>extern crate clap</code> in <code>main.rs</code>, just like normal. And that's it! You can start using
<code>clap</code> in your program.</p>
<p><code>cargo</code> also supports <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html">other types of dependencies</a>. Here is just
a small sampling:</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # from crates.io
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # from online repo
bar = { path = &quot;../bar&quot; } # from a path in the local filesystem
</code></pre>
<p><code>cargo</code> is more than a dependency manager. All of the available
configuration options are listed in the <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">format specification</a> of
<code>Cargo.toml</code>.</p>
<p>To build our project we can execute <code>cargo build</code> anywhere in the project
directory (including subdirectories!). We can also do <code>cargo run</code> to build and
run. Notice that these commands will resolve all dependencies, download crates
if needed, and build everything, including your crate. (Note that it only
rebuilds what it has not already built, similar to <code>make</code>).</p>
<p>Voila! That's all there is to it!</p>
<h1><a class="header" href="#conventions" id="conventions">Conventions</a></h1>
<p>In the previous chapter, we saw the following directory hierarchy:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>Suppose that we wanted to have two binaries in the same project, though. What
then?</p>
<p>It turns out that <code>cargo</code> supports this. The default binary name is <code>main</code>, as
we saw before, but you can add additional binaries by placing them in a <code>bin/</code>
directory:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<p>To tell <code>cargo</code> to compile or run this binary as opposed to the default or other
binaries, we just pass <code>cargo</code> the <code>--bin my_other_bin</code> flag, where <code>my_other_bin</code>
is the name of the binary we want to work with.</p>
<p>In addition to extra binaries, <code>cargo</code> supports <a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">more features</a> such as
benchmarks, tests, and examples.</p>
<p>In the next chapter, we will look more closely at tests.</p>
<h1><a class="header" href="#testing" id="testing">Testing</a></h1>
<p>As we know testing is integral to any piece of software! Rust has first-class
support for unit and integration testing (<a href="https://doc.rust-lang.org/book/ch11-00-testing.html">see this
chapter</a> in
TRPL).</p>
<p>From the testing chapters linked above, we see how to write unit tests and
integration tests. Organizationally, we can place unit tests in the modules they
test and integration tests in their own <code>tests/</code> directory:</p>
<pre><code class="language-txt">foo
├── Cargo.toml
├── src
│   └── main.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<p>Each file in <code>tests</code> is a separate integration test.</p>
<p><code>cargo</code> naturally provides an easy way to run all of your tests!</p>
<pre><code class="language-sh">cargo test
</code></pre>
<p>You should see output like this:</p>
<pre><code class="language-txt">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 3 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>You can also run tests whose name matches a pattern:</p>
<pre><code class="language-sh">cargo test test_foo
</code></pre>
<pre><code class="language-txt">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>One word of caution: Cargo may run multiple tests concurrently, so make sure
that they don't race with each other. For example, if they all output to a
file, you should make them write to different files.</p>
<h1><a class="header" href="#build-scripts" id="build-scripts">Build Scripts</a></h1>
<p>Sometimes a normal build from cargo is not enough. Perhaps your crate needs some
pre-requisites before cargo will successfully compile, things like code
generation, or some native code that needs to be compiled. To solve this problem
we have build scripts that Cargo can run.</p>
<p>To add a build script to your package it can either be specified in the
<code>Cargo.toml</code> as follows:</p>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;
</code></pre>
<p>Otherwise Cargo will look for a <code>build.rs</code> file in the project directory by
default.</p>
<h2><a class="header" href="#how-to-use-a-build-script" id="how-to-use-a-build-script">How to use a build script</a></h2>
<p>The build script is simply another Rust file that will be compiled and invoked
prior to compiling anything else in the package. Hence it can be used to fulfil
pre-requisites of your crate.</p>
<p>Cargo provides the script with inputs via environment variables <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">specified
here</a> that can be used.</p>
<p>The script provides output via stdout. All lines printed are written to
<code>target/debug/build/&lt;pkg&gt;/output</code>. Further, lines prefixed with <code>cargo:</code> will be
interpreted by Cargo directly and hence can be used to define parameters for the
packages compilation.</p>
<p>For further specification and examples have a read of the <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">cargo specification</a>.</p>
<h1><a class="header" href="#attributes" id="attributes">Attributes</a></h1>
<p>An attribute is metadata applied to some module, crate or item. This metadata
can be used to/for:</p>
<!-- TODO: Link these to their respective examples -->
<ul>
<li><a href="rustexample/attribute/cfg.html">conditional compilation of code</a></li>
<li><a href="rustexample/attribute/crate.html">set crate name, version and type (binary or library)</a></li>
<li>disable <a href="https://en.wikipedia.org/wiki/Lint_%28software%29">lints</a> (warnings)</li>
<li>enable compiler features (macros, glob imports, etc.)</li>
<li>link to a foreign library</li>
<li>mark functions as unit tests</li>
<li>mark functions that will be part of a benchmark</li>
</ul>
<p>When attributes apply to a whole crate, their syntax is <code>#![crate_attribute]</code>,
and when they apply to a module or item, the syntax is <code>#[item_attribute]</code>
(notice the missing bang <code>!</code>).</p>
<p>Attributes can take arguments with different syntaxes:</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>Attributes can have multiple values and can be separated over multiple lines, too:</p>
<pre><code class="language-rust ignore">#[attribute(value, value2)]


#[attribute(value, value2, value3,
            value4, value5)]
</code></pre>
<h1><a class="header" href="#dead_code" id="dead_code"><code>dead_code</code></a></h1>
<p>The compiler provides a <code>dead_code</code>
<a href="https://en.wikipedia.org/wiki/Lint_%28software%29"><em>lint</em></a> that will warn
about unused functions. An <em>attribute</em> can be used to disable the lint.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn used_function() {}

// `#[allow(dead_code)]` is an attribute that disables the `dead_code` lint
#[allow(dead_code)]
fn unused_function() {}

fn noisy_unused_function() {}
// FIXME ^ Add an attribute to suppress the warning

fn main() {
    used_function();
}
</code></pre></pre>
<p>Note that in real programs, you should eliminate dead code. In these examples
we'll allow dead code in some places because of the interactive nature of the
examples.</p>
<h1><a class="header" href="#crates-1" id="crates-1">Crates</a></h1>
<p>The <code>crate_type</code> attribute can be used to tell the compiler whether a crate is
a binary or a library (and even which type of library), and the <code>crate_name</code>
attribute can be used to set the name of the crate.</p>
<p>However, it is important to note that both the <code>crate_type</code> and <code>crate_name</code>
attributes have <strong>no</strong> effect whatsoever when using Cargo, the Rust package
manager. Since Cargo is used for the majority of Rust projects, this means
real-world uses of <code>crate_type</code> and <code>crate_name</code> are relatively limited.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This crate is a library
#![crate_type = &quot;lib&quot;]
// The library is named &quot;rary&quot;
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
</code></pre></pre>
<p>When the <code>crate_type</code> attribute is used, we no longer need to pass the
<code>--crate-type</code> flag to <code>rustc</code>.</p>
<pre><code class="language-bash">$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<h1><a class="header" href="#cfg" id="cfg"><code>cfg</code></a></h1>
<p>Conditional compilation is possible through two different operators:</p>
<ul>
<li>the <code>cfg</code> attribute: <code>#[cfg(...)]</code> in attribute position</li>
<li>the <code>cfg!</code> macro: <code>cfg!(...)</code> in boolean expressions</li>
</ul>
<p>Both utilize identical argument syntax.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This function only gets compiled if the target OS is linux
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;You are running linux!&quot;);
}

// And this function only gets compiled if the target OS is *not* linux
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;You are *not* running linux!&quot;);
}

fn main() {
    are_you_on_linux();
    
    println!(&quot;Are you sure?&quot;);
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Yes. It's definitely linux!&quot;);
    } else {
        println!(&quot;Yes. It's definitely *not* linux!&quot;);
    }
}
</code></pre></pre>
<h3><a class="header" href="#see-also-30" id="see-also-30">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#conditional-compilation">the reference</a>, <a href="https://doc.rust-lang.org/std/macro.cfg!.html"><code>cfg!</code></a>, and <a href="rustexample/attribute/../macros.html">macros</a>.</p>
<h1><a class="header" href="#custom" id="custom">Custom</a></h1>
<p>Some conditionals like <code>target_os</code> are implicitly provided by <code>rustc</code>, but
custom conditionals must be passed to <code>rustc</code> using the <code>--cfg</code> flag.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;);
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p>Try to run this to see what happens without the custom <code>cfg</code> flag.</p>
<p>With the custom <code>cfg</code> flag:</p>
<pre><code class="language-bash">$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<h1><a class="header" href="#generics" id="generics">Generics</a></h1>
<p><em>Generics</em> is the topic of generalizing types and functionalities to broader
cases. This is extremely useful for reducing code duplication in many ways,
but can call for rather involving syntax. Namely, being generic requires 
taking great care to specify over which types a generic type 
is actually considered valid. The simplest and most common use of generics 
is for type parameters.</p>
<p>A type parameter is specified as generic by the use of angle brackets and upper
<a href="https://en.wikipedia.org/wiki/CamelCase">camel case</a>: <code>&lt;Aaa, Bbb, ...&gt;</code>. &quot;Generic type parameters&quot; are
typically represented as <code>&lt;T&gt;</code>. In Rust, &quot;generic&quot; also describes anything that
accepts one or more generic type parameters <code>&lt;T&gt;</code>. Any type specified as a 
generic type parameter is generic, and everything else is concrete (non-generic).</p>
<p>For example, defining a <em>generic function</em> named <code>foo</code> that takes an argument
<code>T</code> of any type:</p>
<pre><code class="language-rust ignore">fn foo&lt;T&gt;(arg: T) { ... }
</code></pre>
<p>Because <code>T</code> has been specified as a generic type parameter using <code>&lt;T&gt;</code>, it 
is considered generic when used here as <code>(arg: T)</code>. This is the case even if <code>T</code> 
has previously been defined as a <code>struct</code>.</p>
<p>This example shows some of the syntax in action:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A concrete type `A`.
struct A;

// In defining the type `Single`, the first use of `A` is not preceded by `&lt;A&gt;`.
// Therefore, `Single` is a concrete type, and `A` is defined as above.
struct Single(A);
//            ^ Here is `Single`s first use of the type `A`.

// Here, `&lt;T&gt;` precedes the first use of `T`, so `SingleGen` is a generic type.
// Because the type parameter `T` is generic, it could be anything, including
// the concrete type `A` defined at the top.
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single` is concrete and explicitly takes `A`.
    let _s = Single(A);
    
    // Create a variable `_char` of type `SingleGen&lt;char&gt;`
    // and give it the value `SingleGen('a')`.
    // Here, `SingleGen` has a type parameter explicitly specified.
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // `SingleGen` can also have a type parameter implicitly specified:
    let _t    = SingleGen(A); // Uses `A` defined at the top.
    let _i32  = SingleGen(6); // Uses `i32`.
    let _char = SingleGen('a'); // Uses `char`.
}
</code></pre></pre>
<h3><a class="header" href="#see-also-31" id="see-also-31">See also:</a></h3>
<p><a href="rustexample/custom_types/structs.html"><code>struct</code>s</a></p>
<h1><a class="header" href="#functions-1" id="functions-1">Functions</a></h1>
<p>The same set of rules can be applied to functions: a type <code>T</code> becomes
generic when preceded by <code>&lt;T&gt;</code>.</p>
<p>Using generic functions sometimes requires explicitly specifying type 
parameters. This may be the case if the function is called where the return type 
is generic, or if the compiler doesn't have enough information to infer 
the necessary type parameters.</p>
<p>A function call with explicitly specified type parameters looks like:
<code>fun::&lt;A, B, ...&gt;()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct A;          // Concrete type `A`.
struct S(A);       // Concrete type `S`.
struct SGen&lt;T&gt;(T); // Generic type `SGen`.

// The following functions all take ownership of the variable passed into
// them and immediately go out of scope, freeing the variable.

// Define a function `reg_fn` that takes an argument `_s` of type `S`.
// This has no `&lt;T&gt;` so this is not a generic function.
fn reg_fn(_s: S) {}

// Define a function `gen_spec_t` that takes an argument `_s` of type `SGen&lt;T&gt;`.
// It has been explicitly given the type parameter `A`, but because `A` has not 
// been specified as a generic type parameter for `gen_spec_t`, it is not generic.
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// Define a function `gen_spec_i32` that takes an argument `_s` of type `SGen&lt;i32&gt;`.
// It has been explicitly given the type parameter `i32`, which is a specific type.
// Because `i32` is not a generic type, this function is also not generic.
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// Define a function `generic` that takes an argument `_s` of type `SGen&lt;T&gt;`.
// Because `SGen&lt;T&gt;` is preceded by `&lt;T&gt;`, this function is generic over `T`.
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // Using the non-generic functions
    reg_fn(S(A));          // Concrete type.
    gen_spec_t(SGen(A));   // Implicitly specified type parameter `A`.
    gen_spec_i32(SGen(6)); // Implicitly specified type parameter `i32`.

    // Explicitly specified type parameter `char` to `generic()`.
    generic::&lt;char&gt;(SGen('a'));

    // Implicitly specified type parameter `char` to `generic()`.
    generic(SGen('c'));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-32" id="see-also-32">See also:</a></h3>
<p><a href="rustexample/generics/../fn.html">functions</a> and <a href="rustexample/generics/../custom_types/structs.html"><code>struct</code>s</a></p>
<h1><a class="header" href="#implementation" id="implementation">Implementation</a></h1>
<p>Similar to functions, implementations require care to remain generic.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct S; // Concrete type `S`
struct GenericVal&lt;T&gt;(T,); // Generic type `GenericVal`

// impl of GenericVal where we explicitly specify type parameters:
impl GenericVal&lt;f32&gt; {} // Specify `f32`
impl GenericVal&lt;S&gt; {} // Specify `S` as defined above

// `&lt;T&gt;` Must precede the type to remain generic
impl &lt;T&gt; GenericVal&lt;T&gt; {}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playpen"><code class="language-rust editable">struct Val {
    val: f64
}

struct GenVal&lt;T&gt;{
    gen_val: T
}

// impl of Val
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 { &amp;self.val }
}

// impl of GenVal for a generic type `T`
impl &lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T { &amp;self.gen_val }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };
    
    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<h3><a class="header" href="#see-also-33" id="see-also-33">See also:</a></h3>
<p><a href="rustexample/generics/../scope/lifetime/fn.html">functions returning references</a>, <a href="rustexample/generics/../fn/methods.html"><code>impl</code></a>, and <a href="rustexample/generics/../custom_types/structs.html"><code>struct</code></a></p>
<h1><a class="header" href="#traits" id="traits">Traits</a></h1>
<p>Of course <code>trait</code>s can also be generic. Here we define one which reimplements
the <code>Drop</code> <code>trait</code> as a generic method to <code>drop</code> itself and an input.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Non-copyable types.
struct Empty;
struct Null;

// A trait generic over `T`.
trait DoubleDrop&lt;T&gt; {
    // Define a method on the caller type which takes an
    // additional single parameter `T` and does nothing with it.
    fn double_drop(self, _: T);
}

// Implement `DoubleDrop&lt;T&gt;` for any generic parameter `T` and
// caller `U`.
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // This method takes ownership of both passed arguments,
    // deallocating both.
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // Deallocate `empty` and `null`.
    empty.double_drop(null);

    //empty;
    //null;
    // ^ TODO: Try uncommenting these lines.
}
</code></pre></pre>
<h3><a class="header" href="#see-also-34" id="see-also-34">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a>, <a href="rustexample/generics/../custom_types/structs.html"><code>struct</code></a>, and <a href="rustexample/generics/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#bounds" id="bounds">Bounds</a></h1>
<p>When working with generics, the type parameters often must use traits as <em>bounds</em> to
stipulate what functionality a type implements. For example, the following
example uses the trait <code>Display</code> to print and so it requires <code>T</code> to be bound
by <code>Display</code>; that is, <code>T</code> <em>must</em> implement <code>Display</code>.</p>
<pre><code class="language-rust ignore">// Define a function `printer` that takes a generic type `T` which
// must implement trait `Display`.
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
</code></pre>
<p>Bounding restricts the generic to types that conform to the bounds. That is:</p>
<pre><code class="language-rust ignore">struct S&lt;T: Display&gt;(T);

// Error! `Vec&lt;T&gt;` does not implement `Display`. This
// specialization will fail.
let s = S(vec![1]);
</code></pre>
<p>Another effect of bounding is that generic instances are allowed to access the 
<a href="rustexample/generics/../fn/methods.html">methods</a> of traits specified in the bounds. For example:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A trait which implements the print marker: `{:?}`.
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// The generic `T` must implement `Debug`. Regardless
// of the type, this will work properly.
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T` must implement `HasArea`. Any type which meets
// the bound can access `HasArea`'s function `area`.
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    //print_debug(&amp;_triangle);
    //println!(&quot;Area: {}&quot;, area(&amp;_triangle));
    // ^ TODO: Try uncommenting these.
    // | Error: Does not implement either `Debug` or `HasArea`. 
}
</code></pre></pre>
<p>As an additional note, <a href="rustexample/generics/../generics/where.html"><code>where</code></a> clauses can also be used to apply bounds in
some cases to be more expressive.</p>
<h3><a class="header" href="#see-also-35" id="see-also-35">See also:</a></h3>
<p><a href="rustexample/generics/../hello/print.html"><code>std::fmt</code></a>, <a href="rustexample/generics/../custom_types/structs.html"><code>struct</code>s</a>, and <a href="rustexample/generics/../trait.html"><code>trait</code>s</a></p>
<h1><a class="header" href="#testcase-empty-bounds" id="testcase-empty-bounds">Testcase: empty bounds</a></h1>
<p>A consequence of how bounds work is that even if a <code>trait</code> doesn't
include any functionality, you can still use it as a bound. <code>Eq</code> and
<code>Ord</code> are examples of such <code>trait</code>s from the <code>std</code> library.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// These functions are only valid for types which implement these
// traits. The fact that the traits are empty is irrelevant.
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;red&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;blue&quot; }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // `red()` won't work on a blue jay nor vice versa
    // because of the bounds.
    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));
    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));
    //println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));
    // ^ TODO: Try uncommenting this line.
}
</code></pre></pre>
<h3><a class="header" href="#see-also-36" id="see-also-36">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>std::cmp::Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>std::cmp::Ord</code>s</a>, and <a href="rustexample/generics/bounds/../../trait.html"><code>trait</code>s</a></p>
<h1><a class="header" href="#multiple-bounds" id="multiple-bounds">Multiple bounds</a></h1>
<p>Multiple bounds can be applied with a <code>+</code>. Like normal, different types are
separated with <code>,</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}`&quot;, t);
    println!(&quot;u: `{:?}`&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    //compare_prints(&amp;array);
    // TODO ^ Try uncommenting this.

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-37" id="see-also-37">See also:</a></h3>
<p><a href="rustexample/generics/../hello/print.html"><code>std::fmt</code></a> and <a href="rustexample/generics/../trait.html"><code>trait</code>s</a></p>
<h1><a class="header" href="#where-clauses" id="where-clauses">Where clauses</a></h1>
<p>A bound can also be expressed using a <code>where</code> clause immediately
before the opening <code>{</code>, rather than at the type's first mention. 
Additionally, <code>where</code> clauses can apply bounds to arbitrary types, 
rather than just to type parameters.</p>
<p>Some cases that a <code>where</code> clause is useful:</p>
<ul>
<li>When specifying generic types and bounds separately is clearer:</li>
</ul>
<pre><code class="language-rust ignore">impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// Expressing bounds with a `where` clause
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
</code></pre>
<ul>
<li>When using a <code>where</code> clause is more expressive than using normal syntax. 
The <code>impl</code> in this example cannot be directly expressed without a <code>where</code> clause:</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// Because we would otherwise have to express this as `T: Debug` or 
// use another method of indirect approach, this requires a `where` clause:
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // We want `Option&lt;T&gt;: Debug` as our bound because that is what's
    // being printed. Doing otherwise would be using the wrong bound.
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<h3><a class="header" href="#see-also-38" id="see-also-38">See also:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">RFC</a>, <a href="rustexample/generics/../custom_types/structs.html"><code>struct</code></a>, and <a href="rustexample/generics/../trait.html"><code>trait</code></a></p>
<h1><a class="header" href="#new-type-idiom" id="new-type-idiom">New Type Idiom</a></h1>
<p>The <code>newtype</code> idiom gives compile time guarantees that the right type of value is supplied
to a program.</p>
<p>For example, an age verification function that checks age in years, <em>must</em> be given
a value of type <code>Years</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}


impl Days {
    /// truncates partial years
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn old_enough(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    // println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days));
}
</code></pre></pre>
<p>Uncomment the last print statement to observe that the type supplied must be <code>Years</code>.</p>
<p>To obtain the <code>newtype</code>'s value as the base type, you may use tuple syntax like so:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Years(i64);

fn main() {
    let years = Years(42);
    let years_as_primitive: i64 = years.0;
}
</code></pre></pre>
<h3><a class="header" href="#see-also-39" id="see-also-39">See also:</a></h3>
<p><a href="rustexample/generics/../custom_types/structs.html"><code>structs</code></a></p>
<h1><a class="header" href="#associated-items" id="associated-items">Associated items</a></h1>
<p>&quot;Associated Items&quot; refers to a set of rules pertaining to <a href="https://doc.rust-lang.org/reference/items.html"><code>item</code></a>s
of various types. It is an extension to <code>trait</code> generics, and allows 
<code>trait</code>s to internally define new items.</p>
<p>One such item is called an <em>associated type</em>, providing simpler usage 
patterns when the <code>trait</code> is generic over its container type.</p>
<h3><a class="header" href="#see-also-40" id="see-also-40">See also:</a></h3>
<p><a href="https://github.com/rust-lang/rfcs/blob/master/text/0195-associated-items.md">RFC</a></p>
<h1><a class="header" href="#the-problem" id="the-problem">The Problem</a></h1>
<p>A <code>trait</code> that is generic over its container type has type specification
requirements - users of the <code>trait</code> <em>must</em> specify all of its generic types.</p>
<p>In the example below, the <code>Contains</code> <code>trait</code> allows the use of the generic 
types <code>A</code> and <code>B</code>. The trait is then implemented for the <code>Container</code> type, 
specifying <code>i32</code> for <code>A</code> and <code>B</code> so that it can be used with <code>fn difference()</code>.</p>
<p>Because <code>Contains</code> is generic, we are forced to explicitly state <em>all</em> of the 
generic types for <code>fn difference()</code>. In practice, we want a way to express that 
<code>A</code> and <code>B</code> are determined by the <em>input</em> <code>C</code>. As you will see in the next 
section, associated types provide exactly that capability.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // Explicitly requires `A` and `B`.
    fn first(&amp;self) -&gt; i32; // Doesn't explicitly require `A` or `B`.
    fn last(&amp;self) -&gt; i32;  // Doesn't explicitly require `A` or `B`.
}

impl Contains&lt;i32, i32&gt; for Container {
    // True if the numbers stored are equal.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// `C` contains `A` and `B`. In light of that, having to express `A` and
// `B` again is a nuisance.
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());

    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-41" id="see-also-41">See also:</a></h3>
<p><a href="rustexample/generics/assoc_items/../../custom_types/structs.html"><code>struct</code>s</a>, and <a href="rustexample/generics/assoc_items/../../trait.html"><code>trait</code>s</a></p>
<h1><a class="header" href="#associated-types" id="associated-types">Associated types</a></h1>
<p>The use of &quot;Associated types&quot; improves the overall readability of code 
by moving inner types locally into a trait as <em>output</em> types. Syntax
for the <code>trait</code> definition is as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// `A` and `B` are defined in the trait via the `type` keyword.
// (Note: `type` in this context is different from `type` when used for
// aliases).
trait Contains {
    type A;
    type B;

    // Updated syntax to refer to these new types generically.
    fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that functions that use the <code>trait</code> <code>Contains</code> are no longer required
to express <code>A</code> or <code>B</code> at all:</p>
<pre><code class="language-rust ignore">// Without using associated types
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// Using associated types
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
</code></pre>
<p>Let's rewrite the example from the previous section using associated types:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Container(i32, i32);

// A trait which checks if 2 items are stored inside of container.
// Also retrieves first or last value.
trait Contains {
    // Define generic types here which methods will be able to utilize.
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // Specify what types `A` and `B` are. If the `input` type
    // is `Container(i32, i32)`, the `output` types are determined
    // as `i32` and `i32`.
    type A = i32;
    type B = i32;

    // `&amp;Self::A` and `&amp;Self::B` are also valid here.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h1><a class="header" href="#phantom-type-parameters" id="phantom-type-parameters">Phantom type parameters</a></h1>
<p>A phantom type parameter is one that doesn't show up at runtime,
but is checked statically (and only) at compile time.</p>
<p>Data types can use extra generic type parameters to act as markers
or to perform type checking at compile time. These extra parameters 
hold no storage values, and have no runtime behavior.</p>
<p>In the following example, we combine <a href="https://doc.rust-lang.org/std/marker/struct.PhantomData.html">std::marker::PhantomData</a>
with the phantom type parameter concept to create tuples containing
different data types.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::marker::PhantomData;

// A phantom tuple struct which is generic over `A` with hidden parameter `B`.
#[derive(PartialEq)] // Allow equality test for this type.
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);

// A phantom type struct which is generic over `A` with hidden parameter `B`.
#[derive(PartialEq)] // Allow equality test for this type.
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// Note: Storage is allocated for generic type `A`, but not for `B`.
//       Therefore, `B` cannot be used in computations.

fn main() {
    // Here, `f32` and `f64` are the hidden parameters.
    // PhantomTuple type specified as `&lt;char, f32&gt;`.
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // PhantomTuple type specified as `&lt;char, f64&gt;`.
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // Type specified as `&lt;char, f32&gt;`.
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // Type specified as `&lt;char, f64&gt;`.
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    //println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,
    //          _tuple1 == _tuple2);
    
    // Compile-time Error! Type mismatch so these cannot be compared:
    //println!(&quot;_struct1 == _struct2 yields: {}&quot;,
    //          _struct1 == _struct2);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-42" id="see-also-42">See also:</a></h3>
<p><a href="rustexample/generics/../trait/derive.html">Derive</a>, <a href="rustexample/generics/../custom_types/structs.html">struct</a>, and <a href="rustexample/generics/../custom_types/structs.html">TupleStructs</a></p>
<h1><a class="header" href="#testcase-unit-clarification" id="testcase-unit-clarification">Testcase: unit clarification</a></h1>
<p>A useful method of unit conversions can be examined by implementing <code>Add</code>
with a phantom type parameter. The <code>Add</code> <code>trait</code> is examined below:</p>
<pre><code class="language-rust ignore">// This construction would impose: `Self + RHS = Output`
// where RHS defaults to Self if not specified in the implementation.
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output` must be `T&lt;U&gt;` so that `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;`.
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
</code></pre>
<p>The whole implementation:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::Add;
use std::marker::PhantomData;

/// Create void enumerations to define unit types.
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

/// `Length` is a type with phantom type parameter `Unit`,
/// and is not generic over the length type (that is `f64`).
///
/// `f64` already implements the `Clone` and `Copy` traits.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

/// The `Add` trait defines the behavior of the `+` operator.
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add() returns a new `Length` struct containing the sum.
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+` calls the `Add` implementation for `f64`.
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // Specifies `one_foot` to have phantom type parameter `Inch`.
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter` has phantom type parameter `Mm`.
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+` calls the `add()` method we implemented for `Length&lt;Unit&gt;`.
    //
    // Since `Length` implements `Copy`, `add()` does not consume
    // `one_foot` and `one_meter` but copies them into `self` and `rhs`.
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // Addition works.
    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);
    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);

    // Nonsensical operations fail as they should:
    // Compile-time Error: type mismatch.
    //let one_feter = one_foot + one_meter;
}
</code></pre></pre>
<h3><a class="header" href="#see-also-43" id="see-also-43">See also:</a></h3>
<p><a href="rustexample/generics/phantom/../../scope/borrow.html">Borrowing (<code>&amp;</code>)</a>, <a href="rustexample/generics/phantom/../../generics/bounds.html">Bounds (<code>X: Y</code>)</a>, <a href="rustexample/generics/phantom/../../custom_types/enum.html">enum</a>, <a href="rustexample/generics/phantom/../../fn/methods.html">impl &amp; self</a>,
<a href="rustexample/generics/phantom/../../trait/ops.html">Overloading</a>, <a href="rustexample/generics/phantom/../../scope/borrow/ref.html">ref</a>, <a href="rustexample/generics/phantom/../../trait.html">Traits (<code>X for Y</code>)</a>, and <a href="rustexample/generics/phantom/../../custom_types/structs.html">TupleStructs</a>.</p>
<h1><a class="header" href="#scoping-rules" id="scoping-rules">Scoping rules</a></h1>
<p>Scopes play an important part in ownership, borrowing, and lifetimes.
That is, they indicate to the compiler when borrows are valid, when 
resources can be freed, and when variables are created or destroyed.</p>
<h1><a class="header" href="#raii" id="raii">RAII</a></h1>
<p>Variables in Rust do more than just hold data in the stack: they also <em>own</em>
resources, e.g. <code>Box&lt;T&gt;</code> owns memory in the heap. Rust enforces <a href="https://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization">RAII</a>
(Resource Acquisition Is Initialization), so whenever an object goes out of
scope, its destructor is called and its owned resources are freed.</p>
<p>This behavior shields against <em>resource leak</em> bugs, so you'll never have to
manually free memory or worry about memory leaks again! Here's a quick showcase:</p>
<pre><pre class="playpen"><code class="language-rust editable">// raii.rs
fn create_box() {
    // Allocate an integer on the heap
    let _box1 = Box::new(3i32);

    // `_box1` is destroyed here, and memory gets freed
}

fn main() {
    // Allocate an integer on the heap
    let _box2 = Box::new(5i32);

    // A nested scope:
    {
        // Allocate an integer on the heap
        let _box3 = Box::new(4i32);

        // `_box3` is destroyed here, and memory gets freed
    }

    // Creating lots of boxes just for fun
    // There's no need to manually free memory!
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` is destroyed here, and memory gets freed
}
</code></pre></pre>
<p>Of course, we can double check for memory errors using <a href="http://valgrind.org/info/"><code>valgrind</code></a>:</p>
<pre><code class="language-bash">$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<p>No leaks here!</p>
<h2><a class="header" href="#destructor" id="destructor">Destructor</a></h2>
<p>The notion of a destructor in Rust is provided through the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait. The
destructor is called when the resource goes out of scope. This trait is not
required to be implemented for every type, only implement it for your type if
you require its own destructor logic.</p>
<p>Run the below example to see how the <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait works. When the variable in
the <code>main</code> function goes out of scope the custom destructor will be invoked.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!(&quot;ToDrop is being dropped&quot;);
    }
}

fn main() {
    let x = ToDrop;
    println!(&quot;Made a ToDrop!&quot;);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-44" id="see-also-44">See also:</a></h3>
<p><a href="rustexample/scope/../std/box.html">Box</a></p>
<h1><a class="header" href="#ownership-and-moves" id="ownership-and-moves">Ownership and moves</a></h1>
<p>Because variables are in charge of freeing their own resources, 
<strong>resources can only have one owner</strong>. This also prevents resources 
from being freed more than once. <strong>Note that not all variables own</strong> 
<strong>resources</strong> (e.g. <a href="rustexample/scope/../flow_control/match/destructuring/destructure_pointers.html">references</a>).</p>
<blockquote>
<p>reference 变量没有resource</p>
</blockquote>
<p>When doing assignments (<code>let x = y</code>) or passing function arguments by value
(<code>foo(x)</code>), the <em>ownership</em> of the resources is transferred. In Rust-speak, 
this is known as a <em>move</em>.</p>
<blockquote>
<p>move 动作有： </p>
<p>let x = y 赋值</p>
<p>函数传值 by value</p>
</blockquote>
<p>After moving resources, the previous owner can no longer be used. This avoids
creating dangling pointers.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This function takes ownership of the heap allocated memory
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Destroying a box that contains {}&quot;, c);

    // `c` is destroyed and the memory freed
}

fn main() {
    // _Stack_ allocated integer
    // integer 这类原始类型都是栈上分配内存 
    let x = 5u32;

    // *Copy* `x` into `y` - no resources are moved
    // Copy 语义的不会发生 move， 就是做了一份copy， 安全
    let y = x;

    // Both values can be independently used
    // Copy后是安全独立的
    println!(&quot;x is {}, and y is {}&quot;, x, y);

    // `a` is a pointer to a _heap_ allocated integer
    let a = Box::new(5i32);

    println!(&quot;a contains: {}&quot;, a);

    // *Move* `a` into `b`
    let b = a;
    // The pointer address of `a` is copied (not the data) into `b`.
    // Both are now pointers to the same heap allocated data, but
    // `b` now owns it.
    // a 的 指针地址copy给了b， 它们指向相同的堆上数据， 但是b拥有所有权
    
    // Error! `a` can no longer access the data, because it no longer owns the
    // heap memory
    //println!(&quot;a contains: {}&quot;, a);
    // TODO ^ Try uncommenting this line
    // 不能够继续通过a访问数据， 因为a不再拥有数据的所有权了

    // This function takes ownership of the heap allocated memory from `b`
    destroy_box(b); //按值传递， 就是move， 相当于被销毁。 

    // Since the heap memory has been freed at this point, this action would
    // result in dereferencing freed memory, but it's forbidden by the compiler
    // Error! Same reason as the previous Error
    //println!(&quot;b contains: {}&quot;, b);
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<h1><a class="header" href="#mutability-1" id="mutability-1">Mutability</a></h1>
<p>Mutability of data can be changed when ownership is transferred.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box contains {}&quot;, immutable_box);

    // Mutability error
    //*immutable_box = 4;

    // *Move* the box, changing the ownership (and mutability)
    // immutable 的变量传递给 mut 变量， 就可以变成修改类型的了
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box contains {}&quot;, mutable_box);

    // Modify the contents of the box
    // 
    *mutable_box = 4;

    println!(&quot;mutable_box now contains {}&quot;, mutable_box);
}
</code></pre></pre>
<h1><a class="header" href="#borrowing" id="borrowing">Borrowing</a></h1>
<p>Most of the time, we'd like to access data without taking ownership over
it. To accomplish this, Rust uses a <em>borrowing</em> mechanism. Instead of
passing objects by value (<code>T</code>), objects can be passed by reference (<code>&amp;T</code>).</p>
<p>The compiler statically guarantees (via its borrow checker) that references 
<em>always</em> point to valid objects. That is, while references to an object
exist, the object cannot be destroyed.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// This function takes ownership of a box and destroys it
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
}

// This function borrows an i32
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;This int is: {}&quot;, borrowed_i32);
}

fn main() {
    // Create a boxed i32, and a stacked i32
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Borrow the contents of the box. Ownership is not taken,
    // so the contents can be borrowed again.
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // Take a reference to the data contained inside the box
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // Error!
        // Can't destroy `boxed_i32` while the inner value is borrowed later in scope.
        eat_box_i32(boxed_i32);
        // FIXME ^ Comment out this line

        // Attempt to borrow `_ref_to_i32` after inner value is destroyed
        borrow_i32(_ref_to_i32);
        // `_ref_to_i32` goes out of scope and is no longer borrowed.
    }

    // `boxed_i32` can now give up ownership to `eat_box` and be destroyed
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<h1><a class="header" href="#mutability-2" id="mutability-2">Mutability</a></h1>
<p>Mutable data can be mutably borrowed using <code>&amp;mut T</code>. This is called 
a <em>mutable reference</em> and gives read/write access to the borrower.
In contrast, <code>&amp;T</code> borrows the data via an immutable reference, and 
the borrower can read the data but not modify it:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str` is a reference to a string allocated in read only memory
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// This function takes a reference to a book
fn borrow_book(book: &amp;Book) {
    println!(&quot;I immutably borrowed {} - {} edition&quot;, book.title, book.year);
}

// This function takes a reference to a mutable book and changes `year` to 2014
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;I mutably borrowed {} - {} edition&quot;, book.title, book.year);
}

fn main() {
    // Create an immutable Book named `immutabook`
    let immutabook = Book {
        // string literals have type `&amp;'static str`
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // Create a mutable copy of `immutabook` and call it `mutabook`
    let mut mutabook = immutabook;
    
    // Immutably borrow an immutable object
    borrow_book(&amp;immutabook);

    // Immutably borrow a mutable object
    borrow_book(&amp;mutabook);
    
    // Borrow a mutable object as mutable
    new_edition(&amp;mut mutabook);
    
    // Error! Cannot borrow an immutable object as mutable
    new_edition(&amp;mut immutabook);
    // FIXME ^ Comment out this line
}
</code></pre></pre>
<h3><a class="header" href="#see-also-45" id="see-also-45">See also:</a></h3>
<p><a href="rustexample/scope/borrow/../lifetime/static_lifetime.html"><code>static</code></a></p>
<h1><a class="header" href="#freezing" id="freezing">Freezing</a></h1>
<p>When data is immutably borrowed, it also <em>freezes</em>. <em>Frozen</em> data can't be 
modified via the original object until all references to it go out of scope:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    let mut _mutable_integer = 7i32;

    {
        // Borrow `_mutable_integer`
        let _large_integer = &amp;_mutable_integer;

        // Error! `_mutable_integer` is frozen in this scope
        _mutable_integer = 50;
        // FIXME ^ Comment out this line

        // `_large_integer` goes out of scope
    }

    // Ok! `_mutable_integer` is not frozen in this scope
    _mutable_integer = 3;
}
</code></pre></pre>
<h1><a class="header" href="#aliasing-1" id="aliasing-1">Aliasing</a></h1>
<p>Data can be immutably borrowed any number of times, but while immutably
borrowed, the original data can't be mutably borrowed. On the other hand,
only <em>one</em> mutable borrow is allowed at a time. The original data can be
borrowed again only <em>after</em> the mutable reference goes out of scope.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    {
        let borrowed_point = &amp;point;
        let another_borrow = &amp;point;

        // Data can be accessed via the references and the original owner
        println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                 borrowed_point.x, another_borrow.y, point.z);

        // Error! Can't borrow point as mutable because it's currently
        // borrowed as immutable.
        //let mutable_borrow = &amp;mut point;
        // TODO ^ Try uncommenting this line

        // Immutable references go out of scope
    }

    {
        let mutable_borrow = &amp;mut point;

        // Change data via mutable reference
        mutable_borrow.x = 5;
        mutable_borrow.y = 2;
        mutable_borrow.z = 1;

        // Error! Can't borrow `point` as immutable because it's currently
        // borrowed as mutable.
        //let y = &amp;point.y;
        // TODO ^ Try uncommenting this line

        // Error! Can't print because `println!` takes an immutable reference.
        //println!(&quot;Point Z coordinate is {}&quot;, point.z);
        // TODO ^ Try uncommenting this line

        // Ok! Mutable references can be passed as immutable to `println!`
        println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                 mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

        // Mutable reference goes out of scope
    }

    // Immutable references to point are allowed again
    let borrowed_point = &amp;point;
    println!(&quot;Point now has coordinates: ({}, {}, {})&quot;,
             borrowed_point.x, borrowed_point.y, borrowed_point.z);
}
</code></pre></pre>
<h1><a class="header" href="#the-ref-pattern" id="the-ref-pattern">The ref pattern</a></h1>
<p>When doing pattern matching or destructuring via the <code>let</code> binding, the <code>ref</code>
keyword can be used to take references to the fields of a struct/tuple. The 
example below shows a few instances where this can be useful:</p>
<pre><pre class="playpen"><code class="language-rust editable">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // A `ref` borrow on the left side of an assignment is equivalent to
    // an `&amp;` borrow on the right side.
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 equals ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref` is also valid when destructuring a struct.
    let _copy_of_x = {
        // `ref_to_x` is a reference to the `x` field of `point`.
        let Point { x: ref ref_to_x, y: _ } = point;

        // Return a copy of the `x` field of `point`.
        *ref_to_x
    };

    // A mutable copy of `point`
    let mut mutable_point = point;

    {
        // `ref` can be paired with `mut` to take mutable references.
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // Mutate the `y` field of `mutable_point` via a mutable reference.
        *mut_ref_to_y = 1;
    }

    println!(&quot;point is ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point is ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // A mutable tuple that includes a pointer
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // Destructure `mutable_tuple` to change the value of `last`.
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple is {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<h1><a class="header" href="#lifetimes" id="lifetimes">Lifetimes</a></h1>
<p>A <em>lifetime</em> is a construct the compiler (or more specifically, its <em>borrow
checker</em>) uses to ensure all borrows are valid. Specifically, a variable's
lifetime begins when it is created and ends when it is destroyed. While
lifetimes and scopes are often referred to together, they are not the same.</p>
<p>Take, for example, the case where we borrow a variable via <code>&amp;</code>. The
borrow has a lifetime that is determined by where it is declared. As a result,
the borrow is valid as long as it ends before the lender is destroyed. However,
the scope of the borrow is determined by where the reference is used.</p>
<p>In the following example and in the rest of this section, we will see how
lifetimes relate to scopes, as well as how the two differ.</p>
<pre><pre class="playpen"><code class="language-rust editable">// Lifetimes are annotated below with lines denoting the creation
// and destruction of each variable.
// `i` has the longest lifetime because its scope entirely encloses 
// both `borrow1` and `borrow2`. The duration of `borrow1` compared 
// to `borrow2` is irrelevant since they are disjoint.
fn main() {
    let i = 3; // Lifetime for `i` starts. ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow1: {}&quot;, borrow1); //              ││
    } // `borrow1 ends. ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2` lifetime starts. ──┐│
        //                                                ││
        println!(&quot;borrow2: {}&quot;, borrow2); //              ││
    } // `borrow2` ends. ─────────────────────────────────┘│
    //                                                     │
}   // Lifetime ends. ─────────────────────────────────────┘
</code></pre></pre>
<p>Note that no names or types are assigned to label lifetimes.
This restricts how lifetimes will be able to be used as we will see.</p>
<h1><a class="header" href="#explicit-annotation" id="explicit-annotation">Explicit annotation</a></h1>
<p>The borrow checker uses explicit lifetime annotations to determine
how long references should be valid. In cases where lifetimes are not
elided<sup class="footnote-reference"><a href="#1">1</a></sup>, Rust requires explicit annotations to determine what the 
lifetime of a reference should be. The syntax for explicitly annotating 
a lifetime uses an apostrophe character as follows: </p>
<pre><code class="language-rust ignore">foo&lt;'a&gt;
// `foo` has a lifetime parameter `'a`
</code></pre>
<p>Similar to <a href="rustexample/scope/lifetime/../../fn/closures/anonymity.html">closures</a>, using lifetimes requires generics. 
Additionally, this lifetime syntax indicates that the lifetime of <code>foo</code> 
may not exceed that of <code>'a</code>. Explicit annotation of a type has the form 
<code>&amp;'a T</code> where <code>'a</code> has already been introduced.</p>
<p>In cases with multiple lifetimes, the syntax is similar:</p>
<pre><code class="language-rust ignore">foo&lt;'a, 'b&gt;
// `foo` has lifetime parameters `'a` and `'b`
</code></pre>
<p>In this case, the lifetime of <code>foo</code> cannot exceed that of either <code>'a</code> <em>or</em> <code>'b</code>.</p>
<p>See the following example for explicit lifetime annotation in use:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// `print_refs` takes two references to `i32` which have different
// lifetimes `'a` and `'b`. These two lifetimes must both be at
// least as long as the function `print_refs`.
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// A function which takes no arguments, but has a lifetime parameter `'a`.
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ERROR: `_x` does not live long enough
    //let y: &amp;'a i32 = &amp;_x;
    // Attempting to use the lifetime `'a` as an explicit type annotation 
    // inside the function will fail because the lifetime of `&amp;_x` is shorter
    // than that of `y`. A short lifetime cannot be coerced into a longer one.
}

fn main() {
    // Create variables to be borrowed below.
    let (four, nine) = (4, 9);
    
    // Borrows (`&amp;`) of both variables are passed into the function.
    print_refs(&amp;four, &amp;nine);
    // Any input which is borrowed must outlive the borrower. 
    // In other words, the lifetime of `four` and `nine` must 
    // be longer than that of `print_refs`.
    
    failed_borrow();
    // `failed_borrow` contains no references to force `'a` to be 
    // longer than the lifetime of the function, but `'a` is longer.
    // Because the lifetime is never constrained, it defaults to `'static`.
}
</code></pre></pre>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p><a href="rustexample/scope/lifetime/elision.html">elision</a> implicitly annotates lifetimes and so is different.</p>
</div>
<h3><a class="header" href="#see-also-46" id="see-also-46">See also:</a></h3>
<p><a href="rustexample/scope/lifetime/../../generics.html">generics</a> and <a href="rustexample/scope/lifetime/../../fn/closures.html">closures</a></p>
<h1><a class="header" href="#functions-2" id="functions-2">Functions</a></h1>
<p>Ignoring <a href="rustexample/scope/lifetime/elision.html">elision</a>, function signatures with lifetimes have a few constraints: </p>
<ul>
<li>any reference <em>must</em> have an annotated lifetime.</li>
<li>any reference being returned <em>must</em> have the same lifetime as an input or
be <code>static</code>.</li>
</ul>
<p>Additionally, note that returning references without input is banned if it
would result in returning references to invalid data. The following example shows
off some valid forms of functions with lifetimes:</p>
<pre><pre class="playpen"><code class="language-rust editable">// One input reference with lifetime `'a` which must live
// at least as long as the function.
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// Mutable references are possible with lifetimes as well.
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// Multiple elements with different lifetimes. In this case, it
// would be fine for both to have the same lifetime `'a`, but
// in more complex cases, different lifetimes may be required.
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// Returning references that have been passed in is acceptable.
// However, the correct lifetime must be returned.
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

//fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from(&quot;foo&quot;) }
// The above is invalid: `'a` must live longer than the function.
// Here, `&amp;String::from(&quot;foo&quot;)` would create a `String`, followed by a
// reference. Then the data is dropped upon exiting the scope, leaving
// a reference to invalid data to be returned.

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-47" id="see-also-47">See also:</a></h3>
<p><a href="rustexample/scope/lifetime/fn.html">functions</a></p>
<h1><a class="header" href="#methods-1" id="methods-1">Methods</a></h1>
<p>Methods are annotated similarly to functions:</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Owner(i32);

impl Owner {
    // Annotate lifetimes as in a standalone function.
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<h3><a class="header" href="#see-also-48" id="see-also-48">See also:</a></h3>
<p><a href="rustexample/scope/lifetime/../../fn/methods.html">methods</a></p>
<h1><a class="header" href="#structs-1" id="structs-1">Structs</a></h1>
<p>Annotation of lifetimes in structures are also similar to functions:</p>
<pre><pre class="playpen"><code class="language-rust editable">// A type `Borrowed` which houses a reference to an
// `i32`. The reference to `i32` must outlive `Borrowed`.
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// Similarly, both references here must outlive this structure.
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// An enum which is either an `i32` or a reference to one.
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!(&quot;x is borrowed in {:?}&quot;, single);
    println!(&quot;x and y are borrowed in {:?}&quot;, double);
    println!(&quot;x is borrowed in {:?}&quot;, reference);
    println!(&quot;y is *not* borrowed in {:?}&quot;, number);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-49" id="see-also-49">See also:</a></h3>
<p><a href="rustexample/scope/lifetime/../../custom_types/structs.html"><code>struct</code>s</a></p>
<h1><a class="header" href="#traits-1" id="traits-1">Traits</a></h1>
<p>Annotation of lifetimes in trait methods basically are similar to functions.
Note that <code>impl</code> may have annotation of lifetimes too.</p>
<pre><pre class="playpen"><code class="language-rust editable">// A struct with annotation of lifetimes.
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }

// Annotate lifetimes to impl.
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!(&quot;b is {:?}&quot;, b);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-50" id="see-also-50">See also:</a></h3>
<p><a href="rustexample/scope/lifetime/../../trait.html"><code>trait</code>s</a></p>
<h1><a class="header" href="#bounds-1" id="bounds-1">Bounds</a></h1>
<p>Just like generic types can be bounded, lifetimes (themselves generic)
use bounds as well. The <code>:</code> character has a slightly different meaning here, 
but <code>+</code> is the same. Note how the following read:</p>
<ol>
<li><code>T: 'a</code>: <em>All</em> references in <code>T</code> must outlive lifetime <code>'a</code>.</li>
<li><code>T: Trait + 'a</code>: Type <code>T</code> must implement trait <code>Trait</code> and <em>all</em> references
in <code>T</code> must outlive <code>'a</code>.</li>
</ol>
<p>The example below shows the above syntax in action used after keyword <code>where</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::fmt::Debug; // Trait to bound with.

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref` contains a reference to a generic type `T` that has
// an unknown lifetime `'a`. `T` is bounded such that any
// *references* in `T` must outlive `'a`. Additionally, the lifetime
// of `Ref` may not exceed `'a`.

// A generic function which prints using the `Debug` trait.
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t is {:?}&quot;, t);
}

// Here a reference to `T` is taken where `T` implements
// `Debug` and all *references* in `T` outlive `'a`. In
// addition, `'a` must outlive the function.
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t is {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-51" id="see-also-51">See also:</a></h3>
<p><a href="rustexample/scope/lifetime/../../generics.html">generics</a>, <a href="rustexample/scope/lifetime/../../generics/bounds.html">bounds in generics</a>, and 
<a href="rustexample/scope/lifetime/../../generics/multi_bounds.html">multiple bounds in generics</a></p>
<h1><a class="header" href="#coercion" id="coercion">Coercion</a></h1>
<p>A longer lifetime can be coerced into a shorter one 
so that it works inside a scope it normally wouldn't work in.
This comes in the form of inferred coercion by the Rust compiler,
and also in the form of declaring a lifetime difference:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Here, Rust infers a lifetime that is as short as possible.
// The two references are then coerced to that lifetime.
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` reads as lifetime `'a` is at least as long as `'b`.
// Here, we take in an `&amp;'a i32` and return a `&amp;'b i32` as a result of coercion.
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // Longer lifetime
    
    {
        let second = 3; // Shorter lifetime
        
        println!(&quot;The product is {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} is the first&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<h1><a class="header" href="#static" id="static">Static</a></h1>
<p>A <code>'static</code> lifetime is the longest possible lifetime, and lasts for 
the lifetime of the running program. A <code>'static</code> lifetime may also be 
coerced to a shorter lifetime. There are two ways to make a variable 
with <code>'static</code> lifetime, and both are stored in the read-only memory
of the binary:</p>
<ul>
<li>Make a constant with the <code>static</code> declaration.</li>
<li>Make a <code>string</code> literal which has type: <code>&amp;'static str</code>.</li>
</ul>
<p>See the following example for a display of each method:</p>
<pre><pre class="playpen"><code class="language-rust editable">// Make a constant with `'static` lifetime.
static NUM: i32 = 18;

// Returns a reference to `NUM` where its `'static` 
// lifetime is coerced to that of the input argument.
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // Make a `string` literal and print it:
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // When `static_string` goes out of scope, the reference
        // can no longer be used, but the data remains in the binary.
    }
    
    {
        // Make an integer to use for `coerce_static`:
        let lifetime_num = 9;

        // Coerce `NUM` to lifetime of `lifetime_num`:
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }
    
    println!(&quot;NUM: {} stays accessible!&quot;, NUM);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-52" id="see-also-52">See also:</a></h3>
<p><a href="rustexample/scope/lifetime/../../custom_types/constants.html"><code>'static</code> constants</a></p>
<h1><a class="header" href="#elision" id="elision">Elision</a></h1>
<p>Some lifetime patterns are overwhelmingly common and so the borrow checker
will allow you to omit them to save typing and to improve readability.
This is known as elision. Elision exists in Rust solely because these patterns
are common.</p>
<p>The following code shows a few examples of elision. For a more comprehensive
description of elision, see <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">lifetime elision</a> in the book.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `elided_input` and `annotated_input` essentially have identical signatures
// because the lifetime of `elided_input` is inferred by the compiler:
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x);
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x);
}

// Similarly, `elided_pass` and `annotated_pass` have identical signatures
// because the lifetime is added implicitly to `elided_pass`:
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-53" id="see-also-53">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">elision</a></p>
<h1><a class="header" href="#traits-2" id="traits-2">Traits</a></h1>
<p>A <code>trait</code> is a collection of methods defined for an unknown type:
<code>Self</code>. They can access other methods declared in the same trait.</p>
<p>Traits can be implemented for any data type. In the example below,
we define <code>Animal</code>, a group of methods. The <code>Animal</code> <code>trait</code> is 
then implemented for the <code>Sheep</code> data type, allowing the use of 
methods from <code>Animal</code> with a <code>Sheep</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // Static method signature; `Self` refers to the implementor type.
    fn new(name: &amp;'static str) -&gt; Self;

    // Instance method signatures; these will return a string.
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // Traits can provide default method definitions.
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // Implementor methods can use the implementor's trait methods.
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// Implement the `Animal` trait for `Sheep`.
impl Animal for Sheep {
    // `Self` is the implementor type: `Sheep`.
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }
    
    // Default trait methods can be overridden.
    fn talk(&amp;self) {
        // For example, we can add some quiet contemplation.
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // Type annotation is necessary in this case.
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);
    // TODO ^ Try removing the type annotations.

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<h1><a class="header" href="#derive" id="derive">Derive</a></h1>
<p>The compiler is capable of providing basic implementations for some traits via
the <code>#[derive]</code> <a href="rustexample/trait/../attribute.html">attribute</a>. These traits can still be
manually implemented if a more complex behavior is required.</p>
<p>The following is a list of derivable traits:</p>
<ul>
<li>Comparison traits:
<a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>.</li>
<li><a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a>, to create <code>T</code> from <code>&amp;T</code> via a copy.</li>
<li><a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><code>Copy</code></a>, to give a type 'copy semantics' instead of 'move semantics'.</li>
<li><a href="https://doc.rust-lang.org/std/hash/trait.Hash.html"><code>Hash</code></a>, to compute a hash from <code>&amp;T</code>.</li>
<li><a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>, to create an empty instance of a data type.</li>
<li><a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a>, to format a value using the <code>{:?}</code> formatter.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">// `Centimeters`, a tuple struct that can be compared
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, a tuple struct that can be printed
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`, a tuple struct with no additional attributes
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // Error: `Seconds` can't be printed; it doesn't implement the `Debug` trait
    //println!(&quot;One second looks like: {:?}&quot;, _one_second);
    // TODO ^ Try uncommenting this line

    // Error: `Seconds` can't be compared; it doesn't implement the `PartialEq` trait
    //let _this_is_true = (_one_second == _one_second);
    // TODO ^ Try uncommenting this line

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-54" id="see-also-54">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/reference/attributes.html#derive"><code>derive</code></a></p>
<h1><a class="header" href="#operator-overloading" id="operator-overloading">Operator Overloading</a></h1>
<p>In Rust, many of the operators can be overloaded via traits. That is, some operators can
be used to accomplish different tasks based on their input arguments. This is possible
because operators are syntactic sugar for method calls. For example, the <code>+</code> operator in
<code>a + b</code> calls the <code>add</code> method (as in <code>a.add(b)</code>). This <code>add</code> method is part of the <code>Add</code>
trait. Hence, the <code>+</code> operator can be used by any implementor of the <code>Add</code> trait.</p>
<p>A list of the traits, such as <code>Add</code>, that overload operators can be found in <a href="https://doc.rust-lang.org/core/ops/"><code>core::ops</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// The `std::ops::Add` trait is used to specify the functionality of `+`.
// Here, we make `Add&lt;Bar&gt;` - the trait for addition with a RHS of type `Bar`.
// The following block implements the operation: Foo + Bar = FooBar
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Foo.add(Bar) was called&quot;);

        FooBar
    }
}

// By reversing the types, we end up implementing non-commutative addition.
// Here, we make `Add&lt;Foo&gt;` - the trait for addition with a RHS of type `Foo`.
// This block implements the operation: Bar + Foo = BarFoo
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Bar.add(Foo) was called&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-55" id="see-also-55">See Also</a></h3>
<p><a href="https://doc.rust-lang.org/core/ops/trait.Add.html">Add</a>, <a href="https://doc.rust-lang.org/book/appendix-02-operators.html">Syntax Index</a></p>
<h1><a class="header" href="#drop" id="drop">Drop</a></h1>
<p>The <a href="https://doc.rust-lang.org/std/ops/trait.Drop.html"><code>Drop</code></a> trait only has one method: <code>drop</code>, which is called automatically 
when an object goes out of scope. The main use of the <code>Drop</code> trait is to free the
resources that the implementor instance owns.</p>
<p><code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, and <code>Process</code> are some examples of types that
implement the <code>Drop</code> trait to free resources. The <code>Drop</code> trait can also be
manually implemented for any custom data type.</p>
<p>The following example adds a print to console to the <code>drop</code> function to announce
when it is called.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Droppable {
    name: &amp;'static str,
}

// This trivial implementation of `drop` adds a print to console.
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Dropping {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // block A
    {
        let _b = Droppable { name: &quot;b&quot; };

        // block B
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Just exited block B&quot;);

        println!(&quot;Exiting block A&quot;);
    }
    println!(&quot;Just exited block A&quot;);

    // Variable can be manually dropped using the `drop` function
    drop(_a);
    // TODO ^ Try commenting this line

    println!(&quot;end of the main function&quot;);

    // `_a` *won't* be `drop`ed again here, because it already has been
    // (manually) `drop`ed
}
</code></pre></pre>
<h1><a class="header" href="#iterators" id="iterators">Iterators</a></h1>
<p>The <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html"><code>Iterator</code></a> trait is used to implement iterators over collections such as arrays.</p>
<p>The trait requires only a method to be defined for the <code>next</code> element, 
which may be manually defined in an <code>impl</code> block or automatically 
defined (as in arrays and ranges).</p>
<p>As a point of convenience for common situations, the <code>for</code> construct 
turns some collections into iterators using the <a href="https://doc.rust-lang.org/std/iter/trait.IntoIterator.html"><code>.into_iter()</code></a> method.</p>
<pre><pre class="playpen"><code class="language-rust editable">struct Fibonacci {
    curr: u32,
    next: u32,
}

// Implement `Iterator` for `Fibonacci`.
// The `Iterator` trait only requires a method to be defined for the `next` element.
impl Iterator for Fibonacci {
    type Item = u32;
    
    // Here, we define the sequence using `.curr` and `.next`.
    // The return type is `Option&lt;T&gt;`:
    //     * When the `Iterator` is finished, `None` is returned.
    //     * Otherwise, the next value is wrapped in `Some` and returned.
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // Since there's no endpoint to a Fibonacci sequence, the `Iterator` 
        // will never return `None`, and `Some` is always returned.
        Some(self.curr)
    }
}

// Returns a Fibonacci sequence generator
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 1, next: 1 }
}

fn main() {
    // `0..3` is an `Iterator` that generates: 0, 1, and 2.
    let mut sequence = 0..3;

    println!(&quot;Four consecutive `next` calls on 0..3&quot;);
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for` works through an `Iterator` until it returns `None`.
    // Each `Some` value is unwrapped and bound to a variable (here, `i`).
    println!(&quot;Iterate through 0..3 using `for`&quot;);
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // The `take(n)` method reduces an `Iterator` to its first `n` terms.
    println!(&quot;The first four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // The `skip(n)` method shortens an `Iterator` by dropping its first `n` terms.
    println!(&quot;The next four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // The `iter` method produces an `Iterator` over an array/slice.
    println!(&quot;Iterate the following array {:?}&quot;, &amp;array);
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<h1><a class="header" href="#clone" id="clone">Clone</a></h1>
<p>When dealing with resources, the default behavior is to transfer them during
assignments or function calls. However, sometimes we need to make a 
copy of the resource as well.</p>
<p>The <a href="https://doc.rust-lang.org/std/clone/trait.Clone.html"><code>Clone</code></a> trait helps us do exactly this. Most commonly, we can 
use the <code>.clone()</code> method defined by the <code>Clone</code> trait.</p>
<pre><pre class="playpen"><code class="language-rust editable">// A unit struct without resources
#[derive(Debug, Clone, Copy)]
struct Nil;

// A tuple struct with resources that implements the `Clone` trait
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // Instantiate `Nil`
    let nil = Nil;
    // Copy `Nil`, there are no resources to move
    let copied_nil = nil;

    // Both `Nil`s can be used independently
    println!(&quot;original: {:?}&quot;, nil);
    println!(&quot;copy: {:?}&quot;, copied_nil);

    // Instantiate `Pair`
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;original: {:?}&quot;, pair);

    // Copy `pair` into `moved_pair`, moves resources
    let moved_pair = pair;
    println!(&quot;copy: {:?}&quot;, moved_pair);

    // Error! `pair` has lost its resources
    //println!(&quot;original: {:?}&quot;, pair);
    // TODO ^ Try uncommenting this line
    
    // Clone `moved_pair` into `cloned_pair` (resources are included)
    let cloned_pair = moved_pair.clone();
    // Drop the original pair using std::mem::drop
    drop(moved_pair);

    // Error! `moved_pair` has been dropped
    //println!(&quot;copy: {:?}&quot;, moved_pair);
    // TODO ^ Try uncommenting this line

    // The result from .clone() can still be used!
    println!(&quot;clone: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<h1><a class="header" href="#macro_rules" id="macro_rules">macro_rules!</a></h1>
<p>Rust provides a powerful macro system that allows metaprogramming. As you've
seen in previous chapters, macros look like functions, except that their name
ends with a bang <code>!</code>, but instead of generating a function call, macros are
expanded into source code that gets compiled with the rest of the program.
However, unlike macros in C and other languages, Rust macros are expanded into
abstract syntax trees, rather than string preprocessing, so you don't get
unexpected precedence bugs.</p>
<p>Macros are created using the <code>macro_rules!</code> macro.</p>
<pre><pre class="playpen"><code class="language-rust editable">// This is a simple macro named `say_hello`.
macro_rules! say_hello {
    // `()` indicates that the macro takes no argument.
    () =&gt; {
        // The macro will expand into the contents of this block.
        println!(&quot;Hello!&quot;);
    };
}

fn main() {
    // This call will expand into `println!(&quot;Hello&quot;);`
    say_hello!()
}
</code></pre></pre>
<p>So why are macros useful?</p>
<ol>
<li>
<p>Don't repeat yourself. There are many cases where you may need similar
functionality in multiple places but with different types. Often, writing a
macro is a useful way to avoid repeating code. (More on this later)</p>
</li>
<li>
<p>Domain-specific languages. Macros allow you to define special syntax for a
specific purpose. (More on this later)</p>
</li>
<li>
<p>Variadic interfaces. Sometime you want to define an interface that takes a
variable number of arguments. An example is <code>println!</code> which could take any
number of arguments, depending on the format string!. (More on this later)</p>
</li>
</ol>
<h1><a class="header" href="#syntax" id="syntax">Syntax</a></h1>
<p>In following subsections, we will show how to define macros in Rust.
There are three basic ideas:</p>
<ul>
<li><a href="rustexample/macros/designators.html">Patterns and Designators</a></li>
<li><a href="rustexample/macros/overload.html">Overloading</a></li>
<li><a href="rustexample/macros/repeat.html">Repetition</a></li>
</ul>
<h1><a class="header" href="#designators" id="designators">Designators</a></h1>
<p>The arguments of a macro are prefixed by a dollar sign <code>$</code> and type annotated
with a <em>designator</em>:</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! create_function {
    // This macro takes an argument of designator `ident` and
    // creates a function named `$func_name`.
    // The `ident` designator is used for variable/function names.
    ($func_name:ident) =&gt; {
        fn $func_name() {
            // The `stringify!` macro converts an `ident` into a string.
            println!(&quot;You called {:?}()&quot;,
                     stringify!($func_name));
        }
    };
}

// Create functions named `foo` and `bar` with the above macro.
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // This macro takes an expression of type `expr` and prints
    // it as a string along with its result.
    // The `expr` designator is used for expressions.
    ($expression:expr) =&gt; {
        // `stringify!` will convert the expression *as it is* into a string.
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression);
    };
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // Recall that blocks are expressions too!
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<p>These are some of the available designators:</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code> is used for expressions</li>
<li><code>ident</code> is used for variable/function names</li>
<li><code>item</code></li>
<li><code>literal</code> is used for literal constants</li>
<li><code>pat</code> (<em>pattern</em>)</li>
<li><code>path</code></li>
<li><code>stmt</code> (<em>statement</em>)</li>
<li><code>tt</code> (<em>token tree</em>)</li>
<li><code>ty</code> (<em>type</em>)</li>
<li><code>vis</code> (<em>visibility qualifier</em>)</li>
</ul>
<p>For a complete list, see the <a href="https://doc.rust-lang.org/reference/macros-by-example.html">Rust Reference</a>.</p>
<h1><a class="header" href="#overload" id="overload">Overload</a></h1>
<p>Macros can be overloaded to accept different combinations of arguments. 
In that regard, <code>macro_rules!</code> can work similarly to a match block:</p>
<pre><pre class="playpen"><code class="language-rust editable">// `test!` will compare `$left` and `$right`
// in different ways depending on how you invoke it:
macro_rules! test {
    // Arguments don't need to be separated by a comma.
    // Any template can be used!
    ($left:expr; and $right:expr) =&gt; {
        println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    };
    // ^ each arm must end with a semicolon.
    ($left:expr; or $right:expr) =&gt; {
        println!(&quot;{:?} or {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    };
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<h1><a class="header" href="#repeat" id="repeat">Repeat</a></h1>
<p>Macros can use <code>+</code> in the argument list to indicate that an argument may
repeat at least once, or <code>*</code>, to indicate that the argument may repeat zero or
more times.</p>
<p>In the following example, surrounding the matcher with <code>$(...),+</code> will
match one or more expression, separated by commas.
Also note that the semicolon is optional on the last case.</p>
<pre><pre class="playpen"><code class="language-rust editable">// `min!` will calculate the minimum of any number of arguments.
macro_rules! find_min {
    // Base case:
    ($x:expr) =&gt; ($x);
    // `$x` followed by at least one `$y,`
    ($x:expr, $($y:expr),+) =&gt; (
        // Call `find_min!` on the tail `$y`
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2, 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<h1><a class="header" href="#dry-dont-repeat-yourself" id="dry-dont-repeat-yourself">DRY (Don't Repeat Yourself)</a></h1>
<p>Macros allow writing DRY code by factoring out the common parts of functions
and/or test suites. Here is an example that implements and tests the <code>+=</code>, <code>*=</code>
and <code>-=</code> operators on <code>Vec&lt;T&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // The `tt` (token tree) designator is used for
    // operators and tokens.
    ($a:ident, $b:ident, $func:ident, $op:tt) =&gt; {
        assert!($a.len() == $b.len(),
                &quot;{:?}: dimension mismatch: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    };
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; {
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    };
}

// Implement `add_assign`, `mul_assign`, and `sub_assign` functions.
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func:ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        };
    }

    // Test `add_assign`, `mul_assign`, and `sub_assign`.
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
</code></pre></pre>
<pre><code class="language-bash">$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<h1><a class="header" href="#domain-specific-languages-dsls" id="domain-specific-languages-dsls">Domain Specific Languages (DSLs)</a></h1>
<p>A DSL is a mini &quot;language&quot; embedded in a Rust macro. It is completely valid
Rust because the macro system expands into normal Rust constructs, but it looks
like a small language. This allows you to define concise or intuitive syntax for
some special functionality (within bounds).</p>
<p>Suppose that I want to define a little calculator API. I would like to supply
an expression and have the output printed to console.</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! calculate {
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2 // hehehe `eval` is _not_ a Rust keyword!
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre></pre>
<p>Output:</p>
<pre><code class="language-txt">1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<p>This was a very simple example, but much more complex interfaces have been
developed, such as <a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> or
<a href="https://crates.io/crates/clap"><code>clap</code></a>.</p>
<p>Also, note the two pairs of braces in the macro. The outer ones are
part of the syntax of <code>macro_rules!</code>, in addition to <code>()</code> or <code>[]</code>.</p>
<h1><a class="header" href="#variadic-interfaces" id="variadic-interfaces">Variadic Interfaces</a></h1>
<p>A <em>variadic</em> interface takes an arbitrary number of arguments. For example,
<code>println!</code> can take an arbitrary number of arguments, as determined by the
format string.</p>
<p>We can extend our <code>calculate!</code> macro from the previous section to be variadic:</p>
<pre><pre class="playpen"><code class="language-rust editable">macro_rules! calculate {
    // The pattern for a single `eval`
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};

    // Decompose multiple `eval`s recursively
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { // Look ma! Variadic `calculate!`!
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre></pre>
<p>Output:</p>
<pre><code class="language-txt">1 + 2 = 3
3 + 4 = 7
(2 * 3) + 1 = 7
</code></pre>
<h1><a class="header" href="#error-handling" id="error-handling">Error handling</a></h1>
<p>Error handling is the process of handling the possibility of failure. For
example, failing to read a file and then continuing to use that <em>bad</em> input
would clearly be problematic. Noticing and explicitly managing those errors
saves the rest of the program from various pitfalls.</p>
<p>There are various ways to deal with errors in Rust, which are described in the
following subchapters. They all have more or less subtle differences and different
use cases. As a rule of thumb:</p>
<p>An explicit <code>panic</code> is mainly useful for tests and dealing with unrecoverable errors.
For prototyping it can be useful, for example when dealing with functions that
haven't been implemented yet, but in those cases the more descriptive <code>unimplemented</code>
is better. In tests <code>panic</code> is a reasonable way to explicitly fail.</p>
<p>The <code>Option</code> type is for when a value is optional or when the lack of a value is
not an error condition. For example the parent of a directory - <code>/</code> and <code>C:</code> don't
have one. When dealing with <code>Option</code>s, <code>unwrap</code> is fine for prototyping and cases
where it's absolutely certain that there is guaranteed to be a value. However <code>expect</code>
is more useful since it lets you specify an error message in case something goes
wrong anyway.</p>
<p>When there is a chance that things do go wrong and the caller has to deal with the
problem, use <code>Result</code>. You can <code>unwrap</code> and <code>expect</code> them as well (please don't
do that unless it's a test or quick prototype).</p>
<p>For a more rigorous discussion of error handling, refer to the error
handling section in the <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">official book</a>.</p>
<h1><a class="header" href="#panic" id="panic"><code>panic</code></a></h1>
<p>The simplest error handling mechanism we will see is <code>panic</code>. It prints an 
error message, starts unwinding the task, and usually exits the program. 
Here, we explicitly call <code>panic</code> on our error condition: </p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn give_princess(gift: &amp;str) {
    // Princesses hate snakes, so we need to stop if she disapproves!
    if gift == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, gift);
}

fn main() {
    give_princess(&quot;teddy bear&quot;);
    give_princess(&quot;snake&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#option--unwrap" id="option--unwrap"><code>Option</code> &amp; <code>unwrap</code></a></h1>
<p>In the last example, we showed that we can induce program failure at will. 
We told our program to <code>panic</code> if the princess received an inappropriate 
gift - a snake. But what if the princess expected a gift and didn't receive 
one? That case would be just as bad, so it needs to be handled!</p>
<p>We <em>could</em> test this against the null string (<code>&quot;&quot;</code>) as we do with a snake. 
Since we're using Rust, let's instead have the compiler point out cases 
where there's no gift.</p>
<p>An <code>enum</code> called <code>Option&lt;T&gt;</code> in the <code>std</code> library is used when absence is a 
possibility. It manifests itself as one of two &quot;options&quot;:</p>
<ul>
<li><code>Some(T)</code>: An element of type <code>T</code> was found</li>
<li><code>None</code>: No element was found</li>
</ul>
<p>These cases can either be explicitly handled via <code>match</code> or implicitly with 
<code>unwrap</code>. Implicit handling will either return the inner element or <code>panic</code>.</p>
<p>Note that it's possible to manually customize <code>panic</code> with <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.expect">expect</a>, 
but <code>unwrap</code> otherwise leaves us with a less meaningful output than explicit 
handling. In the following example, explicit handling yields a more 
controlled result while retaining the option to <code>panic</code> if desired.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// The commoner has seen it all, and can handle any gift well.
// All gifts are handled explicitly using `match`.
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // Specify a course of action for each case.
    match gift {
        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I'm throwing that snake in a fire.&quot;),
        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),
        None          =&gt; println!(&quot;No gift? Oh well.&quot;),
    }
}

// Our sheltered princess will `panic` at the sight of snakes.
// All gifts are handled implicitly using `unwrap`.
fn give_princess(gift: Option&lt;&amp;str&gt;) {
    // `unwrap` returns a `panic` when it receives a `None`.
    let inside = gift.unwrap();
    if inside == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, inside);
}

fn main() {
    let food  = Some(&quot;cabbage&quot;);
    let snake = Some(&quot;snake&quot;);
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some(&quot;robin&quot;);
    let nothing = None;

    give_princess(bird);
    give_princess(nothing);
}
</code></pre></pre>
<h1><a class="header" href="#combinators-map" id="combinators-map">Combinators: <code>map</code></a></h1>
<p><code>match</code> is a valid method for handling <code>Option</code>s. However, you may 
eventually find heavy usage tedious, especially with operations only valid 
with an input. In these cases, <a href="https://doc.rust-lang.org/book/glossary.html#combinators">combinators</a> can be used to 
manage control flow in a modular fashion.</p>
<p><code>Option</code> has a built in method called <code>map()</code>, a combinator for the simple 
mapping of <code>Some -&gt; Some</code> and <code>None -&gt; None</code>. Multiple <code>map()</code> calls can be 
chained together for even more flexibility.</p>
<p>In the following example, <code>process()</code> replaces all functions previous
to it while staying compact.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// Peeling food. If there isn't any, then return `None`.
// Otherwise, return the peeled food.
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// Chopping food. If there isn't any, then return `None`.
// Otherwise, return the chopped food.
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// Cooking food. Here, we showcase `map()` instead of `match` for case handling.
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// A function to peel, chop, and cook food all in sequence.
// We chain multiple uses of `map()` to simplify the code.
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

// Check whether there's food or not before trying to eat it!
fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),
        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));
    // Let's try the simpler looking `process()` now.
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-56" id="see-also-56">See also:</a></h3>
<p><a href="rustexample/error/option_unwrap/../../fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.map"><code>Option::map()</code></a></p>
<h1><a class="header" href="#combinators-and_then" id="combinators-and_then">Combinators: <code>and_then</code></a></h1>
<p><code>map()</code> was described as a chainable way to simplify <code>match</code> statements. 
However, using <code>map()</code> on a function that returns an <code>Option&lt;T&gt;</code> results 
in the nested <code>Option&lt;Option&lt;T&gt;&gt;</code>. Chaining multiple calls together can 
then become confusing. That's where another combinator called <code>and_then()</code>, 
known in some languages as flatmap, comes in.</p>
<p><code>and_then()</code> calls its function input with the wrapped value and returns the result. If the <code>Option</code> is <code>None</code>, then it returns <code>None</code> instead.</p>
<p>In the following example, <code>cookable_v2()</code> results in an <code>Option&lt;Food&gt;</code>. 
Using <code>map()</code> instead of <code>and_then()</code> would have given an 
<code>Option&lt;Option&lt;Food&gt;&gt;</code>, which is an invalid type for <code>eat()</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// We don't have the ingredients to make Sushi.
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// We have the recipe for everything except Cordon Bleu.
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

// To make a dish, we need both the recipe and the ingredients.
// We can represent the logic with a chain of `match`es:
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_recipe(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_ingredients(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// This can conveniently be rewritten more compactly with `and_then()`:
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_recipe(food).and_then(have_ingredients)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! On {:?} we get to eat {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;Oh no. We don't get to eat on {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<h3><a class="header" href="#see-also-57" id="see-also-57">See also:</a></h3>
<p><a href="rustexample/error/option_unwrap/../../fn/closures.html">closures</a>, <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a>, and <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.and_then"><code>Option::and_then()</code></a></p>
<h1><a class="header" href="#result" id="result"><code>Result</code></a></h1>
<p><a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> is a richer version of the <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> type that
describes possible <em>error</em> instead of possible <em>absence</em>.</p>
<p>That is, <code>Result&lt;T, E&gt;</code> could have one of two outcomes:</p>
<ul>
<li><code>Ok&lt;T&gt;</code>: An element <code>T</code> was found</li>
<li><code>Err&lt;E&gt;</code>: An error was found with element <code>E</code></li>
</ul>
<p>By convention, the expected outcome is <code>Ok</code> while the unexpected outcome is <code>Err</code>.</p>
<p>Like <code>Option</code>, <code>Result</code> has many methods associated with it. <code>unwrap()</code>, for
example, either yields the element <code>T</code> or <code>panic</code>s. For case handling,
there are many combinators between <code>Result</code> and <code>Option</code> that overlap.</p>
<p>In working with Rust, you will likely encounter methods that return the
<code>Result</code> type, such as the <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a> method. It might not always
be possible to parse a string into the other type, so <code>parse()</code> returns a
<code>Result</code> indicating possible failure.</p>
<p>Let's see what happens when we successfully and unsuccessfully <code>parse()</code> a string:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    // Let's try using `unwrap()` to get the number out. Will it bite us?
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, tt);
}
</code></pre></pre>
<p>In the unsuccessful case, <code>parse()</code> leaves us with an error for <code>unwrap()</code>
to <code>panic</code> on. Additionally, the <code>panic</code> exits our program and provides an
unpleasant error message.</p>
<p>To improve the quality of our error message, we should be more specific
about the return type and consider explicitly handling the error.</p>
<h2><a class="header" href="#using-result-in-main" id="using-result-in-main">Using <code>Result</code> in <code>main</code></a></h2>
<p>The <code>Result</code> type can also be the return type of the <code>main</code> function if
specified explicitly. Typically the <code>main</code> function will be of the form:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>However <code>main</code> is also able to have a return type of <code>Result</code>. If an error
occurs within the <code>main</code> function it will return an error code and print a debug
representation of the error (using the <a href="https://doc.rust-lang.org/std/fmt/trait.Debug.html"><code>Debug</code></a> trait). The following example
shows such a scenario and touches on aspects covered in <a href="rustexample/error/result/early_returns.html">the following section</a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    let number_str = &quot;10&quot;;
    let number = match number_str.parse::&lt;i32&gt;() {
        Ok(number)  =&gt; number,
        Err(e) =&gt; return Err(e),
    };
    println!(&quot;{}&quot;, number);
    Ok(())
}
</code></pre></pre>
<h1><a class="header" href="#map-for-result" id="map-for-result"><code>map</code> for <code>Result</code></a></h1>
<p>Panicking in the previous example's <code>multiply</code> does not make for robust code.
Generally, we want to return the error to the caller so it can decide what is
the right way to respond to errors.</p>
<p>We first need to know what kind of error type we are dealing with. To determine
the <code>Err</code> type, we look to <a href="https://doc.rust-lang.org/std/primitive.str.html#method.parse"><code>parse()</code></a>, which is implemented with the
<a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>FromStr</code></a> trait for <a href="https://doc.rust-lang.org/std/primitive.i32.html"><code>i32</code></a>. As a result, the <code>Err</code> type is
specified as <a href="https://doc.rust-lang.org/std/num/struct.ParseIntError.html"><code>ParseIntError</code></a>.</p>
<p>In the example below, the straightforward <code>match</code> statement leads to code
that is overall more cumbersome.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// With the return type rewritten, we use pattern matching without `unwrap()`.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<p>Luckily, <code>Option</code>'s <code>map</code>, <code>and_then</code>, and many other combinators are also
implemented for <code>Result</code>. <a href="https://doc.rust-lang.org/std/result/enum.Result.html"><code>Result</code></a> contains a complete listing.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// As with `Option`, we can use combinators such as `map()`.
// This function is otherwise identical to the one above and reads:
// Modify n if the value is valid, otherwise pass on the error.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // This still presents a reasonable answer.
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // The following now provides a much more helpful error message.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<h1><a class="header" href="#aliases-for-result" id="aliases-for-result">aliases for <code>Result</code></a></h1>
<p>How about when we want to reuse a specific <code>Result</code> type many times?
Recall that Rust allows us to create <a href="rustexample/error/result/../../types/alias.html">aliases</a>. Conveniently,
we can define one for the specific <code>Result</code> in question.</p>
<p>At a module level, creating aliases can be particularly helpful. Errors
found in a specific module often have the same <code>Err</code> type, so a single alias
can succinctly define <em>all</em> associated <code>Results</code>. This is so useful that the
<code>std</code> library even supplies one: <a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a>!</p>
<p>Here's a quick example to show off the syntax:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

// Define a generic alias for a `Result` with the error type `ParseIntError`.
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// Use the above alias to refer to our specific `Result` type.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// Here, the alias again allows us to save some space.
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-58" id="see-also-58">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/io/type.Result.html"><code>io::Result</code></a></p>
<h1><a class="header" href="#early-returns" id="early-returns">Early returns</a></h1>
<p>In the previous example, we explicitly handled the errors using combinators.
Another way to deal with this case analysis is to use a combination of
<code>match</code> statements and <em>early returns</em>.</p>
<p>That is, we can simply stop executing the function and return the error if
one occurs. For some, this form of code can be easier to both read and
write. Consider this version of the previous example, rewritten using early returns:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<p>At this point, we've learned to explicitly handle errors using combinators
and early returns. While we generally want to avoid panicking, explicitly
handling all of our errors is cumbersome.</p>
<p>In the next section, we'll introduce <code>?</code> for the cases where we simply
need to <code>unwrap</code> without possibly inducing <code>panic</code>.</p>
<h1><a class="header" href="#introducing-" id="introducing-">Introducing <code>?</code></a></h1>
<p>Sometimes we just want the simplicity of <code>unwrap</code> without the possibility of
a <code>panic</code>. Until now, <code>unwrap</code> has forced us to nest deeper and deeper when
what we really wanted was to get the variable <em>out</em>. This is exactly the purpose of <code>?</code>.</p>
<p>Upon finding an <code>Err</code>, there are two valid actions to take:</p>
<ol>
<li><code>panic!</code> which we already decided to try to avoid if possible</li>
<li><code>return</code> because an <code>Err</code> means it cannot be handled</li>
</ol>
<p><code>?</code> is <em>almost</em><sup class="footnote-reference"><a href="#†">1</a></sup> exactly equivalent to an <code>unwrap</code> which <code>return</code>s
instead of <code>panic</code>s on <code>Err</code>s. Let's see how we can simplify the earlier
example that used combinators:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h2><a class="header" href="#the-try-macro" id="the-try-macro">The <code>try!</code> macro</a></h2>
<p>Before there was <code>?</code>, the same functionality was achieved with the <code>try!</code> macro.
The <code>?</code> operator is now recommended, but you may still find <code>try!</code> when looking
at older code. The same <code>multiply</code> function from the previous example
would look like this using <code>try!</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable">// To compile and run this example without errors, while using Cargo, change the value 
// of the `edition` field, in the `[package]` section of the `Cargo.toml` file, to &quot;2015&quot;.

use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>See <a href="rustexample/error/result/../multiple_error_types/reenter_question_mark.html">re-enter ?</a> for more details.</p>
</div>
<h1><a class="header" href="#multiple-error-types" id="multiple-error-types">Multiple error types</a></h1>
<p>The previous examples have always been very convenient; <code>Result</code>s interact
with other <code>Result</code>s and <code>Option</code>s interact with other <code>Option</code>s.</p>
<p>Sometimes an <code>Option</code> needs to interact with a <code>Result</code>, or a
<code>Result&lt;T, Error1&gt;</code> needs to interact with a <code>Result&lt;T, Error2&gt;</code>. In those
cases, we want to manage our different error types in a way that makes them
composable and easy to interact with.</p>
<p>In the following code, two instances of <code>unwrap</code> generate different error
types. <code>Vec::first</code> returns an <code>Option</code>, while <code>parse::&lt;i32&gt;</code> returns a
<code>Result&lt;i32, ParseIntError&gt;</code>:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // Generate error 1
    2 * first.parse::&lt;i32&gt;().unwrap() // Generate error 2
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre></pre>
<p>Over the next sections, we'll see several strategies for handling these kind of problems.</p>
<h1><a class="header" href="#pulling-results-out-of-options" id="pulling-results-out-of-options">Pulling <code>Result</code>s out of <code>Option</code>s</a></h1>
<p>The most basic way of handling mixed error types is to just embed them in each
other.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    // Error 1: the input vector is empty

    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
    // Error 2: the element doesn't parse to a number
}
</code></pre></pre>
<p>There are times when we'll want to stop processing on errors (like with
<a href="rustexample/error/multiple_error_types/../result/enter_question_mark.html"><code>?</code></a>) but keep going when the <code>Option</code> is <code>None</code>. A
couple of combinators come in handy to swap the <code>Result</code> and <code>Option</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    let opt = opt.map_or(Ok(None), |r| r.map(Some))?;

    Ok(opt)
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));
    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#defining-an-error-type" id="defining-an-error-type">Defining an error type</a></h1>
<p>Sometimes it simplifies the code to mask all of the different errors with a
single type of error.  We'll show this with a custom error.</p>
<p>Rust allows us to define our own error types. In general, a &quot;good&quot; error type:</p>
<ul>
<li>Represents different errors with the same type</li>
<li>Presents nice error messages to the user</li>
<li>Is easy to compare with other types
<ul>
<li>Good: <code>Err(EmptyVec)</code></li>
<li>Bad: <code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>Can hold information about the error
<ul>
<li>Good: <code>Err(BadChar(c, position))</code></li>
<li>Bad: <code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
<li>Composes well with other errors</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

// Define our error types. These may be customized for our error handling cases.
// Now we will be able to write our own errors, defer to an underlying error
// implementation, or do something in between.
#[derive(Debug, Clone)]
struct DoubleError;

// Generation of an error is completely separate from how it is displayed.
// There's no need to be concerned about cluttering complex logic with the display style.
//
// Note that we don't store any extra info about the errors. This means we can't state
// which string failed to parse without modifying our types to carry that information.
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

// This is important for other errors to wrap this one.
impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        // Generic error, underlying cause isn't tracked.
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        // Change the error to our new type.
        .ok_or(DoubleError)
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // Update to the new error type here also.
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h1><a class="header" href="#boxing-errors" id="boxing-errors"><code>Box</code>ing errors</a></h1>
<p>A way to write simple code while preserving the original errors is to <a href="https://doc.rust-lang.org/std/boxed/struct.Box.html"><code>Box</code></a>
them.  The drawback is that the underlying error type is only known at runtime and not
<a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">statically determined</a>.</p>
<p>The stdlib helps in boxing our errors by having <code>Box</code> implement conversion from
any type that implements the <code>Error</code> trait into the trait object <code>Box&lt;Error&gt;</code>,
via <a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;

// Change the alias to `Box&lt;error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;invalid first item to double&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        // Generic error, underlying cause isn't tracked.
        None
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        .ok_or_else(|| EmptyVec.into()) // Converts to Box
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into()) // Converts to Box
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<h3><a class="header" href="#see-also-59" id="see-also-59">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html#trait-objects-perform-dynamic-dispatch">Dynamic dispatch</a> and <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code> trait</a></p>
<h1><a class="header" href="#other-uses-of-" id="other-uses-of-">Other uses of <code>?</code></a></h1>
<p>Notice in the previous example that our immediate reaction to calling
<code>parse</code> is to <code>map</code> the error from a library error into a boxed
error:</p>
<pre><code class="language-rust ignore">.and_then(|s| s.parse::&lt;i32&gt;()
    .map_err(|e| e.into())
</code></pre>
<p>Since this is a simple and common operation, it would be convenient if it
could be elided. Alas, because <code>and_then</code> is not sufficiently flexible, it
cannot. However, we can instead use <code>?</code>.</p>
<p><code>?</code> was previously explained as either <code>unwrap</code> or <code>return Err(err)</code>.
This is only mostly true. It actually means <code>unwrap</code> or
<code>return Err(From::from(err))</code>. Since <code>From::from</code> is a conversion utility
between different types, this means that if you <code>?</code> where the error is
convertible to the return type, it will convert automatically.</p>
<p>Here, we rewrite the previous example using <code>?</code>. As a result, the
<code>map_err</code> will go away when <code>From::from</code> is implemented for our error type:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::fmt;

// Change the alias to `Box&lt;error::Error&gt;`.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {
    fn description(&amp;self) -&gt; &amp;str {
        &quot;invalid first item to double&quot;
    }

    fn cause(&amp;self) -&gt; Option&lt;&amp;error::Error&gt; {
        // Generic error, underlying cause isn't tracked.
        None
    }
}

// The same structure as before but rather than chain all `Results`
// and `Options` along, we `?` to get the inner value out immediately.
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>This is actually fairly clean now. Compared with the original <code>panic</code>, it
is very similar to replacing the <code>unwrap</code> calls with <code>?</code> except that the
return types are <code>Result</code>. As a result, they must be destructured at the
top level.</p>
<h3><a class="header" href="#see-also-60" id="see-also-60">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> and <a href="https://doc.rust-lang.org/reference/expressions/operator-expr.html#the-question-mark-operator"><code>?</code></a></p>
<h1><a class="header" href="#wrapping-errors" id="wrapping-errors">Wrapping errors</a></h1>
<p>An alternative to boxing errors is to wrap them in your own error type.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::error;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // We will defer to the parse error implementation for their error.
    // Supplying extra info requires adding more data to the type.
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // This is a wrapper, so defer to the underlying types' implementation of `fmt`.
            DoubleError::Parse(ref e) =&gt; e.fmt(f),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // The cause is the underlying implementation error type. Is implicitly
            // cast to the trait object `&amp;error::Error`. This works because the
            // underlying type already implements the `Error` trait.
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// Implement the conversion from `ParseIntError` to `DoubleError`.
// This will be automatically called by `?` if a `ParseIntError`
// needs to be converted into a `DoubleError`.
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>This adds a bit more boilerplate for handling errors and might not be needed in
all applications. There are some libraries that can take care of the boilerplate
for you.</p>
<h3><a class="header" href="#see-also-61" id="see-also-61">See also:</a></h3>
<p><a href="https://doc.rust-lang.org/std/convert/trait.From.html"><code>From::from</code></a> and <a href="rustexample/error/multiple_error_types/../../custom_types/enum.html"><code>Enums</code></a></p>
<h1><a class="header" href="#iterating-over-results" id="iterating-over-results">Iterating over <code>Result</code>s</a></h1>
<p>An <code>Iter::map</code> operation might fail, for example:</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let possible_numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, possible_numbers);
}
</code></pre></pre>
<p>Let's step through strategies for handling this.</p>
<h2><a class="header" href="#ignore-the-failed-items-with-filter_map" id="ignore-the-failed-items-with-filter_map">Ignore the failed items with <code>filter_map()</code></a></h2>
<p><code>filter_map</code> calls a function and filters out the results that are <code>None</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .filter_map(Result::ok)
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<h2><a class="header" href="#fail-the-entire-operation-with-collect" id="fail-the-entire-operation-with-collect">Fail the entire operation with <code>collect()</code></a></h2>
<p><code>Result</code> implements <code>FromIter</code> so that a vector of results (<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>)
can be turned into a result with a vector (<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>). Once an
<code>Result::Err</code> is found, the iteration will terminate.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>This same technique can be used with <code>Option</code>.</p>
<h2><a class="header" href="#collect-all-valid-values-and-failures-with-partition" id="collect-all-valid-values-and-failures-with-partition">Collect all valid values and failures with <code>partition()</code></a></h2>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<p>When you look at the results, you'll note that everything is still wrapped in
<code>Result</code>.  A little more boilerplate is needed for this.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<h1><a class="header" href="#std-library-types" id="std-library-types">Std library types</a></h1>
<p>The <code>std</code> library provides many custom types which expands drastically on
the <code>primitives</code>. Some of these include:</p>
<ul>
<li>growable <code>String</code>s like: <code>&quot;hello world&quot;</code></li>
<li>growable vectors: <code>[1, 2, 3]</code></li>
<li>optional types: <code>Option&lt;i32&gt;</code></li>
<li>error handling types: <code>Result&lt;i32, i32&gt;</code></li>
<li>heap allocated pointers: <code>Box&lt;i32&gt;</code></li>
</ul>
<h3><a class="header" href="#see-also-62" id="see-also-62">See also:</a></h3>
<p><a href="rustexample/primitives.html">primitives</a> and <a href="https://doc.rust-lang.org/std/">the std library</a></p>
<h1><a class="header" href="#box-stack-and-heap" id="box-stack-and-heap">Box, stack and heap</a></h1>
<p>All values in Rust are stack allocated by default. Values can be <em>boxed</em>
(allocated on the heap) by creating a <code>Box&lt;T&gt;</code>. A box is a smart pointer to a
heap allocated value of type <code>T</code>. When a box goes out of scope, its destructor
is called, the inner object is destroyed, and the memory on the heap is freed.</p>
<p>Boxed values can be dereferenced using the <code>*</code> operator; this removes one layer
of indirection. </p>
<pre><pre class="playpen"><code class="language-rust editable">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

#[allow(dead_code)]
struct Rectangle {
    p1: Point,
    p2: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // Allocate this point on the heap, and return a pointer to it
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // (all the type annotations are superfluous)
    // Stack allocated variables
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        p1: origin(),
        p2: Point { x: 3.0, y: 4.0 }
    };

    // Heap allocated rectangle
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        p1: origin(),
        p2: origin()
    });

    // The output of functions can be boxed
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // Double indirection
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;rectangle));

    // box size == pointer size
    println!(&quot;Boxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Boxed rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Boxed box occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // Copy the data contained in `boxed_point` into `unboxed_point`
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Unboxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<h1><a class="header" href="#vectors" id="vectors">Vectors</a></h1>
<p>Vectors are re-sizable arrays. Like slices, their size is not known at compile
time, but they can grow or shrink at any time. A vector is represented using
3 words: a pointer to the data, its length, and its capacity. The capacity
indicates how much memory is reserved for the vector. The vector can grow as
long as the length is smaller than the capacity. When this threshold needs to
be surpassed, the vector is reallocated with a larger capacity.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">fn main() {
    // Iterators can be collected into vectors
    let mut collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

    // The `vec!` macro can be used to initialize a vector
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Initial vector: {:?}&quot;, xs);

    // Insert new element at the end of the vector
    println!(&quot;Push 4 into the vector&quot;);
    xs.push(4);
    println!(&quot;Vector: {:?}&quot;, xs);

    // Error! Immutable vectors can't grow
    collected_iterator.push(0);
    // FIXME ^ Comment out this line

    // The `len` method yields the current size of the vector
    println!(&quot;Vector size: {}&quot;, xs.len());

    // Indexing is done using the square brackets (indexing starts at 0)
    println!(&quot;Second element: {}&quot;, xs[1]);

    // `pop` removes the last element from the vector and returns it
    println!(&quot;Pop last element: {:?}&quot;, xs.pop());

    // Out of bounds indexing yields a panic
    println!(&quot;Fourth element: {}&quot;, xs[3]);
    // FIXME ^ Comment out this line

    // `Vector`s can be easily iterated over
    println!(&quot;Contents of xs:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // A `Vector` can also be iterated over while the iteration
    // count is enumerated in a separate variable (`i`)
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // Thanks to `iter_mut`, mutable `Vector`s can also be iterated
    // over in a way that allows modifying each value
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
</code></pre></pre>
<p>More <code>Vec</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/vec/">std::vec</a> module</p>
<h1><a class="header" href="#strings" id="strings">Strings</a></h1>
<p>There are two types of strings in Rust: <code>String</code> and <code>&amp;str</code>.</p>
<p>A <code>String</code> is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>), but guaranteed to
always be a valid UTF-8 sequence. <code>String</code> is heap allocated, growable and not
null terminated.</p>
<p><code>&amp;str</code> is a slice (<code>&amp;[u8]</code>) that always points to a valid UTF-8 sequence, and
can be used to view into a <code>String</code>, just like <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // (all the type annotations are superfluous)
    // A reference to a string allocated in read only memory
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // Iterate over words in reverse, no new string is allocated
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // Copy chars into a vector, sort and remove duplicates
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // Create an empty and growable `String`
    let mut string = String::new();
    for c in chars {
        // Insert a char at the end of string
        string.push(c);
        // Insert a string at the end of string
        string.push_str(&quot;, &quot;);
    }

    // The trimmed string is a slice to the original string, hence no new
    // allocation is performed
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // Heap allocate a string
    let alice = String::from(&quot;I like dogs&quot;);
    // Allocate new memory and store the modified string there
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p>More <code>str</code>/<code>String</code> methods can be found under the
<a href="https://doc.rust-lang.org/std/str/">std::str</a> and
<a href="https://doc.rust-lang.org/std/string/">std::string</a>
modules</p>
<h2><a class="header" href="#literals-and-escapes" id="literals-and-escapes">Literals and escapes</a></h2>
<p>There are multiple ways to write string literals with special characters in them.
All result in a similar <code>&amp;str</code> so it's best to use the form that is the most
convenient to write. Similarly there are multiple ways to write byte string literals,
which all result in <code>&amp;[u8; N]</code>.</p>
<p>Generally special characters are escaped with a backslash character: <code>\</code>.
This way you can add any character to your string, even unprintable ones
and ones that you don't know how to type. If you want a literal backslash,
escape it with another one: <code>\\</code></p>
<p>String or character literal delimiters occuring within a literal must be escaped: <code>&quot;\&quot;&quot;</code>, <code>'\''</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    // You can use escapes to write bytes by their hexadecimal values...
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>Sometimes there are just too many characters that need to be escaped or it's just
much more convenient to write a string out as-is. This is where raw string literals come into play.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // There is no limit for the number of #s you can use.
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>Want a string that's not UTF-8? (Remember, <code>str</code> and <code>String</code> must be valid UTF-8)
Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::str;

fn main() {
    // Note that this is not actually a &amp;str
    let bytestring: &amp;[u8; 20] = b&quot;this is a bytestring&quot;;

    // Byte arrays don't have Display so printing them is a bit limited
    println!(&quot;A bytestring: {:?}&quot;, bytestring);

    // Bytestrings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...but no unicode escapes
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw bytestrings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to str can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Bytestrings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82&quot;; // &quot;ようこそ&quot; in SHIFT-JIS

    // But then they can't always be converted to str
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>For conversions between character encodings check out the <a href="https://crates.io/crates/encoding">encoding</a> crate.</p>
<p>A more detailed listing of the ways to write string literals and escape characters
is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' chapter</a> of the Rust Reference.</p>
<h1><a class="header" href="#option" id="option"><code>Option</code></a></h1>
<p>Sometimes it's desirable to catch the failure of some parts of a program
instead of calling <code>panic!</code>; this can be accomplished using the <code>Option</code> enum.</p>
<p>The <code>Option&lt;T&gt;</code> enum has two variants:</p>
<ul>
<li><code>None</code>, to indicate failure or lack of value, and</li>
<li><code>Some(value)</code>, a tuple struct that wraps a <code>value</code> with type <code>T</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// An integer division that doesn't `panic!`
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // Failure is represented as the `None` variant
        None
    } else {
        // Result is wrapped in a `Some` variant
        Some(dividend / divisor)
    }
}

// This function handles a division that may not succeed
fn try_division(dividend: i32, divisor: i32) {
    // `Option` values can be pattern matched, just like other enums
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} failed!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // Binding `None` to a variable needs to be type annotated
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // Unwrapping a `Some` variant will extract the value wrapped.
    println!(&quot;{:?} unwraps to {:?}&quot;, optional_float, optional_float.unwrap());

    // Unwrapping a `None` variant will `panic!`
    println!(&quot;{:?} unwraps to {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<h1><a class="header" href="#result-1" id="result-1"><code>Result</code></a></h1>
<p>We've seen that the <code>Option</code> enum can be used as a return value from functions
that may fail, where <code>None</code> can be returned to indicate failure. However,
sometimes it is important to express <em>why</em> an operation failed. To do this we 
have the <code>Result</code> enum.</p>
<p>The <code>Result&lt;T, E&gt;</code> enum has two variants:</p>
<ul>
<li><code>Ok(value)</code> which indicates that the operation succeeded, and wraps the
<code>value</code> returned by the operation. (<code>value</code> has type <code>T</code>)</li>
<li><code>Err(why)</code>, which indicates that the operation failed, and wraps <code>why</code>,
which (hopefully) explains the cause of the failure. (<code>why</code> has type <code>E</code>)</li>
</ul>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    // Mathematical &quot;errors&quot; we want to catch
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // This operation would `fail`, instead let's return the reason of
            // the failure wrapped in `Err`
            Err(MathError::DivisionByZero)
        } else {
            // This operation is valid, return the result wrapped in `Ok`
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // This is a three level match pyramid!
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    // Will this fail?
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<h1><a class="header" href="#" id=""><code>?</code></a></h1>
<p>Chaining results using match can get pretty untidy; luckily, the <code>?</code> operator
can be used to make things pretty again. <code>?</code> is used at the end of an expression
returning a <code>Result</code>, and is equivalent to a match expression, where the 
<code>Err(err)</code> branch expands to an early <code>Err(From::from(err))</code>, and the <code>Ok(ok)</code>
branch expands to an <code>ok</code> expression.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // Intermediate function
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // if `div` &quot;fails&quot;, then `DivisionByZero` will be `return`ed
        let ratio = div(x, y)?;

        // if `ln` &quot;fails&quot;, then `NonPositiveLogarithm` will be `return`ed
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(match why {
                MathError::NonPositiveLogarithm
                    =&gt; &quot;logarithm of non-positive number&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;division by zero&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;square root of negative number&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p>Be sure to check the <a href="https://doc.rust-lang.org/std/result/index.html">documentation</a>,
as there are many methods to map/compose <code>Result</code>.</p>
<h1><a class="header" href="#panic-1" id="panic-1"><code>panic!</code></a></h1>
<p>The <code>panic!</code> macro can be used to generate a panic and start unwinding
its stack. While unwinding, the runtime will take care of freeing all the
resources <em>owned</em> by the thread by calling the destructor of all its objects.</p>
<p>Since we are dealing with programs with only one thread, <code>panic!</code> will cause the
program to report the panic message and exit.</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">// Re-implementation of integer division (/)
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // Division by zero triggers a panic
        panic!(&quot;division by zero&quot;);
    } else {
        dividend / divisor
    }
}

// The `main` task
fn main() {
    // Heap allocated integer
    let _x = Box::new(0i32);

    // This operation will trigger a task failure
    division(3, 0);

    println!(&quot;This point won't be reached!&quot;);

    // `_x` should get destroyed at this point
}
</code></pre></pre>
<p>Let's check that <code>panic!</code> doesn't leak memory.</p>
<pre><code class="language-bash">$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<h1><a class="header" href="#hashmap" id="hashmap">HashMap</a></h1>
<p>Where vectors store values by an integer index, <code>HashMap</code>s store values by key. 
<code>HashMap</code> keys can be booleans, integers, strings, 
or any other type that implements the <code>Eq</code> and <code>Hash</code> traits. 
More on this in the next section.</p>
<p>Like vectors, <code>HashMap</code>s are growable, but HashMaps can also shrink themselves 
when they have excess space. 
You can create a HashMap with a certain starting capacity using 
<code>HashMap::with_capacity(uint)</code>, or use <code>HashMap::new()</code> to get a HashMap 
with a default initial capacity (recommended).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?&quot;,
        _ =&gt; &quot;Hi! Who is this again?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Daniel&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Ashley&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Katie&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Robert&quot;, &quot;956-1745&quot;);

    // Takes a reference and returns Option&lt;&amp;V&gt;
    match contacts.get(&amp;&quot;Daniel&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Daniel: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Daniel's number.&quot;),
    }

    // `HashMap::insert()` returns `None`
    // if the inserted value is new, `Some(value)` otherwise
    contacts.insert(&quot;Daniel&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Ashley&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Ashley: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Ashley's number.&quot;),
    }

    contacts.remove(&amp;&quot;Ashley&quot;); 

    // `HashMap::iter()` returns an iterator that yields 
    // (&amp;'a key, &amp;'a value) pairs in arbitrary order.
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Calling {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<p>For more information on how hashing and hash maps 
(sometimes called hash tables) work, have a look at 
<a href="https://en.wikipedia.org/wiki/Hash_table">Hash Table Wikipedia</a></p>
<h1><a class="header" href="#alternatecustom-key-types" id="alternatecustom-key-types">Alternate/custom key types</a></h1>
<p>Any type that implements the <code>Eq</code> and <code>Hash</code> traits can be a key in <code>HashMap</code>. 
This includes:</p>
<ul>
<li><code>bool</code> (though not very useful since there is only two possible keys)</li>
<li><code>int</code>, <code>uint</code>, and all variations thereof</li>
<li><code>String</code> and <code>&amp;str</code> (protip: you can have a <code>HashMap</code> keyed by <code>String</code>
and call <code>.get()</code> with an <code>&amp;str</code>)</li>
</ul>
<p>Note that <code>f32</code> and <code>f64</code> do <em>not</em> implement <code>Hash</code>,
likely because <a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">floating-point precision errors</a>
would make using them as hashmap keys horribly error-prone.</p>
<p>All collection classes implement <code>Eq</code> and <code>Hash</code> 
if their contained type also respectively implements <code>Eq</code> and <code>Hash</code>. 
For example, <code>Vec&lt;T&gt;</code> will implement <code>Hash</code> if <code>T</code> implements <code>Hash</code>.</p>
<p>You can easily implement <code>Eq</code> and <code>Hash</code> for a custom type with just one line: 
<code>#[derive(PartialEq, Eq, Hash)]</code></p>
<p>The compiler will do the rest. If you want more control over the details, 
you can implement <code>Eq</code> and/or <code>Hash</code> yourself. 
This guide will not cover the specifics of implementing <code>Hash</code>. </p>
<p>To play around with using a <code>struct</code> in <code>HashMap</code>, 
let's try making a very simple user logon system:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::collections::HashMap;

// Eq requires that you derive PartialEq on the type.
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Username: {}&quot;, username);
    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Attempting logon...&quot;);

    let logon = Account {
        username: username,
        password: password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Successful logon!&quot;);
            println!(&quot;Name: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Login failed!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<h1><a class="header" href="#hashset" id="hashset">HashSet</a></h1>
<p>Consider a <code>HashSet</code> as a <code>HashMap</code> where we just care about the keys (
<code>HashSet&lt;T&gt;</code> is, in actuality, just a wrapper around <code>HashMap&lt;T, ()&gt;</code>).</p>
<p>&quot;What's the point of that?&quot; you ask. &quot;I could just store the keys in a <code>Vec</code>.&quot;</p>
<p>A <code>HashSet</code>'s unique feature is that 
it is guaranteed to not have duplicate elements. 
That's the contract that any set collection fulfills. 
<code>HashSet</code> is just one implementation. (see also: <a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html"><code>BTreeSet</code></a>)</p>
<p>If you insert a value that is already present in the <code>HashSet</code>, 
(i.e. the new value is equal to the existing and they both have the same hash), 
then the new value will replace the old.</p>
<p>This is great for when you never want more than one of something, 
or when you want to know if you've already got something.</p>
<p>But sets can do more than that. </p>
<p>Sets have 4 primary operations (all of the following calls return an iterator):</p>
<ul>
<li>
<p><code>union</code>: get all the unique elements in both sets.</p>
</li>
<li>
<p><code>difference</code>: get all the elements that are in the first set but not the second.</p>
</li>
<li>
<p><code>intersection</code>: get all the elements that are only in <em>both</em> sets.</p>
</li>
<li>
<p><code>symmetric_difference</code>: 
get all the elements that are in one set or the other, but <em>not</em> both.</p>
</li>
</ul>
<p>Try all of these in the following example:</p>
<pre><pre class="playpen"><code class="language-rust editable ignore mdbook-runnable">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec!(1i32, 2, 3).into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec!(2i32, 3, 4).into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // `HashSet::insert()` returns false if
    // there was a value already present.
    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);
    // FIXME ^ Comment out this line

    b.insert(5);

    // If a collection's element type implements `Debug`,
    // then the collection implements `Debug`.
    // It usually prints its elements in the format `[elem1, elem2, ...]`
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // Print [1, 2, 3, 4, 5] in arbitrary order
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // This should print [1]
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [2, 3, 4] in arbitrary order.
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // Print [1, 5]
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<p>(Examples are adapted from the <a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#method.difference">documentation.</a>)</p>
<h1><a class="header" href="#std-misc" id="std-misc">Std misc</a></h1>
<p>Many other types are provided by the std library to support
things such as:</p>
<ul>
<li>Threads</li>
<li>Channels</li>
<li>File I/O</li>
</ul>
<p>These expand beyond what the <a href="rustexample/primitives.html">primitives</a> provide.</p>
<h3><a class="header" href="#see-also-63" id="see-also-63">See also:</a></h3>
<p><a href="rustexample/primitives.html">primitives</a> and <a href="https://doc.rust-lang.org/std/">the std library</a></p>
<h1><a class="header" href="#threads" id="threads">Threads</a></h1>
<p>Rust provides a mechanism for spawning native OS threads via the <code>spawn</code>
function, the argument of this function is a moving closure.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

static NTHREADS: i32 = 10;

// This is the `main` thread
fn main() {
    // Make a vector to hold the children which are spawned.
    let mut children = vec![];

    for i in 0..NTHREADS {
        // Spin up another thread
        children.push(thread::spawn(move || {
            println!(&quot;this is thread number {}&quot;, i);
        }));
    }

    for child in children {
        // Wait for the thread to finish. Returns a result.
        let _ = child.join();
    }
}
</code></pre></pre>
<p>These threads will be scheduled by the OS.</p>
<h1><a class="header" href="#testcase-map-reduce" id="testcase-map-reduce">Testcase: map-reduce</a></h1>
<p>Rust makes it very easy to parallelise data processing, without many of the headaches traditionally associated with such an attempt.</p>
<p>The standard library provides great threading primitives out of the box.
These, combined with Rust's concept of Ownership and aliasing rules, automatically prevent
data races.</p>
<p>The aliasing rules (one writable reference XOR many readable references) automatically prevent
you from manipulating state that is visible to other threads. (Where synchronisation is needed,
there are synchronisation
primitives like <code>Mutex</code>es or <code>Channel</code>s.)</p>
<p>In this example, we will calculate the sum of all digits in a block of numbers.
We will do this by parcelling out chunks of the block into different threads. Each thread will sum
its tiny block of digits, and subsequently we will sum the intermediate sums produced by each
thread.</p>
<p>Note that, although we're passing references across thread boundaries, Rust understands that we're
only passing read-only references, and that thus no unsafety or data races can occur. Because
we're <code>move</code>-ing the data segments into the thread, Rust will also ensure the data is kept alive
until the threads exit, so no dangling pointers occur.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::thread;

// This is the `main` thread
fn main() {

    // This is our data to process.
    // We will calculate the sum of all digits via a threaded  map-reduce algorithm.
    // Each whitespace separated chunk will be handled in a different thread.
    //
    // TODO: see what happens to the output if you insert spaces!
    let data = &quot;86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668&quot;;

    // Make a vector to hold the child-threads which we will spawn.
    let mut children = vec![];

    /*************************************************************************
     * &quot;Map&quot; phase
     *
     * Divide our data into segments, and apply initial processing
     ************************************************************************/

    // split our data into segments for individual calculation
    // each chunk will be a reference (&amp;str) into the actual data
    let chunked_data = data.split_whitespace();

    // Iterate over the data segments.
    // .enumerate() adds the current loop index to whatever is iterated
    // the resulting tuple &quot;(index, element)&quot; is then immediately
    // &quot;destructured&quot; into two variables, &quot;i&quot; and &quot;data_segment&quot; with a
    // &quot;destructuring assignment&quot;
    for (i, data_segment) in chunked_data.enumerate() {
        println!(&quot;data segment {} is \&quot;{}\&quot;&quot;, i, data_segment);

        // Process each data segment in a separate thread
        //
        // spawn() returns a handle to the new thread,
        // which we MUST keep to access the returned value
        //
        // 'move || -&gt; u32' is syntax for a closure that:
        // * takes no arguments ('||')
        // * takes ownership of its captured variables ('move') and
        // * returns an unsigned 32-bit integer ('-&gt; u32')
        //
        // Rust is smart enough to infer the '-&gt; u32' from
        // the closure itself so we could have left that out.
        //
        // TODO: try removing the 'move' and see what happens
        children.push(thread::spawn(move || -&gt; u32 {
            // Calculate the intermediate sum of this segment:
            let result = data_segment
                        // iterate over the characters of our segment..
                        .chars()
                        // .. convert text-characters to their number value..
                        .map(|c| c.to_digit(10).expect(&quot;should be a digit&quot;))
                        // .. and sum the resulting iterator of numbers
                        .sum();

            // println! locks stdout, so no text-interleaving occurs
            println!(&quot;processed segment {}, result={}&quot;, i, result);

            // &quot;return&quot; not needed, because Rust is an &quot;expression language&quot;, the
            // last evaluated expression in each block is automatically its value.
            result

        }));
    }


    /*************************************************************************
     * &quot;Reduce&quot; phase
     *
     * Collect our intermediate results, and combine them into a final result
     ************************************************************************/

    // collect each thread's intermediate results into a new Vec
    let mut intermediate_sums = vec![];
    for child in children {
        // collect each child thread's return-value
        let intermediate_sum = child.join().unwrap();
        intermediate_sums.push(intermediate_sum);
    }

    // combine all intermediate sums into a single final sum.
    //
    // we use the &quot;turbofish&quot; ::&lt;&gt; to provide sum() with a type hint.
    //
    // TODO: try without the turbofish, by instead explicitly
    // specifying the type of final_result
    let final_result = intermediate_sums.iter().sum::&lt;u32&gt;();

    println!(&quot;Final sum result: {}&quot;, final_result);
}


</code></pre></pre>
<h3><a class="header" href="#assignments" id="assignments">Assignments</a></h3>
<p>It is not wise to let our number of threads depend on user inputted data.
What if the user decides to insert a lot of spaces? Do we <em>really</em> want to spawn 2,000 threads?
Modify the program so that the data is always chunked into a limited number of chunks,
defined by a static constant at the beginning of the program.</p>
<h3><a class="header" href="#see-also-64" id="see-also-64">See also:</a></h3>
<ul>
<li><a href="rustexample/std_misc/threads/../threads.html">Threads</a></li>
<li><a href="rustexample/std_misc/threads/../../std/vec.html">vectors</a> and <a href="rustexample/std_misc/threads/../../trait/iter.html">iterators</a></li>
<li><a href="rustexample/std_misc/threads/../../fn/closures.html">closures</a>, <a href="rustexample/std_misc/threads/../../scope/move.html">move</a> semantics and <a href="rustexample/std_misc/threads//rustbook/ch13-01-closures.html#closures-can-capture-their-environment"><code>move</code> closures</a></li>
<li><a href="rustexample/std_misc/threads//rustbook/ch18-03-pattern-syntax.html#destructuring-to-break-apart-values">destructuring</a> assignments</li>
<li><a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">turbofish notation</a> to help type inference</li>
<li><a href="rustexample/std_misc/threads/../../error/option_unwrap.html">unwrap vs. expect</a></li>
<li><a href="https://doc.rust-lang.org/book/loops.html#enumerate">enumerate</a></li>
</ul>
<h1><a class="header" href="#channels" id="channels">Channels</a></h1>
<p>Rust provides asynchronous <code>channels</code> for communication between threads. Channels
allow a unidirectional flow of information between two end-points: the
<code>Sender</code> and the <code>Receiver</code>.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::sync::mpsc::{Sender, Receiver};
use std::sync::mpsc;
use std::thread;

static NTHREADS: i32 = 3;

fn main() {
    // Channels have two endpoints: the `Sender&lt;T&gt;` and the `Receiver&lt;T&gt;`,
    // where `T` is the type of the message to be transferred
    // (type annotation is superfluous)
    let (tx, rx): (Sender&lt;i32&gt;, Receiver&lt;i32&gt;) = mpsc::channel();
    let mut children = Vec::new();

    for id in 0..NTHREADS {
        // The sender endpoint can be copied
        let thread_tx = tx.clone();

        // Each thread will send its id via the channel
        let child = thread::spawn(move || {
            // The thread takes ownership over `thread_tx`
            // Each thread queues a message in the channel
            thread_tx.send(id).unwrap();

            // Sending is a non-blocking operation, the thread will continue
            // immediately after sending its message
            println!(&quot;thread {} finished&quot;, id);
        });

        children.push(child);
    }

    // Here, all the messages are collected
    let mut ids = Vec::with_capacity(NTHREADS as usize);
    for _ in 0..NTHREADS {
        // The `recv` method picks a message from the channel
        // `recv` will block the current thread if there are no messages available
        ids.push(rx.recv());
    }
    
    // Wait for the threads to complete any remaining work
    for child in children {
        child.join().expect(&quot;oops! the child thread panicked&quot;);
    }

    // Show the order in which the messages were sent
    println!(&quot;{:?}&quot;, ids);
}
</code></pre></pre>
<h1><a class="header" href="#path" id="path">Path</a></h1>
<p>The <code>Path</code> struct represents file paths in the underlying filesystem. There are
two flavors of <code>Path</code>: <code>posix::Path</code>, for UNIX-like systems, and
<code>windows::Path</code>, for Windows. The prelude exports the appropriate
platform-specific <code>Path</code> variant.</p>
<p>A <code>Path</code> can be created from an <code>OsStr</code>, and provides several methods to get
information from the file/directory the path points to.</p>
<p>Note that a <code>Path</code> is <em>not</em> internally represented as an UTF-8 string, but
instead is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>). Therefore, converting a
<code>Path</code> to a <code>&amp;str</code> is <em>not</em> free and may fail (an <code>Option</code> is returned).</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::path::Path;

fn main() {
    // Create a `Path` from an `&amp;'static str`
    let path = Path::new(&quot;.&quot;);

    // The `display` method returns a `Show`able structure
    let _display = path.display();

    // `join` merges a path with a byte container using the OS specific
    // separator, and returns the new path
    let new_path = path.join(&quot;a&quot;).join(&quot;b&quot;);

    // Convert the path into a string slice
    match new_path.to_str() {
        None =&gt; panic!(&quot;new path is not a valid UTF-8 sequence&quot;),
        Some(s) =&gt; println!(&quot;new path is {}&quot;, s),
    }
}

</code></pre></pre>
<p>Be sure to check at other <code>Path</code> methods (<code>posix::Path</code> or <code>windows::Path</code>) and
the <code>Metadata</code> struct.</p>
<h3><a class="header" href="#see-also-65" id="see-also-65">See also</a></h3>
<p><a href="https://doc.rust-lang.org/std/ffi/struct.OsStr.html">OsStr</a> and <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html">Metadata</a>.</p>
<h1><a class="header" href="#file-io" id="file-io">File I/O</a></h1>
<p>The <code>File</code> struct represents a file that has been opened (it wraps a file
descriptor), and gives read and/or write access to the underlying file.</p>
<p>Since many things can go wrong when doing file I/O, all the <code>File</code> methods
return the <code>io::Result&lt;T&gt;</code> type, which is an alias for <code>Result&lt;T, io::Error&gt;</code>.</p>
<p>This makes the failure of all I/O operations <em>explicit</em>. Thanks to this, the
programmer can see all the failure paths, and is encouraged to handle them in
a proactive manner.</p>
<h1><a class="header" href="#open" id="open"><code>open</code></a></h1>
<p>The <code>open</code> static method can be used to open a file in read-only mode.</p>
<p>A <code>File</code> owns a resource, the file descriptor and takes care of closing the
file when it is <code>drop</code>ed.</p>
<pre><code class="language-rust editable ignore">use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    // Create a path to the desired file
    let path = Path::new(&quot;hello.txt&quot;);
    let display = path.display();

    // Open the path in read-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::open(&amp;path) {
        // The `description` method of `io::Error` returns a string that
        // describes the error
        Err(why) =&gt; panic!(&quot;couldn't open {}: {}&quot;, display,
                                                   why.description()),
        Ok(file) =&gt; file,
    };

    // Read the file contents into a string, returns `io::Result&lt;usize&gt;`
    let mut s = String::new();
    match file.read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read {}: {}&quot;, display,
                                                   why.description()),
        Ok(_) =&gt; print!(&quot;{} contains:\n{}&quot;, display, s),
    }

    // `file` goes out of scope, and the &quot;hello.txt&quot; file gets closed
}

</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-bash">$ echo &quot;Hello World!&quot; &gt; hello.txt
$ rustc open.rs &amp;&amp; ./open
hello.txt contains:
Hello World!
</code></pre>
<p>(You are encouraged to test the previous example under different failure
conditions: <code>hello.txt</code> doesn't exist, or <code>hello.txt</code> is not readable,
etc.)</p>
<h1><a class="header" href="#create" id="create"><code>create</code></a></h1>
<p>The <code>create</code> static method opens a file in write-only mode. If the file
already existed, the old content is destroyed. Otherwise, a new file is
created.</p>
<pre><code class="language-rust ignore">static LOREM_IPSUM: &amp;str =
    &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
&quot;;

use std::error::Error;
use std::fs::File;
use std::io::prelude::*;
use std::path::Path;

fn main() {
    let path = Path::new(&quot;out/lorem_ipsum.txt&quot;);
    let display = path.display();

    // Open a file in write-only mode, returns `io::Result&lt;File&gt;`
    let mut file = match File::create(&amp;path) {
        Err(why) =&gt; panic!(&quot;couldn't create {}: {}&quot;, display, why.description()),
        Ok(file) =&gt; file,
    };

    // Write the `LOREM_IPSUM` string to `file`, returns `io::Result&lt;()&gt;`
    match file.write_all(LOREM_IPSUM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to {}: {}&quot;, display, why.description()),
        Ok(_) =&gt; println!(&quot;successfully wrote to {}&quot;, display),
    }
}
</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-bash">$ mkdir out
$ rustc create.rs &amp;&amp; ./create
successfully wrote to out/lorem_ipsum.txt
$ cat out/lorem_ipsum.txt
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
</code></pre>
<p>(As in the previous example, you are encouraged to test this example under
failure conditions.)</p>
<p>There is <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html"><code>OpenOptions</code></a> struct that can be used to configure how a file is opened.</p>
<h1><a class="header" href="#read-lines" id="read-lines">Read Lines</a></h1>
<p>The method <code>lines()</code> returns an iterator over the lines
of a file.</p>
<p><code>File::open</code> expects a generic, <code>AsRef&lt;Path&gt;</code>.  That's what
<code>read_lines()</code> expects as input.</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;

fn main() {
    // File hosts must exist in current path before this produces output
    if let Ok(lines) = read_lines(&quot;./hosts&quot;) {
        // Consumes the iterator, returns an (Optional) String
        for line in lines {
            if let Ok(ip) = line {
                println!(&quot;{}&quot;, ip);
            }      
        }   
    }
}

// The output is wrapped in a Result to allow matching on errors
// Returns an Iterator to the Reader of the lines of the file.
fn read_lines&lt;P&gt;(filename: P) -&gt; io::Result&lt;io::Lines&lt;io::BufReader&lt;File&gt;&gt;&gt;
where P: AsRef&lt;Path&gt;, {
    let file = File::open(filename)?;
    Ok(io::BufReader::new(file).lines())
}
</code></pre></pre>
<p>Running this program simply prints the lines individually.</p>
<pre><code class="language-bash">$ echo -e &quot;127.0.0.1\n192.168.0.1\n&quot; &gt; hosts
$ rustc read_lines.rs &amp;&amp; ./read_lines
127.0.0.1
192.168.0.1
</code></pre>
<p>This process is more efficient than creating a <code>String</code> in memory
especially working with larger files.</p>
<h1><a class="header" href="#child-processes" id="child-processes">Child processes</a></h1>
<p>The <code>process::Output</code> struct represents the output of a finished child process,
and the <code>process::Command</code> struct is a process builder.</p>
<pre><code class="language-rust editable ignore">use std::process::Command;

fn main() {
    let output = Command::new(&quot;rustc&quot;)
        .arg(&quot;--version&quot;)
        .output().unwrap_or_else(|e| {
            panic!(&quot;failed to execute process: {}&quot;, e)
    });

    if output.status.success() {
        let s = String::from_utf8_lossy(&amp;output.stdout);

        print!(&quot;rustc succeeded and stdout was:\n{}&quot;, s);
    } else {
        let s = String::from_utf8_lossy(&amp;output.stderr);

        print!(&quot;rustc failed and stderr was:\n{}&quot;, s);
    }
}
</code></pre>
<p>(You are encouraged to try the previous example with an incorrect flag passed
to <code>rustc</code>)</p>
<h1><a class="header" href="#pipes" id="pipes">Pipes</a></h1>
<p>The <code>std::Child</code> struct represents a running child process, and exposes the
<code>stdin</code>, <code>stdout</code> and <code>stderr</code> handles for interaction with the underlying
process via pipes.</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::io::prelude::*;
use std::process::{Command, Stdio};

static PANGRAM: &amp;'static str =
&quot;the quick brown fox jumped over the lazy dog\n&quot;;

fn main() {
    // Spawn the `wc` command
    let process = match Command::new(&quot;wc&quot;)
                                .stdin(Stdio::piped())
                                .stdout(Stdio::piped())
                                .spawn() {
        Err(why) =&gt; panic!(&quot;couldn't spawn wc: {}&quot;, why.description()),
        Ok(process) =&gt; process,
    };

    // Write a string to the `stdin` of `wc`.
    //
    // `stdin` has type `Option&lt;ChildStdin&gt;`, but since we know this instance
    // must have one, we can directly `unwrap` it.
    match process.stdin.unwrap().write_all(PANGRAM.as_bytes()) {
        Err(why) =&gt; panic!(&quot;couldn't write to wc stdin: {}&quot;,
                           why.description()),
        Ok(_) =&gt; println!(&quot;sent pangram to wc&quot;),
    }

    // Because `stdin` does not live after the above calls, it is `drop`ed,
    // and the pipe is closed.
    //
    // This is very important, otherwise `wc` wouldn't start processing the
    // input we just sent.

    // The `stdout` field also has type `Option&lt;ChildStdout&gt;` so must be unwrapped.
    let mut s = String::new();
    match process.stdout.unwrap().read_to_string(&amp;mut s) {
        Err(why) =&gt; panic!(&quot;couldn't read wc stdout: {}&quot;,
                           why.description()),
        Ok(_) =&gt; print!(&quot;wc responded with:\n{}&quot;, s),
    }
}
</code></pre>
<h1><a class="header" href="#wait" id="wait">Wait</a></h1>
<p>If you'd like to wait for a <code>process::Child</code> to finish, you must call
<code>Child::wait</code>, which will return a <code>process::ExitStatus</code>.</p>
<pre><code class="language-rust ignore">use std::process::Command;

fn main() {
    let mut child = Command::new(&quot;sleep&quot;).arg(&quot;5&quot;).spawn().unwrap();
    let _result = child.wait().unwrap();

    println!(&quot;reached end of main&quot;);
}
</code></pre>
<pre><code class="language-bash">$ rustc wait.rs &amp;&amp; ./wait
# `wait` keeps running for 5 seconds until the `sleep 5` command finishes
reached end of main
</code></pre>
<h1><a class="header" href="#filesystem-operations" id="filesystem-operations">Filesystem Operations</a></h1>
<p>The <code>std::fs</code> module contains several functions that deal with the filesystem.</p>
<pre><code class="language-rust ignore">use std::fs;
use std::fs::{File, OpenOptions};
use std::io;
use std::io::prelude::*;
use std::os::unix;
use std::path::Path;

// A simple implementation of `% cat path`
fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}

// A simple implementation of `% echo s &gt; path`
fn echo(s: &amp;str, path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    let mut f = File::create(path)?;

    f.write_all(s.as_bytes())
}

// A simple implementation of `% touch path` (ignores existing files)
fn touch(path: &amp;Path) -&gt; io::Result&lt;()&gt; {
    match OpenOptions::new().create(true).write(true).open(path) {
        Ok(_) =&gt; Ok(()),
        Err(e) =&gt; Err(e),
    }
}

fn main() {
    println!(&quot;`mkdir a`&quot;);
    // Create a directory, returns `io::Result&lt;()&gt;`
    match fs::create_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(_) =&gt; {},
    }

    println!(&quot;`echo hello &gt; a/b.txt`&quot;);
    // The previous match can be simplified using the `unwrap_or_else` method
    echo(&quot;hello&quot;, &amp;Path::new(&quot;a/b.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`mkdir -p a/c/d`&quot;);
    // Recursively create a directory, returns `io::Result&lt;()&gt;`
    fs::create_dir_all(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`touch a/c/e.txt`&quot;);
    touch(&amp;Path::new(&quot;a/c/e.txt&quot;)).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`ln -s ../b.txt a/c/b.txt`&quot;);
    // Create a symbolic link, returns `io::Result&lt;()&gt;`
    if cfg!(target_family = &quot;unix&quot;) {
        unix::fs::symlink(&quot;../b.txt&quot;, &quot;a/c/b.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
        });
    }

    println!(&quot;`cat a/c/b.txt`&quot;);
    match cat(&amp;Path::new(&quot;a/c/b.txt&quot;)) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(s) =&gt; println!(&quot;&gt; {}&quot;, s),
    }

    println!(&quot;`ls a`&quot;);
    // Read the contents of a directory, returns `io::Result&lt;Vec&lt;Path&gt;&gt;`
    match fs::read_dir(&quot;a&quot;) {
        Err(why) =&gt; println!(&quot;! {:?}&quot;, why.kind()),
        Ok(paths) =&gt; for path in paths {
            println!(&quot;&gt; {:?}&quot;, path.unwrap().path());
        },
    }

    println!(&quot;`rm a/c/e.txt`&quot;);
    // Remove a file, returns `io::Result&lt;()&gt;`
    fs::remove_file(&quot;a/c/e.txt&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });

    println!(&quot;`rmdir a/c/d`&quot;);
    // Remove an empty directory, returns `io::Result&lt;()&gt;`
    fs::remove_dir(&quot;a/c/d&quot;).unwrap_or_else(|why| {
        println!(&quot;! {:?}&quot;, why.kind());
    });
}

</code></pre>
<p>Here's the expected successful output:</p>
<pre><code class="language-bash">$ rustc fs.rs &amp;&amp; ./fs
`mkdir a`
`echo hello &gt; a/b.txt`
`mkdir -p a/c/d`
`touch a/c/e.txt`
`ln -s ../b.txt a/c/b.txt`
`cat a/c/b.txt`
&gt; hello
`ls a`
&gt; &quot;a/b.txt&quot;
&gt; &quot;a/c&quot;
`rm a/c/e.txt`
`rmdir a/c/d`
</code></pre>
<p>And the final state of the <code>a</code> directory is:</p>
<pre><code class="language-text">$ tree a
a
|-- b.txt
`-- c
    `-- b.txt -&gt; ../b.txt

1 directory, 2 files
</code></pre>
<p>An alternative way to define the function <code>cat</code> is with <code>?</code> notation:</p>
<pre><code class="language-rust ignore">fn cat(path: &amp;Path) -&gt; io::Result&lt;String&gt; {
    let mut f = File::open(path)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
</code></pre>
<h3><a class="header" href="#see-also-66" id="see-also-66">See also:</a></h3>
<p><a href="rustexample/std_misc/../attribute/cfg.html"><code>cfg!</code></a></p>
<h1><a class="header" href="#program-arguments" id="program-arguments">Program arguments</a></h1>
<h2><a class="header" href="#standard-library" id="standard-library">Standard Library</a></h2>
<p>The command line arguments can be accessed using <code>std::env::args</code>, which
returns an iterator that yields a <code>String</code> for each argument:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    // The first argument is the path that was used to call the program.
    println!(&quot;My path is {}.&quot;, args[0]);

    // The rest of the arguments are the passed command line parameters.
    // Call the program like this:
    //   $ ./args arg1 arg2
    println!(&quot;I got {:?} arguments: {:?}.&quot;, args.len() - 1, &amp;args[1..]);
}
</code></pre></pre>
<pre><code class="language-bash">$ ./args 1 2 3
My path is ./args.
I got 3 arguments: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].
</code></pre>
<h2><a class="header" href="#crates-2" id="crates-2">Crates</a></h2>
<p>Alternatively, there are numerous crates that can provide extra functionality
when creating command-line applications. The <a href="https://rust-lang-nursery.github.io/rust-cookbook/cli/arguments.html">Rust Cookbook</a> exhibits best
practices on how to use one of the more popular command line argument crates,
<code>clap</code>.</p>
<h1><a class="header" href="#argument-parsing" id="argument-parsing">Argument parsing</a></h1>
<p>Matching can be used to parse simple arguments:</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::env;

fn increase(number: i32) {
    println!(&quot;{}&quot;, number + 1);
}

fn decrease(number: i32) {
    println!(&quot;{}&quot;, number - 1);
}

fn help() {
    println!(&quot;usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {{increase|decrease}} &lt;integer&gt;
    Increase or decrease given integer by one.&quot;);
}

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    match args.len() {
        // no arguments passed
        1 =&gt; {
            println!(&quot;My name is 'match_args'. Try passing some arguments!&quot;);
        },
        // one argument passed
        2 =&gt; {
            match args[1].parse() {
                Ok(42) =&gt; println!(&quot;This is the answer!&quot;),
                _ =&gt; println!(&quot;This is not the answer.&quot;),
            }
        },
        // one command and one argument passed
        3 =&gt; {
            let cmd = &amp;args[1];
            let num = &amp;args[2];
            // parse the number
            let number: i32 = match num.parse() {
                Ok(n) =&gt; {
                    n
                },
                Err(_) =&gt; {
                    eprintln!(&quot;error: second argument not an integer&quot;);
                    help();
                    return;
                },
            };
            // parse the command
            match &amp;cmd[..] {
                &quot;increase&quot; =&gt; increase(number),
                &quot;decrease&quot; =&gt; decrease(number),
                _ =&gt; {
                    eprintln!(&quot;error: invalid command&quot;);
                    help();
                },
            }
        },
        // all the other cases
        _ =&gt; {
            // show a help message
            help();
        }
    }
}
</code></pre></pre>
<pre><code class="language-bash">$ ./match_args Rust
This is not the answer.
$ ./match_args 42
This is the answer!
$ ./match_args do something
error: second argument not an integer
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args do 42
error: invalid command
usage:
match_args &lt;string&gt;
    Check whether given string is the answer.
match_args {increase|decrease} &lt;integer&gt;
    Increase or decrease given integer by one.
$ ./match_args increase 42
43
</code></pre>
<h1><a class="header" href="#foreign-function-interface" id="foreign-function-interface">Foreign Function Interface</a></h1>
<p>Rust provides a Foreign Function Interface (FFI) to C libraries. Foreign
functions must be declared inside an <code>extern</code> block annotated with a <code>#[link]</code>
attribute containing the name of the foreign library.</p>
<pre><code class="language-rust ignore">use std::fmt;

// this extern block links to the libm library
#[link(name = &quot;m&quot;)]
extern {
    // this is a foreign function
    // that computes the square root of a single precision complex number
    fn csqrtf(z: Complex) -&gt; Complex;

    fn ccosf(z: Complex) -&gt; Complex;
}

// Since calling foreign functions is considered unsafe,
// it's common to write safe wrappers around them.
fn cos(z: Complex) -&gt; Complex {
    unsafe { ccosf(z) }
}

fn main() {
    // z = -1 + 0i
    let z = Complex { re: -1., im: 0. };

    // calling a foreign function is an unsafe operation
    let z_sqrt = unsafe { csqrtf(z) };

    println!(&quot;the square root of {:?} is {:?}&quot;, z, z_sqrt);

    // calling safe API wrapped around unsafe operation
    println!(&quot;cos({:?}) = {:?}&quot;, z, cos(z));
}

// Minimal implementation of single precision complex numbers
#[repr(C)]
#[derive(Clone, Copy)]
struct Complex {
    re: f32,
    im: f32,
}

impl fmt::Debug for Complex {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        if self.im &lt; 0. {
            write!(f, &quot;{}-{}i&quot;, self.re, -self.im)
        } else {
            write!(f, &quot;{}+{}i&quot;, self.re, self.im)
        }
    }
}
</code></pre>
<h1><a class="header" href="#testing-1" id="testing-1">Testing</a></h1>
<p>Rust is a programming language that cares a lot about correctness and it
includes support for writing software tests within the language itself.</p>
<p>Testing comes in three styles:</p>
<ul>
<li><a href="rustexample/testing/unit_testing.html">Unit</a> testing.</li>
<li><a href="rustexample/testing/doc_testing.html">Doc</a> testing.</li>
<li><a href="rustexample/testing/integration_testing.html">Integration</a> testing.</li>
</ul>
<p>Also Rust has support for specifying additional dependencies for tests:</p>
<ul>
<li><a href="rustexample/testing/dev_dependencies.html">Dev-dependencies</a></li>
</ul>
<h2><a class="header" href="#see-also-67" id="see-also-67">See Also</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch11-00-testing.html">The Book</a> chapter on testing</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on doc-testing</li>
</ul>
<h1><a class="header" href="#unit-testing" id="unit-testing">Unit testing</a></h1>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform some setup,
run the code we want to test, then assert whether the results are what we
expect.</p>
<p>Most unit tests go into a <code>tests</code> <a href="rustexample/testing/../mod.html">mod</a> with the <code>#[cfg(test)]</code> <a href="rustexample/testing/../attribute.html">attribute</a>.
Test functions are marked with the <code>#[test]</code> attribute.</p>
<p>Tests fail when something in the test function <a href="rustexample/testing/../std/panic.html">panics</a>. There are some
helper <a href="rustexample/testing/../macros.html">macros</a>:</p>
<ul>
<li><code>assert!(expression)</code> - panics if expression evaluates to <code>false</code>.</li>
<li><code>assert_eq!(left, right)</code> and <code>assert_ne!(left, right)</code> - testing left and
right expressions for equality and inequality respectively.</li>
</ul>
<pre><code class="language-rust ignore">pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

// This is a really bad adding function, its purpose is to fail in this
// example.
#[allow(dead_code)]
fn bad_add(a: i32, b: i32) -&gt; i32 {
    a - b
}

#[cfg(test)]
mod tests {
    // Note this useful idiom: importing names from outer (for mod tests) scope.
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }

    #[test]
    fn test_bad_add() {
        // This assert would fire and test will fail.
        // Please note, that private functions can be tested too!
        assert_eq!(bad_add(1, 2), 3);
    }
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>.</p>
<pre><code class="language-bash">$ cargo test

running 2 tests
test tests::test_bad_add ... FAILED
test tests::test_add ... ok

failures:

---- tests::test_bad_add stdout ----
        thread 'tests::test_bad_add' panicked at 'assertion failed: `(left == right)`
  left: `-1`,
 right: `3`', src/lib.rs:21:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::test_bad_add

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#testing-panics" id="testing-panics">Testing panics</a></h2>
<p>To check functions that should panic under certain circumstances, use attribute
<code>#[should_panic]</code>. This attribute accepts optional parameter <code>expected = </code> with
the text of the panic message. If your function can panic in multiple ways, it helps
make sure your test is testing the correct panic.</p>
<pre><code class="language-rust ignore">pub fn divide_non_zero_result(a: u32, b: u32) -&gt; u32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    } else if a &lt; b {
        panic!(&quot;Divide result is zero&quot;);
    }
    a / b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_divide() {
        assert_eq!(divide_non_zero_result(10, 2), 5);
    }

    #[test]
    #[should_panic]
    fn test_any_panic() {
        divide_non_zero_result(1, 0);
    }

    #[test]
    #[should_panic(expected = &quot;Divide result is zero&quot;)]
    fn test_specific_panic() {
        divide_non_zero_result(1, 10);
    }
}
</code></pre>
<p>Running these tests gives us:</p>
<pre><code class="language-bash">$ cargo test

running 3 tests
test tests::test_any_panic ... ok
test tests::test_divide ... ok
test tests::test_specific_panic ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#running-specific-tests" id="running-specific-tests">Running specific tests</a></h2>
<p>To run specific tests one may specify the test name to <code>cargo test</code> command.</p>
<pre><code class="language-bash">$ cargo test test_any_panic
running 1 test
test tests::test_any_panic ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>To run multiple tests one may specify part of a test name that matches all the
tests that should be run.</p>
<pre><code class="language-bash">$ cargo test panic
running 2 tests
test tests::test_any_panic ... ok
test tests::test_specific_panic ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests tmp-test-should-panic

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#ignoring-tests" id="ignoring-tests">Ignoring tests</a></h2>
<p>Tests can be marked with the<code>#[ignore]</code> attribute to exclude some tests. Or to run
them with command <code>cargo test -- --ignored</code></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 2), 4);
    }

    #[test]
    fn test_add_hundred() {
        assert_eq!(add(100, 2), 102);
        assert_eq!(add(2, 100), 102);
    }

    #[test]
    #[ignore]
    fn ignored_test() {
        assert_eq!(add(0, 0), 0);
    }
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-bash">$ cargo test
running 1 test
test tests::ignored_test ... ignored

test result: ok. 0 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

$ cargo test -- --ignored
running 1 test
test tests::ignored_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests tmp-ignore

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h1><a class="header" href="#documentation-testing" id="documentation-testing">Documentation testing</a></h1>
<p>The primary way of documenting a Rust project is through annotating the source
code. Documentation comments are written in <a href="https://daringfireball.net/projects/markdown/">markdown</a> and support code
blocks in them. Rust takes care about correctness, so these code blocks are
compiled and used as tests.</p>
<pre><code class="language-rust ignore">/// First line is a short summary describing function.
///
/// The next lines present detailed documentation. Code blocks start with
/// triple backquotes and have implicit `fn main()` inside
/// and `extern crate &lt;cratename&gt;`. Assume we're testing `doccomments` crate:
///
/// ```
/// let result = doccomments::add(2, 3);
/// assert_eq!(result, 5);
/// ```
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

/// Usually doc comments may include sections &quot;Examples&quot;, &quot;Panics&quot; and &quot;Failures&quot;.
///
/// The next function divides two numbers.
///
/// # Examples
///
/// ```
/// let result = doccomments::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # Panics
///
/// The function panics if the second argument is zero.
///
/// ```rust,should_panic
/// // panics on division by zero
/// doccomments::div(10, 0);
/// ```
pub fn div(a: i32, b: i32) -&gt; i32 {
    if b == 0 {
        panic!(&quot;Divide-by-zero error&quot;);
    }

    a / b
}
</code></pre>
<p>Tests can be run with <code>cargo test</code>:</p>
<pre><code class="language-bash">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests doccomments

running 3 tests
test src/lib.rs - add (line 7) ... ok
test src/lib.rs - div (line 21) ... ok
test src/lib.rs - div (line 31) ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h2><a class="header" href="#motivation-behind-documentation-tests" id="motivation-behind-documentation-tests">Motivation behind documentation tests</a></h2>
<p>The main purpose of documentation tests is to serve as examples that exercise
the functionality, which is one of the most important
<a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html#examples-use--not-try-not-unwrap-c-question-mark">guidelines</a>. It allows using examples from docs as
complete code snippets. But using <code>?</code> makes compilation fail since <code>main</code>
returns <code>unit</code>. The ability to hide some source lines from documentation comes
to the rescue: one may write <code>fn try_main() -&gt; Result&lt;(), ErrorType&gt;</code>, hide it and
<code>unwrap</code> it in hidden <code>main</code>. Sounds complicated? Here's an example:</p>
<pre><code class="language-rust ignore">/// Using hidden `try_main` in doc tests.
///
/// ```
/// # // hidden lines start with `#` symbol, but they're still compileable!
/// # fn try_main() -&gt; Result&lt;(), String&gt; { // line that wraps the body shown in doc
/// let res = try::try_div(10, 2)?;
/// # Ok(()) // returning from try_main
/// # }
/// # fn main() { // starting main that'll unwrap()
/// #    try_main().unwrap(); // calling try_main and unwrapping
/// #                         // so that test will panic in case of error
/// # }
pub fn try_div(a: i32, b: i32) -&gt; Result&lt;i32, String&gt; {
    if b == 0 {
        Err(String::from(&quot;Divide-by-zero&quot;))
    } else {
        Ok(a / b)
    }
}
</code></pre>
<h2><a class="header" href="#see-also-68" id="see-also-68">See Also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/0505-api-comment-conventions.md">RFC505</a> on documentation style</li>
<li><a href="https://rust-lang-nursery.github.io/api-guidelines/documentation.html">API Guidelines</a> on documentation guidelines</li>
</ul>
<h1><a class="header" href="#integration-testing" id="integration-testing">Integration testing</a></h1>
<p><a href="rustexample/testing/unit_testing.html">Unit tests</a> are testing one module in isolation at a time: they're small
and can test private code. Integration tests are external to your crate and use
only its public interface in the same way any other code would. Their purpose is
to test that many parts of your library work correctly together.</p>
<p>Cargo looks for integration tests in <code>tests</code> directory next to <code>src</code>.</p>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// Assume that crate is called adder, will have to extern it in integration test.
pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code>:</p>
<pre><code class="language-rust ignore">// extern crate we're testing, same as any other code would do.
extern crate adder;

#[test]
fn test_add() {
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Running tests with <code>cargo test</code> command:</p>
<pre><code class="language-bash">$ cargo test
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-bcd60824f5fbfe19

running 1 test
test test_add ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Each Rust source file in <code>tests</code> directory is compiled as a separate crate. One
way of sharing some code between integration tests is making module with public
functions, importing and using it within tests.</p>
<p>File <code>tests/common.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn setup() {
    // some setup code, like creating required files/directories, starting
    // servers, etc.
}
</code></pre>
<p>File with test: <code>tests/integration_test.rs</code></p>
<pre><code class="language-rust ignore">// extern crate we're testing, same as any other code will do.
extern crate adder;

// importing common module.
mod common;

#[test]
fn test_add() {
    // using common code.
    common::setup();
    assert_eq!(adder::add(3, 2), 5);
}
</code></pre>
<p>Modules with common code follow the ordinary <a href="rustexample/testing/../mod.html">modules</a> rules, so it's ok to
create common module as <code>tests/common/mod.rs</code>.</p>
<h1><a class="header" href="#development-dependencies" id="development-dependencies">Development dependencies</a></h1>
<p>Sometimes there is a need to have a dependencies for tests (examples,
benchmarks) only. Such dependencies are added to <code>Cargo.toml</code> in
<code>[dev-dependencies]</code> section. These dependencies are not propagated to other
packages which depend on this package.</p>
<p>One such example is using a crate that extends standard <code>assert!</code> macros.<br />
File <code>Cargo.toml</code>:</p>
<pre><code class="language-ignore"># standard crate data is left out
[dev-dependencies]
pretty_assertions = &quot;0.4.0&quot;
</code></pre>
<p>File <code>src/lib.rs</code>:</p>
<pre><code class="language-rust ignore">// externing crate for test-only use
#[cfg(test)]
#[macro_use]
extern crate pretty_assertions;

pub fn add(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
</code></pre>
<h2><a class="header" href="#see-also-69" id="see-also-69">See Also</a></h2>
<p><a href="http://doc.crates.io/specifying-dependencies.html">Cargo</a> docs on specifying dependencies.</p>
<h1><a class="header" href="#unsafe-operations" id="unsafe-operations">Unsafe Operations</a></h1>
<p>As an introduction to this section, to borrow from <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">the official docs</a>,
&quot;one should try to minimize the amount of unsafe code in a code base.&quot; With that
in mind, let's get started! Unsafe annotations in Rust are used to bypass
protections put in place by the compiler; specifically, there are four primary
things that unsafe is used for:</p>
<ul>
<li>dereferencing raw pointers</li>
<li>calling functions or methods which are <code>unsafe</code> (including calling a function
over FFI, see <a href="rustexample/std_misc/ffi.html">a previous chapter</a> of the book) </li>
<li>accessing or modifying static mutable variables</li>
<li>implementing unsafe traits</li>
</ul>
<h3><a class="header" href="#raw-pointers" id="raw-pointers">Raw Pointers</a></h3>
<p>Raw pointers <code>*</code> and references <code>&amp;T</code> function similarly, but references are
always safe because they are guaranteed to point to valid data due to the
borrow checker. Dereferencing a raw pointer can only be done through an unsafe
block.</p>
<pre><pre class="playpen"><code class="language-rust editable">fn main() {
    let raw_p: *const u32 = &amp;10;

    unsafe {
        assert!(*raw_p == 10);
    }
}
</code></pre></pre>
<h3><a class="header" href="#calling-unsafe-functions" id="calling-unsafe-functions">Calling Unsafe Functions</a></h3>
<p>Some functions can be declared as <code>unsafe</code>, meaning it is the programmer's
responsibility to ensure correctness instead of the compiler's. One example
of this is <a href="https://doc.rust-lang.org/std/slice/fn.from_raw_parts.html"><code>std::slice::from_raw_parts</code></a> which will create a slice given a
pointer to the first element and a length.</p>
<pre><pre class="playpen"><code class="language-rust editable">use std::slice;

fn main() {
    let some_vector = vec![1, 2, 3, 4];

    let pointer = some_vector.as_ptr();
    let length = some_vector.len();

    unsafe {
        let my_slice: &amp;[u32] = slice::from_raw_parts(pointer, length);

        assert_eq!(some_vector.as_slice(), my_slice);
    }
}
</code></pre></pre>
<p>For <code>slice::from_raw_parts</code>, one of the assumptions which <em>must</em> be upheld is 
that the pointer passed in points to valid memory and that the memory pointed to
is of the correct type. If these invariants aren't upheld then the program's 
behaviour is undefined and there is no knowing what will happen.</p>
<h1><a class="header" href="#compatibility" id="compatibility">Compatibility</a></h1>
<p>The Rust language is fastly evolving, and because of this certain compatibility
issues can arise, despite efforts to ensure forwards-compatibility wherever
possible.</p>
<ul>
<li><a href="rustexample/compatibility/raw_identifiers.html">Raw identifiers</a></li>
</ul>
<h1><a class="header" href="#raw-identifiers" id="raw-identifiers">Raw identifiers</a></h1>
<p>Rust, like many programming languages, has the concept of &quot;keywords&quot;.
These identifiers mean something to the language, and so you cannot use them in
places like variable names, function names, and other places.
Raw identifiers let you use keywords where they would not normally be allowed.
This is particularly useful when Rust introduces new keywords, and a library
using an older edition of Rust has a variable or function with the same name
as a keyword introduced in a newer edition.</p>
<p>For example, consider a crate <code>foo</code> compiled with the 2015 edition of Rust that
exports a function named <code>try</code>. This keyword is reserved for a new feature in
the 2018 edition, so without raw identifiers, we would have no way to name the
function.</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::try();
}
</code></pre>
<p>You'll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `try`
 --&gt; src/main.rs:4:4
  |
4 | foo::try();
  |      ^^^ expected identifier, found keyword
</code></pre>
<p>You can write this with a raw identifier:</p>
<pre><code class="language-rust ignore">extern crate foo;

fn main() {
    foo::r#try();
}
</code></pre>
<h1><a class="header" href="#meta" id="meta">Meta</a></h1>
<p>Some topics aren't exactly relevant to how you program but provide you
tooling or infrastructure support which just makes things better for
everyone. These topics include:</p>
<ul>
<li>Documentation: Generate library documentation for users via the included
<code>rustdoc</code>.</li>
<li>Testing: Create testsuites for libraries to give confidence that your
library does exactly what it's supposed to.</li>
<li>Benchmarking: Create benchmarks for functionality to be confident that
they run quickly.</li>
</ul>
<h1><a class="header" href="#documentation" id="documentation">Documentation</a></h1>
<p>Use <code>cargo doc</code> to build documentation in <code>target/doc</code>.</p>
<p>Use <code>cargo test</code> to run all tests (including documentation tests), and <code>cargo test --doc</code> to only run documentation tests.</p>
<p>These commands will appropriately invoke <code>rustdoc</code> (and <code>rustc</code>) as required.</p>
<h3><a class="header" href="#doc-comments" id="doc-comments">Doc comments</a></h3>
<p>Doc comments are very useful for big projects that require documentation. When
running Rustdoc, these are the comments that get compiled into
documentation. They are denoted by a <code>///</code>, and support <a href="https://en.wikipedia.org/wiki/Markdown">Markdown</a>.</p>
<pre><code class="language-rust editable ignore">#![crate_name = &quot;doc&quot;]

/// A human being is represented here
pub struct Person {
    /// A person must have a name, no matter how much Juliet may hate it
    name: String,
}

impl Person {
    /// Returns a person with the name given them
    ///
    /// # Arguments
    ///
    /// * `name` - A string slice that holds the name of the person
    ///
    /// # Example
    ///
    /// ```
    /// // You can have rust code between fences inside the comments
    /// // If you pass --test to Rustdoc, it will even test it for you!
    /// use doc::Person;
    /// let person = Person::new(&quot;name&quot;);
    /// ```
    pub fn new(name: &amp;str) -&gt; Person {
        Person {
            name: name.to_string(),
        }
    }

    /// Gives a friendly hello!
    ///
    /// Says &quot;Hello, [name]&quot; to the `Person` it is called on.
    pub fn hello(&amp; self) {
        println!(&quot;Hello, {}!&quot;, self.name);
    }
}

fn main() {
    let john = Person::new(&quot;John&quot;);

    john.hello();
}
</code></pre>
<p>To run the tests, first build the code as a library, then tell rustdoc where
to find the library so it can link it into each doctest program:</p>
<pre><code class="language-bash">$ rustc doc.rs --crate-type lib
$ rustdoc --test --extern doc=&quot;libdoc.rlib&quot; doc.rs
</code></pre>
<h3><a class="header" href="#see-also-70" id="see-also-70">See also:</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments">The Rust Book: Making Useful Documentation Comments</a></li>
<li><a href="https://doc.rust-lang.org/rustdoc/index.html">The Rustdoc Book</a></li>
<li><a href="https://doc.rust-lang.org/stable/reference/comments.html#doc-comments">The Reference: Doc comments</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html#appendix-a-full-conventions-text">RFC 1574: API Documentation Conventions</a></li>
<li><a href="https://rust-lang.github.io/rfcs/1946-intra-rustdoc-links.html">RFC 1946: Relative links to other items from doc comments (intra-rustdoc links)</a></li>
<li><a href="https://www.reddit.com/r/rust/comments/ahb50s/is_there_any_documentation_style_guide_for/">Is there any documentation style guide for comments? (reddit)</a></li>
</ul>
<h1><a class="header" href="#introduction" id="introduction">Introduction</a></h1>
<blockquote>
<p>Note: This edition of the book is the same as <a href="https://nostarch.com/rust">The Rust Programming
Language</a> available in print and ebook format from <a href="https://nostarch.com/">No Starch
Press</a>.</p>
</blockquote>
<p>Welcome to <em>The Rust Programming Language</em>, an introductory book about Rust.
The Rust programming language helps you write faster, more reliable software.
High-level ergonomics and low-level control are often at odds in programming
language design; Rust challenges that conflict. Through balancing powerful
technical capacity and a great developer experience, Rust gives you the option
to control low-level details (such as memory usage) without all the hassle
traditionally associated with such control.</p>
<h2><a class="header" href="#who-rust-is-for" id="who-rust-is-for">Who Rust Is For</a></h2>
<p>Rust is ideal for many people for a variety of reasons. Let’s look at a few of
the most important groups.</p>
<h3><a class="header" href="#teams-of-developers" id="teams-of-developers">Teams of Developers</a></h3>
<p>Rust is proving to be a productive tool for collaborating among large teams of
developers with varying levels of systems programming knowledge. Low-level code
is prone to a variety of subtle bugs, which in most other languages can be
caught only through extensive testing and careful code review by experienced
developers. In Rust, the compiler plays a gatekeeper role by refusing to
compile code with these elusive bugs, including concurrency bugs. By working
alongside the compiler, the team can spend their time focusing on the program’s
logic rather than chasing down bugs.</p>
<p>Rust also brings contemporary developer tools to the systems programming world:</p>
<ul>
<li>Cargo, the included dependency manager and build tool, makes adding,
compiling, and managing dependencies painless and consistent across the Rust
ecosystem.</li>
<li>Rustfmt ensures a consistent coding style across developers.</li>
<li>The Rust Language Server powers Integrated Development Environment (IDE)
integration for code completion and inline error messages.</li>
</ul>
<p>By using these and other tools in the Rust ecosystem, developers can be
productive while writing systems-level code.</p>
<h3><a class="header" href="#students" id="students">Students</a></h3>
<p>Rust is for students and those who are interested in learning about systems
concepts. Using Rust, many people have learned about topics like operating
systems development. The community is very welcoming and happy to answer
student questions. Through efforts such as this book, the Rust teams want to
make systems concepts more accessible to more people, especially those new to
programming.</p>
<h3><a class="header" href="#companies" id="companies">Companies</a></h3>
<p>Hundreds of companies, large and small, use Rust in production for a variety of
tasks. Those tasks include command line tools, web services, DevOps tooling,
embedded devices, audio and video analysis and transcoding, cryptocurrencies,
bioinformatics, search engines, Internet of Things applications, machine
learning, and even major parts of the Firefox web browser.</p>
<h3><a class="header" href="#open-source-developers" id="open-source-developers">Open Source Developers</a></h3>
<p>Rust is for people who want to build the Rust programming language, community,
developer tools, and libraries. We’d love to have you contribute to the Rust
language.</p>
<h3><a class="header" href="#people-who-value-speed-and-stability" id="people-who-value-speed-and-stability">People Who Value Speed and Stability</a></h3>
<p>Rust is for people who crave speed and stability in a language. By speed, we
mean the speed of the programs that you can create with Rust and the speed at
which Rust lets you write them. The Rust compiler’s checks ensure stability
through feature additions and refactoring. This is in contrast to the brittle
legacy code in languages without these checks, which developers are often
afraid to modify. By striving for zero-cost abstractions, higher-level features
that compile to lower-level code as fast as code written manually, Rust
endeavors to make safe code be fast code as well.</p>
<p>The Rust language hopes to support many other users as well; those mentioned
here are merely some of the biggest stakeholders. Overall, Rust’s greatest
ambition is to eliminate the trade-offs that programmers have accepted for
decades by providing safety <em>and</em> productivity, speed <em>and</em> ergonomics. Give
Rust a try and see if its choices work for you.</p>
<h2><a class="header" href="#who-this-book-is-for" id="who-this-book-is-for">Who This Book Is For</a></h2>
<p>This book assumes that you’ve written code in another programming language but
doesn’t make any assumptions about which one. We’ve tried to make the material
broadly accessible to those from a wide variety of programming backgrounds. We
don’t spend a lot of time talking about what programming <em>is</em> or how to think
about it. If you’re entirely new to programming, you would be better served by
reading a book that specifically provides an introduction to programming.</p>
<h2><a class="header" href="#how-to-use-this-book" id="how-to-use-this-book">How to Use This Book</a></h2>
<p>In general, this book assumes that you’re reading it in sequence from front to
back. Later chapters build on concepts in earlier chapters, and earlier
chapters might not delve into details on a topic; we typically revisit the
topic in a later chapter.</p>
<p>You’ll find two kinds of chapters in this book: concept chapters and project
chapters. In concept chapters, you’ll learn about an aspect of Rust. In project
chapters, we’ll build small programs together, applying what you’ve learned so
far. Chapters 2, 12, and 20 are project chapters; the rest are concept chapters.</p>
<p>Chapter 1 explains how to install Rust, how to write a Hello, world! program,
and how to use Cargo, Rust’s package manager and build tool. Chapter 2 is a
hands-on introduction to the Rust language. Here we cover concepts at a high
level, and later chapters will provide additional detail. If you want to get
your hands dirty right away, Chapter 2 is the place for that. At first, you
might even want to skip Chapter 3, which covers Rust features similar to those
of other programming languages, and head straight to Chapter 4 to learn about
Rust’s ownership system. However, if you’re a particularly meticulous learner
who prefers to learn every detail before moving on to the next, you might want
to skip Chapter 2 and go straight to Chapter 3, returning to Chapter 2 when
you’d like to work on a project applying the details you’ve learned.</p>
<p>Chapter 5 discusses structs and methods, and Chapter 6 covers enums, <code>match</code>
expressions, and the <code>if let</code> control flow construct. You’ll use structs and
enums to make custom types in Rust.</p>
<p>In Chapter 7, you’ll learn about Rust’s module system and about privacy rules
for organizing your code and its public Application Programming Interface
(API). Chapter 8 discusses some common collection data structures that the
standard library provides, such as vectors, strings, and hash maps. Chapter 9
explores Rust’s error-handling philosophy and techniques.</p>
<p>Chapter 10 digs into generics, traits, and lifetimes, which give you the power
to define code that applies to multiple types. Chapter 11 is all about testing,
which even with Rust’s safety guarantees is necessary to ensure your program’s
logic is correct. In Chapter 12, we’ll build our own implementation of a subset
of functionality from the <code>grep</code> command line tool that searches for text
within files. For this, we’ll use many of the concepts we discussed in the
previous chapters.</p>
<p>Chapter 13 explores closures and iterators: features of Rust that come from
functional programming languages. In Chapter 14, we’ll examine Cargo in more
depth and talk about best practices for sharing your libraries with others.
Chapter 15 discusses smart pointers that the standard library provides and the
traits that enable their functionality.</p>
<p>In Chapter 16, we’ll walk through different models of concurrent programming
and talk about how Rust helps you to program in multiple threads fearlessly.
Chapter 17 looks at how Rust idioms compare to object-oriented programming
principles you might be familiar with.</p>
<p>Chapter 18 is a reference on patterns and pattern matching, which are powerful
ways of expressing ideas throughout Rust programs. Chapter 19 contains a
smorgasbord of advanced topics of interest, including unsafe Rust, macros, and
more about lifetimes, traits, types, functions, and closures.</p>
<p>In Chapter 20, we’ll complete a project in which we’ll implement a low-level
multithreaded web server!</p>
<p>Finally, some appendixes contain useful information about the language in a
more reference-like format. Appendix A covers Rust’s keywords, Appendix B
covers Rust’s operators and symbols, Appendix C covers derivable traits
provided by the standard library, Appendix D covers some useful development
tools, and Appendix E explains Rust editions.</p>
<p>There is no wrong way to read this book: if you want to skip ahead, go for it!
You might have to jump back to earlier chapters if you experience any
confusion. But do whatever works for you.</p>
<p><span id="ferris"></span></p>
<p>An important part of the process of learning Rust is learning how to read the
error messages the compiler displays: these will guide you toward working code.
As such, we’ll provide many examples that don’t compile along with the error
message the compiler will show you in each situation. Know that if you enter
and run a random example, it may not compile! Make sure you read the
surrounding text to see whether the example you’re trying to run is meant to
error. Ferris will also help you distinguish code that isn’t meant to work:</p>
<table><thead><tr><th>Ferris</th><th>Meaning</th></tr></thead><tbody>
<tr><td><img src="rustbook/img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>This code does not compile!</td></tr>
<tr><td><img src="rustbook/img/ferris/panics.svg" class="ferris-explain"/></td><td>This code panics!</td></tr>
<tr><td><img src="rustbook/img/ferris/unsafe.svg" class="ferris-explain"/></td><td>This code block contains unsafe code.</td></tr>
<tr><td><img src="rustbook/img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>This code does not produce the desired behavior.</td></tr>
</tbody></table>
<p>In most situations, we’ll lead you to the correct version of any code that
doesn’t compile.</p>
<h2><a class="header" href="#source-code" id="source-code">Source Code</a></h2>
<p>The source files from which this book is generated can be found on
<a href="https://github.com/rust-lang/book/tree/master/src">GitHub</a>.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting Started</a></h1>
<p>Let’s start your Rust journey! There’s a lot to learn, but every journey starts
somewhere. In this chapter, we’ll discuss:</p>
<ul>
<li>Installing Rust on Linux, macOS, and Windows</li>
<li>Writing a program that prints <code>Hello, world!</code></li>
<li>Using <code>cargo</code>, Rust’s package manager and build system</li>
</ul>
<h2><a class="header" href="#installation" id="installation">Installation</a></h2>
<p>The first step is to install Rust. We’ll download Rust through <code>rustup</code>, a
command line tool for managing Rust versions and associated tools. You’ll need
an internet connection for the download.</p>
<blockquote>
<p>Note: If you prefer not to use <code>rustup</code> for some reason, please see <a href="https://www.rust-lang.org/tools/install">the Rust
installation page</a> for other options.</p>
</blockquote>
<p>The following steps install the latest stable version of the Rust compiler.
Rust’s stability guarantees ensure that all the examples in the book that
compile will continue to compile with newer Rust versions. The output might
differ slightly between versions, because Rust often improves error messages
and warnings. In other words, any newer, stable version of Rust you install
using these steps should work as expected with the content of this book.</p>
<blockquote>
<h3><a class="header" href="#command-line-notation" id="command-line-notation">Command Line Notation</a></h3>
<p>In this chapter and throughout the book, we’ll show some commands used in the
terminal. Lines that you should enter in a terminal all start with <code>$</code>. You
don’t need to type in the <code>$</code> character; it indicates the start of each
command. Lines that don’t start with <code>$</code> typically show the output of the
previous command. Additionally, PowerShell-specific examples will use <code>&gt;</code>
rather than <code>$</code>.</p>
</blockquote>
<h3><a class="header" href="#installing-rustup-on-linux-or-macos" id="installing-rustup-on-linux-or-macos">Installing <code>rustup</code> on Linux or macOS</a></h3>
<p>If you’re using Linux or macOS, open a terminal and enter the following command:</p>
<pre><code class="language-text">$ curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>The command downloads a script and starts the installation of the <code>rustup</code>
tool, which installs the latest stable version of Rust. You might be prompted
for your password. If the install is successful, the following line will appear:</p>
<pre><code class="language-text">Rust is installed now. Great!
</code></pre>
<p>If you prefer, feel free to download the script and inspect it before running
it.</p>
<p>The installation script automatically adds Rust to your system PATH after your
next login. If you want to start using Rust right away instead of restarting
your terminal, run the following command in your shell to add Rust to your
system PATH manually:</p>
<pre><code class="language-text">$ source $HOME/.cargo/env
</code></pre>
<p>Alternatively, you can add the following line to your <em>~/.bash_profile</em>:</p>
<pre><code class="language-text">$ export PATH=&quot;$HOME/.cargo/bin:$PATH&quot;
</code></pre>
<p>Additionally, you’ll need a linker of some kind. It’s likely one is already
installed, but when you try to compile a Rust program and get errors indicating
that a linker could not execute, that means a linker isn’t installed on your
system and you’ll need to install one manually. C compilers usually come with
the correct linker. Check your platform’s documentation for how to install a C
compiler. Also, some common Rust packages depend on C code and will need a C
compiler. Therefore, it might be worth installing one now.</p>
<h3><a class="header" href="#installing-rustup-on-windows" id="installing-rustup-on-windows">Installing <code>rustup</code> on Windows</a></h3>
<p>On Windows, go to <a href="https://www.rust-lang.org/tools/install">https://www.rust-lang.org/tools/install</a> and follow
the instructions for installing Rust. At some point in the installation, you’ll
receive a message explaining that you’ll also need the C++ build tools for
Visual Studio 2013 or later. The easiest way to acquire the build tools is to
install <a href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2019">Build Tools for Visual Studio 2019</a>. The tools are in
the Other Tools and Frameworks section.</p>
<p>The rest of this book uses commands that work in both <em>cmd.exe</em> and PowerShell.
If there are specific differences, we’ll explain which to use.</p>
<h3><a class="header" href="#updating-and-uninstalling" id="updating-and-uninstalling">Updating and Uninstalling</a></h3>
<p>After you’ve installed Rust via <code>rustup</code>, updating to the latest version is
easy. From your shell, run the following update script:</p>
<pre><code class="language-text">$ rustup update
</code></pre>
<p>To uninstall Rust and <code>rustup</code>, run the following uninstall script from your
shell:</p>
<pre><code class="language-text">$ rustup self uninstall
</code></pre>
<h3><a class="header" href="#troubleshooting" id="troubleshooting">Troubleshooting</a></h3>
<p>To check whether you have Rust installed correctly, open a shell and enter this
line:</p>
<pre><code class="language-text">$ rustc --version
</code></pre>
<p>You should see the version number, commit hash, and commit date for the latest
stable version that has been released in the following format:</p>
<pre><code class="language-text">rustc x.y.z (abcabcabc yyyy-mm-dd)
</code></pre>
<p>If you see this information, you have installed Rust successfully! If you don’t
see this information and you’re on Windows, check that Rust is in your <code>%PATH%</code>
system variable. If that’s all correct and Rust still isn’t working, there are
a number of places you can get help. The easiest is the #beginners channel on
<a href="https://discord.gg/rust-lang">the official Rust Discord</a>. There, you can chat with other Rustaceans
(a silly nickname we call ourselves) who can help you out. Other great
resources include <a href="https://users.rust-lang.org/">the Users forum</a> and <a href="http://stackoverflow.com/questions/tagged/rust">Stack Overflow</a>.</p>
<h3><a class="header" href="#local-documentation" id="local-documentation">Local Documentation</a></h3>
<p>The installer also includes a copy of the documentation locally, so you can
read it offline. Run <code>rustup doc</code> to open the local documentation in your
browser.</p>
<p>Any time a type or function is provided by the standard library and you’re not
sure what it does or how to use it, use the application programming interface
(API) documentation to find out!</p>
<h2><a class="header" href="#hello-world-1" id="hello-world-1">Hello, World!</a></h2>
<p>Now that you’ve installed Rust, let’s write your first Rust program. It’s
traditional when learning a new language to write a little program that prints
the text <code>Hello, world!</code> to the screen, so we’ll do the same here!</p>
<blockquote>
<p>Note: This book assumes basic familiarity with the command line. Rust makes
no specific demands about your editing or tooling or where your code lives, so
if you prefer to use an integrated development environment (IDE) instead of
the command line, feel free to use your favorite IDE. Many IDEs now have some
degree of Rust support; check the IDE’s documentation for details. Recently,
the Rust team has been focusing on enabling great IDE support, and progress
has been made rapidly on that front!</p>
</blockquote>
<h3><a class="header" href="#creating-a-project-directory" id="creating-a-project-directory">Creating a Project Directory</a></h3>
<p>You’ll start by making a directory to store your Rust code. It doesn’t matter
to Rust where your code lives, but for the exercises and projects in this book,
we suggest making a <em>projects</em> directory in your home directory and keeping all
your projects there.</p>
<p>Open a terminal and enter the following commands to make a <em>projects</em> directory
and a directory for the Hello, world! project within the <em>projects</em> directory.</p>
<p>For Linux, macOS, and PowerShell on Windows, enter this:</p>
<pre><code class="language-text">$ mkdir ~/projects
$ cd ~/projects
$ mkdir hello_world
$ cd hello_world
</code></pre>
<p>For Windows CMD, enter this:</p>
<pre><code class="language-cmd">&gt; mkdir &quot;%USERPROFILE%\projects&quot;
&gt; cd /d &quot;%USERPROFILE%\projects&quot;
&gt; mkdir hello_world
&gt; cd hello_world
</code></pre>
<h3><a class="header" href="#writing-and-running-a-rust-program" id="writing-and-running-a-rust-program">Writing and Running a Rust Program</a></h3>
<p>Next, make a new source file and call it <em>main.rs</em>. Rust files always end with
the <em>.rs</em> extension. If you’re using more than one word in your filename, use
an underscore to separate them. For example, use <em>hello_world.rs</em> rather than
<em>helloworld.rs</em>.</p>
<p>Now open the <em>main.rs</em> file you just created and enter the code in Listing 1-1.</p>
<p><span class="filename">Filename: main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 1-1: A program that prints <code>Hello, world!</code></span></p>
<p>Save the file and go back to your terminal window. On Linux or macOS, enter
the following commands to compile and run the file:</p>
<pre><code class="language-text">$ rustc main.rs
$ ./main
Hello, world!
</code></pre>
<p>On Windows, enter the command <code>.\main.exe</code> instead of <code>./main</code>:</p>
<pre><code class="language-powershell">&gt; rustc main.rs
&gt; .\main.exe
Hello, world!
</code></pre>
<p>Regardless of your operating system, the string <code>Hello, world!</code> should print to
the terminal. If you don’t see this output, refer back to the
<a href="rustbook/ch01-01-installation.html#troubleshooting">“Troubleshooting”</a><!-- ignore --> part of the Installation
section for ways to get help.</p>
<p>If <code>Hello, world!</code> did print, congratulations! You’ve officially written a Rust
program. That makes you a Rust programmer—welcome!</p>
<h3><a class="header" href="#anatomy-of-a-rust-program" id="anatomy-of-a-rust-program">Anatomy of a Rust Program</a></h3>
<p>Let’s review in detail what just happened in your Hello, world! program.
Here’s the first piece of the puzzle:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {

}
</code></pre></pre>
<p>These lines define a function in Rust. The <code>main</code> function is special: it is
always the first code that runs in every executable Rust program. The first
line declares a function named <code>main</code> that has no parameters and returns
nothing. If there were parameters, they would go inside the parentheses, <code>()</code>.</p>
<p>Also, note that the function body is wrapped in curly brackets, <code>{}</code>. Rust
requires these around all function bodies. It’s good style to place the opening
curly bracket on the same line as the function declaration, adding one space in
between.</p>
<p>At the time of this writing, an automatic formatter tool called <code>rustfmt</code> is
under development. If you want to stick to a standard style across Rust
projects, <code>rustfmt</code> will format your code in a particular style. The Rust team
plans to eventually include this tool with the standard Rust distribution, like
<code>rustc</code>. So depending on when you read this book, it might already be installed
on your computer! Check the online documentation for more details.</p>
<p>Inside the <code>main</code> function is the following code:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>    println!(&quot;Hello, world!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>This line does all the work in this little program: it prints text to the
screen. There are four important details to notice here. First, Rust style is
to indent with four spaces, not a tab.</p>
<p>Second, <code>println!</code> calls a Rust macro. If it called a function instead, it
would be entered as <code>println</code> (without the <code>!</code>). We’ll discuss Rust macros in
more detail in Chapter 19. For now, you just need to know that using a <code>!</code>
means that you’re calling a macro instead of a normal function.</p>
<p>Third, you see the <code>&quot;Hello, world!&quot;</code> string. We pass this string as an argument
to <code>println!</code>, and the string is printed to the screen.</p>
<p>Fourth, we end the line with a semicolon (<code>;</code>), which indicates that this
expression is over and the next one is ready to begin. Most lines of Rust code
end with a semicolon.</p>
<h3><a class="header" href="#compiling-and-running-are-separate-steps" id="compiling-and-running-are-separate-steps">Compiling and Running Are Separate Steps</a></h3>
<p>You’ve just run a newly created program, so let’s examine each step in the
process.</p>
<p>Before running a Rust program, you must compile it using the Rust compiler by
entering the <code>rustc</code> command and passing it the name of your source file, like
this:</p>
<pre><code class="language-text">$ rustc main.rs
</code></pre>
<p>If you have a C or C++ background, you’ll notice that this is similar to <code>gcc</code>
or <code>clang</code>. After compiling successfully, Rust outputs a binary executable.</p>
<p>On Linux, macOS, and PowerShell on Windows, you can see the executable by
entering the <code>ls</code> command in your shell. On Linux and macOS, you’ll see two
files. With PowerShell on Windows, you’ll see the same three files that you
would see using CMD.</p>
<pre><code class="language-text">$ ls
main  main.rs
</code></pre>
<p>With CMD on Windows, you would enter the following:</p>
<pre><code class="language-cmd">&gt; dir /B %= the /B option says to only show the file names =%
main.exe
main.pdb
main.rs
</code></pre>
<p>This shows the source code file with the <em>.rs</em> extension, the executable file
(<em>main.exe</em> on Windows, but <em>main</em> on all other platforms), and, when using
Windows, a file containing debugging information with the <em>.pdb</em> extension.
From here, you run the <em>main</em> or <em>main.exe</em> file, like this:</p>
<pre><code class="language-text">$ ./main # or .\main.exe on Windows
</code></pre>
<p>If <em>main.rs</em> was your Hello, world! program, this line would print <code>Hello, world!</code> to your terminal.</p>
<p>If you’re more familiar with a dynamic language, such as Ruby, Python, or
JavaScript, you might not be used to compiling and running a program as
separate steps. Rust is an <em>ahead-of-time compiled</em> language, meaning you can
compile a program and give the executable to someone else, and they can run it
even without having Rust installed. If you give someone a <em>.rb</em>, <em>.py</em>, or
<em>.js</em> file, they need to have a Ruby, Python, or JavaScript implementation
installed (respectively). But in those languages, you only need one command to
compile and run your program. Everything is a trade-off in language design.</p>
<p>Just compiling with <code>rustc</code> is fine for simple programs, but as your project
grows, you’ll want to manage all the options and make it easy to share your
code. Next, we’ll introduce you to the Cargo tool, which will help you write
real-world Rust programs.</p>
<h2><a class="header" href="#hello-cargo" id="hello-cargo">Hello, Cargo!</a></h2>
<p>Cargo is Rust’s build system and package manager. Most Rustaceans use this tool
to manage their Rust projects because Cargo handles a lot of tasks for you,
such as building your code, downloading the libraries your code depends on, and
building those libraries. (We call libraries your code needs <em>dependencies</em>.)</p>
<p>The simplest Rust programs, like the one we’ve written so far, don’t have any
dependencies. So if we had built the Hello, world! project with Cargo, it would
only use the part of Cargo that handles building your code. As you write more
complex Rust programs, you’ll add dependencies, and if you start a project
using Cargo, adding dependencies will be much easier to do.</p>
<p>Because the vast majority of Rust projects use Cargo, the rest of this book
assumes that you’re using Cargo too. Cargo comes installed with Rust if you
used the official installers discussed in the
<a href="rustbook/ch01-01-installation.html#installation">“Installation”</a><!-- ignore --> section. If you installed Rust
through some other means, check whether Cargo is installed by entering the
following into your terminal:</p>
<pre><code class="language-text">$ cargo --version
</code></pre>
<p>If you see a version number, you have it! If you see an error, such as <code>command not found</code>, look at the documentation for your method of installation to
determine how to install Cargo separately.</p>
<h3><a class="header" href="#creating-a-project-with-cargo" id="creating-a-project-with-cargo">Creating a Project with Cargo</a></h3>
<p>Let’s create a new project using Cargo and look at how it differs from our
original Hello, world! project. Navigate back to your <em>projects</em> directory (or
wherever you decided to store your code). Then, on any operating system, run
the following:</p>
<pre><code class="language-text">$ cargo new hello_cargo
$ cd hello_cargo
</code></pre>
<p>The first command creates a new directory called <em>hello_cargo</em>. We’ve named
our project <em>hello_cargo</em>, and Cargo creates its files in a directory of the
same name.</p>
<p>Go into the <em>hello_cargo</em> directory and list the files. You’ll see that Cargo
has generated two files and one directory for us: a <em>Cargo.toml</em> file and a
<em>src</em> directory with a <em>main.rs</em> file inside. It has also initialized a new Git
repository along with a <em>.gitignore</em> file.</p>
<blockquote>
<p>Note: Git is a common version control system. You can change <code>cargo new</code> to
use a different version control system or no version control system by using
the <code>--vcs</code> flag. Run <code>cargo new --help</code> to see the available options.</p>
</blockquote>
<p>Open <em>Cargo.toml</em> in your text editor of choice. It should look similar to the
code in Listing 1-2.</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;hello_cargo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p><span class="caption">Listing 1-2: Contents of <em>Cargo.toml</em> generated by <code>cargo new</code></span></p>
<p>This file is in the <a href="https://github.com/toml-lang/toml"><em>TOML</em></a><!-- ignore --> (<em>Tom’s Obvious, Minimal
Language</em>) format, which is Cargo’s configuration format.</p>
<p>The first line, <code>[package]</code>, is a section heading that indicates that the
following statements are configuring a package. As we add more information to
this file, we’ll add other sections.</p>
<p>The next four lines set the configuration information Cargo needs to compile
your program: the name, the version, who wrote it, and the edition of Rust to
use. Cargo gets your name and email information from your environment, so if
that information is not correct, fix the information now and then save the
file. We’ll talk about the <code>edition</code> key in Appendix E.</p>
<p>The last line, <code>[dependencies]</code>, is the start of a section for you to list any
of your project’s dependencies. In Rust, packages of code are referred to as
<em>crates</em>. We won’t need any other crates for this project, but we will in the
first project in Chapter 2, so we’ll use this dependencies section then.</p>
<p>Now open <em>src/main.rs</em> and take a look:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Cargo has generated a Hello, world! program for you, just like the one we wrote
in Listing 1-1! So far, the differences between our previous project and the
project Cargo generates are that Cargo placed the code in the <em>src</em> directory,
and we have a <em>Cargo.toml</em> configuration file in the top directory.</p>
<p>Cargo expects your source files to live inside the <em>src</em> directory. The
top-level project directory is just for README files, license information,
configuration files, and anything else not related to your code. Using Cargo
helps you organize your projects. There’s a place for everything, and
everything is in its place.</p>
<p>If you started a project that doesn’t use Cargo, as we did with the Hello,
world! project, you can convert it to a project that does use Cargo. Move the
project code into the <em>src</em> directory and create an appropriate <em>Cargo.toml</em>
file.</p>
<h3><a class="header" href="#building-and-running-a-cargo-project" id="building-and-running-a-cargo-project">Building and Running a Cargo Project</a></h3>
<p>Now let’s look at what’s different when we build and run the Hello, world!
program with Cargo! From your <em>hello_cargo</em> directory, build your project by
entering the following command:</p>
<pre><code class="language-text">$ cargo build
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 2.85 secs
</code></pre>
<p>This command creates an executable file in <em>target/debug/hello_cargo</em> (or
<em>target\debug\hello_cargo.exe</em> on Windows) rather than in your current
directory. You can run the executable with this command:</p>
<pre><code class="language-text">$ ./target/debug/hello_cargo # or .\target\debug\hello_cargo.exe on Windows
Hello, world!
</code></pre>
<p>If all goes well, <code>Hello, world!</code> should print to the terminal. Running <code>cargo build</code> for the first time also causes Cargo to create a new file at the top
level: <em>Cargo.lock</em>. This file keeps track of the exact versions of
dependencies in your project. This project doesn’t have dependencies, so the
file is a bit sparse. You won’t ever need to change this file manually; Cargo
manages its contents for you.</p>
<p>We just built a project with <code>cargo build</code> and ran it with
<code>./target/debug/hello_cargo</code>, but we can also use <code>cargo run</code> to compile the
code and then run the resulting executable all in one command:</p>
<pre><code class="language-text">$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Notice that this time we didn’t see output indicating that Cargo was compiling
<code>hello_cargo</code>. Cargo figured out that the files hadn’t changed, so it just ran
the binary. If you had modified your source code, Cargo would have rebuilt the
project before running it, and you would have seen this output:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33 secs
     Running `target/debug/hello_cargo`
Hello, world!
</code></pre>
<p>Cargo also provides a command called <code>cargo check</code>. This command quickly checks
your code to make sure it compiles but doesn’t produce an executable:</p>
<pre><code class="language-text">$ cargo check
   Checking hello_cargo v0.1.0 (file:///projects/hello_cargo)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>Why would you not want an executable? Often, <code>cargo check</code> is much faster than
<code>cargo build</code>, because it skips the step of producing an executable. If you’re
continually checking your work while writing the code, using <code>cargo check</code> will
speed up the process! As such, many Rustaceans run <code>cargo check</code> periodically
as they write their program to make sure it compiles. Then they run <code>cargo build</code> when they’re ready to use the executable.</p>
<p>Let’s recap what we’ve learned so far about Cargo:</p>
<ul>
<li>We can build a project using <code>cargo build</code> or <code>cargo check</code>.</li>
<li>We can build and run a project in one step using <code>cargo run</code>.</li>
<li>Instead of saving the result of the build in the same directory as our code,
Cargo stores it in the <em>target/debug</em> directory.</li>
</ul>
<p>An additional advantage of using Cargo is that the commands are the same no
matter which operating system you’re working on. So, at this point, we’ll no
longer provide specific instructions for Linux and macOS versus Windows.</p>
<h3><a class="header" href="#building-for-release" id="building-for-release">Building for Release</a></h3>
<p>When your project is finally ready for release, you can use <code>cargo build --release</code> to compile it with optimizations. This command will create an
executable in <em>target/release</em> instead of <em>target/debug</em>. The optimizations
make your Rust code run faster, but turning them on lengthens the time it takes
for your program to compile. This is why there are two different profiles: one
for development, when you want to rebuild quickly and often, and another for
building the final program you’ll give to a user that won’t be rebuilt
repeatedly and that will run as fast as possible. If you’re benchmarking your
code’s running time, be sure to run <code>cargo build --release</code> and benchmark with
the executable in <em>target/release</em>.</p>
<h3><a class="header" href="#cargo-as-convention" id="cargo-as-convention">Cargo as Convention</a></h3>
<p>With simple projects, Cargo doesn’t provide a lot of value over just using
<code>rustc</code>, but it will prove its worth as your programs become more intricate.
With complex projects composed of multiple crates, it’s much easier to let
Cargo coordinate the build.</p>
<p>Even though the <code>hello_cargo</code> project is simple, it now uses much of the real
tooling you’ll use in the rest of your Rust career. In fact, to work on any
existing projects, you can use the following commands to check out the code
using Git, change to that project’s directory, and build:</p>
<pre><code class="language-text">$ git clone someurl.com/someproject
$ cd someproject
$ cargo build
</code></pre>
<p>For more information about Cargo, check out <a href="https://doc.rust-lang.org/cargo/">its documentation</a>.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>You’re already off to a great start on your Rust journey! In this chapter,
you’ve learned how to:</p>
<ul>
<li>Install the latest stable version of Rust using <code>rustup</code></li>
<li>Update to a newer Rust version</li>
<li>Open locally installed documentation</li>
<li>Write and run a Hello, world! program using <code>rustc</code> directly</li>
<li>Create and run a new project using the conventions of Cargo</li>
</ul>
<p>This is a great time to build a more substantial program to get used to reading
and writing Rust code. So, in Chapter 2, we’ll build a guessing game program.
If you would rather start by learning how common programming concepts work in
Rust, see Chapter 3 and then return to Chapter 2.</p>
<h1><a class="header" href="#programming-a-guessing-game" id="programming-a-guessing-game">Programming a Guessing Game</a></h1>
<p>Let’s jump into Rust by working through a hands-on project together! This
chapter introduces you to a few common Rust concepts by showing you how to use
them in a real program. You’ll learn about <code>let</code>, <code>match</code>, methods, associated
functions, using external crates, and more! The following chapters will explore
these ideas in more detail. In this chapter, you’ll practice the fundamentals.</p>
<p>We’ll implement a classic beginner programming problem: a guessing game. Here’s
how it works: the program will generate a random integer between 1 and 100. It
will then prompt the player to enter a guess. After a guess is entered, the
program will indicate whether the guess is too low or too high. If the guess is
correct, the game will print a congratulatory message and exit.</p>
<h2><a class="header" href="#setting-up-a-new-project" id="setting-up-a-new-project">Setting Up a New Project</a></h2>
<p>To set up a new project, go to the <em>projects</em> directory that you created in
Chapter 1 and make a new project using Cargo, like so:</p>
<pre><code class="language-text">$ cargo new guessing_game
$ cd guessing_game
</code></pre>
<p>The first command, <code>cargo new</code>, takes the name of the project (<code>guessing_game</code>)
as the first argument. The second command changes to the new project’s
directory.</p>
<p>Look at the generated <em>Cargo.toml</em> file:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;

[dependencies]
</code></pre>
<p>If the author information that Cargo obtained from your environment is not
correct, fix that in the file and save it again.</p>
<p>As you saw in Chapter 1, <code>cargo new</code> generates a “Hello, world!” program for
you. Check out the <em>src/main.rs</em> file:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Now let’s compile this “Hello, world!” program and run it in the same step
using the <code>cargo run</code> command:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Hello, world!
</code></pre>
<p>The <code>run</code> command comes in handy when you need to rapidly iterate on a project,
as we’ll do in this game, quickly testing each iteration before moving on to
the next one.</p>
<p>Reopen the <em>src/main.rs</em> file. You’ll be writing all the code in this file.</p>
<h2><a class="header" href="#processing-a-guess" id="processing-a-guess">Processing a Guess</a></h2>
<p>The first part of the guessing game program will ask for user input, process
that input, and check that the input is in the expected form. To start, we’ll
allow the player to input a guess. Enter the code in Listing 2-1 into
<em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;

fn main() {
    println!(&quot;Guess the number!&quot;);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Listing 2-1: Code that gets a guess from the user and
prints it</span></p>
<p>This code contains a lot of information, so let’s go over it line by line. To
obtain user input and then print the result as output, we need to bring the
<code>io</code> (input/output) library into scope. The <code>io</code> library comes from the
standard library (which is known as <code>std</code>):</p>
<pre><code class="language-rust ignore">use std::io;
</code></pre>
<p>By default, Rust brings only a few types into the scope of every program in
<a href="rustbook/../std/prelude/index.html">the <em>prelude</em></a><!-- ignore -->. If a type you want to use isn’t in the
prelude, you have to bring that type into scope explicitly with a <code>use</code>
statement. Using the <code>std::io</code> library provides you with a number of useful
features, including the ability to accept user input.</p>
<p>As you saw in Chapter 1, the <code>main</code> function is the entry point into the
program:</p>
<pre><code class="language-rust ignore">fn main() {
</code></pre>
<p>The <code>fn</code> syntax declares a new function, the parentheses, <code>()</code>, indicate there
are no parameters, and the curly bracket, <code>{</code>, starts the body of the function.</p>
<p>As you also learned in Chapter 1, <code>println!</code> is a macro that prints a string to
the screen:</p>
<pre><code class="language-rust ignore">println!(&quot;Guess the number!&quot;);

println!(&quot;Please input your guess.&quot;);
</code></pre>
<p>This code is printing a prompt stating what the game is and requesting input
from the user.</p>
<h3><a class="header" href="#storing-values-with-variables" id="storing-values-with-variables">Storing Values with Variables</a></h3>
<p>Next, we’ll create a place to store the user input, like this:</p>
<pre><code class="language-rust ignore">let mut guess = String::new();
</code></pre>
<p>Now the program is getting interesting! There’s a lot going on in this little
line. Notice that this is a <code>let</code> statement, which is used to create a
<em>variable</em>. Here’s another example:</p>
<pre><code class="language-rust ignore">let foo = bar;
</code></pre>
<p>This line creates a new variable named <code>foo</code> and binds it to the value of the
<code>bar</code> variable. In Rust, variables are immutable by default. We’ll be
discussing this concept in detail in the <a href="rustbook/ch03-01-variables-and-mutability.html#variables-and-mutability">“Variables and
Mutability”</a><!-- ignore --> section in Chapter 3.
The following example shows how to use <code>mut</code> before the variable name to make
a variable mutable:</p>
<pre><code class="language-rust ignore">let foo = 5; // immutable
let mut bar = 5; // mutable
</code></pre>
<blockquote>
<p>Note: The <code>//</code> syntax starts a comment that continues until the end of the
line. Rust ignores everything in comments, which are discussed in more detail
in Chapter 3.</p>
</blockquote>
<p>Let’s return to the guessing game program. You now know that <code>let mut guess</code>
will introduce a mutable variable named <code>guess</code>. On the other side of the equal
sign (<code>=</code>) is the value that <code>guess</code> is bound to, which is the result of
calling <code>String::new</code>, a function that returns a new instance of a <code>String</code>.
<a href="rustbook/../std/string/struct.String.html"><code>String</code></a><!-- ignore --> is a string type provided by the standard
library that is a growable, UTF-8 encoded bit of text.</p>
<p>The <code>::</code> syntax in the <code>::new</code> line indicates that <code>new</code> is an <em>associated
function</em> of the <code>String</code> type. An associated function is implemented on a type,
in this case <code>String</code>, rather than on a particular instance of a <code>String</code>. Some
languages call this a <em>static method</em>.</p>
<p>This <code>new</code> function creates a new, empty string. You’ll find a <code>new</code> function
on many types, because it’s a common name for a function that makes a new value
of some kind.</p>
<p>To summarize, the <code>let mut guess = String::new();</code> line has created a mutable
variable that is currently bound to a new, empty instance of a <code>String</code>. Whew!</p>
<p>Recall that we included the input/output functionality from the standard
library with <code>use std::io;</code> on the first line of the program. Now we’ll call
the <code>stdin</code> function from the <code>io</code> module:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);
</code></pre>
<p>If we hadn’t listed the <code>use std::io</code> line at the beginning of the program, we
could have written this function call as <code>std::io::stdin</code>. The <code>stdin</code> function
returns an instance of <a href="rustbook/../std/io/struct.Stdin.html"><code>std::io::Stdin</code></a><!-- ignore -->, which is a
type that represents a handle to the standard input for your terminal.</p>
<p>The next part of the code, <code>.read_line(&amp;mut guess)</code>, calls the
<a href="rustbook/../std/io/struct.Stdin.html#method.read_line"><code>read_line</code></a><!-- ignore --> method on the standard input handle to
get input from the user. We’re also passing one argument to <code>read_line</code>: <code>&amp;mut guess</code>.</p>
<p>The job of <code>read_line</code> is to take whatever the user types into standard input
and place that into a string, so it takes that string as an argument. The
string argument needs to be mutable so the method can change the string’s
content by adding the user input.</p>
<p>The <code>&amp;</code> indicates that this argument is a <em>reference</em>, which gives you a way to
let multiple parts of your code access one piece of data without needing to
copy that data into memory multiple times. References are a complex feature,
and one of Rust’s major advantages is how safe and easy it is to use
references. You don’t need to know a lot of those details to finish this
program. For now, all you need to know is that like variables, references are
immutable by default. Hence, you need to write <code>&amp;mut guess</code> rather than
<code>&amp;guess</code> to make it mutable. (Chapter 4 will explain references more
thoroughly.)</p>
<h3><a class="header" href="#handling-potential-failure-with-the-result-type" id="handling-potential-failure-with-the-result-type">Handling Potential Failure with the <code>Result</code> Type</a></h3>
<p>We’re not quite done with this line of code. Although what we’ve discussed so
far is a single line of text, it’s only the first part of the single logical
line of code. The second part is this method:</p>
<pre><code class="language-rust ignore">.expect(&quot;Failed to read line&quot;);
</code></pre>
<p>When you call a method with the <code>.foo()</code> syntax, it’s often wise to introduce a
newline and other whitespace to help break up long lines. We could have
written this code as:</p>
<pre><code class="language-rust ignore">io::stdin().read_line(&amp;mut guess).expect(&quot;Failed to read line&quot;);
</code></pre>
<p>However, one long line is difficult to read, so it’s best to divide it: two
lines for two method calls. Now let’s discuss what this line does.</p>
<p>As mentioned earlier, <code>read_line</code> puts what the user types into the string
we’re passing it, but it also returns a value—in this case, an
<a href="rustbook/../std/io/type.Result.html"><code>io::Result</code></a><!-- ignore -->. Rust has a number of types named
<code>Result</code> in its standard library: a generic <a href="rustbook/../std/result/enum.Result.html"><code>Result</code></a><!-- ignore -->
as well as specific versions for submodules, such as <code>io::Result</code>.</p>
<p>The <code>Result</code> types are <a href="rustbook/ch06-00-enums.html"><em>enumerations</em></a><!-- ignore -->, often referred
to as <em>enums</em>. An enumeration is a type that can have a fixed set of values,
and those values are called the enum’s <em>variants</em>. Chapter 6 will cover enums
in more detail.</p>
<p>For <code>Result</code>, the variants are <code>Ok</code> or <code>Err</code>. The <code>Ok</code> variant indicates the
operation was successful, and inside <code>Ok</code> is the successfully generated value.
The <code>Err</code> variant means the operation failed, and <code>Err</code> contains information
about how or why the operation failed.</p>
<p>The purpose of these <code>Result</code> types is to encode error-handling information.
Values of the <code>Result</code> type, like values of any type, have methods defined on
them. An instance of <code>io::Result</code> has an <a href="rustbook/../std/result/enum.Result.html#method.expect"><code>expect</code> method</a><!-- ignore
--> that you can call. If this instance of <code>io::Result</code> is an <code>Err</code> value,
<code>expect</code> will cause the program to crash and display the message that you
passed as an argument to <code>expect</code>. If the <code>read_line</code> method returns an <code>Err</code>,
it would likely be the result of an error coming from the underlying operating
system. If this instance of <code>io::Result</code> is an <code>Ok</code> value, <code>expect</code> will take
the return value that <code>Ok</code> is holding and return just that value to you so you
can use it. In this case, that value is the number of bytes in what the user
entered into standard input.</p>
<p>If you don’t call <code>expect</code>, the program will compile, but you’ll get a warning:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
warning: unused `std::result::Result` which must be used
  --&gt; src/main.rs:10:5
   |
10 |     io::stdin().read_line(&amp;mut guess);
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>Rust warns that you haven’t used the <code>Result</code> value returned from <code>read_line</code>,
indicating that the program hasn’t handled a possible error.</p>
<p>The right way to suppress the warning is to actually write error handling, but
because you just want to crash this program when a problem occurs, you can use
<code>expect</code>. You’ll learn about recovering from errors in Chapter 9.</p>
<h3><a class="header" href="#printing-values-with-println-placeholders" id="printing-values-with-println-placeholders">Printing Values with <code>println!</code> Placeholders</a></h3>
<p>Aside from the closing curly brackets, there’s only one more line to discuss in
the code added so far, which is the following:</p>
<pre><code class="language-rust ignore">println!(&quot;You guessed: {}&quot;, guess);
</code></pre>
<p>This line prints the string we saved the user’s input in. The set of curly
brackets, <code>{}</code>, is a placeholder: think of <code>{}</code> as little crab pincers that
hold a value in place. You can print more than one value using curly brackets:
the first set of curly brackets holds the first value listed after the format
string, the second set holds the second value, and so on. Printing multiple
values in one call to <code>println!</code> would look like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = 10;

println!(&quot;x = {} and y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>This code would print <code>x = 5 and y = 10</code>.</p>
<h3><a class="header" href="#testing-the-first-part" id="testing-the-first-part">Testing the First Part</a></h3>
<p>Let’s test the first part of the guessing game. Run it using <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
Please input your guess.
6
You guessed: 6
</code></pre>
<p>At this point, the first part of the game is done: we’re getting input from the
keyboard and then printing it.</p>
<h2><a class="header" href="#generating-a-secret-number" id="generating-a-secret-number">Generating a Secret Number</a></h2>
<p>Next, we need to generate a secret number that the user will try to guess. The
secret number should be different every time so the game is fun to play more
than once. Let’s use a random number between 1 and 100 so the game isn’t too
difficult. Rust doesn’t yet include random number functionality in its standard
library. However, the Rust team does provide a <a href="https://crates.io/crates/rand"><code>rand</code> crate</a>.</p>
<h3><a class="header" href="#using-a-crate-to-get-more-functionality" id="using-a-crate-to-get-more-functionality">Using a Crate to Get More Functionality</a></h3>
<p>Remember that a crate is a collection of Rust source code files.
The project we’ve been building is a <em>binary crate</em>, which is an executable.
The <code>rand</code> crate is a <em>library crate</em>, which contains code intended to be
used in other programs.</p>
<p>Cargo’s use of external crates is where it really shines. Before we can write
code that uses <code>rand</code>, we need to modify the <em>Cargo.toml</em> file to include the
<code>rand</code> crate as a dependency. Open that file now and add the following line to
the bottom beneath the <code>[dependencies]</code> section header that Cargo created for
you:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>In the <em>Cargo.toml</em> file, everything that follows a header is part of a section
that continues until another section starts. The <code>[dependencies]</code> section is
where you tell Cargo which external crates your project depends on and which
versions of those crates you require. In this case, we’ll specify the <code>rand</code>
crate with the semantic version specifier <code>0.3.14</code>. Cargo understands <a href="http://semver.org">Semantic
Versioning</a><!-- ignore --> (sometimes called <em>SemVer</em>), which is a
standard for writing version numbers. The number <code>0.3.14</code> is actually shorthand
for <code>^0.3.14</code>, which means “any version that has a public API compatible with
version 0.3.14.”</p>
<p>Now, without changing any of the code, let’s build the project, as shown in
Listing 2-2.</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
 Downloading libc v0.2.14
   Compiling libc v0.2.14
   Compiling rand v0.3.14
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p><span class="caption">Listing 2-2: The output from running <code>cargo build</code> after
adding the rand crate as a dependency</span></p>
<p>You may see different version numbers (but they will all be compatible with
the code, thanks to SemVer!), and the lines may be in a different order.</p>
<p>Now that we have an external dependency, Cargo fetches the latest versions of
everything from the <em>registry</em>, which is a copy of data from
<a href="https://crates.io/">Crates.io</a>. Crates.io is where people in the Rust ecosystem post
their open source Rust projects for others to use.</p>
<p>After updating the registry, Cargo checks the <code>[dependencies]</code> section and
downloads any crates you don’t have yet. In this case, although we only listed
<code>rand</code> as a dependency, Cargo also grabbed a copy of <code>libc</code>, because <code>rand</code>
depends on <code>libc</code> to work. After downloading the crates, Rust compiles them and
then compiles the project with the dependencies available.</p>
<p>If you immediately run <code>cargo build</code> again without making any changes, you
won’t get any output aside from the <code>Finished</code> line. Cargo knows it has already
downloaded and compiled the dependencies, and you haven’t changed anything
about them in your <em>Cargo.toml</em> file. Cargo also knows that you haven’t changed
anything about your code, so it doesn’t recompile that either. With nothing to
do, it simply exits.</p>
<p>If you open up the <em>src/main.rs</em> file, make a trivial change, and then save it
and build again, you’ll only see two lines of output:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
</code></pre>
<p>These lines show Cargo only updates the build with your tiny change to the
<em>src/main.rs</em> file. Your dependencies haven’t changed, so Cargo knows it can
reuse what it has already downloaded and compiled for those. It just rebuilds
your part of the code.</p>
<h4><a class="header" href="#ensuring-reproducible-builds-with-the-cargolock-file" id="ensuring-reproducible-builds-with-the-cargolock-file">Ensuring Reproducible Builds with the <em>Cargo.lock</em> File</a></h4>
<p>Cargo has a mechanism that ensures you can rebuild the same artifact every time
you or anyone else builds your code: Cargo will use only the versions of the
dependencies you specified until you indicate otherwise. For example, what
happens if next week version 0.3.15 of the <code>rand</code> crate comes out and
contains an important bug fix but also contains a regression that will break
your code?</p>
<p>The answer to this problem is the <em>Cargo.lock</em> file, which was created the
first time you ran <code>cargo build</code> and is now in your <em>guessing_game</em> directory.
When you build a project for the first time, Cargo figures out all the
versions of the dependencies that fit the criteria and then writes them to
the <em>Cargo.lock</em> file. When you build your project in the future, Cargo will
see that the <em>Cargo.lock</em> file exists and use the versions specified there
rather than doing all the work of figuring out versions again. This lets you
have a reproducible build automatically. In other words, your project will
remain at <code>0.3.14</code> until you explicitly upgrade, thanks to the <em>Cargo.lock</em>
file.</p>
<h4><a class="header" href="#updating-a-crate-to-get-a-new-version" id="updating-a-crate-to-get-a-new-version">Updating a Crate to Get a New Version</a></h4>
<p>When you <em>do</em> want to update a crate, Cargo provides another command, <code>update</code>,
which will ignore the <em>Cargo.lock</em> file and figure out all the latest versions
that fit your specifications in <em>Cargo.toml</em>. If that works, Cargo will write
those versions to the <em>Cargo.lock</em> file.</p>
<p>But by default, Cargo will only look for versions greater than <code>0.3.0</code> and less
than <code>0.4.0</code>. If the <code>rand</code> crate has released two new versions, <code>0.3.15</code> and
<code>0.4.0</code>, you would see the following if you ran <code>cargo update</code>:</p>
<pre><code class="language-text">$ cargo update
    Updating registry `https://github.com/rust-lang/crates.io-index`
    Updating rand v0.3.14 -&gt; v0.3.15
</code></pre>
<p>At this point, you would also notice a change in your <em>Cargo.lock</em> file noting
that the version of the <code>rand</code> crate you are now using is <code>0.3.15</code>.</p>
<p>If you wanted to use <code>rand</code> version <code>0.4.0</code> or any version in the <code>0.4.x</code>
series, you’d have to update the <em>Cargo.toml</em> file to look like this instead:</p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.4.0&quot;
</code></pre>
<p>The next time you run <code>cargo build</code>, Cargo will update the registry of crates
available and reevaluate your <code>rand</code> requirements according to the new version
you have specified.</p>
<p>There’s a lot more to say about <a href="http://doc.crates.io">Cargo</a><!-- ignore --> and <a href="http://doc.crates.io/crates-io.html">its
ecosystem</a><!-- ignore --> which we’ll discuss in Chapter 14, but
for now, that’s all you need to know. Cargo makes it very easy to reuse
libraries, so Rustaceans are able to write smaller projects that are assembled
from a number of packages.</p>
<h3><a class="header" href="#generating-a-random-number" id="generating-a-random-number">Generating a Random Number</a></h3>
<p>Now that you’ve added the <code>rand</code> crate to <em>Cargo.toml</em>, let’s start using
<code>rand</code>. The next step is to update <em>src/main.rs</em>, as shown in Listing 2-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    println!(&quot;The secret number is: {}&quot;, secret_number);

    println!(&quot;Please input your guess.&quot;);

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    println!(&quot;You guessed: {}&quot;, guess);
}
</code></pre>
<p><span class="caption">Listing 2-3: Adding code to generate a random
number</span></p>
<p>First, we add a <code>use</code> line: <code>use rand::Rng</code>. The <code>Rng</code> trait defines
methods that random number generators implement, and this trait must be in
scope for us to use those methods. Chapter 10 will cover traits in detail.</p>
<p>Next, we’re adding two lines in the middle. The <code>rand::thread_rng</code> function
will give us the particular random number generator that we’re going to use:
one that is local to the current thread of execution and seeded by the
operating system. Then we call the <code>gen_range</code> method on the random number
generator. This method is defined by the <code>Rng</code> trait that we brought into
scope with the <code>use rand::Rng</code> statement. The <code>gen_range</code> method takes two
numbers as arguments and generates a random number between them. It’s inclusive
on the lower bound but exclusive on the upper bound, so we need to specify <code>1</code>
and <code>101</code> to request a number between 1 and 100.</p>
<blockquote>
<p>Note: You won’t just know which traits to use and which methods and functions
to call from a crate. Instructions for using a crate are in each crate’s
documentation. Another neat feature of Cargo is that you can run the <code>cargo doc --open</code> command, which will build documentation provided by all of your
dependencies locally and open it in your browser. If you’re interested in
other functionality in the <code>rand</code> crate, for example, run <code>cargo doc --open</code>
and click <code>rand</code> in the sidebar on the left.</p>
</blockquote>
<p>The second line that we added to the middle of the code prints the secret
number. This is useful while we’re developing the program to be able to test
it, but we’ll delete it from the final version. It’s not much of a game if the
program prints the answer as soon as it starts!</p>
<p>Try running the program a few times:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 2.53 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 7
Please input your guess.
4
You guessed: 4
$ cargo run
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 83
Please input your guess.
5
You guessed: 5
</code></pre>
<p>You should get different random numbers, and they should all be numbers between
1 and 100. Great job!</p>
<h2><a class="header" href="#comparing-the-guess-to-the-secret-number" id="comparing-the-guess-to-the-secret-number">Comparing the Guess to the Secret Number</a></h2>
<p>Now that we have user input and a random number, we can compare them. That step
is shown in Listing 2-4. Note that this code won’t compile quite yet, as we
will explain.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {

    // ---snip---

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p><span class="caption">Listing 2-4: Handling the possible return values of
comparing two numbers</span></p>
<p>The first new bit here is another <code>use</code> statement, bringing a type called
<code>std::cmp::Ordering</code> into scope from the standard library. Like <code>Result</code>,
<code>Ordering</code> is another enum, but the variants for <code>Ordering</code> are <code>Less</code>,
<code>Greater</code>, and <code>Equal</code>. These are the three outcomes that are possible when you
compare two values.</p>
<p>Then we add five new lines at the bottom that use the <code>Ordering</code> type. The
<code>cmp</code> method compares two values and can be called on anything that can be
compared. It takes a reference to whatever you want to compare with: here it’s
comparing the <code>guess</code> to the <code>secret_number</code>. Then it returns a variant of the
<code>Ordering</code> enum we brought into scope with the <code>use</code> statement. We use a
<a href="rustbook/ch06-02-match.html"><code>match</code></a><!-- ignore --> expression to decide what to do next based on
which variant of <code>Ordering</code> was returned from the call to <code>cmp</code> with the values
in <code>guess</code> and <code>secret_number</code>.</p>
<p>A <code>match</code> expression is made up of <em>arms</em>. An arm consists of a <em>pattern</em> and
the code that should be run if the value given to the beginning of the <code>match</code>
expression fits that arm’s pattern. Rust takes the value given to <code>match</code> and
looks through each arm’s pattern in turn. The <code>match</code> construct and patterns
are powerful features in Rust that let you express a variety of situations your
code might encounter and make sure that you handle them all. These features
will be covered in detail in Chapter 6 and Chapter 18, respectively.</p>
<p>Let’s walk through an example of what would happen with the <code>match</code> expression
used here. Say that the user has guessed 50 and the randomly generated secret
number this time is 38. When the code compares 50 to 38, the <code>cmp</code> method will
return <code>Ordering::Greater</code>, because 50 is greater than 38. The <code>match</code>
expression gets the <code>Ordering::Greater</code> value and starts checking each arm’s
pattern. It looks at the first arm’s pattern, <code>Ordering::Less</code>, and sees that
the value <code>Ordering::Greater</code> does not match <code>Ordering::Less</code>, so it ignores
the code in that arm and moves to the next arm. The next arm’s pattern,
<code>Ordering::Greater</code>, <em>does</em> match <code>Ordering::Greater</code>! The associated code in
that arm will execute and print <code>Too big!</code> to the screen. The <code>match</code>
expression ends because it has no need to look at the last arm in this scenario.</p>
<p>However, the code in Listing 2-4 won’t compile yet. Let’s try it:</p>
<pre><code class="language-text">$ cargo build
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
error[E0308]: mismatched types
  --&gt; src/main.rs:23:21
   |
23 |     match guess.cmp(&amp;secret_number) {
   |                     ^^^^^^^^^^^^^^ expected struct `std::string::String`, found integral variable
   |
   = note: expected type `&amp;std::string::String`
   = note:    found type `&amp;{integer}`

error: aborting due to previous error
Could not compile `guessing_game`.
</code></pre>
<p>The core of the error states that there are <em>mismatched types</em>. Rust has a
strong, static type system. However, it also has type inference. When we wrote
<code>let mut guess = String::new()</code>, Rust was able to infer that <code>guess</code> should be
a <code>String</code> and didn’t make us write the type. The <code>secret_number</code>, on the other
hand, is a number type. A few number types can have a value between 1 and 100:
<code>i32</code>, a 32-bit number; <code>u32</code>, an unsigned 32-bit number; <code>i64</code>, a 64-bit
number; as well as others. Rust defaults to an <code>i32</code>, which is the type of
<code>secret_number</code> unless you add type information elsewhere that would cause Rust
to infer a different numerical type. The reason for the error is that Rust
cannot compare a string and a number type.</p>
<p>Ultimately, we want to convert the <code>String</code> the program reads as input into a
real number type so we can compare it numerically to the secret number. We can
do that by adding the following two lines to the <code>main</code> function body:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    let mut guess = String::new();

    io::stdin().read_line(&amp;mut guess)
        .expect(&quot;Failed to read line&quot;);

    let guess: u32 = guess.trim().parse()
        .expect(&quot;Please type a number!&quot;);

    println!(&quot;You guessed: {}&quot;, guess);

    match guess.cmp(&amp;secret_number) {
        Ordering::Less =&gt; println!(&quot;Too small!&quot;),
        Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
        Ordering::Equal =&gt; println!(&quot;You win!&quot;),
    }
}
</code></pre>
<p>The two new lines are:</p>
<pre><code class="language-rust ignore">let guess: u32 = guess.trim().parse()
    .expect(&quot;Please type a number!&quot;);
</code></pre>
<p>We create a variable named <code>guess</code>. But wait, doesn’t the program already have
a variable named <code>guess</code>? It does, but Rust allows us to <em>shadow</em> the previous
value of <code>guess</code> with a new one. This feature is often used in situations in
which you want to convert a value from one type to another type. Shadowing lets
us reuse the <code>guess</code> variable name rather than forcing us to create two unique
variables, such as <code>guess_str</code> and <code>guess</code> for example. (Chapter 3 covers
shadowing in more detail.)</p>
<p>We bind <code>guess</code> to the expression <code>guess.trim().parse()</code>. The <code>guess</code> in the
expression refers to the original <code>guess</code> that was a <code>String</code> with the input in
it. The <code>trim</code> method on a <code>String</code> instance will eliminate any whitespace at
the beginning and end. Although <code>u32</code> can contain only numerical characters,
the user must press <span class="keystroke">enter</span> to satisfy
<code>read_line</code>. When the user presses <span class="keystroke">enter</span>, a
newline character is added to the string. For example, if the user types <span
class="keystroke">5</span> and presses <span class="keystroke">enter</span>,
<code>guess</code> looks like this: <code>5\n</code>. The <code>\n</code> represents “newline,” the result of
pressing <span class="keystroke">enter</span>. The <code>trim</code> method eliminates
<code>\n</code>, resulting in just <code>5</code>.</p>
<p>The <a href="rustbook/../std/primitive.str.html#method.parse"><code>parse</code> method on strings</a><!-- ignore --> parses a string into some
kind of number. Because this method can parse a variety of number types, we
need to tell Rust the exact number type we want by using <code>let guess: u32</code>. The
colon (<code>:</code>) after <code>guess</code> tells Rust we’ll annotate the variable’s type. Rust
has a few built-in number types; the <code>u32</code> seen here is an unsigned, 32-bit
integer. It’s a good default choice for a small positive number. You’ll learn
about other number types in Chapter 3. Additionally, the <code>u32</code> annotation in
this example program and the comparison with <code>secret_number</code> means that Rust
will infer that <code>secret_number</code> should be a <code>u32</code> as well. So now the
comparison will be between two values of the same type!</p>
<p>The call to <code>parse</code> could easily cause an error. If, for example, the string
contained <code>A👍%</code>, there would be no way to convert that to a number. Because it
might fail, the <code>parse</code> method returns a <code>Result</code> type, much as the <code>read_line</code>
method does (discussed earlier in <a href="rustbook/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“Handling Potential Failure with the
<code>Result</code> Type”</a><!-- ignore
-->). We’ll treat this <code>Result</code> the same way by using the <code>expect</code> method
again. If <code>parse</code> returns an <code>Err</code> <code>Result</code> variant because it couldn’t create
a number from the string, the <code>expect</code> call will crash the game and print the
message we give it. If <code>parse</code> can successfully convert the string to a number,
it will return the <code>Ok</code> variant of <code>Result</code>, and <code>expect</code> will return the
number that we want from the <code>Ok</code> value.</p>
<p>Let’s run the program now!</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 58
Please input your guess.
  76
You guessed: 76
Too big!
</code></pre>
<p>Nice! Even though spaces were added before the guess, the program still figured
out that the user guessed 76. Run the program a few times to verify the
different behavior with different kinds of input: guess the number correctly,
guess a number that is too high, and guess a number that is too low.</p>
<p>We have most of the game working now, but the user can make only one guess.
Let’s change that by adding a loop!</p>
<h2><a class="header" href="#allowing-multiple-guesses-with-looping" id="allowing-multiple-guesses-with-looping">Allowing Multiple Guesses with Looping</a></h2>
<p>The <code>loop</code> keyword creates an infinite loop. We’ll add that now to give users
more chances at guessing the number:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

    println!(&quot;The secret number is: {}&quot;, secret_number);

    loop {
        println!(&quot;Please input your guess.&quot;);

        // --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; println!(&quot;You win!&quot;),
        }
    }
}
</code></pre>
<p>As you can see, we’ve moved everything into a loop from the guess input prompt
onward. Be sure to indent the lines inside the loop another four spaces each
and run the program again. Notice that there is a new problem because the
program is doing exactly what we told it to do: ask for another guess forever!
It doesn’t seem like the user can quit!</p>
<p>The user could always interrupt the program by using the keyboard shortcut <span
class="keystroke">ctrl-c</span>. But there’s another way to escape this
insatiable monster, as mentioned in the <code>parse</code> discussion in <a href="rustbook/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the
Guess to the Secret Number”</a><!--
ignore -->: if the user enters a non-number answer, the program will crash. The
user can take advantage of that in order to quit, as shown here:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished dev [unoptimized + debuginfo] target(s) in 1.50 secs
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 59
Please input your guess.
45
You guessed: 45
Too small!
Please input your guess.
60
You guessed: 60
Too big!
Please input your guess.
59
You guessed: 59
You win!
Please input your guess.
quit
thread 'main' panicked at 'Please type a number!: ParseIntError { kind: InvalidDigit }', src/libcore/result.rs:785
note: Run with `RUST_BACKTRACE=1` for a backtrace.
error: Process didn't exit successfully: `target/debug/guess` (exit code: 101)
</code></pre>
<p>Typing <code>quit</code> actually quits the game, but so will any other non-number input.
However, this is suboptimal to say the least. We want the game to automatically
stop when the correct number is guessed.</p>
<h3><a class="header" href="#quitting-after-a-correct-guess" id="quitting-after-a-correct-guess">Quitting After a Correct Guess</a></h3>
<p>Let’s program the game to quit when the user wins by adding a <code>break</code> statement:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Adding the <code>break</code> line after <code>You win!</code> makes the program exit the loop when
the user guesses the secret number correctly. Exiting the loop also means
exiting the program, because the loop is the last part of <code>main</code>.</p>
<h3><a class="header" href="#handling-invalid-input" id="handling-invalid-input">Handling Invalid Input</a></h3>
<p>To further refine the game’s behavior, rather than crashing the program when
the user inputs a non-number, let’s make the game ignore a non-number so the
user can continue guessing. We can do that by altering the line where <code>guess</code>
is converted from a <code>String</code> to a <code>u32</code>, as shown in Listing 2-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--

io::stdin().read_line(&amp;mut guess)
    .expect(&quot;Failed to read line&quot;);

let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};

println!(&quot;You guessed: {}&quot;, guess);

// --snip--
</code></pre>
<p><span class="caption">Listing 2-5: Ignoring a non-number guess and asking for
another guess instead of crashing the program</span></p>
<p>Switching from an <code>expect</code> call to a <code>match</code> expression is how you generally
move from crashing on an error to handling the error. Remember that <code>parse</code>
returns a <code>Result</code> type and <code>Result</code> is an enum that has the variants <code>Ok</code> or
<code>Err</code>. We’re using a <code>match</code> expression here, as we did with the <code>Ordering</code>
result of the <code>cmp</code> method.</p>
<p>If <code>parse</code> is able to successfully turn the string into a number, it will
return an <code>Ok</code> value that contains the resulting number. That <code>Ok</code> value will
match the first arm’s pattern, and the <code>match</code> expression will just return the
<code>num</code> value that <code>parse</code> produced and put inside the <code>Ok</code> value. That number
will end up right where we want it in the new <code>guess</code> variable we’re creating.</p>
<p>If <code>parse</code> is <em>not</em> able to turn the string into a number, it will return an
<code>Err</code> value that contains more information about the error. The <code>Err</code> value
does not match the <code>Ok(num)</code> pattern in the first <code>match</code> arm, but it does
match the <code>Err(_)</code> pattern in the second arm. The underscore, <code>_</code>, is a
catchall value; in this example, we’re saying we want to match all <code>Err</code>
values, no matter what information they have inside them. So the program will
execute the second arm’s code, <code>continue</code>, which tells the program to go to the
next iteration of the <code>loop</code> and ask for another guess. So, effectively, the
program ignores all errors that <code>parse</code> might encounter!</p>
<p>Now everything in the program should work as expected. Let’s try it:</p>
<pre><code class="language-text">$ cargo run
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
     Running `target/debug/guessing_game`
Guess the number!
The secret number is: 61
Please input your guess.
10
You guessed: 10
Too small!
Please input your guess.
99
You guessed: 99
Too big!
Please input your guess.
foo
Please input your guess.
61
You guessed: 61
You win!
</code></pre>
<p>Awesome! With one tiny final tweak, we will finish the guessing game. Recall
that the program is still printing the secret number. That worked well for
testing, but it ruins the game. Let’s delete the <code>println!</code> that outputs the
secret number. Listing 2-6 shows the final code.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::io;
use std::cmp::Ordering;
use rand::Rng;

fn main() {
    println!(&quot;Guess the number!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        println!(&quot;Please input your guess.&quot;);

        let mut guess = String::new();

        io::stdin().read_line(&amp;mut guess)
            .expect(&quot;Failed to read line&quot;);

        let guess: u32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        println!(&quot;You guessed: {}&quot;, guess);

        match guess.cmp(&amp;secret_number) {
            Ordering::Less =&gt; println!(&quot;Too small!&quot;),
            Ordering::Greater =&gt; println!(&quot;Too big!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;You win!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listing 2-6: Complete guessing game code</span></p>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>At this point, you’ve successfully built the guessing game. Congratulations!</p>
<p>This project was a hands-on way to introduce you to many new Rust concepts:
<code>let</code>, <code>match</code>, methods, associated functions, the use of external crates, and
more. In the next few chapters, you’ll learn about these concepts in more
detail. Chapter 3 covers concepts that most programming languages have, such as
variables, data types, and functions, and shows how to use them in Rust.
Chapter 4 explores ownership, a feature that makes Rust different from other
languages. Chapter 5 discusses structs and method syntax, and Chapter 6
explains how enums work.</p>
<h1><a class="header" href="#common-programming-concepts" id="common-programming-concepts">Common Programming Concepts</a></h1>
<p>This chapter covers concepts that appear in almost every programming language
and how they work in Rust. Many programming languages have much in common at
their core. None of the concepts presented in this chapter are unique to Rust,
but we’ll discuss them in the context of Rust and explain the conventions
around using these concepts.</p>
<p>Specifically, you’ll learn about variables, basic types, functions, comments,
and control flow. These foundations will be in every Rust program, and learning
them early will give you a strong core to start from.</p>
<blockquote>
<h4><a class="header" href="#keywords" id="keywords">Keywords</a></h4>
<p>The Rust language has a set of <em>keywords</em> that are reserved for use by
the language only, much as in other languages. Keep in mind that you cannot
use these words as names of variables or functions. Most of the keywords have
special meanings, and you’ll be using them to do various tasks in your Rust
programs; a few have no current functionality associated with them but have
been reserved for functionality that might be added to Rust in the future. You
can find a list of the keywords in Appendix A.</p>
</blockquote>
<h2><a class="header" href="#variables-and-mutability" id="variables-and-mutability">Variables and Mutability</a></h2>
<p>As mentioned in Chapter 2, by default variables are immutable. This is one of
many nudges Rust gives you to write your code in a way that takes advantage of
the safety and easy concurrency that Rust offers. However, you still have the
option to make your variables mutable. Let’s explore how and why Rust
encourages you to favor immutability and why sometimes you might want to opt
out.</p>
<p>When a variable is immutable, once a value is bound to a name, you can’t change
that value. To illustrate this, let’s generate a new project called <em>variables</em>
in your <em>projects</em> directory by using <code>cargo new variables</code>.</p>
<p>Then, in your new <em>variables</em> directory, open <em>src/main.rs</em> and replace its
code with the following code that won’t compile just yet:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre>
<p>Save and run the program using <code>cargo run</code>. You should receive an error
message, as shown in this output:</p>
<pre><code class="language-text">error[E0384]: cannot assign twice to immutable variable `x`
 --&gt; src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!(&quot;The value of x is: {}&quot;, x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
</code></pre>
<p>This example shows how the compiler helps you find errors in your programs.
Even though compiler errors can be frustrating, they only mean your program
isn’t safely doing what you want it to do yet; they do <em>not</em> mean that you’re
not a good programmer! Experienced Rustaceans still get compiler errors.</p>
<p>The error message indicates that the cause of the error is that you <code>cannot assign twice to immutable variable x</code>, because you tried to assign a second
value to the immutable <code>x</code> variable.</p>
<p>It’s important that we get compile-time errors when we attempt to change a
value that we previously designated as immutable because this very situation
can lead to bugs. If one part of our code operates on the assumption that a
value will never change and another part of our code changes that value, it’s
possible that the first part of the code won’t do what it was designed to do.
The cause of this kind of bug can be difficult to track down after the fact,
especially when the second piece of code changes the value only <em>sometimes</em>.</p>
<p>In Rust, the compiler guarantees that when you state that a value won’t change,
it really won’t change. That means that when you’re reading and writing code,
you don’t have to keep track of how and where a value might change. Your code
is thus easier to reason through.</p>
<p>But mutability can be very useful. Variables are immutable only by default; as
you did in Chapter 2, you can make them mutable by adding <code>mut</code> in front of the
variable name. In addition to allowing this value to change, <code>mut</code> conveys
intent to future readers of the code by indicating that other parts of the code
will be changing this variable value.</p>
<p>For example, let’s change <em>src/main.rs</em> to the following:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = 5;
    println!(&quot;The value of x is: {}&quot;, x);
    x = 6;
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>When we run the program now, we get this:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
</code></pre>
<p>We’re allowed to change the value that <code>x</code> binds to from <code>5</code> to <code>6</code> when <code>mut</code>
is used. In some cases, you’ll want to make a variable mutable because it makes
the code more convenient to write than if it had only immutable variables.</p>
<p>There are multiple trade-offs to consider in addition to the prevention of
bugs. For example, in cases where you’re using large data structures, mutating
an instance in place may be faster than copying and returning newly allocated
instances. With smaller data structures, creating new instances and writing in
a more functional programming style may be easier to think through, so lower
performance might be a worthwhile penalty for gaining that clarity.</p>
<h3><a class="header" href="#differences-between-variables-and-constants" id="differences-between-variables-and-constants">Differences Between Variables and Constants</a></h3>
<p>Being unable to change the value of a variable might have reminded you of
another programming concept that most other languages have: <em>constants</em>. Like
immutable variables, constants are values that are bound to a name and are not
allowed to change, but there are a few differences between constants and
variables.</p>
<p>First, you aren’t allowed to use <code>mut</code> with constants. Constants aren’t just
immutable by default—they’re always immutable.</p>
<p>You declare constants using the <code>const</code> keyword instead of the <code>let</code> keyword,
and the type of the value <em>must</em> be annotated. We’re about to cover types and
type annotations in the next section, <a href="rustbook/ch03-02-data-types.html#data-types">“Data Types,”</a><!-- ignore
--> so don’t worry about the details right now. Just know that you must always
annotate the type.</p>
<p>Constants can be declared in any scope, including the global scope, which makes
them useful for values that many parts of code need to know about.</p>
<p>The last difference is that constants may be set only to a constant expression,
not the result of a function call or any other value that could only be
computed at runtime.</p>
<p>Here’s an example of a constant declaration where the constant’s name is
<code>MAX_POINTS</code> and its value is set to 100,000. (Rust’s naming convention for
constants is to use all uppercase with underscores between words, and
underscores can be inserted in numeric literals to improve readability):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<p>Constants are valid for the entire time a program runs, within the scope they
were declared in, making them a useful choice for values in your application
domain that multiple parts of the program might need to know about, such as the
maximum number of points any player of a game is allowed to earn or the speed
of light.</p>
<p>Naming hardcoded values used throughout your program as constants is useful in
conveying the meaning of that value to future maintainers of the code. It also
helps to have only one place in your code you would need to change if the
hardcoded value needed to be updated in the future.</p>
<h3><a class="header" href="#shadowing" id="shadowing">Shadowing</a></h3>
<p>As you saw in the guessing game tutorial in the <a href="rustbook/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the
Secret Number”</a><!-- ignore -->
section in Chapter 2, you can declare a new variable with the same name as a
previous variable, and the new variable shadows the previous variable.
Rustaceans say that the first variable is <em>shadowed</em> by the second, which means
that the second variable’s value is what appears when the variable is used. We
can shadow a variable by using the same variable’s name and repeating the use
of the <code>let</code> keyword as follows:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>This program first binds <code>x</code> to a value of <code>5</code>. Then it shadows <code>x</code> by
repeating <code>let x =</code>, taking the original value and adding <code>1</code> so the value of
<code>x</code> is then <code>6</code>. The third <code>let</code> statement also shadows <code>x</code>, multiplying the
previous value by <code>2</code> to give <code>x</code> a final value of <code>12</code>. When we run this
program, it will output the following:</p>
<pre><code class="language-text">$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
</code></pre>
<p>Shadowing is different from marking a variable as <code>mut</code>, because we’ll get a
compile-time error if we accidentally try to reassign to this variable without
using the <code>let</code> keyword. By using <code>let</code>, we can perform a few transformations
on a value but have the variable be immutable after those transformations have
been completed.</p>
<p>The other difference between <code>mut</code> and shadowing is that because we’re
effectively creating a new variable when we use the <code>let</code> keyword again, we can
change the type of the value but reuse the same name. For example, say our
program asks a user to show how many spaces they want between some text by
inputting space characters, but we really want to store that input as a number:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let spaces = &quot;   &quot;;
let spaces = spaces.len();
<span class="boring">}
</span></code></pre></pre>
<p>This construct is allowed because the first <code>spaces</code> variable is a string type
and the second <code>spaces</code> variable, which is a brand-new variable that happens to
have the same name as the first one, is a number type. Shadowing thus spares us
from having to come up with different names, such as <code>spaces_str</code> and
<code>spaces_num</code>; instead, we can reuse the simpler <code>spaces</code> name. However, if we
try to use <code>mut</code> for this, as shown here, we’ll get a compile-time error:</p>
<pre><code class="language-rust ignore does_not_compile">let mut spaces = &quot;   &quot;;
spaces = spaces.len();
</code></pre>
<p>The error says we’re not allowed to mutate a variable’s type:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &amp;str, found usize
  |
  = note: expected type `&amp;str`
             found type `usize`
</code></pre>
<p>Now that we’ve explored how variables work, let’s look at more data types they
can have.</p>
<h2><a class="header" href="#data-types" id="data-types">Data Types</a></h2>
<p>Every value in Rust is of a certain <em>data type</em>, which tells Rust what kind of
data is being specified so it knows how to work with that data. We’ll look at
two data type subsets: scalar and compound.</p>
<p>Keep in mind that Rust is a <em>statically typed</em> language, which means that it
must know the types of all variables at compile time. The compiler can usually
infer what type we want to use based on the value and how we use it. In cases
when many types are possible, such as when we converted a <code>String</code> to a numeric
type using <code>parse</code> in the <a href="rustbook/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the Secret
Number”</a><!-- ignore --> section in
Chapter 2, we must add a type annotation, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>If we don’t add the type annotation here, Rust will display the following
error, which means the compiler needs more information from us to know which
type we want to use:</p>
<pre><code class="language-text">error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
</code></pre>
<p>You’ll see different type annotations for other data types.</p>
<h3><a class="header" href="#scalar-types-1" id="scalar-types-1">Scalar Types</a></h3>
<p>A <em>scalar</em> type represents a single value. Rust has four primary scalar types:
integers, floating-point numbers, Booleans, and characters. You may recognize
these from other programming languages. Let’s jump into how they work in Rust.</p>
<h4><a class="header" href="#integer-types" id="integer-types">Integer Types</a></h4>
<p>An <em>integer</em> is a number without a fractional component. We used one integer
type in Chapter 2, the <code>u32</code> type. This type declaration indicates that the
value it’s associated with should be an unsigned integer (signed integer types
start with <code>i</code>, instead of <code>u</code>) that takes up 32 bits of space. Table 3-1 shows
the built-in integer types in Rust. Each variant in the Signed and Unsigned
columns (for example, <code>i16</code>) can be used to declare the type of an integer
value.</p>
<p><span class="caption">Table 3-1: Integer Types in Rust</span></p>
<table><thead><tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr></thead><tbody>
<tr><td>8-bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td>16-bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td>32-bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td>64-bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td>128-bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td>arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>Each variant can be either signed or unsigned and has an explicit size.
<em>Signed</em> and <em>unsigned</em> refer to whether it’s possible for the number to be
negative or positive—in other words, whether the number needs to have a sign
with it (signed) or whether it will only ever be positive and can therefore be
represented without a sign (unsigned). It’s like writing numbers on paper: when
the sign matters, a number is shown with a plus sign or a minus sign; however,
when it’s safe to assume the number is positive, it’s shown with no sign.
Signed numbers are stored using <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two’s complement</a> representation.</p>
<p>Each signed variant can store numbers from -(2<sup>n - 1</sup>) to 2<sup>n -
1</sup> - 1 inclusive, where <em>n</em> is the number of bits that variant uses. So an
<code>i8</code> can store numbers from -(2<sup>7</sup>) to 2<sup>7</sup> - 1, which equals
-128 to 127. Unsigned variants can store numbers from 0 to 2<sup>n</sup> - 1,
so a <code>u8</code> can store numbers from 0 to 2<sup>8</sup> - 1, which equals 0 to 255.</p>
<p>Additionally, the <code>isize</code> and <code>usize</code> types depend on the kind of computer your
program is running on: 64 bits if you’re on a 64-bit architecture and 32 bits
if you’re on a 32-bit architecture.</p>
<p>You can write integer literals in any of the forms shown in Table 3-2. Note
that all number literals except the byte literal allow a type suffix, such as
<code>57u8</code>, and <code>_</code> as a visual separator, such as <code>1_000</code>.</p>
<p><span class="caption">Table 3-2: Integer Literals in Rust</span></p>
<table><thead><tr><th>Number literals</th><th>Example</th></tr></thead><tbody>
<tr><td>Decimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Octal</td><td><code>0o77</code></td></tr>
<tr><td>Binary</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>So how do you know which type of integer to use? If you’re unsure, Rust’s
defaults are generally good choices, and integer types default to <code>i32</code>: this
type is generally the fastest, even on 64-bit systems. The primary situation in
which you’d use <code>isize</code> or <code>usize</code> is when indexing some sort of collection.</p>
<blockquote>
<h5><a class="header" href="#integer-overflow" id="integer-overflow">Integer Overflow</a></h5>
<p>Let’s say you have a variable of type <code>u8</code> that can hold values between 0 and 255.
If you try to change the variable to a value outside of that range, such
as 256, <em>integer overflow</em> will occur. Rust has some interesting rules
involving this behavior. When you’re compiling in debug mode, Rust includes
checks for integer overflow that cause your program to <em>panic</em> at runtime if
this behavior occurs. Rust uses the term panicking when a program exits with
an error; we’ll discuss panics in more depth in the <a href="rustbook/ch09-01-unrecoverable-errors-with-panic.html">“Unrecoverable Errors
with <code>panic!</code>”</a><!-- ignore --> section in
Chapter 9.</p>
<p>When you’re compiling in release mode with the <code>--release</code> flag, Rust does
<em>not</em> include checks for integer overflow that cause panics. Instead, if
overflow occurs, Rust performs <em>two’s complement wrapping</em>. In short, values
greater than the maximum value the type can hold “wrap around” to the minimum
of the values the type can hold. In the case of a <code>u8</code>, 256 becomes 0, 257
becomes 1, and so on. The program won’t panic, but the variable will have a
value that probably isn’t what you were expecting it to have. Relying on
integer overflow’s wrapping behavior is considered an error. If you want to
wrap explicitly, you can use the standard library type <a href="rustbook/../std/num/struct.Wrapping.html"><code>Wrapping</code></a>.</p>
</blockquote>
<h4><a class="header" href="#floating-point-types" id="floating-point-types">Floating-Point Types</a></h4>
<p>Rust also has two primitive types for <em>floating-point numbers</em>, which are
numbers with decimal points. Rust’s floating-point types are <code>f32</code> and <code>f64</code>,
which are 32 bits and 64 bits in size, respectively. The default type is <code>f64</code>
because on modern CPUs it’s roughly the same speed as <code>f32</code> but is capable of
more precision.</p>
<p>Here’s an example that shows floating-point numbers in action:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Floating-point numbers are represented according to the IEEE-754 standard. The
<code>f32</code> type is a single-precision float, and <code>f64</code> has double precision.</p>
<h4><a class="header" href="#numeric-operations" id="numeric-operations">Numeric Operations</a></h4>
<p>Rust supports the basic mathematical operations you’d expect for all of the
number types: addition, subtraction, multiplication, division, and remainder.
The following code shows how you’d use each one in a <code>let</code> statement:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // addition
    let sum = 5 + 10;

    // subtraction
    let difference = 95.5 - 4.3;

    // multiplication
    let product = 4 * 30;

    // division
    let quotient = 56.7 / 32.2;

    // remainder
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>Each expression in these statements uses a mathematical operator and evaluates
to a single value, which is then bound to a variable. Appendix B contains a
list of all operators that Rust provides.</p>
<h4><a class="header" href="#the-boolean-type" id="the-boolean-type">The Boolean Type</a></h4>
<p>As in most other programming languages, a Boolean type in Rust has two possible
values: <code>true</code> and <code>false</code>. Booleans are one byte in size. The Boolean type in
Rust is specified using <code>bool</code>. For example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // with explicit type annotation
}
</code></pre></pre>
<p>The main way to use Boolean values is through conditionals, such as an <code>if</code>
expression. We’ll cover how <code>if</code> expressions work in Rust in the <a href="rustbook/ch03-05-control-flow.html#control-flow">“Control
Flow”</a><!-- ignore --> section.</p>
<h4><a class="header" href="#the-character-type" id="the-character-type">The Character Type</a></h4>
<p>So far we’ve worked only with numbers, but Rust supports letters too. Rust’s
<code>char</code> type is the language’s most primitive alphabetic type, and the following
code shows one way to use it. (Note that <code>char</code> literals are specified with
single quotes, as opposed to string literals, which use double quotes.)</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Rust’s <code>char</code> type is four bytes in size and represents a Unicode Scalar Value,
which means it can represent a lot more than just ASCII. Accented letters;
Chinese, Japanese, and Korean characters; emoji; and zero-width spaces are all
valid <code>char</code> values in Rust. Unicode Scalar Values range from <code>U+0000</code> to
<code>U+D7FF</code> and <code>U+E000</code> to <code>U+10FFFF</code> inclusive. However, a “character” isn’t
really a concept in Unicode, so your human intuition for what a “character” is
may not match up with what a <code>char</code> is in Rust. We’ll discuss this topic in
detail in <a href="rustbook/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“Storing UTF-8 Encoded Text with Strings”</a><!-- ignore -->
in Chapter 8.</p>
<h3><a class="header" href="#compound-types-1" id="compound-types-1">Compound Types</a></h3>
<p><em>Compound types</em> can group multiple values into one type. Rust has two
primitive compound types: tuples and arrays.</p>
<h4><a class="header" href="#the-tuple-type" id="the-tuple-type">The Tuple Type</a></h4>
<p>A tuple is a general way of grouping together some number of other values
with a variety of types into one compound type. Tuples have a fixed length:
once declared, they cannot grow or shrink in size.</p>
<p>We create a tuple by writing a comma-separated list of values inside
parentheses. Each position in the tuple has a type, and the types of the
different values in the tuple don’t have to be the same. We’ve added optional
type annotations in this example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>The variable <code>tup</code> binds to the entire tuple, because a tuple is considered a
single compound element. To get the individual values out of a tuple, we can
use pattern matching to destructure a tuple value, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>This program first creates a tuple and binds it to the variable <code>tup</code>. It then
uses a pattern with <code>let</code> to take <code>tup</code> and turn it into three separate
variables, <code>x</code>, <code>y</code>, and <code>z</code>. This is called <em>destructuring</em>, because it breaks
the single tuple into three parts. Finally, the program prints the value of
<code>y</code>, which is <code>6.4</code>.</p>
<p>In addition to destructuring through pattern matching, we can access a tuple
element directly by using a period (<code>.</code>) followed by the index of the value we
want to access. For example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>This program creates a tuple, <code>x</code>, and then makes new variables for each
element by using their index. As with most programming languages, the first
index in a tuple is 0.</p>
<h4><a class="header" href="#the-array-type" id="the-array-type">The Array Type</a></h4>
<p>Another way to have a collection of multiple values is with an <em>array</em>. Unlike
a tuple, every element of an array must have the same type. Arrays in Rust are
different from arrays in some other languages because arrays in Rust have a
fixed length, like tuples.</p>
<p>In Rust, the values going into an array are written as a comma-separated list
inside square brackets:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Arrays are useful when you want your data allocated on the stack rather than
the heap (we will discuss the stack and the heap more in Chapter 4) or when
you want to ensure you always have a fixed number of elements. An array isn’t
as flexible as the vector type, though. A vector is a similar collection type
provided by the standard library that <em>is</em> allowed to grow or shrink in size.
If you’re unsure whether to use an array or a vector, you should probably use a
vector. Chapter 8 discusses vectors in more detail.</p>
<p>An example of when you might want to use an array rather than a vector is in a
program that needs to know the names of the months of the year. It’s very
unlikely that such a program will need to add or remove months, so you can use
an array because you know it will always contain 12 items:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let months = [&quot;January&quot;, &quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>You would write an array’s type by using square brackets, and within the
brackets include the type of each element, a semicolon, and then the number of
elements in the array, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Here, <code>i32</code> is the type of each element. After the semicolon, the number <code>5</code>
indicates the element contains five items.</p>
<p>Writing an array’s type this way looks similar to an alternative syntax for
initializing an array: if you want to create an array that contains the same
value for each element, you can specify the initial value, followed by a
semicolon, and then the length of the array in square brackets, as shown here:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p>The array named <code>a</code> will contain <code>5</code> elements that will all be set to the value
<code>3</code> initially. This is the same as writing <code>let a = [3, 3, 3, 3, 3];</code> but in a
more concise way.</p>
<h5><a class="header" href="#accessing-array-elements" id="accessing-array-elements">Accessing Array Elements</a></h5>
<p>An array is a single chunk of memory allocated on the stack. You can access
elements of an array using indexing, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>In this example, the variable named <code>first</code> will get the value <code>1</code>, because
that is the value at index <code>[0]</code> in the array. The variable named <code>second</code> will
get the value <code>2</code> from index <code>[1]</code> in the array.</p>
<h5><a class="header" href="#invalid-array-element-access" id="invalid-array-element-access">Invalid Array Element Access</a></h5>
<p>What happens if you try to access an element of an array that is past the end
of the array? Say you change the example to the following code, which will
compile but exit with an error when it runs:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;The value of element is: {}&quot;, element);
}
</code></pre>
<p>Running this code using <code>cargo run</code> produces the following result:</p>
<pre><code class="language-text">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:5:19
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>The compilation didn’t produce any errors, but the program resulted in a
<em>runtime</em> error and didn’t exit successfully. When you attempt to access an
element using indexing, Rust will check that the index you’ve specified is less
than the array length. If the index is greater than or equal to the array
length, Rust will panic.</p>
<p>This is the first example of Rust’s safety principles in action. In many
low-level languages, this kind of check is not done, and when you provide an
incorrect index, invalid memory can be accessed. Rust protects you against this
kind of error by immediately exiting instead of allowing the memory access and
continuing. Chapter 9 discusses more of Rust’s error handling.</p>
<h2><a class="header" href="#functions-3" id="functions-3">Functions</a></h2>
<p>Functions are pervasive in Rust code. You’ve already seen one of the most
important functions in the language: the <code>main</code> function, which is the entry
point of many programs. You’ve also seen the <code>fn</code> keyword, which allows you to
declare new functions.</p>
<p>Rust code uses <em>snake case</em> as the conventional style for function and variable
names. In snake case, all letters are lowercase and underscores separate words.
Here’s a program that contains an example function definition:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Another function.&quot;);
}
</code></pre></pre>
<p>Function definitions in Rust start with <code>fn</code> and have a set of parentheses
after the function name. The curly brackets tell the compiler where the
function body begins and ends.</p>
<p>We can call any function we’ve defined by entering its name followed by a set
of parentheses. Because <code>another_function</code> is defined in the program, it can be
called from inside the <code>main</code> function. Note that we defined <code>another_function</code>
<em>after</em> the <code>main</code> function in the source code; we could have defined it before
as well. Rust doesn’t care where you define your functions, only that they’re
defined somewhere.</p>
<p>Let’s start a new binary project named <em>functions</em> to explore functions
further. Place the <code>another_function</code> example in <em>src/main.rs</em> and run it. You
should see the following output:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28 secs
     Running `target/debug/functions`
Hello, world!
Another function.
</code></pre>
<p>The lines execute in the order in which they appear in the <code>main</code> function.
First, the “Hello, world!” message prints, and then <code>another_function</code> is
called and its message is printed.</p>
<h3><a class="header" href="#function-parameters" id="function-parameters">Function Parameters</a></h3>
<p>Functions can also be defined to have <em>parameters</em>, which are special variables
that are part of a function’s signature. When a function has parameters, you
can provide it with concrete values for those parameters. Technically, the
concrete values are called <em>arguments</em>, but in casual conversation, people tend
to use the words <em>parameter</em> and <em>argument</em> interchangeably for either the
variables in a function’s definition or the concrete values passed in when you
call a function.</p>
<p>The following rewritten version of <code>another_function</code> shows what parameters
look like in Rust:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>Try running this program; you should get the following output:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>The declaration of <code>another_function</code> has one parameter named <code>x</code>. The type of
<code>x</code> is specified as <code>i32</code>. When <code>5</code> is passed to <code>another_function</code>, the
<code>println!</code> macro puts <code>5</code> where the pair of curly brackets were in the format
string.</p>
<p>In function signatures, you <em>must</em> declare the type of each parameter. This is
a deliberate decision in Rust’s design: requiring type annotations in function
definitions means the compiler almost never needs you to use them elsewhere in
the code to figure out what you mean.</p>
<p>When you want a function to have multiple parameters, separate the parameter
declarations with commas, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;The value of x is: {}&quot;, x);
    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>This example creates a function with two parameters, both of which are <code>i32</code>
types. The function then prints the values in both of its parameters. Note that
function parameters don’t all need to be the same type, they just happen to be
in this example.</p>
<p>Let’s try running this code. Replace the program currently in your <em>functions</em>
project’s <em>src/main.rs</em> file with the preceding example and run it using <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/functions`
The value of x is: 5
The value of y is: 6
</code></pre>
<p>Because we called the function with <code>5</code> as the value for  <code>x</code> and <code>6</code> is passed
as the value for <code>y</code>, the two strings are printed with these values.</p>
<h3><a class="header" href="#function-bodies-contain-statements-and-expressions" id="function-bodies-contain-statements-and-expressions">Function Bodies Contain Statements and Expressions</a></h3>
<p>Function bodies are made up of a series of statements optionally ending in an
expression. So far, we’ve only covered functions without an ending expression,
but you have seen an expression as part of a statement. Because Rust is an
expression-based language, this is an important distinction to understand.
Other languages don’t have the same distinctions, so let’s look at what
statements and expressions are and how their differences affect the bodies of
functions.</p>
<p>We’ve actually already used statements and expressions. <em>Statements</em> are
instructions that perform some action and do not return a value. <em>Expressions</em>
evaluate to a resulting value. Let’s look at some examples.</p>
<p>Creating a variable and assigning a value to it with the <code>let</code> keyword is a
statement. In Listing 3-1, <code>let y = 6;</code> is a statement.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">Listing 3-1: A <code>main</code> function declaration containing one statement</span></p>
<p>Function definitions are also statements; the entire preceding example is a
statement in itself.</p>
<p>Statements do not return values. Therefore, you can’t assign a <code>let</code> statement
to another variable, as the following code tries to do; you’ll get an error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = (let y = 6);
}
</code></pre>
<p>When you run this program, the error you’ll get looks like this:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p>The <code>let y = 6</code> statement does not return a value, so there isn’t anything for
<code>x</code> to bind to. This is different from what happens in other languages, such as
C and Ruby, where the assignment returns the value of the assignment. In those
languages, you can write <code>x = y = 6</code> and have both <code>x</code> and <code>y</code> have the value
<code>6</code>; that is not the case in Rust.</p>
<p>Expressions evaluate to something and make up most of the rest of the code that
you’ll write in Rust. Consider a simple math operation, such as <code>5 + 6</code>, which
is an expression that evaluates to the value <code>11</code>. Expressions can be part of
statements: in Listing 3-1, the <code>6</code> in the statement <code>let y = 6;</code> is an
expression that evaluates to the value <code>6</code>. Calling a function is an
expression. Calling a macro is an expression. The block that we use to create
new scopes, <code>{}</code>, is an expression, for example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;The value of y is: {}&quot;, y);
}
</code></pre></pre>
<p>This expression:</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>is a block that, in this case, evaluates to <code>4</code>. That value gets bound to <code>y</code>
as part of the <code>let</code> statement. Note the <code>x + 1</code> line without a semicolon at
the end, which is unlike most of the lines you’ve seen so far. Expressions do
not include ending semicolons. If you add a semicolon to the end of an
expression, you turn it into a statement, which will then not return a value.
Keep this in mind as you explore function return values and expressions next.</p>
<h3><a class="header" href="#functions-with-return-values" id="functions-with-return-values">Functions with Return Values</a></h3>
<p>Functions can return values to the code that calls them. We don’t name return
values, but we do declare their type after an arrow (<code>-&gt;</code>). In Rust, the return
value of the function is synonymous with the value of the final expression in
the block of the body of a function. You can return early from a function by
using the <code>return</code> keyword and specifying a value, but most functions return
the last expression implicitly. Here’s an example of a function that returns a
value:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;The value of x is: {}&quot;, x);
}
</code></pre></pre>
<p>There are no function calls, macros, or even <code>let</code> statements in the <code>five</code>
function—just the number <code>5</code> by itself. That’s a perfectly valid function in
Rust. Note that the function’s return type is specified too, as <code>-&gt; i32</code>. Try
running this code; the output should look like this:</p>
<pre><code class="language-text">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/functions`
The value of x is: 5
</code></pre>
<p>The <code>5</code> in <code>five</code> is the function’s return value, which is why the return type
is <code>i32</code>. Let’s examine this in more detail. There are two important bits:
first, the line <code>let x = five();</code> shows that we’re using the return value of a
function to initialize a variable. Because the function <code>five</code> returns a <code>5</code>,
that line is the same as the following:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>Second, the <code>five</code> function has no parameters and defines the type of the
return value, but the body of the function is a lonely <code>5</code> with no semicolon
because it’s an expression whose value we want to return.</p>
<p>Let’s look at another example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Running this code will print <code>The value of x is: 6</code>. But if we place a
semicolon at the end of the line containing <code>x + 1</code>, changing it from an
expression to a statement, we’ll get an error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;The value of x is: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre>
<p>Compiling this code produces an error, as follows:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:28
  |
7 |   fn plus_one(x: i32) -&gt; i32 {
  |  ____________________________^
8 | |     x + 1;
  | |          - help: consider removing this semicolon
9 | | }
  | |_^ expected i32, found ()
  |
  = note: expected type `i32`
             found type `()`
</code></pre>
<p>The main error message, “mismatched types,” reveals the core issue with this
code. The definition of the function <code>plus_one</code> says that it will return an
<code>i32</code>, but statements don’t evaluate to a value, which is expressed by <code>()</code>,
an empty tuple. Therefore, nothing is returned, which contradicts the function
definition and results in an error. In this output, Rust provides a message to
possibly help rectify this issue: it suggests removing the semicolon, which
would fix the error.</p>
<h2><a class="header" href="#comments-1" id="comments-1">Comments</a></h2>
<p>All programmers strive to make their code easy to understand, but sometimes
extra explanation is warranted. In these cases, programmers leave notes, or
<em>comments</em>, in their source code that the compiler will ignore but people
reading the source code may find useful.</p>
<p>Here’s a simple comment:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// hello, world
<span class="boring">}
</span></code></pre></pre>
<p>In Rust, comments must start with two slashes and continue until the end of the
line. For comments that extend beyond a single line, you’ll need to include
<code>//</code> on each line, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// So we’re doing something complicated here, long enough that we need
// multiple lines of comments to do it! Whew! Hopefully, this comment will
// explain what’s going on.
<span class="boring">}
</span></code></pre></pre>
<p>Comments can also be placed at the end of lines containing code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lucky_number = 7; // I’m feeling lucky today
}
</code></pre></pre>
<p>But you’ll more often see them used in this format, with the comment on a
separate line above the code it’s annotating:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // I’m feeling lucky today
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rust also has another kind of comment, documentation comments, which we’ll
discuss in the “Publishing a Crate to Crates.io” section of Chapter 14.</p>
<h2><a class="header" href="#control-flow" id="control-flow">Control Flow</a></h2>
<p>Deciding whether or not to run some code depending on if a condition is true
and deciding to run some code repeatedly while a condition is true are basic
building blocks in most programming languages. The most common constructs that
let you control the flow of execution of Rust code are <code>if</code> expressions and
loops.</p>
<h3><a class="header" href="#if-expressions" id="if-expressions"><code>if</code> Expressions</a></h3>
<p>An <code>if</code> expression allows you to branch your code depending on conditions. You
provide a condition and then state, “If this condition is met, run this block
of code. If the condition is not met, do not run this block of code.”</p>
<p>Create a new project called <em>branches</em> in your <em>projects</em> directory to explore
the <code>if</code> expression. In the <em>src/main.rs</em> file, input the following:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number &lt; 5 {
        println!(&quot;condition was true&quot;);
    } else {
        println!(&quot;condition was false&quot;);
    }
}
</code></pre></pre>
<p>All <code>if</code> expressions start with the keyword <code>if</code>, which is followed by a
condition. In this case, the condition checks whether or not the variable
<code>number</code> has a value less than 5. The block of code we want to execute if the
condition is true is placed immediately after the condition inside curly
brackets. Blocks of code associated with the conditions in <code>if</code> expressions are
sometimes called <em>arms</em>, just like the arms in <code>match</code> expressions that we
discussed in the <a href="rustbook/ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">“Comparing the Guess to the Secret
Number”</a><!-- ignore --> section of
Chapter 2.</p>
<p>Optionally, we can also include an <code>else</code> expression, which we chose
to do here, to give the program an alternative block of code to execute should
the condition evaluate to false. If you don’t provide an <code>else</code> expression and
the condition is false, the program will just skip the <code>if</code> block and move on
to the next bit of code.</p>
<p>Try running this code; you should see the following output:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was true
</code></pre>
<p>Let’s try changing the value of <code>number</code> to a value that makes the condition
<code>false</code> to see what happens:</p>
<pre><code class="language-rust ignore">let number = 7;
</code></pre>
<p>Run the program again, and look at the output:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
condition was false
</code></pre>
<p>It’s also worth noting that the condition in this code <em>must</em> be a <code>bool</code>. If
the condition isn’t a <code>bool</code>, we’ll get an error. For example, try running the
following code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let number = 3;

    if number {
        println!(&quot;number was three&quot;);
    }
}
</code></pre>
<p>The <code>if</code> condition evaluates to a value of <code>3</code> this time, and Rust throws an
error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:8
  |
4 |     if number {
  |        ^^^^^^ expected bool, found integral variable
  |
  = note: expected type `bool`
             found type `{integer}`
</code></pre>
<p>The error indicates that Rust expected a <code>bool</code> but got an integer. Unlike
languages such as Ruby and JavaScript, Rust will not automatically try to
convert non-Boolean types to a Boolean. You must be explicit and always provide
<code>if</code> with a Boolean as its condition. If we want the <code>if</code> code block to run
only when a number is not equal to <code>0</code>, for example, we can change the <code>if</code>
expression to the following:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 3;

    if number != 0 {
        println!(&quot;number was something other than zero&quot;);
    }
}
</code></pre></pre>
<p>Running this code will print <code>number was something other than zero</code>.</p>
<h4><a class="header" href="#handling-multiple-conditions-with-else-if" id="handling-multiple-conditions-with-else-if">Handling Multiple Conditions with <code>else if</code></a></h4>
<p>You can have multiple conditions by combining <code>if</code> and <code>else</code> in an <code>else if</code>
expression. For example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number = 6;

    if number % 4 == 0 {
        println!(&quot;number is divisible by 4&quot;);
    } else if number % 3 == 0 {
        println!(&quot;number is divisible by 3&quot;);
    } else if number % 2 == 0 {
        println!(&quot;number is divisible by 2&quot;);
    } else {
        println!(&quot;number is not divisible by 4, 3, or 2&quot;);
    }
}
</code></pre></pre>
<p>This program has four possible paths it can take. After running it, you should
see the following output:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/branches`
number is divisible by 3
</code></pre>
<p>When this program executes, it checks each <code>if</code> expression in turn and executes
the first body for which the condition holds true. Note that even though 6 is
divisible by 2, we don’t see the output <code>number is divisible by 2</code>, nor do we
see the <code>number is not divisible by 4, 3, or 2</code> text from the <code>else</code> block.
That’s because Rust only executes the block for the first true condition, and
once it finds one, it doesn’t even check the rest.</p>
<p>Using too many <code>else if</code> expressions can clutter your code, so if you have more
than one, you might want to refactor your code. Chapter 6 describes a powerful
Rust branching construct called <code>match</code> for these cases.</p>
<h4><a class="header" href="#using-if-in-a-let-statement" id="using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> Statement</a></h4>
<p>Because <code>if</code> is an expression, we can use it on the right side of a <code>let</code>
statement, as in Listing 3-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let condition = true;
    let number = if condition {
        5
    } else {
        6
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre></pre>
<p><span class="caption">Listing 3-2: Assigning the result of an <code>if</code> expression
to a variable</span></p>
<p>The <code>number</code> variable will be bound to a value based on the outcome of the <code>if</code>
expression. Run this code to see what happens:</p>
<pre><code class="language-text">$ cargo run
   Compiling branches v0.1.0 (file:///projects/branches)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/branches`
The value of number is: 5
</code></pre>
<p>Remember that blocks of code evaluate to the last expression in them, and
numbers by themselves are also expressions. In this case, the value of the
whole <code>if</code> expression depends on which block of code executes. This means the
values that have the potential to be results from each arm of the <code>if</code> must be
the same type; in Listing 3-2, the results of both the <code>if</code> arm and the <code>else</code>
arm were <code>i32</code> integers. If the types are mismatched, as in the following
example, we’ll get an error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let condition = true;

    let number = if condition {
        5
    } else {
        &quot;six&quot;
    };

    println!(&quot;The value of number is: {}&quot;, number);
}
</code></pre>
<p>When we try to compile this code, we’ll get an error. The <code>if</code> and <code>else</code> arms
have value types that are incompatible, and Rust indicates exactly where to
find the problem in the program:</p>
<pre><code class="language-text">error[E0308]: if and else have incompatible types
 --&gt; src/main.rs:4:18
  |
4 |       let number = if condition {
  |  __________________^
5 | |         5
6 | |     } else {
7 | |         &quot;six&quot;
8 | |     };
  | |_____^ expected integral variable, found &amp;str
  |
  = note: expected type `{integer}`
             found type `&amp;str`
</code></pre>
<p>The expression in the <code>if</code> block evaluates to an integer, and the expression in
the <code>else</code> block evaluates to a string. This won’t work because variables must
have a single type. Rust needs to know at compile time what type the <code>number</code>
variable is, definitively, so it can verify at compile time that its type is
valid everywhere we use <code>number</code>. Rust wouldn’t be able to do that if the type
of <code>number</code> was only determined at runtime; the compiler would be more complex
and would make fewer guarantees about the code if it had to keep track of
multiple hypothetical types for any variable.</p>
<h3><a class="header" href="#repetition-with-loops" id="repetition-with-loops">Repetition with Loops</a></h3>
<p>It’s often useful to execute a block of code more than once. For this task,
Rust provides several <em>loops</em>. A loop runs through the code inside the loop
body to the end and then starts immediately back at the beginning. To
experiment with loops, let’s make a new project called <em>loops</em>.</p>
<p>Rust has three kinds of loops: <code>loop</code>, <code>while</code>, and <code>for</code>. Let’s try each one.</p>
<h4><a class="header" href="#repeating-code-with-loop" id="repeating-code-with-loop">Repeating Code with <code>loop</code></a></h4>
<p>The <code>loop</code> keyword tells Rust to execute a block of code over and over again
forever or until you explicitly tell it to stop.</p>
<p>As an example, change the <em>src/main.rs</em> file in your <em>loops</em> directory to look
like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    loop {
        println!(&quot;again!&quot;);
    }
}
</code></pre>
<p>When we run this program, we’ll see <code>again!</code> printed over and over continuously
until we stop the program manually. Most terminals support a keyboard shortcut,
<span class="keystroke">ctrl-c</span>, to interrupt a program that is stuck in
a continual loop. Give it a try:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.29 secs
     Running `target/debug/loops`
again!
again!
again!
again!
^Cagain!
</code></pre>
<p>The symbol <code>^C</code> represents where you pressed <span class="keystroke">ctrl-c
</span>. You may or may not see the word <code>again!</code> printed after the <code>^C</code>,
depending on where the code was in the loop when it received the interrupt
signal.</p>
<p>Fortunately, Rust provides another, more reliable way to break out of a loop.
You can place the <code>break</code> keyword within the loop to tell the program when to
stop executing the loop. Recall that we did this in the guessing game in the
<a href="rustbook/ch02-00-guessing-game-tutorial.html#quitting-after-a-correct-guess">“Quitting After a Correct Guess”</a><!-- ignore
--> section of Chapter 2 to exit the program when the user won the game by
guessing the correct number.</p>
<h4><a class="header" href="#returning-values-from-loops" id="returning-values-from-loops">Returning Values from Loops</a></h4>
<p>One of the uses of a <code>loop</code> is to retry an operation you know might fail, such
as checking whether a thread has completed its job. However, you might need to
pass the result of that operation to the rest of your code. To do this, you can
add the value you want returned after the <code>break</code> expression you use to stop
the loop; that value will be returned out of the loop so you can use it, as
shown here:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!(&quot;The result is {}&quot;, result);
}
</code></pre></pre>
<p>Before the loop, we declare a variable named <code>counter</code> and initialize it to
<code>0</code>. Then we declare a variable named <code>result</code> to hold the value returned from
the loop. On every iteration of the loop, we add <code>1</code> to the <code>counter</code> variable,
and then check whether the counter is equal to <code>10</code>. When it is, we use the
<code>break</code> keyword with the value <code>counter * 2</code>. After the loop, we use a
semicolon to end the statement that assigns the value to <code>result</code>. Finally, we
print the value in <code>result</code>, which in this case is 20.</p>
<h4><a class="header" href="#conditional-loops-with-while" id="conditional-loops-with-while">Conditional Loops with <code>while</code></a></h4>
<p>It’s often useful for a program to evaluate a condition within a loop. While
the condition is true, the loop runs. When the condition ceases to be true, the
program calls <code>break</code>, stopping the loop. This loop type could be implemented
using a combination of <code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>; you could try that
now in a program, if you’d like.</p>
<p>However, this pattern is so common that Rust has a built-in language construct
for it, called a <code>while</code> loop. Listing 3-3 uses <code>while</code>: the program loops
three times, counting down each time, and then, after the loop, it prints
another message and exits.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut number = 3;

    while number != 0 {
        println!(&quot;{}!&quot;, number);

        number -= 1;
    }

    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 3-3: Using a <code>while</code> loop to run code while a
condition holds true</span></p>
<p>This construct eliminates a lot of nesting that would be necessary if you used
<code>loop</code>, <code>if</code>, <code>else</code>, and <code>break</code>, and it’s clearer. While a condition holds
true, the code runs; otherwise, it exits the loop.</p>
<h4><a class="header" href="#looping-through-a-collection-with-for" id="looping-through-a-collection-with-for">Looping Through a Collection with <code>for</code></a></h4>
<p>You could use the <code>while</code> construct to loop over the elements of a collection,
such as an array. For example, let’s look at Listing 3-4.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];
    let mut index = 0;

    while index &lt; 5 {
        println!(&quot;the value is: {}&quot;, a[index]);

        index += 1;
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-4: Looping through each element of a collection
using a <code>while</code> loop</span></p>
<p>Here, the code counts up through the elements in the array. It starts at index
<code>0</code>, and then loops until it reaches the final index in the array (that is,
when <code>index &lt; 5</code> is no longer true). Running this code will print every element
in the array:</p>
<pre><code class="language-text">$ cargo run
   Compiling loops v0.1.0 (file:///projects/loops)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
     Running `target/debug/loops`
the value is: 10
the value is: 20
the value is: 30
the value is: 40
the value is: 50
</code></pre>
<p>All five array values appear in the terminal, as expected. Even though <code>index</code>
will reach a value of <code>5</code> at some point, the loop stops executing before trying
to fetch a sixth value from the array.</p>
<p>But this approach is error prone; we could cause the program to panic if the
index length is incorrect. It’s also slow, because the compiler adds runtime
code to perform the conditional check on every element on every iteration
through the loop.</p>
<p>As a more concise alternative, you can use a <code>for</code> loop and execute some code
for each item in a collection. A <code>for</code> loop looks like the code in Listing 3-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a.iter() {
        println!(&quot;the value is: {}&quot;, element);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 3-5: Looping through each element of a collection
using a <code>for</code> loop</span></p>
<p>When we run this code, we’ll see the same output as in Listing 3-4. More
importantly, we’ve now increased the safety of the code and eliminated the
chance of bugs that might result from going beyond the end of the array or not
going far enough and missing some items.</p>
<p>For example, in the code in Listing 3-4, if you removed an item from the <code>a</code>
array but forgot to update the condition to <code>while index &lt; 4</code>, the code would
panic. Using the <code>for</code> loop, you wouldn’t need to remember to change any other
code if you changed the number of values in the array.</p>
<p>The safety and conciseness of <code>for</code> loops make them the most commonly used loop
construct in Rust. Even in situations in which you want to run some code a
certain number of times, as in the countdown example that used a <code>while</code> loop
in Listing 3-3, most Rustaceans would use a <code>for</code> loop. The way to do that
would be to use a <code>Range</code>, which is a type provided by the standard library
that generates all numbers in sequence starting from one number and ending
before another number.</p>
<p>Here’s what the countdown would look like using a <code>for</code> loop and another method
we’ve not yet talked about, <code>rev</code>, to reverse the range:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    for number in (1..4).rev() {
        println!(&quot;{}!&quot;, number);
    }
    println!(&quot;LIFTOFF!!!&quot;);
}
</code></pre></pre>
<p>This code is a bit nicer, isn’t it?</p>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<p>You made it! That was a sizable chapter: you learned about variables, scalar
and compound data types, functions, comments, <code>if</code> expressions, and loops! If
you want to practice with the concepts discussed in this chapter, try building
programs to do the following:</p>
<ul>
<li>Convert temperatures between Fahrenheit and Celsius.</li>
<li>Generate the nth Fibonacci number.</li>
<li>Print the lyrics to the Christmas carol “The Twelve Days of Christmas,”
taking advantage of the repetition in the song.</li>
</ul>
<p>When you’re ready to move on, we’ll talk about a concept in Rust that <em>doesn’t</em>
commonly exist in other programming languages: ownership.</p>
<h1><a class="header" href="#understanding-ownership" id="understanding-ownership">Understanding Ownership</a></h1>
<p>Ownership is Rust’s most unique feature, and it enables Rust to make memory
safety guarantees without needing a garbage collector. Therefore, it’s
important to understand how ownership works in Rust. In this chapter, we’ll
talk about ownership as well as several related features: borrowing, slices,
and how Rust lays data out in memory.</p>
<h2><a class="header" href="#what-is-ownership" id="what-is-ownership">What Is Ownership?</a></h2>
<p>Rust’s central feature is <em>ownership</em>. Although the feature is straightforward
to explain, it has deep implications for the rest of the language.</p>
<p>All programs have to manage the way they use a computer’s memory while running.
Some languages have garbage collection that constantly looks for no longer used
memory as the program runs; in other languages, the programmer must explicitly
allocate and free the memory. Rust uses a third approach: memory is managed
through a system of ownership with a set of rules that the compiler checks at
compile time. None of the ownership features slow down your program while it’s
running.</p>
<p>Because ownership is a new concept for many programmers, it does take some time
to get used to. The good news is that the more experienced you become with Rust
and the rules of the ownership system, the more you’ll be able to naturally
develop code that is safe and efficient. Keep at it!</p>
<p>When you understand ownership, you’ll have a solid foundation for understanding
the features that make Rust unique. In this chapter, you’ll learn ownership by
working through some examples that focus on a very common data structure:
strings.</p>
<blockquote>
<h3><a class="header" href="#the-stack-and-the-heap" id="the-stack-and-the-heap">The Stack and the Heap</a></h3>
<p>In many programming languages, you don’t have to think about the stack and
the heap very often. But in a systems programming language like Rust, whether
a value is on the stack or the heap has more of an effect on how the language
behaves and why you have to make certain decisions. Parts of ownership will
be described in relation to the stack and the heap later in this chapter, so
here is a brief explanation in preparation.</p>
<p>Both the stack and the heap are parts of memory that are available to your code
to use at runtime, but they are structured in different ways. The stack stores
values in the order it gets them and removes the values in the opposite order.
This is referred to as <em>last in, first out</em>. Think of a stack of plates: when
you add more plates, you put them on top of the pile, and when you need a
plate, you take one off the top. Adding or removing plates from the middle or
bottom wouldn’t work as well! Adding data is called <em>pushing onto the stack</em>,
and removing data is called <em>popping off the stack</em>.</p>
<p>All data stored on the stack must have a known, fixed size. Data with an
unknown size at compile time or a size that might change must be stored on
the heap instead. The heap is less organized: when you put data on the heap,
you request a certain amount of space. The operating system finds an empty
spot in the heap that is big enough, marks it as being in use, and returns a
<em>pointer</em>, which is the address of that location. This process is called
<em>allocating on the heap</em> and is sometimes abbreviated as just <em>allocating</em>.
Pushing values onto the stack is not considered allocating. Because the
pointer is a known, fixed size, you can store the pointer on the stack, but
when you want the actual data, you must follow the pointer.</p>
<p>Think of being seated at a restaurant. When you enter, you state the number of
people in your group, and the staff finds an empty table that fits everyone
and leads you there. If someone in your group comes late, they can ask where
you’ve been seated to find you.</p>
<p>Pushing to the stack is faster than allocating on the heap because the
operating system never has to search for a place to store new data; that
location is always at the top of the stack. Comparatively, allocating space
on the heap requires more work, because the operating system must first find
a big enough space to hold the data and then perform bookkeeping to prepare
for the next allocation.</p>
<p>Accessing data in the heap is slower than accessing data on the stack because
you have to follow a pointer to get there. Contemporary processors are faster
if they jump around less in memory. Continuing the analogy, consider a server
at a restaurant taking orders from many tables. It’s most efficient to get
all the orders at one table before moving on to the next table. Taking an
order from table A, then an order from table B, then one from A again, and
then one from B again would be a much slower process. By the same token, a
processor can do its job better if it works on data that’s close to other
data (as it is on the stack) rather than farther away (as it can be on the
heap). Allocating a large amount of space on the heap can also take time.</p>
<p>When your code calls a function, the values passed into the function
(including, potentially, pointers to data on the heap) and the function’s
local variables get pushed onto the stack. When the function is over, those
values get popped off the stack.</p>
<p>Keeping track of what parts of code are using what data on the heap,
minimizing the amount of duplicate data on the heap, and cleaning up unused
data on the heap so you don’t run out of space are all problems that ownership
addresses. Once you understand ownership, you won’t need to think about the
stack and the heap very often, but knowing that managing heap data is why
ownership exists can help explain why it works the way it does.</p>
</blockquote>
<h3><a class="header" href="#ownership-rules" id="ownership-rules">Ownership Rules</a></h3>
<p>First, let’s take a look at the ownership rules. Keep these rules in mind as we
work through the examples that illustrate them:</p>
<ul>
<li>Each value in Rust has a variable that’s called its <em>owner</em>.</li>
<li>There can only be one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<h3><a class="header" href="#variable-scope" id="variable-scope">Variable Scope</a></h3>
<p>We’ve walked through an example of a Rust program already in Chapter 2. Now
that we’re past basic syntax, we won’t include all the <code>fn main() {</code> code in
examples, so if you’re following along, you’ll have to put the following
examples inside a <code>main</code> function manually. As a result, our examples will be a
bit more concise, letting us focus on the actual details rather than
boilerplate code.</p>
<p>As a first example of ownership, we’ll look at the <em>scope</em> of some variables. A
scope is the range within a program for which an item is valid. Let’s say we
have a variable that looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = &quot;hello&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>The variable <code>s</code> refers to a string literal, where the value of the string is
hardcoded into the text of our program. The variable is valid from the point at
which it’s declared until the end of the current <em>scope</em>. Listing 4-1 has
comments annotating where the variable <code>s</code> is valid.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{                      // s is not valid here, it’s not yet declared
    let s = &quot;hello&quot;;   // s is valid from this point forward

    // do stuff with s
}                      // this scope is now over, and s is no longer valid
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-1: A variable and the scope in which it is
valid</span></p>
<p>In other words, there are two important points in time here:</p>
<ul>
<li>When <code>s</code> comes <em>into scope</em>, it is valid.</li>
<li>It remains valid until it goes <em>out of scope</em>.</li>
</ul>
<p>At this point, the relationship between scopes and when variables are valid is
similar to that in other programming languages. Now we’ll build on top of this
understanding by introducing the <code>String</code> type.</p>
<h3><a class="header" href="#the-string-type" id="the-string-type">The <code>String</code> Type</a></h3>
<p>To illustrate the rules of ownership, we need a data type that is more complex
than the ones we covered in the <a href="rustbook/ch03-02-data-types.html#data-types">“Data Types”</a><!-- ignore -->
section of Chapter 3. The types covered previously are all stored on the stack
and popped off the stack when their scope is over, but we want to look at data
that is stored on the heap and explore how Rust knows when to clean up that
data.</p>
<p>We’ll use <code>String</code> as the example here and concentrate on the parts of <code>String</code>
that relate to ownership. These aspects also apply to other complex data types
provided by the standard library and that you create. We’ll discuss <code>String</code> in
more depth in Chapter 8.</p>
<p>We’ve already seen string literals, where a string value is hardcoded into our
program. String literals are convenient, but they aren’t suitable for every
situation in which we may want to use text. One reason is that they’re
immutable. Another is that not every string value can be known when we write
our code: for example, what if we want to take user input and store it? For
these situations, Rust has a second string type, <code>String</code>. This type is
allocated on the heap and as such is able to store an amount of text that is
unknown to us at compile time. You can create a <code>String</code> from a string literal
using the <code>from</code> function, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The double colon (<code>::</code>) is an operator that allows us to namespace this
particular <code>from</code> function under the <code>String</code> type rather than using some sort
of name like <code>string_from</code>. We’ll discuss this syntax more in the <a href="rustbook/ch05-03-method-syntax.html#method-syntax">“Method
Syntax”</a><!-- ignore --> section of Chapter 5 and when we talk
about namespacing with modules in <a href="rustbook/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the
Module Tree”</a><!-- ignore --> in Chapter 7.</p>
<p>This kind of string <em>can</em> be mutated:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // push_str() appends a literal to a String

println!(&quot;{}&quot;, s); // This will print `hello, world!`
<span class="boring">}
</span></code></pre></pre>
<p>So, what’s the difference here? Why can <code>String</code> be mutated but literals
cannot? The difference is how these two types deal with memory.</p>
<h3><a class="header" href="#memory-and-allocation" id="memory-and-allocation">Memory and Allocation</a></h3>
<p>In the case of a string literal, we know the contents at compile time, so the
text is hardcoded directly into the final executable. This is why string
literals are fast and efficient. But these properties only come from the string
literal’s immutability. Unfortunately, we can’t put a blob of memory into the
binary for each piece of text whose size is unknown at compile time and whose
size might change while running the program.</p>
<p>With the <code>String</code> type, in order to support a mutable, growable piece of text,
we need to allocate an amount of memory on the heap, unknown at compile time,
to hold the contents. This means:</p>
<ul>
<li>The memory must be requested from the operating system at runtime.</li>
<li>We need a way of returning this memory to the operating system when we’re
done with our <code>String</code>.</li>
</ul>
<p>That first part is done by us: when we call <code>String::from</code>, its implementation
requests the memory it needs. This is pretty much universal in programming
languages.</p>
<p>However, the second part is different. In languages with a <em>garbage collector
(GC)</em>, the GC keeps track and cleans up memory that isn’t being used anymore,
and we don’t need to think about it. Without a GC, it’s our responsibility to
identify when memory is no longer being used and call code to explicitly return
it, just as we did to request it. Doing this correctly has historically been a
difficult programming problem. If we forget, we’ll waste memory. If we do it
too early, we’ll have an invalid variable. If we do it twice, that’s a bug too.
We need to pair exactly one <code>allocate</code> with exactly one <code>free</code>.</p>
<p>Rust takes a different path: the memory is automatically returned once the
variable that owns it goes out of scope. Here’s a version of our scope example
from Listing 4-1 using a <code>String</code> instead of a string literal:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;hello&quot;); // s is valid from this point forward

    // do stuff with s
}                                  // this scope is now over, and s is no
                                   // longer valid
<span class="boring">}
</span></code></pre></pre>
<p>There is a natural point at which we can return the memory our <code>String</code> needs
to the operating system: when <code>s</code> goes out of scope. When a variable goes out
of scope, Rust calls a special function for us. This function is called <code>drop</code>,
and it’s where the author of <code>String</code> can put the code to return the memory.
Rust calls <code>drop</code> automatically at the closing curly bracket.</p>
<blockquote>
<p>Note: In C++, this pattern of deallocating resources at the end of an item’s
lifetime is sometimes called <em>Resource Acquisition Is Initialization (RAII)</em>.
The <code>drop</code> function in Rust will be familiar to you if you’ve used RAII
patterns.</p>
</blockquote>
<p>This pattern has a profound impact on the way Rust code is written. It may seem
simple right now, but the behavior of code can be unexpected in more
complicated situations when we want to have multiple variables use the data
we’ve allocated on the heap. Let’s explore some of those situations now.</p>
<h4><a class="header" href="#ways-variables-and-data-interact-move" id="ways-variables-and-data-interact-move">Ways Variables and Data Interact: Move</a></h4>
<p>Multiple variables can interact with the same data in different ways in Rust.
Let’s look at an example using an integer in Listing 4-2.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-2: Assigning the integer value of variable <code>x</code>
to <code>y</code></span></p>
<p>We can probably guess what this is doing: “bind the value <code>5</code> to <code>x</code>; then make
a copy of the value in <code>x</code> and bind it to <code>y</code>.” We now have two variables, <code>x</code>
and <code>y</code>, and both equal <code>5</code>. This is indeed what is happening, because integers
are simple values with a known, fixed size, and these two <code>5</code> values are pushed
onto the stack.</p>
<p>Now let’s look at the <code>String</code> version:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>This looks very similar to the previous code, so we might assume that the way
it works would be the same: that is, the second line would make a copy of the
value in <code>s1</code> and bind it to <code>s2</code>. But this isn’t quite what happens.</p>
<p>Take a look at Figure 4-1 to see what is happening to <code>String</code> under the
covers. A <code>String</code> is made up of three parts, shown on the left: a pointer to
the memory that holds the contents of the string, a length, and a capacity.
This group of data is stored on the stack. On the right is the memory on the
heap that holds the contents.</p>
<img alt="String in memory" src="rustbook/img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-1: Representation in memory of a <code>String</code>
holding the value <code>&quot;hello&quot;</code> bound to <code>s1</code></span></p>
<p>The length is how much memory, in bytes, the contents of the <code>String</code> is
currently using. The capacity is the total amount of memory, in bytes, that the
<code>String</code> has received from the operating system. The difference between length
and capacity matters, but not in this context, so for now, it’s fine to ignore
the capacity.</p>
<p>When we assign <code>s1</code> to <code>s2</code>, the <code>String</code> data is copied, meaning we copy the
pointer, the length, and the capacity that are on the stack. We do not copy the
data on the heap that the pointer refers to. In other words, the data
representation in memory looks like Figure 4-2.</p>
<img alt="s1 and s2 pointing to the same value" src="rustbook/img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-2: Representation in memory of the variable <code>s2</code>
that has a copy of the pointer, length, and capacity of <code>s1</code></span></p>
<p>The representation does <em>not</em> look like Figure 4-3, which is what memory would
look like if Rust instead copied the heap data as well. If Rust did this, the
operation <code>s2 = s1</code> could be very expensive in terms of runtime performance if
the data on the heap were large.</p>
<img alt="s1 and s2 to two places" src="rustbook/img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-3: Another possibility for what <code>s2 = s1</code> might
do if Rust copied the heap data as well</span></p>
<p>Earlier, we said that when a variable goes out of scope, Rust automatically
calls the <code>drop</code> function and cleans up the heap memory for that variable. But
Figure 4-2 shows both data pointers pointing to the same location. This is a
problem: when <code>s2</code> and <code>s1</code> go out of scope, they will both try to free the
same memory. This is known as a <em>double free</em> error and is one of the memory
safety bugs we mentioned previously. Freeing memory twice can lead to memory
corruption, which can potentially lead to security vulnerabilities.</p>
<p>To ensure memory safety, there’s one more detail to what happens in this
situation in Rust. Instead of trying to copy the allocated memory, Rust
considers <code>s1</code> to no longer be valid and, therefore, Rust doesn’t need to free
anything when <code>s1</code> goes out of scope. Check out what happens when you try to
use <code>s1</code> after <code>s2</code> is created; it won’t work:</p>
<pre><code class="language-rust ignore does_not_compile">let s1 = String::from(&quot;hello&quot;);
let s2 = s1;

println!(&quot;{}, world!&quot;, s1);
</code></pre>
<p>You’ll get an error like this because Rust prevents you from using the
invalidated reference:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
3 |     let s2 = s1;
  |         -- value moved here
4 |
5 |     println!(&quot;{}, world!&quot;, s1);
  |                            ^^ value used here after move
  |
  = note: move occurs because `s1` has type `std::string::String`, which does
  not implement the `Copy` trait
</code></pre>
<p>If you’ve heard the terms <em>shallow copy</em> and <em>deep copy</em> while working with
other languages, the concept of copying the pointer, length, and capacity
without copying the data probably sounds like making a shallow copy. But
because Rust also invalidates the first variable, instead of being called a
shallow copy, it’s known as a <em>move</em>. In this example, we would say that
<code>s1</code> was <em>moved</em> into <code>s2</code>. So what actually happens is shown in Figure 4-4.</p>
<img alt="s1 moved to s2" src="rustbook/img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-4: Representation in memory after <code>s1</code> has been
invalidated</span></p>
<p>That solves our problem! With only <code>s2</code> valid, when it goes out of scope, it
alone will free the memory, and we’re done.</p>
<p>In addition, there’s a design choice that’s implied by this: Rust will never
automatically create “deep” copies of your data. Therefore, any <em>automatic</em>
copying can be assumed to be inexpensive in terms of runtime performance.</p>
<h4><a class="header" href="#ways-variables-and-data-interact-clone" id="ways-variables-and-data-interact-clone">Ways Variables and Data Interact: Clone</a></h4>
<p>If we <em>do</em> want to deeply copy the heap data of the <code>String</code>, not just the
stack data, we can use a common method called <code>clone</code>. We’ll discuss method
syntax in Chapter 5, but because methods are a common feature in many
programming languages, you’ve probably seen them before.</p>
<p>Here’s an example of the <code>clone</code> method in action:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>This works just fine and explicitly produces the behavior shown in Figure 4-3,
where the heap data <em>does</em> get copied.</p>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being
executed and that code may be expensive. It’s a visual indicator that something
different is going on.</p>
<h4><a class="header" href="#stack-only-data-copy" id="stack-only-data-copy">Stack-Only Data: Copy</a></h4>
<p>There’s another wrinkle we haven’t talked about yet. This code using integers,
part of which was shown in Listing 4-2, works and is valid:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>But this code seems to contradict what we just learned: we don’t have a call to
<code>clone</code>, but <code>x</code> is still valid and wasn’t moved into <code>y</code>.</p>
<p>The reason is that types such as integers that have a known size at compile
time are stored entirely on the stack, so copies of the actual values are quick
to make. That means there’s no reason we would want to prevent <code>x</code> from being
valid after we create the variable <code>y</code>. In other words, there’s no difference
between deep and shallow copying here, so calling <code>clone</code> wouldn’t do anything
different from the usual shallow copying and we can leave it out.</p>
<p>Rust has a special annotation called the <code>Copy</code> trait that we can place on
types like integers that are stored on the stack (we’ll talk more about traits
in Chapter 10). If a type has the <code>Copy</code> trait, an older variable is still
usable after assignment. Rust won’t let us annotate a type with the <code>Copy</code>
trait if the type, or any of its parts, has implemented the <code>Drop</code> trait. If
the type needs something special to happen when the value goes out of scope and
we add the <code>Copy</code> annotation to that type, we’ll get a compile-time error. To
learn about how to add the <code>Copy</code> annotation to your type, see <a href="rustbook/appendix-03-derivable-traits.html">“Derivable
Traits”</a><!-- ignore --> in Appendix C.</p>
<p>So what types are <code>Copy</code>? You can check the documentation for the given type to
be sure, but as a general rule, any group of simple scalar values can be
<code>Copy</code>, and nothing that requires allocation or is some form of resource is
<code>Copy</code>. Here are some of the types that are <code>Copy</code>:</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>The Boolean type, <code>bool</code>, with values <code>true</code> and <code>false</code>.</li>
<li>All the floating point types, such as <code>f64</code>.</li>
<li>The character type, <code>char</code>.</li>
<li>Tuples, if they only contain types that are also <code>Copy</code>. For example,
<code>(i32, i32)</code> is <code>Copy</code>, but <code>(i32, String)</code> is not.</li>
</ul>
<h3><a class="header" href="#ownership-and-functions" id="ownership-and-functions">Ownership and Functions</a></h3>
<p>The semantics for passing a value to a function are similar to those for
assigning a value to a variable. Passing a variable to a function will move or
copy, just as assignment does. Listing 4-3 has an example with some annotations
showing where variables go into and out of scope.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;hello&quot;);  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
                                    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
                                    // but i32 is Copy, so it’s okay to still
                                    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
  // special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!(&quot;{}&quot;, some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
  // memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!(&quot;{}&quot;, some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
</code></pre></pre>
<p><span class="caption">Listing 4-3: Functions with ownership and scope
annotated</span></p>
<p>If we tried to use <code>s</code> after the call to <code>takes_ownership</code>, Rust would throw a
compile-time error. These static checks protect us from mistakes. Try adding
code to <code>main</code> that uses <code>s</code> and <code>x</code> to see where you can use them and where
the ownership rules prevent you from doing so.</p>
<h3><a class="header" href="#return-values-and-scope" id="return-values-and-scope">Return Values and Scope</a></h3>
<p>Returning values can also transfer ownership. Listing 4-4 is an example with
similar annotations to those in Listing 4-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from(&quot;hello&quot;);     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -&gt; String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from(&quot;hello&quot;); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
</code></pre></pre>
<p><span class="caption">Listing 4-4: Transferring ownership of return
values</span></p>
<p>The ownership of a variable follows the same pattern every time: assigning a
value to another variable moves it. When a variable that includes data on the
heap goes out of scope, the value will be cleaned up by <code>drop</code> unless the data
has been moved to be owned by another variable.</p>
<p>Taking ownership and then returning ownership with every function is a bit
tedious. What if we want to let a function use a value but not take ownership?
It’s quite annoying that anything we pass in also needs to be passed back if we
want to use it again, in addition to any data resulting from the body of the
function that we might want to return as well.</p>
<p>It’s possible to return multiple values using a tuple, as shown in Listing 4-5.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;The length of '{}' is {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() returns the length of a String

    (s, length)
}
</code></pre></pre>
<p><span class="caption">Listing 4-5: Returning ownership of parameters</span></p>
<p>But this is too much ceremony and a lot of work for a concept that should be
common. Luckily for us, Rust has a feature for this concept, called
<em>references</em>.</p>
<h2><a class="header" href="#references-and-borrowing" id="references-and-borrowing">References and Borrowing</a></h2>
<p>The issue with the tuple code in Listing 4-5 is that we have to return the
<code>String</code> to the calling function so we can still use the <code>String</code> after the
call to <code>calculate_length</code>, because the <code>String</code> was moved into
<code>calculate_length</code>.</p>
<p>Here is how you would define and use a <code>calculate_length</code> function that has a
reference to an object as a parameter instead of taking ownership of the
value:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;hello&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>First, notice that all the tuple code in the variable declaration and the
function return value is gone. Second, note that we pass <code>&amp;s1</code> into
<code>calculate_length</code> and, in its definition, we take <code>&amp;String</code> rather than
<code>String</code>.</p>
<p>These ampersands are <em>references</em>, and they allow you to refer to some value
without taking ownership of it. Figure 4-5 shows a diagram.</p>
<img alt="&String s pointing at String s1" src="rustbook/img/trpl04-05.svg" class="center" />
<p><span class="caption">Figure 4-5: A diagram of <code>&amp;String s</code> pointing at <code>String s1</code></span></p>
<blockquote>
<p>Note: The opposite of referencing by using <code>&amp;</code> is <em>dereferencing</em>, which is
accomplished with the dereference operator, <code>*</code>. We’ll see some uses of the
dereference operator in Chapter 8 and discuss details of dereferencing in
Chapter 15.</p>
</blockquote>
<p>Let’s take a closer look at the function call here:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span>let s1 = String::from(&quot;hello&quot;);

let len = calculate_length(&amp;s1);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>&amp;s1</code> syntax lets us create a reference that <em>refers</em> to the value of <code>s1</code>
but does not own it. Because it does not own it, the value it points to will
not be dropped when the reference goes out of scope.</p>
<p>Likewise, the signature of the function uses <code>&amp;</code> to indicate that the type of
the parameter <code>s</code> is a reference. Let’s add some explanatory annotations:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s is a reference to a String
    s.len()
} // Here, s goes out of scope. But because it does not have ownership of what
  // it refers to, nothing happens.
<span class="boring">}
</span></code></pre></pre>
<p>The scope in which the variable <code>s</code> is valid is the same as any function
parameter’s scope, but we don’t drop what the reference points to when it goes
out of scope because we don’t have ownership. When functions have references as
parameters instead of the actual values, we won’t need to return the values in
order to give back ownership, because we never had ownership.</p>
<p>We call having references as function parameters <em>borrowing</em>. As in real life,
if a person owns something, you can borrow it from them. When you’re done, you
have to give it back.</p>
<p>So what happens if we try to modify something we’re borrowing? Try the code in
Listing 4-6. Spoiler alert: it doesn’t work!</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let s = String::from(&quot;hello&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre>
<p><span class="caption">Listing 4-6: Attempting to modify a borrowed value</span></p>
<p>Here’s the error:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable borrowed content `*some_string` as mutable
 --&gt; error.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- use `&amp;mut String` here to make mutable
8 |     some_string.push_str(&quot;, world&quot;);
  |     ^^^^^^^^^^^ cannot borrow as mutable
</code></pre>
<p>Just as variables are immutable by default, so are references. We’re not
allowed to modify something we have a reference to.</p>
<h3><a class="header" href="#mutable-references" id="mutable-references">Mutable References</a></h3>
<p>We can fix the error in the code from Listing 4-6 with just a small tweak:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;hello&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot;, world&quot;);
}
</code></pre></pre>
<p>First, we had to change <code>s</code> to be <code>mut</code>. Then we had to create a mutable
reference with <code>&amp;mut s</code> and accept a mutable reference with <code>some_string: &amp;mut String</code>.</p>
<p>But mutable references have one big restriction: you can have only one mutable
reference to a particular piece of data in a particular scope. This code will
fail:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
</code></pre>
<p>Here’s the error:</p>
<pre><code class="language-text">error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 |
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here
</code></pre>
<p>This restriction allows for mutation but in a very controlled fashion. It’s
something that new Rustaceans struggle with, because most languages let you
mutate whenever you’d like.</p>
<p>The benefit of having this restriction is that Rust can prevent data races at
compile time. A <em>data race</em> is similar to a race condition and happens when
these three behaviors occur:</p>
<ul>
<li>Two or more pointers access the same data at the same time.</li>
<li>At least one of the pointers is being used to write to the data.</li>
<li>There’s no mechanism being used to synchronize access to the data.</li>
</ul>
<p>Data races cause undefined behavior and can be difficult to diagnose and fix
when you’re trying to track them down at runtime; Rust prevents this problem
from happening because it won’t even compile code with data races!</p>
<p>As always, we can use curly brackets to create a new scope, allowing for
multiple mutable references, just not <em>simultaneous</em> ones:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;hello&quot;);

{
    let r1 = &amp;mut s;

} // r1 goes out of scope here, so we can make a new reference with no problems.

let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>A similar rule exists for combining mutable and immutable references. This code
results in an error:</p>
<pre><code class="language-rust ignore does_not_compile">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // no problem
let r2 = &amp;s; // no problem
let r3 = &amp;mut s; // BIG PROBLEM

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
</code></pre>
<p>Here’s the error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s; // no problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s; // no problem
6 |     let r3 = &amp;mut s; // BIG PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
  |                                -- immutable borrow later used here
</code></pre>
<p>Whew! We <em>also</em> cannot have a mutable reference while we have an immutable one.
Users of an immutable reference don’t expect the values to suddenly change out
from under them! However, multiple immutable references are okay because no one
who is just reading the data has the ability to affect anyone else’s reading of
the data.</p>
<p>Note that a reference’s scope starts from where it is introduced and continues
through the last time that reference is used. For instance, this code will
compile because the last usage of the immutable references occurs before the
mutable reference is introduced:</p>
<!-- This example is being ignored because there's a bug in rustdoc making the
edition2018 not work. The bug is currently fixed in nightly, so when we update
the book to >= 1.35, `ignore` can be removed from this example. -->
<pre><code class="language-rust edition2018 ignore">let mut s = String::from(&quot;hello&quot;);

let r1 = &amp;s; // no problem
let r2 = &amp;s; // no problem
println!(&quot;{} and {}&quot;, r1, r2);
// r1 and r2 are no longer used after this point

let r3 = &amp;mut s; // no problem
println!(&quot;{}&quot;, r3);
</code></pre>
<p>The scopes of the immutable references <code>r1</code> and <code>r2</code> end after the <code>println!</code>
where they are last used, which is before the mutable reference <code>r3</code> is
created. These scopes don’t overlap, so this code is allowed.</p>
<p>Even though borrowing errors may be frustrating at times, remember that it’s
the Rust compiler pointing out a potential bug early (at compile time rather
than at runtime) and showing you exactly where the problem is. Then you don’t
have to track down why your data isn’t what you thought it was.</p>
<h3><a class="header" href="#dangling-references" id="dangling-references">Dangling References</a></h3>
<p>In languages with pointers, it’s easy to erroneously create a <em>dangling
pointer</em>, a pointer that references a location in memory that may have been
given to someone else, by freeing some memory while preserving a pointer to
that memory. In Rust, by contrast, the compiler guarantees that references will
never be dangling references: if you have a reference to some data, the
compiler will ensure that the data will not go out of scope before the
reference to the data does.</p>
<p>Let’s try to create a dangling reference, which Rust will prevent with a
compile-time error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;hello&quot;);

    &amp;s
}
</code></pre>
<p>Here’s the error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but there is
  no value for it to be borrowed from
  = help: consider giving it a 'static lifetime
</code></pre>
<p>This error message refers to a feature we haven’t covered yet: lifetimes. We’ll
discuss lifetimes in detail in Chapter 10. But, if you disregard the parts
about lifetimes, the message does contain the key to why this code is a problem:</p>
<pre><code class="language-text">this function's return type contains a borrowed value, but there is no value
for it to be borrowed from.
</code></pre>
<p>Let’s take a closer look at exactly what’s happening at each stage of our
<code>dangle</code> code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn dangle() -&gt; &amp;String { // dangle returns a reference to a String

    let s = String::from(&quot;hello&quot;); // s is a new String

    &amp;s // we return a reference to the String, s
} // Here, s goes out of scope, and is dropped. Its memory goes away.
  // Danger!
</code></pre>
<p>Because <code>s</code> is created inside <code>dangle</code>, when the code of <code>dangle</code> is finished,
<code>s</code> will be deallocated. But we tried to return a reference to it. That means
this reference would be pointing to an invalid <code>String</code>. That’s no good! Rust
won’t let us do this.</p>
<p>The solution here is to return the <code>String</code> directly:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;hello&quot;);

    s
}
<span class="boring">}
</span></code></pre></pre>
<p>This works without any problems. Ownership is moved out, and nothing is
deallocated.</p>
<h3><a class="header" href="#the-rules-of-references" id="the-rules-of-references">The Rules of References</a></h3>
<p>Let’s recap what we’ve discussed about references:</p>
<ul>
<li>At any given time, you can have <em>either</em> one mutable reference <em>or</em> any
number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p>Next, we’ll look at a different kind of reference: slices.</p>
<h2><a class="header" href="#the-slice-type" id="the-slice-type">The Slice Type</a></h2>
<p>Another data type that does not have ownership is the <em>slice</em>. Slices let you
reference a contiguous sequence of elements in a collection rather than the
whole collection.</p>
<p>Here’s a small programming problem: write a function that takes a string and
returns the first word it finds in that string. If the function doesn’t find a
space in the string, the whole string must be one word, so the entire string
should be returned.</p>
<p>Let’s think about the signature of this function:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>This function, <code>first_word</code>, has a <code>&amp;String</code> as a parameter. We don’t want
ownership, so this is fine. But what should we return? We don’t really have a
way to talk about <em>part</em> of a string. However, we could return the index of the
end of the word. Let’s try that, as shown in Listing 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 4-7: The <code>first_word</code> function that returns a
byte index value into the <code>String</code> parameter</span></p>
<p>Because we need to go through the <code>String</code> element by element and check whether
a value is a space, we’ll convert our <code>String</code> to an array of bytes using the
<code>as_bytes</code> method:</p>
<pre><code class="language-rust ignore">let bytes = s.as_bytes();
</code></pre>
<p>Next, we create an iterator over the array of bytes using the <code>iter</code> method:</p>
<pre><code class="language-rust ignore">for (i, &amp;item) in bytes.iter().enumerate() {
</code></pre>
<p>We’ll discuss iterators in more detail in Chapter 13. For now, know that <code>iter</code>
is a method that returns each element in a collection and that <code>enumerate</code>
wraps the result of <code>iter</code> and returns each element as part of a tuple instead.
The first element of the tuple returned from <code>enumerate</code> is the index, and the
second element is a reference to the element. This is a bit more convenient
than calculating the index ourselves.</p>
<p>Because the <code>enumerate</code> method returns a tuple, we can use patterns to
destructure that tuple, just like everywhere else in Rust. So in the <code>for</code>
loop, we specify a pattern that has <code>i</code> for the index in the tuple and <code>&amp;item</code>
for the single byte in the tuple. Because we get a reference to the element
from <code>.iter().enumerate()</code>, we use <code>&amp;</code> in the pattern.</p>
<p>Inside the <code>for</code> loop, we search for the byte that represents the space by
using the byte literal syntax. If we find a space, we return the position.
Otherwise, we return the length of the string by using <code>s.len()</code>:</p>
<pre><code class="language-rust ignore">    if item == b' ' {
        return i;
    }
}

s.len()
</code></pre>
<p>We now have a way to find out the index of the end of the first word in the
string, but there’s a problem. We’re returning a <code>usize</code> on its own, but it’s
only a meaningful number in the context of the <code>&amp;String</code>. In other words,
because it’s a separate value from the <code>String</code>, there’s no guarantee that it
will still be valid in the future. Consider the program in Listing 4-8 that
uses the <code>first_word</code> function from Listing 4-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s); // word will get the value 5

    s.clear(); // this empties the String, making it equal to &quot;&quot;

    // word still has the value 5 here, but there's no more string that
    // we could meaningfully use the value 5 with. word is now totally invalid!
}
</code></pre></pre>
<p><span class="caption">Listing 4-8: Storing the result from calling the
<code>first_word</code> function and then changing the <code>String</code> contents</span></p>
<p>This program compiles without any errors and would also do so if we used <code>word</code>
after calling <code>s.clear()</code>. Because <code>word</code> isn’t connected to the state of <code>s</code>
at all, <code>word</code> still contains the value <code>5</code>. We could use that value <code>5</code> with
the variable <code>s</code> to try to extract the first word out, but this would be a bug
because the contents of <code>s</code> have changed since we saved <code>5</code> in <code>word</code>.</p>
<p>Having to worry about the index in <code>word</code> getting out of sync with the data in
<code>s</code> is tedious and error prone! Managing these indices is even more brittle if
we write a <code>second_word</code> function. Its signature would have to look like this:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Now we’re tracking a starting <em>and</em> an ending index, and we have even more
values that were calculated from data in a particular state but aren’t tied to
that state at all. We now have three unrelated variables floating around that
need to be kept in sync.</p>
<p>Luckily, Rust has a solution to this problem: string slices.</p>
<h3><a class="header" href="#string-slices" id="string-slices">String Slices</a></h3>
<p>A <em>string slice</em> is a reference to part of a <code>String</code>, and it looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello world&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>This is similar to taking a reference to the whole <code>String</code> but with the extra
<code>[0..5]</code> bit. Rather than a reference to the entire <code>String</code>, it’s a reference
to a portion of the <code>String</code>.</p>
<p>We can create slices using a range within brackets by specifying
<code>[starting_index..ending_index]</code>, where <code>starting_index</code> is the first position
in the slice and <code>ending_index</code> is one more than the last position in the
slice. Internally, the slice data structure stores the starting position and
the length of the slice, which corresponds to <code>ending_index</code> minus
<code>starting_index</code>. So in the case of <code>let world = &amp;s[6..11];</code>, <code>world</code> would be
a slice that contains a pointer to the 7th byte of <code>s</code> with a length value of 5.</p>
<p>Figure 4-6 shows this in a diagram.</p>
<img alt="world containing a pointer to the 6th byte of String s and a length 5" src="rustbook/img/trpl04-06.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 4-6: String slice referring to part of a
<code>String</code></span></p>
<p>With Rust’s <code>..</code> range syntax, if you want to start at the first index (zero),
you can drop the value before the two periods. In other words, these are equal:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>By the same token, if your slice includes the last byte of the <code>String</code>, you
can drop the trailing number. That means these are equal:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>You can also drop both values to take a slice of the entire string. So these
are equal:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: String slice range indices must occur at valid UTF-8 character
boundaries. If you attempt to create a string slice in the middle of a
multibyte character, your program will exit with an error. For the purposes
of introducing string slices, we are assuming ASCII only in this section; a
more thorough discussion of UTF-8 handling is in the <a href="rustbook/ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">“Storing UTF-8 Encoded
Text with Strings”</a><!-- ignore --> section of Chapter 8.</p>
</blockquote>
<p>With all this information in mind, let’s rewrite <code>first_word</code> to return a
slice. The type that signifies “string slice” is written as <code>&amp;str</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}
</span></code></pre></pre>
<p>We get the index for the end of the word in the same way as we did in Listing
4-7, by looking for the first occurrence of a space. When we find a space, we
return a string slice using the start of the string and the index of the space
as the starting and ending indices.</p>
<p>Now when we call <code>first_word</code>, we get back a single value that is tied to the
underlying data. The value is made up of a reference to the starting point of
the slice and the number of elements in the slice.</p>
<p>Returning a slice would also work for a <code>second_word</code> function:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>We now have a straightforward API that’s much harder to mess up, because the
compiler will ensure the references into the <code>String</code> remain valid. Remember
the bug in the program in Listing 4-8, when we got the index to the end of the
first word but then cleared the string so our index was invalid? That code was
logically incorrect but didn’t show any immediate errors. The problems would
show up later if we kept trying to use the first word index with an emptied
string. Slices make this bug impossible and let us know we have a problem with
our code much sooner. Using the slice version of <code>first_word</code> will throw a
compile-time error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
</code></pre>
<p>Here’s the compiler error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 |
18 |     s.clear(); // error!
   |     ^^^^^^^^^ mutable borrow occurs here
19 |
20 |     println!(&quot;the first word is: {}&quot;, word);
   |                                       ---- immutable borrow later used here
</code></pre>
<p>Recall from the borrowing rules that if we have an immutable reference to
something, we cannot also take a mutable reference. Because <code>clear</code> needs to
truncate the <code>String</code>, it needs to get a mutable reference. Rust disallows
this, and compilation fails. Not only has Rust made our API easier to use, but
it has also eliminated an entire class of errors at compile time!</p>
<h4><a class="header" href="#string-literals-are-slices" id="string-literals-are-slices">String Literals Are Slices</a></h4>
<p>Recall that we talked about string literals being stored inside the binary. Now
that we know about slices, we can properly understand string literals:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hello, world!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>The type of <code>s</code> here is <code>&amp;str</code>: it’s a slice pointing to that specific point of
the binary. This is also why string literals are immutable; <code>&amp;str</code> is an
immutable reference.</p>
<h4><a class="header" href="#string-slices-as-parameters" id="string-slices-as-parameters">String Slices as Parameters</a></h4>
<p>Knowing that you can take slices of literals and <code>String</code> values leads us to
one more improvement on <code>first_word</code>, and that’s its signature:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>A more experienced Rustacean would write the signature shown in Listing 4-9
instead because it allows us to use the same function on both <code>&amp;String</code> values
and <code>&amp;str</code> values.</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p><span class="caption">Listing 4-9: Improving the <code>first_word</code> function by using
a string slice for the type of the <code>s</code> parameter</span></p>
<p>If we have a string slice, we can pass that directly. If we have a <code>String</code>, we
can pass a slice of the entire <code>String</code>. Defining a function to take a string
slice instead of a reference to a <code>String</code> makes our API more general and useful
without losing any functionality:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span>fn main() {
    let my_string = String::from(&quot;hello world&quot;);

    // first_word works on slices of `String`s
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;hello world&quot;;

    // first_word works on slices of string literals
    let word = first_word(&amp;my_string_literal[..]);

    // Because string literals *are* string slices already,
    // this works too, without the slice syntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3><a class="header" href="#other-slices" id="other-slices">Other Slices</a></h3>
<p>String slices, as you might imagine, are specific to strings. But there’s a
more general slice type, too. Consider this array:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Just as we might want to refer to a part of a string, we might want to refer
to part of an array. We’d do so like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<p>This slice has the type <code>&amp;[i32]</code>. It works the same way as string slices do, by
storing a reference to the first element and a length. You’ll use this kind of
slice for all sorts of other collections. We’ll discuss these collections in
detail when we talk about vectors in Chapter 8.</p>
<h2><a class="header" href="#summary-3" id="summary-3">Summary</a></h2>
<p>The concepts of ownership, borrowing, and slices ensure memory safety in Rust
programs at compile time. The Rust language gives you control over your memory
usage in the same way as other systems programming languages, but having the
owner of data automatically clean up that data when the owner goes out of scope
means you don’t have to write and debug extra code to get this control.</p>
<p>Ownership affects how lots of other parts of Rust work, so we’ll talk about
these concepts further throughout the rest of the book. Let’s move on to
Chapter 5 and look at grouping pieces of data together in a <code>struct</code>.</p>
<h1><a class="header" href="#using-structs-to-structure-related-data" id="using-structs-to-structure-related-data">Using Structs to Structure Related Data</a></h1>
<p>A <em>struct</em>, or <em>structure</em>, is a custom data type that lets you name and
package together multiple related values that make up a meaningful group. If
you’re familiar with an object-oriented language, a <em>struct</em> is like an
object’s data attributes. In this chapter, we’ll compare and contrast tuples
with structs, demonstrate how to use structs, and discuss how to define methods
and associated functions to specify behavior associated with a struct’s data.
Structs and enums (discussed in Chapter 6) are the building blocks for creating
new types in your program’s domain to take full advantage of Rust’s compile
time type checking.</p>
<h2><a class="header" href="#defining-and-instantiating-structs" id="defining-and-instantiating-structs">Defining and Instantiating Structs</a></h2>
<p>Structs are similar to tuples, which were discussed in Chapter 3. Like tuples,
the pieces of a struct can be different types. Unlike with tuples, you’ll name
each piece of data so it’s clear what the values mean. As a result of these
names, structs are more flexible than tuples: you don’t have to rely on the
order of the data to specify or access the values of an instance.</p>
<p>To define a struct, we enter the keyword <code>struct</code> and name the entire struct. A
struct’s name should describe the significance of the pieces of data being
grouped together. Then, inside curly brackets, we define the names and types of
the pieces of data, which we call <em>fields</em>. For example, Listing 5-1 shows a
struct that stores information about a user account.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-1: A <code>User</code> struct definition</span></p>
<p>To use a struct after we’ve defined it, we create an <em>instance</em> of that struct
by specifying concrete values for each of the fields. We create an instance by
stating the name of the struct and then add curly brackets containing <code>key: value</code> pairs, where the keys are the names of the fields and the values are the
data we want to store in those fields. We don’t have to specify the fields in
the same order in which we declared them in the struct. In other words, the
struct definition is like a general template for the type, and instances fill
in that template with particular data to create values of the type. For
example, we can declare a particular user as shown in Listing 5-2.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>let user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-2: Creating an instance of the <code>User</code>
struct</span></p>
<p>To get a specific value from a struct, we can use dot notation. If we wanted
just this user’s email address, we could use <code>user1.email</code> wherever we wanted
to use this value. If the instance is mutable, we can change a value by using
the dot notation and assigning into a particular field. Listing 5-3 shows how
to change the value in the <code>email</code> field of a mutable <code>User</code> instance.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>let mut user1 = User {
    email: String::from(&quot;someone@example.com&quot;),
    username: String::from(&quot;someusername123&quot;),
    active: true,
    sign_in_count: 1,
};

user1.email = String::from(&quot;anotheremail@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-3: Changing the value in the <code>email</code> field of a
<code>User</code> instance</span></p>
<p>Note that the entire instance must be mutable; Rust doesn’t allow us to mark
only certain fields as mutable. As with any expression, we can construct a new
instance of the struct as the last expression in the function body to
implicitly return that new instance.</p>
<p>Listing 5-4 shows a <code>build_user</code> function that returns a <code>User</code> instance with
the given email and username. The <code>active</code> field gets the value of <code>true</code>, and
the <code>sign_in_count</code> gets a value of <code>1</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-4: A <code>build_user</code> function that takes an email
and username and returns a <code>User</code> instance</span></p>
<p>It makes sense to name the function parameters with the same name as the struct
fields, but having to repeat the <code>email</code> and <code>username</code> field names and
variables is a bit tedious. If the struct had more fields, repeating each name
would get even more annoying. Luckily, there’s a convenient shorthand!</p>
<h3><a class="header" href="#using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name" id="using-the-field-init-shorthand-when-variables-and-fields-have-the-same-name">Using the Field Init Shorthand when Variables and Fields Have the Same Name</a></h3>
<p>Because the parameter names and the struct field names are exactly the same in
Listing 5-4, we can use the <em>field init shorthand</em> syntax to rewrite
<code>build_user</code> so that it behaves exactly the same but doesn’t have the
repetition of <code>email</code> and <code>username</code>, as shown in Listing 5-5.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-5: A <code>build_user</code> function that uses field init
shorthand because the <code>email</code> and <code>username</code> parameters have the same name as
struct fields</span></p>
<p>Here, we’re creating a new instance of the <code>User</code> struct, which has a field
named <code>email</code>. We want to set the <code>email</code> field’s value to the value in the
<code>email</code> parameter of the <code>build_user</code> function. Because the <code>email</code> field and
the <code>email</code> parameter have the same name, we only need to write <code>email</code> rather
than <code>email: email</code>.</p>
<h3><a class="header" href="#creating-instances-from-other-instances-with-struct-update-syntax" id="creating-instances-from-other-instances-with-struct-update-syntax">Creating Instances From Other Instances With Struct Update Syntax</a></h3>
<p>It’s often useful to create a new instance of a struct that uses most of an old
instance’s values but changes some. You’ll do this using <em>struct update syntax</em>.</p>
<p>First, Listing 5-6 shows how we create a new <code>User</code> instance in <code>user2</code> without
the update syntax. We set new values for <code>email</code> and <code>username</code> but otherwise
use the same values from <code>user1</code> that we created in Listing 5-2.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let user1 = User {
</span><span class="boring">    email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">    username: String::from(&quot;someusername123&quot;),
</span><span class="boring">    active: true,
</span><span class="boring">    sign_in_count: 1,
</span><span class="boring">};
</span><span class="boring">
</span>let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    active: user1.active,
    sign_in_count: user1.sign_in_count,
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-6: Creating a new <code>User</code> instance using some of
the values from <code>user1</code></span></p>
<p>Using struct update syntax, we can achieve the same effect with less code, as
shown in Listing 5-7. The syntax <code>..</code> specifies that the remaining fields not
explicitly set should have the same value as the fields in the given instance.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let user1 = User {
</span><span class="boring">    email: String::from(&quot;someone@example.com&quot;),
</span><span class="boring">    username: String::from(&quot;someusername123&quot;),
</span><span class="boring">    active: true,
</span><span class="boring">    sign_in_count: 1,
</span><span class="boring">};
</span><span class="boring">
</span>let user2 = User {
    email: String::from(&quot;another@example.com&quot;),
    username: String::from(&quot;anotherusername567&quot;),
    ..user1
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-7: Using struct update syntax to set new
<code>email</code> and <code>username</code> values for a <code>User</code> instance but use the rest of the
values from the fields of the instance in the <code>user1</code> variable</span></p>
<p>The code in Listing 5-7 also creates an instance in <code>user2</code> that has a
different value for <code>email</code> and <code>username</code> but has the same values for the
<code>active</code> and <code>sign_in_count</code> fields from <code>user1</code>.</p>
<h3><a class="header" href="#using-tuple-structs-without-named-fields-to-create-different-types" id="using-tuple-structs-without-named-fields-to-create-different-types">Using Tuple Structs without Named Fields to Create Different Types</a></h3>
<p>You can also define structs that look similar to tuples, called <em>tuple
structs</em>. Tuple structs have the added meaning the struct name provides but
don’t have names associated with their fields; rather, they just have the types
of the fields. Tuple structs are useful when you want to give the whole tuple a
name and make the tuple be a different type from other tuples, and naming each
field as in a regular struct would be verbose or redundant.</p>
<p>To define a tuple struct, start with the <code>struct</code> keyword and the struct name
followed by the types in the tuple. For example, here are definitions and
usages of two tuple structs named <code>Color</code> and <code>Point</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<p>Note that the <code>black</code> and <code>origin</code> values are different types, because they’re
instances of different tuple structs. Each struct you define is its own type,
even though the fields within the struct have the same types. For example, a
function that takes a parameter of type <code>Color</code> cannot take a <code>Point</code> as an
argument, even though both types are made up of three <code>i32</code> values. Otherwise,
tuple struct instances behave like tuples: you can destructure them into their
individual pieces, you can use a <code>.</code> followed by the index to access an
individual value, and so on.</p>
<h3><a class="header" href="#unit-like-structs-without-any-fields" id="unit-like-structs-without-any-fields">Unit-Like Structs Without Any Fields</a></h3>
<p>You can also define structs that don’t have any fields! These are called
<em>unit-like structs</em> because they behave similarly to <code>()</code>, the unit type.
Unit-like structs can be useful in situations in which you need to implement a
trait on some type but don’t have any data that you want to store in the type
itself. We’ll discuss traits in Chapter 10.</p>
<blockquote>
<h3><a class="header" href="#ownership-of-struct-data" id="ownership-of-struct-data">Ownership of Struct Data</a></h3>
<p>In the <code>User</code> struct definition in Listing 5-1, we used the owned <code>String</code>
type rather than the <code>&amp;str</code> string slice type. This is a deliberate choice
because we want instances of this struct to own all of its data and for that
data to be valid for as long as the entire struct is valid.</p>
<p>It’s possible for structs to store references to data owned by something else,
but to do so requires the use of <em>lifetimes</em>, a Rust feature that we’ll
discuss in Chapter 10. Lifetimes ensure that the data referenced by a struct
is valid for as long as the struct is. Let’s say you try to store a reference
in a struct without specifying lifetimes, like this, which won’t work:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;someone@example.com&quot;,
        username: &quot;someusername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre>
<p>The compiler will complain that it needs lifetime specifiers:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt;
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt;
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter
</code></pre>
<p>In Chapter 10, we’ll discuss how to fix these errors so you can store
references in structs, but for now, we’ll fix errors like these using owned
types like <code>String</code> instead of references like <code>&amp;str</code>.</p>
</blockquote>
<h2><a class="header" href="#an-example-program-using-structs" id="an-example-program-using-structs">An Example Program Using Structs</a></h2>
<p>To understand when we might want to use structs, let’s write a program that
calculates the area of a rectangle. We’ll start with single variables, and then
refactor the program until we’re using structs instead.</p>
<p>Let’s make a new binary project with Cargo called <em>rectangles</em> that will take
the width and height of a rectangle specified in pixels and calculate the area
of the rectangle. Listing 5-8 shows a short program with one way of doing
exactly that in our project’s <em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">Listing 5-8: Calculating the area of a rectangle
specified by separate width and height variables</span></p>
<p>Now, run this program using <code>cargo run</code>:</p>
<pre><code class="language-text">The area of the rectangle is 1500 square pixels.
</code></pre>
<p>Even though Listing 5-8 works and figures out the area of the rectangle by
calling the <code>area</code> function with each dimension, we can do better. The width
and the height are related to each other because together they describe one
rectangle.</p>
<p>The issue with this code is evident in the signature of <code>area</code>:</p>
<pre><code class="language-rust ignore">fn area(width: u32, height: u32) -&gt; u32 {
</code></pre>
<p>The <code>area</code> function is supposed to calculate the area of one rectangle, but the
function we wrote has two parameters. The parameters are related, but that’s
not expressed anywhere in our program. It would be more readable and more
manageable to group width and height together. We’ve already discussed one way
we might do that in <a href="rustbook/ch03-02-data-types.html#the-tuple-type">“The Tuple Type”</a><!-- ignore --> section
of Chapter 3: by using tuples.</p>
<h3><a class="header" href="#refactoring-with-tuples" id="refactoring-with-tuples">Refactoring with Tuples</a></h3>
<p>Listing 5-9 shows another version of our program that uses tuples.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Listing 5-9: Specifying the width and height of the
rectangle with a tuple</span></p>
<p>In one way, this program is better. Tuples let us add a bit of structure, and
we’re now passing just one argument. But in another way, this version is less
clear: tuples don’t name their elements, so our calculation has become more
confusing because we have to index into the parts of the tuple.</p>
<p>It doesn’t matter if we mix up width and height for the area calculation, but
if we want to draw the rectangle on the screen, it would matter! We would have
to keep in mind that <code>width</code> is the tuple index <code>0</code> and <code>height</code> is the tuple
index <code>1</code>. If someone else worked on this code, they would have to figure this
out and keep it in mind as well. It would be easy to forget or mix up these
values and cause errors, because we haven’t conveyed the meaning of our data in
our code.</p>
<h3><a class="header" href="#refactoring-with-structs-adding-more-meaning" id="refactoring-with-structs-adding-more-meaning">Refactoring with Structs: Adding More Meaning</a></h3>
<p>We use structs to add meaning by labeling the data. We can transform the tuple
we’re using into a data type with a name for the whole as well as names for the
parts, as shown in Listing 5-10.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">Listing 5-10: Defining a <code>Rectangle</code> struct</span></p>
<p>Here we’ve defined a struct and named it <code>Rectangle</code>. Inside the curly
brackets, we defined the fields as <code>width</code> and <code>height</code>, both of which have
type <code>u32</code>. Then in <code>main</code>, we created a particular instance of <code>Rectangle</code>
that has a width of 30 and a height of 50.</p>
<p>Our <code>area</code> function is now defined with one parameter, which we’ve named
<code>rectangle</code>, whose type is an immutable borrow of a struct <code>Rectangle</code>
instance. As mentioned in Chapter 4, we want to borrow the struct rather than
take ownership of it. This way, <code>main</code> retains its ownership and can continue
using <code>rect1</code>, which is the reason we use the <code>&amp;</code> in the function signature and
where we call the function.</p>
<p>The <code>area</code> function accesses the <code>width</code> and <code>height</code> fields of the <code>Rectangle</code>
instance. Our function signature for <code>area</code> now says exactly what we mean:
calculate the area of <code>Rectangle</code>, using its <code>width</code> and <code>height</code> fields. This
conveys that the width and height are related to each other, and it gives
descriptive names to the values rather than using the tuple index values of <code>0</code>
and <code>1</code>. This is a win for clarity.</p>
<h3><a class="header" href="#adding-useful-functionality-with-derived-traits" id="adding-useful-functionality-with-derived-traits">Adding Useful Functionality with Derived Traits</a></h3>
<p>It’d be nice to be able to print an instance of <code>Rectangle</code> while we’re
debugging our program and see the values for all its fields. Listing 5-11 tries
using the <code>println!</code> macro as we have used in previous chapters. This won’t
work, however.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {}&quot;, rect1);
}
</code></pre>
<p><span class="caption">Listing 5-11: Attempting to print a <code>Rectangle</code>
instance</span></p>
<p>When we run this code, we get an error with this core message:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>The <code>println!</code> macro can do many kinds of formatting, and by default, the curly
brackets tell <code>println!</code> to use formatting known as <code>Display</code>: output intended
for direct end user consumption. The primitive types we’ve seen so far
implement <code>Display</code> by default, because there’s only one way you’d want to show
a <code>1</code> or any other primitive type to a user. But with structs, the way
<code>println!</code> should format the output is less clear because there are more
display possibilities: Do you want commas or not? Do you want to print the
curly brackets? Should all the fields be shown? Due to this ambiguity, Rust
doesn’t try to guess what we want, and structs don’t have a provided
implementation of <code>Display</code>.</p>
<p>If we continue reading the errors, we’ll find this helpful note:</p>
<pre><code class="language-text">= help: the trait `std::fmt::Display` is not implemented for `Rectangle`
= note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Let’s try it! The <code>println!</code> macro call will now look like <code>println!(&quot;rect1 is {:?}&quot;, rect1);</code>. Putting the specifier <code>:?</code> inside the curly brackets tells
<code>println!</code> we want to use an output format called <code>Debug</code>. The <code>Debug</code> trait
enables us to print our struct in a way that is useful for developers so we can
see its value while we’re debugging our code.</p>
<p>Run the code with this change. Drat! We still get an error:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
</code></pre>
<p>But again, the compiler gives us a helpful note:</p>
<pre><code class="language-text">= help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
= note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
</code></pre>
<p>Rust <em>does</em> include functionality to print out debugging information, but we
have to explicitly opt in to make that functionality available for our struct.
To do that, we add the annotation <code>#[derive(Debug)]</code> just before the struct
definition, as shown in Listing 5-12.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(&quot;rect1 is {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Listing 5-12: Adding the annotation to derive the <code>Debug</code>
trait and printing the <code>Rectangle</code> instance using debug formatting</span></p>
<p>Now when we run the program, we won’t get any errors, and we’ll see the
following output:</p>
<pre><code class="language-text">rect1 is Rectangle { width: 30, height: 50 }
</code></pre>
<p>Nice! It’s not the prettiest output, but it shows the values of all the fields
for this instance, which would definitely help during debugging. When we have
larger structs, it’s useful to have output that’s a bit easier to read; in
those cases, we can use <code>{:#?}</code> instead of <code>{:?}</code> in the <code>println!</code> string.
When we use the <code>{:#?}</code> style in the example, the output will look like this:</p>
<pre><code class="language-text">rect1 is Rectangle {
    width: 30,
    height: 50
}
</code></pre>
<p>Rust has provided a number of traits for us to use with the <code>derive</code> annotation
that can add useful behavior to our custom types. Those traits and their
behaviors are listed in Appendix C. We’ll cover how to implement these traits
with custom behavior as well as how to create your own traits in Chapter 10.</p>
<p>Our <code>area</code> function is very specific: it only computes the area of rectangles.
It would be helpful to tie this behavior more closely to our <code>Rectangle</code>
struct, because it won’t work with any other type. Let’s look at how we can
continue to refactor this code by turning the <code>area</code> function into an <code>area</code>
<em>method</em> defined on our <code>Rectangle</code> type.</p>
<h2><a class="header" href="#method-syntax" id="method-syntax">Method Syntax</a></h2>
<p><em>Methods</em> are similar to functions: they’re declared with the <code>fn</code> keyword and
their name, they can have parameters and a return value, and they contain some
code that is run when they’re called from somewhere else. However, methods are
different from functions in that they’re defined within the context of a struct
(or an enum or a trait object, which we cover in Chapters 6 and 17,
respectively), and their first parameter is always <code>self</code>, which represents the
instance of the struct the method is being called on.</p>
<h3><a class="header" href="#defining-methods" id="defining-methods">Defining Methods</a></h3>
<p>Let’s change the <code>area</code> function that has a <code>Rectangle</code> instance as a parameter
and instead make an <code>area</code> method defined on the <code>Rectangle</code> struct, as shown
in Listing 5-13.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    println!(
        &quot;The area of the rectangle is {} square pixels.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Listing 5-13: Defining an <code>area</code> method on the
<code>Rectangle</code> struct</span></p>
<p>To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code>
(implementation) block. Then we move the <code>area</code> function within the <code>impl</code>
curly brackets and change the first (and in this case, only) parameter to be
<code>self</code> in the signature and everywhere within the body. In <code>main</code>, where we
called the <code>area</code> function and passed <code>rect1</code> as an argument, we can instead
use <em>method syntax</em> to call the <code>area</code> method on our <code>Rectangle</code> instance.
The method syntax goes after an instance: we add a dot followed by the method
name, parentheses, and any arguments.</p>
<p>In the signature for <code>area</code>, we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code>
because Rust knows the type of <code>self</code> is <code>Rectangle</code> due to this method’s being
inside the <code>impl Rectangle</code> context. Note that we still need to use the <code>&amp;</code>
before <code>self</code>, just as we did in <code>&amp;Rectangle</code>. Methods can take ownership of
<code>self</code>, borrow <code>self</code> immutably as we’ve done here, or borrow <code>self</code> mutably,
just as they can any other parameter.</p>
<p>We’ve chosen <code>&amp;self</code> here for the same reason we used <code>&amp;Rectangle</code> in the
function version: we don’t want to take ownership, and we just want to read the
data in the struct, not write to it. If we wanted to change the instance that
we’ve called the method on as part of what the method does, we’d use <code>&amp;mut self</code> as the first parameter. Having a method that takes ownership of the
instance by using just <code>self</code> as the first parameter is rare; this technique is
usually used when the method transforms <code>self</code> into something else and you want
to prevent the caller from using the original instance after the transformation.</p>
<p>The main benefit of using methods instead of functions, in addition to using
method syntax and not having to repeat the type of <code>self</code> in every method’s
signature, is for organization. We’ve put all the things we can do with an
instance of a type in one <code>impl</code> block rather than making future users of our
code search for capabilities of <code>Rectangle</code> in various places in the library we
provide.</p>
<blockquote>
<h3><a class="header" href="#wheres-the---operator" id="wheres-the---operator">Where’s the <code>-&gt;</code> Operator?</a></h3>
<p>In C and C++, two different operators are used for calling methods: you use
<code>.</code> if you’re calling a method on the object directly and <code>-&gt;</code> if you’re
calling the method on a pointer to the object and need to dereference the
pointer first. In other words, if <code>object</code> is a pointer,
<code>object-&gt;something()</code> is similar to <code>(*object).something()</code>.</p>
<p>Rust doesn’t have an equivalent to the <code>-&gt;</code> operator; instead, Rust has a
feature called <em>automatic referencing and dereferencing</em>. Calling methods is
one of the few places in Rust that has this behavior.</p>
<p>Here’s how it works: when you call a method with <code>object.something()</code>, Rust
automatically adds in <code>&amp;</code>, <code>&amp;mut</code>, or <code>*</code> so <code>object</code> matches the signature of
the method. In other words, the following are the same:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>The first one looks much cleaner. This automatic referencing behavior works
because methods have a clear receiver—the type of <code>self</code>. Given the receiver
and name of a method, Rust can figure out definitively whether the method is
reading (<code>&amp;self</code>), mutating (<code>&amp;mut self</code>), or consuming (<code>self</code>). The fact
that Rust makes borrowing implicit for method receivers is a big part of
making ownership ergonomic in practice.</p>
</blockquote>
<h3><a class="header" href="#methods-with-more-parameters" id="methods-with-more-parameters">Methods with More Parameters</a></h3>
<p>Let’s practice using methods by implementing a second method on the <code>Rectangle</code>
struct. This time, we want an instance of <code>Rectangle</code> to take another instance
of <code>Rectangle</code> and return <code>true</code> if the second <code>Rectangle</code> can fit completely
within <code>self</code>; otherwise it should return <code>false</code>. That is, we want to be able
to write the program shown in Listing 5-14, once we’ve defined the <code>can_hold</code>
method.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    let rect2 = Rectangle { width: 10, height: 40 };
    let rect3 = Rectangle { width: 60, height: 45 };

    println!(&quot;Can rect1 hold rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Can rect1 hold rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Listing 5-14: Using the as-yet-unwritten <code>can_hold</code>
method</span></p>
<p>And the expected output would look like the following, because both dimensions
of <code>rect2</code> are smaller than the dimensions of <code>rect1</code> but <code>rect3</code> is wider than
<code>rect1</code>:</p>
<pre><code class="language-text">Can rect1 hold rect2? true
Can rect1 hold rect3? false
</code></pre>
<p>We know we want to define a method, so it will be within the <code>impl Rectangle</code>
block. The method name will be <code>can_hold</code>, and it will take an immutable borrow
of another <code>Rectangle</code> as a parameter. We can tell what the type of the
parameter will be by looking at the code that calls the method:
<code>rect1.can_hold(&amp;rect2)</code> passes in <code>&amp;rect2</code>, which is an immutable borrow to
<code>rect2</code>, an instance of <code>Rectangle</code>. This makes sense because we only need to
read <code>rect2</code> (rather than write, which would mean we’d need a mutable borrow),
and we want <code>main</code> to retain ownership of <code>rect2</code> so we can use it again after
calling the <code>can_hold</code> method. The return value of <code>can_hold</code> will be a
Boolean, and the implementation will check whether the width and height of
<code>self</code> are both greater than the width and height of the other <code>Rectangle</code>,
respectively. Let’s add the new <code>can_hold</code> method to the <code>impl</code> block from
Listing 5-13, shown in Listing 5-15.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-15: Implementing the <code>can_hold</code> method on
<code>Rectangle</code> that takes another <code>Rectangle</code> instance as a parameter</span></p>
<p>When we run this code with the <code>main</code> function in Listing 5-14, we’ll get our
desired output. Methods can take multiple parameters that we add to the
signature after the <code>self</code> parameter, and those parameters work just like
parameters in functions.</p>
<h3><a class="header" href="#associated-functions" id="associated-functions">Associated Functions</a></h3>
<p>Another useful feature of <code>impl</code> blocks is that we’re allowed to define
functions within <code>impl</code> blocks that <em>don’t</em> take <code>self</code> as a parameter. These
are called <em>associated functions</em> because they’re associated with the struct.
They’re still functions, not methods, because they don’t have an instance of
the struct to work with. You’ve already used the <code>String::from</code> associated
function.</p>
<p>Associated functions are often used for constructors that will return a new
instance of the struct. For example, we could provide an associated function
that would have one dimension parameter and use that as both width and height,
thus making it easier to create a square <code>Rectangle</code> rather than having to
specify the same value twice:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle { width: size, height: size }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To call this associated function, we use the <code>::</code> syntax with the struct name;
<code>let sq = Rectangle::square(3);</code> is an example. This function is namespaced by
the struct: the <code>::</code> syntax is used for both associated functions and
namespaces created by modules. We’ll discuss modules in Chapter 7.</p>
<h3><a class="header" href="#multiple-impl-blocks" id="multiple-impl-blocks">Multiple <code>impl</code> Blocks</a></h3>
<p>Each struct is allowed to have multiple <code>impl</code> blocks. For example, Listing
5-15 is equivalent to the code shown in Listing 5-16, which has each method
in its own <code>impl</code> block.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 5-16: Rewriting Listing 5-15 using multiple <code>impl</code>
blocks</span></p>
<p>There’s no reason to separate these methods into multiple <code>impl</code> blocks here,
but this is valid syntax. We’ll see a case in which multiple <code>impl</code> blocks are
useful in Chapter 10, where we discuss generic types and traits.</p>
<h2><a class="header" href="#summary-4" id="summary-4">Summary</a></h2>
<p>Structs let you create custom types that are meaningful for your domain. By
using structs, you can keep associated pieces of data connected to each other
and name each piece to make your code clear. Methods let you specify the
behavior that instances of your structs have, and associated functions let you
namespace functionality that is particular to your struct without having an
instance available.</p>
<p>But structs aren’t the only way you can create custom types: let’s turn to
Rust’s enum feature to add another tool to your toolbox.</p>
<h1><a class="header" href="#enums-and-pattern-matching" id="enums-and-pattern-matching">Enums and Pattern Matching</a></h1>
<p>In this chapter we’ll look at <em>enumerations</em>, also referred to as <em>enums</em>.
Enums allow you to define a type by enumerating its possible values. First,
we’ll define and use an enum to show how an enum can encode meaning along with
data. Next, we’ll explore a particularly useful enum, called <code>Option</code>, which
expresses that a value can be either something or nothing. Then we’ll look at
how pattern matching in the <code>match</code> expression makes it easy to run different
code for different values of an enum. Finally, we’ll cover how the <code>if let</code>
construct is another convenient and concise idiom available to you to handle
enums in your code.</p>
<p>Enums are a feature in many languages, but their capabilities differ in each
language. Rust’s enums are most similar to <em>algebraic data types</em> in functional
languages, such as F#, OCaml, and Haskell.</p>
<h2><a class="header" href="#defining-an-enum" id="defining-an-enum">Defining an Enum</a></h2>
<p>Let’s look at a situation we might want to express in code and see why enums
are useful and more appropriate than structs in this case. Say we need to work
with IP addresses. Currently, two major standards are used for IP addresses:
version four and version six. These are the only possibilities for an IP
address that our program will come across: we can <em>enumerate</em> all possible
values, which is where enumeration gets its name.</p>
<p>Any IP address can be either a version four or a version six address, but not
both at the same time. That property of IP addresses makes the enum data
structure appropriate, because enum values can only be one of the variants.
Both version four and version six addresses are still fundamentally IP
addresses, so they should be treated as the same type when the code is handling
situations that apply to any kind of IP address.</p>
<p>We can express this concept in code by defining an <code>IpAddrKind</code> enumeration and
listing the possible kinds an IP address can be, <code>V4</code> and <code>V6</code>. These are known
as the <em>variants</em> of the enum:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">}
</span></code></pre></pre>
<p><code>IpAddrKind</code> is now a custom data type that we can use elsewhere in our code.</p>
<h3><a class="header" href="#enum-values" id="enum-values">Enum Values</a></h3>
<p>We can create instances of each of the two variants of <code>IpAddrKind</code> like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span>let four = IpAddrKind::V4;
let six = IpAddrKind::V6;
<span class="boring">}
</span></code></pre></pre>
<p>Note that the variants of the enum are namespaced under its identifier, and we
use a double colon to separate the two. The reason this is useful is that now
both values <code>IpAddrKind::V4</code> and <code>IpAddrKind::V6</code> are of the same type:
<code>IpAddrKind</code>. We can then, for instance, define a function that takes any
<code>IpAddrKind</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) { }
<span class="boring">}
</span></code></pre></pre>
<p>And we can call this function with either variant:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) { }
</span><span class="boring">
</span>route(IpAddrKind::V4);
route(IpAddrKind::V6);
<span class="boring">}
</span></code></pre></pre>
<p>Using enums has even more advantages. Thinking more about our IP address type,
at the moment we don’t have a way to store the actual IP address <em>data</em>; we
only know what <em>kind</em> it is. Given that you just learned about structs in
Chapter 5, you might tackle this problem as shown in Listing 6-1.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-1: Storing the data and <code>IpAddrKind</code> variant of
an IP address using a <code>struct</code></span></p>
<p>Here, we’ve defined a struct <code>IpAddr</code> that has two fields: a <code>kind</code> field that
is of type <code>IpAddrKind</code> (the enum we defined previously) and an <code>address</code> field
of type <code>String</code>. We have two instances of this struct. The first, <code>home</code>, has
the value <code>IpAddrKind::V4</code> as its <code>kind</code> with associated address data of
<code>127.0.0.1</code>. The second instance, <code>loopback</code>, has the other variant of
<code>IpAddrKind</code> as its <code>kind</code> value, <code>V6</code>, and has address <code>::1</code> associated with
it. We’ve used a struct to bundle the <code>kind</code> and <code>address</code> values together, so
now the variant is associated with the value.</p>
<p>We can represent the same concept in a more concise way using just an enum,
rather than an enum inside a struct, by putting data directly into each enum
variant. This new definition of the <code>IpAddr</code> enum says that both <code>V4</code> and <code>V6</code>
variants will have associated <code>String</code> values:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>We attach data to each variant of the enum directly, so there is no need for an
extra struct.</p>
<p>There’s another advantage to using an enum rather than a struct: each variant
can have different types and amounts of associated data. Version four type IP
addresses will always have four numeric components that will have values
between 0 and 255. If we wanted to store <code>V4</code> addresses as four <code>u8</code> values but
still express <code>V6</code> addresses as one <code>String</code> value, we wouldn’t be able to with
a struct. Enums handle this case with ease:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>We’ve shown several different ways to define data structures to store version
four and version six IP addresses. However, as it turns out, wanting to store
IP addresses and encode which kind they are is so common that <a href="rustbook/../std/net/enum.IpAddr.html">the standard
library has a definition we can use!</a><!-- ignore --> Let’s look at how
the standard library defines <code>IpAddr</code>: it has the exact enum and variants that
we’ve defined and used, but it embeds the address data inside the variants in
the form of two different structs, which are defined differently for each
variant:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>This code illustrates that you can put any kind of data inside an enum variant:
strings, numeric types, or structs, for example. You can even include another
enum! Also, standard library types are often not much more complicated than
what you might come up with.</p>
<p>Note that even though the standard library contains a definition for <code>IpAddr</code>,
we can still create and use our own definition without conflict because we
haven’t brought the standard library’s definition into our scope. We’ll talk
more about bringing types into scope in Chapter 7.</p>
<p>Let’s look at another example of an enum in Listing 6-2: this one has a wide
variety of types embedded in its variants.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-2: A <code>Message</code> enum whose variants each store
different amounts and types of values</span></p>
<p>This enum has four variants with different types:</p>
<ul>
<li><code>Quit</code> has no data associated with it at all.</li>
<li><code>Move</code> includes an anonymous struct inside it.</li>
<li><code>Write</code> includes a single <code>String</code>.</li>
<li><code>ChangeColor</code> includes three <code>i32</code> values.</li>
</ul>
<p>Defining an enum with variants such as the ones in Listing 6-2 is similar to
defining different kinds of struct definitions, except the enum doesn’t use the
<code>struct</code> keyword and all the variants are grouped together under the <code>Message</code>
type. The following structs could hold the same data that the preceding enum
variants hold:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct QuitMessage; // unit struct
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // tuple struct
struct ChangeColorMessage(i32, i32, i32); // tuple struct
<span class="boring">}
</span></code></pre></pre>
<p>But if we used the different structs, which each have their own type, we
couldn’t as easily define a function to take any of these kinds of messages as
we could with the <code>Message</code> enum defined in Listing 6-2, which is a single type.</p>
<p>There is one more similarity between enums and structs: just as we’re able to
define methods on structs using <code>impl</code>, we’re also able to define methods on
enums. Here’s a method named <code>call</code> that we could define on our <code>Message</code> enum:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Message {
</span><span class="boring">    Quit,
</span><span class="boring">    Move { x: i32, y: i32 },
</span><span class="boring">    Write(String),
</span><span class="boring">    ChangeColor(i32, i32, i32),
</span><span class="boring">}
</span><span class="boring">
</span>impl Message {
    fn call(&amp;self) {
        // method body would be defined here
    }
}

let m = Message::Write(String::from(&quot;hello&quot;));
m.call();
<span class="boring">}
</span></code></pre></pre>
<p>The body of the method would use <code>self</code> to get the value that we called the
method on. In this example, we’ve created a variable <code>m</code> that has the value
<code>Message::Write(String::from(&quot;hello&quot;))</code>, and that is what <code>self</code> will be in the
body of the <code>call</code> method when <code>m.call()</code> runs.</p>
<p>Let’s look at another enum in the standard library that is very common and
useful: <code>Option</code>.</p>
<h3><a class="header" href="#the-option-enum-and-its-advantages-over-null-values" id="the-option-enum-and-its-advantages-over-null-values">The <code>Option</code> Enum and Its Advantages Over Null Values</a></h3>
<p>In the previous section, we looked at how the <code>IpAddr</code> enum let us use Rust’s
type system to encode more information than just the data into our program.
This section explores a case study of <code>Option</code>, which is another enum defined
by the standard library. The <code>Option</code> type is used in many places because it
encodes the very common scenario in which a value could be something or it
could be nothing. Expressing this concept in terms of the type system means the
compiler can check whether you’ve handled all the cases you should be handling;
this functionality can prevent bugs that are extremely common in other
programming languages.</p>
<p>Programming language design is often thought of in terms of which features you
include, but the features you exclude are important too. Rust doesn’t have the
null feature that many other languages have. <em>Null</em> is a value that means there
is no value there. In languages with null, variables can always be in one of
two states: null or not-null.</p>
<p>In his 2009 presentation “Null References: The Billion Dollar Mistake,” Tony
Hoare, the inventor of null, has this to say:</p>
<blockquote>
<p>I call it my billion-dollar mistake. At that time, I was designing the first
comprehensive type system for references in an object-oriented language. My
goal was to ensure that all use of references should be absolutely safe, with
checking performed automatically by the compiler. But I couldn’t resist the
temptation to put in a null reference, simply because it was so easy to
implement. This has led to innumerable errors, vulnerabilities, and system
crashes, which have probably caused a billion dollars of pain and damage in
the last forty years.</p>
</blockquote>
<p>The problem with null values is that if you try to use a null value as a
not-null value, you’ll get an error of some kind. Because this null or not-null
property is pervasive, it’s extremely easy to make this kind of error.</p>
<p>However, the concept that null is trying to express is still a useful one: a
null is a value that is currently invalid or absent for some reason.</p>
<p>The problem isn’t really with the concept but with the particular
implementation. As such, Rust does not have nulls, but it does have an enum
that can encode the concept of a value being present or absent. This enum is
<code>Option&lt;T&gt;</code>, and it is <a href="rustbook/../std/option/enum.Option.html">defined by the standard library</a><!-- ignore -->
as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Option&lt;T&gt;</code> enum is so useful that it’s even included in the prelude; you
don’t need to bring it into scope explicitly. In addition, so are its variants:
you can use <code>Some</code> and <code>None</code> directly without the <code>Option::</code> prefix. The
<code>Option&lt;T&gt;</code> enum is still just a regular enum, and <code>Some(T)</code> and <code>None</code> are
still variants of type <code>Option&lt;T&gt;</code>.</p>
<p>The <code>&lt;T&gt;</code> syntax is a feature of Rust we haven’t talked about yet. It’s a
generic type parameter, and we’ll cover generics in more detail in Chapter 10.
For now, all you need to know is that <code>&lt;T&gt;</code> means the <code>Some</code> variant of the
<code>Option</code> enum can hold one piece of data of any type. Here are some examples of
using <code>Option</code> values to hold number types and string types:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let some_number = Some(5);
let some_string = Some(&quot;a string&quot;);

let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>If we use <code>None</code> rather than <code>Some</code>, we need to tell Rust what type of
<code>Option&lt;T&gt;</code> we have, because the compiler can’t infer the type that the <code>Some</code>
variant will hold by looking only at a <code>None</code> value.</p>
<p>When we have a <code>Some</code> value, we know that a value is present and the value is
held within the <code>Some</code>. When we have a <code>None</code> value, in some sense, it means
the same thing as null: we don’t have a valid value. So why is having
<code>Option&lt;T&gt;</code> any better than having null?</p>
<p>In short, because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different
types, the compiler won’t let us use an <code>Option&lt;T&gt;</code> value as if it were
definitely a valid value. For example, this code won’t compile because it’s
trying to add an <code>i8</code> to an <code>Option&lt;i8&gt;</code>:</p>
<pre><code class="language-rust ignore does_not_compile">let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
</code></pre>
<p>If we run this code, we get an error message like this:</p>
<pre><code class="language-text">error[E0277]: the trait bound `i8: std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is
not satisfied
 --&gt;
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
</code></pre>
<p>Intense! In effect, this error message means that Rust doesn’t understand how
to add an <code>i8</code> and an <code>Option&lt;i8&gt;</code>, because they’re different types. When we
have a value of a type like <code>i8</code> in Rust, the compiler will ensure that we
always have a valid value. We can proceed confidently without having to check
for null before using that value. Only when we have an <code>Option&lt;i8&gt;</code> (or
whatever type of value we’re working with) do we have to worry about possibly
not having a value, and the compiler will make sure we handle that case before
using the value.</p>
<p>In other words, you have to convert an <code>Option&lt;T&gt;</code> to a <code>T</code> before you can
perform <code>T</code> operations with it. Generally, this helps catch one of the most
common issues with null: assuming that something isn’t null when it actually
is.</p>
<p>Not having to worry about incorrectly assuming a not-null value helps you to be
more confident in your code. In order to have a value that can possibly be
null, you must explicitly opt in by making the type of that value <code>Option&lt;T&gt;</code>.
Then, when you use that value, you are required to explicitly handle the case
when the value is null. Everywhere that a value has a type that isn’t an
<code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value isn’t null. This was a
deliberate design decision for Rust to limit null’s pervasiveness and increase
the safety of Rust code.</p>
<p>So, how do you get the <code>T</code> value out of a <code>Some</code> variant when you have a value
of type <code>Option&lt;T&gt;</code> so you can use that value? The <code>Option&lt;T&gt;</code> enum has a large
number of methods that are useful in a variety of situations; you can check
them out in <a href="rustbook/../std/option/enum.Option.html">its documentation</a><!-- ignore -->. Becoming familiar with
the methods on <code>Option&lt;T&gt;</code> will be extremely useful in your journey with Rust.</p>
<p>In general, in order to use an <code>Option&lt;T&gt;</code> value, you want to have code that
will handle each variant. You want some code that will run only when you have a
<code>Some(T)</code> value, and this code is allowed to use the inner <code>T</code>. You want some
other code to run if you have a <code>None</code> value, and that code doesn’t have a <code>T</code>
value available. The <code>match</code> expression is a control flow construct that does
just this when used with enums: it will run different code depending on which
variant of the enum it has, and that code can use the data inside the matching
value.</p>
<h2><a class="header" href="#the-match-control-flow-operator" id="the-match-control-flow-operator">The <code>match</code> Control Flow Operator</a></h2>
<p>Rust has an extremely powerful control flow operator called <code>match</code> that allows
you to compare a value against a series of patterns and then execute code based
on which pattern matches. Patterns can be made up of literal values, variable
names, wildcards, and many other things; Chapter 18 covers all the different
kinds of patterns and what they do. The power of <code>match</code> comes from the
expressiveness of the patterns and the fact that the compiler confirms that all
possible cases are handled.</p>
<p>Think of a <code>match</code> expression as being like a coin-sorting machine: coins slide
down a track with variously sized holes along it, and each coin falls through
the first hole it encounters that it fits into. In the same way, values go
through each pattern in a <code>match</code>, and at the first pattern the value “fits,”
the value falls into the associated code block to be used during execution.</p>
<p>Because we just mentioned coins, let’s use them as an example using <code>match</code>! We
can write a function that can take an unknown United States coin and, in a
similar way as the counting machine, determine which coin it is and return its
value in cents, as shown here in Listing 6-3.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-3: An enum and a <code>match</code> expression that has
the variants of the enum as its patterns</span></p>
<p>Let’s break down the <code>match</code> in the <code>value_in_cents</code> function. First, we list
the <code>match</code> keyword followed by an expression, which in this case is the value
<code>coin</code>. This seems very similar to an expression used with <code>if</code>, but there’s a
big difference: with <code>if</code>, the expression needs to return a Boolean value, but
here, it can be any type. The type of <code>coin</code> in this example is the <code>Coin</code> enum
that we defined on line 1.</p>
<p>Next are the <code>match</code> arms. An arm has two parts: a pattern and some code. The
first arm here has a pattern that is the value <code>Coin::Penny</code> and then the <code>=&gt;</code>
operator that separates the pattern and the code to run. The code in this case
is just the value <code>1</code>. Each arm is separated from the next with a comma.</p>
<p>When the <code>match</code> expression executes, it compares the resulting value against
the pattern of each arm, in order. If a pattern matches the value, the code
associated with that pattern is executed. If that pattern doesn’t match the
value, execution continues to the next arm, much as in a coin-sorting machine.
We can have as many arms as we need: in Listing 6-3, our <code>match</code> has four arms.</p>
<p>The code associated with each arm is an expression, and the resulting value of
the expression in the matching arm is the value that gets returned for the
entire <code>match</code> expression.</p>
<p>Curly brackets typically aren’t used if the match arm code is short, as it is
in Listing 6-3 where each arm just returns a value. If you want to run multiple
lines of code in a match arm, you can use curly brackets. For example, the
following code would print “Lucky penny!” every time the method was called with
a <code>Coin::Penny</code> but would still return the last value of the block, <code>1</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Lucky penny!&quot;);
            1
        },
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#patterns-that-bind-to-values" id="patterns-that-bind-to-values">Patterns that Bind to Values</a></h3>
<p>Another useful feature of match arms is that they can bind to the parts of the
values that match the pattern. This is how we can extract values out of enum
variants.</p>
<p>As an example, let’s change one of our enum variants to hold data inside it.
From 1999 through 2008, the United States minted quarters with different
designs for each of the 50 states on one side. No other coins got state
designs, so only quarters have this extra value. We can add this information to
our <code>enum</code> by changing the <code>Quarter</code> variant to include a <code>UsState</code> value stored
inside it, which we’ve done here in Listing 6-4.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-4: A <code>Coin</code> enum in which the <code>Quarter</code> variant
also holds a <code>UsState</code> value</span></p>
<p>Let’s imagine that a friend of ours is trying to collect all 50 state quarters.
While we sort our loose change by coin type, we’ll also call out the name of
the state associated with each quarter so if it’s one our friend doesn’t have,
they can add it to their collection.</p>
<p>In the match expression for this code, we add a variable called <code>state</code> to the
pattern that matches values of the variant <code>Coin::Quarter</code>. When a
<code>Coin::Quarter</code> matches, the <code>state</code> variable will bind to the value of that
quarter’s state. Then we can use <code>state</code> in the code for that arm, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;State quarter from {:?}!&quot;, state);
            25
        },
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>If we were to call <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code>, <code>coin</code>
would be <code>Coin::Quarter(UsState::Alaska)</code>. When we compare that value with each
of the match arms, none of them match until we reach <code>Coin::Quarter(state)</code>. At
that point, the binding for <code>state</code> will be the value <code>UsState::Alaska</code>. We can
then use that binding in the <code>println!</code> expression, thus getting the inner
state value out of the <code>Coin</code> enum variant for <code>Quarter</code>.</p>
<h3><a class="header" href="#matching-with-optiont" id="matching-with-optiont">Matching with <code>Option&lt;T&gt;</code></a></h3>
<p>In the previous section, we wanted to get the inner <code>T</code> value out of the <code>Some</code>
case when using <code>Option&lt;T&gt;</code>; we can also handle <code>Option&lt;T&gt;</code> using <code>match</code> as we
did with the <code>Coin</code> enum! Instead of comparing coins, we’ll compare the
variants of <code>Option&lt;T&gt;</code>, but the way that the <code>match</code> expression works remains
the same.</p>
<p>Let’s say we want to write a function that takes an <code>Option&lt;i32&gt;</code> and, if
there’s a value inside, adds 1 to that value. If there isn’t a value inside,
the function should return the <code>None</code> value and not attempt to perform any
operations.</p>
<p>This function is very easy to write, thanks to <code>match</code>, and will look like
Listing 6-5.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-5: A function that uses a <code>match</code> expression on
an <code>Option&lt;i32&gt;</code></span></p>
<p>Let’s examine the first execution of <code>plus_one</code> in more detail. When we call
<code>plus_one(five)</code>, the variable <code>x</code> in the body of <code>plus_one</code> will have the
value <code>Some(5)</code>. We then compare that against each match arm.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>The <code>Some(5)</code> value doesn’t match the pattern <code>None</code>, so we continue to the
next arm.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p>Does <code>Some(5)</code> match <code>Some(i)</code>? Why yes it does! We have the same variant. The
<code>i</code> binds to the value contained in <code>Some</code>, so <code>i</code> takes the value <code>5</code>. The
code in the match arm is then executed, so we add 1 to the value of <code>i</code> and
create a new <code>Some</code> value with our total <code>6</code> inside.</p>
<p>Now let’s consider the second call of <code>plus_one</code> in Listing 6-5, where <code>x</code> is
<code>None</code>. We enter the <code>match</code> and compare to the first arm.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>It matches! There’s no value to add to, so the program stops and returns the
<code>None</code> value on the right side of <code>=&gt;</code>. Because the first arm matched, no other
arms are compared.</p>
<p>Combining <code>match</code> and enums is useful in many situations. You’ll see this
pattern a lot in Rust code: <code>match</code> against an enum, bind a variable to the
data inside, and then execute code based on it. It’s a bit tricky at first, but
once you get used to it, you’ll wish you had it in all languages. It’s
consistently a user favorite.</p>
<h3><a class="header" href="#matches-are-exhaustive" id="matches-are-exhaustive">Matches Are Exhaustive</a></h3>
<p>There’s one other aspect of <code>match</code> we need to discuss. Consider this version
of our <code>plus_one</code> function that has a bug and won’t compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}
</code></pre>
<p>We didn’t handle the <code>None</code> case, so this code will cause a bug. Luckily, it’s
a bug Rust knows how to catch. If we try to compile this code, we’ll get this
error:</p>
<pre><code class="language-text">error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt;
  |
6 |         match x {
  |               ^ pattern `None` not covered
</code></pre>
<p>Rust knows that we didn’t cover every possible case and even knows which
pattern we forgot! Matches in Rust are <em>exhaustive</em>: we must exhaust every last
possibility in order for the code to be valid. Especially in the case of
<code>Option&lt;T&gt;</code>, when Rust prevents us from forgetting to explicitly handle the
<code>None</code> case, it protects us from assuming that we have a value when we might
have null, thus making the billion-dollar mistake discussed earlier.</p>
<h3><a class="header" href="#the-_-placeholder" id="the-_-placeholder">The <code>_</code> Placeholder</a></h3>
<p>Rust also has a pattern we can use when we don’t want to list all possible
values. For example, a <code>u8</code> can have valid values of 0 through 255. If we only
care about the values 1, 3, 5, and 7, we don’t want to have to list out 0, 2,
4, 6, 8, 9 all the way up to 255. Fortunately, we don’t have to: we can use the
special pattern <code>_</code> instead:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;one&quot;),
    3 =&gt; println!(&quot;three&quot;),
    5 =&gt; println!(&quot;five&quot;),
    7 =&gt; println!(&quot;seven&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>_</code> pattern will match any value. By putting it after our other arms, the
<code>_</code> will match all the possible cases that aren’t specified before it. The <code>()</code>
is just the unit value, so nothing will happen in the <code>_</code> case. As a result, we
can say that we want to do nothing for all the possible values that we don’t
list before the <code>_</code> placeholder.</p>
<p>However, the <code>match</code> expression can be a bit wordy in a situation in which we
care about only <em>one</em> of the cases. For this situation, Rust provides <code>if let</code>.</p>
<h2><a class="header" href="#concise-control-flow-with-if-let" id="concise-control-flow-with-if-let">Concise Control Flow with <code>if let</code></a></h2>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to
handle values that match one pattern while ignoring the rest. Consider the
program in Listing 6-6 that matches on an <code>Option&lt;u8&gt;</code> value but only wants to
execute code if the value is 3.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let some_u8_value = Some(0u8);
match some_u8_value {
    Some(3) =&gt; println!(&quot;three&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 6-6: A <code>match</code> that only cares about executing
code when the value is <code>Some(3)</code></span></p>
<p>We want to do something with the <code>Some(3)</code> match but do nothing with any other
<code>Some&lt;u8&gt;</code> value or the <code>None</code> value. To satisfy the <code>match</code> expression, we
have to add <code>_ =&gt; ()</code> after processing just one variant, which is a lot of
boilerplate code to add.</p>
<p>Instead, we could write this in a shorter way using <code>if let</code>. The following
code behaves the same as the <code>match</code> in Listing 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_u8_value = Some(0u8);
</span>if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>The syntax <code>if let</code> takes a pattern and an expression separated by an equal
sign. It works the same way as a <code>match</code>, where the expression is given to the
<code>match</code> and the pattern is its first arm.</p>
<p>Using <code>if let</code> means less typing, less indentation, and less boilerplate code.
However, you lose the exhaustive checking that <code>match</code> enforces. Choosing
between <code>match</code> and <code>if let</code> depends on what you’re doing in your particular
situation and whether gaining conciseness is an appropriate trade-off for
losing exhaustive checking.</p>
<p>In other words, you can think of <code>if let</code> as syntax sugar for a <code>match</code> that
runs code when the value matches one pattern and then ignores all other values.</p>
<p>We can include an <code>else</code> with an <code>if let</code>. The block of code that goes with the
<code>else</code> is the same as the block of code that would go with the <code>_</code> case in the
<code>match</code> expression that is equivalent to the <code>if let</code> and <code>else</code>. Recall the
<code>Coin</code> enum definition in Listing 6-4, where the <code>Quarter</code> variant also held a
<code>UsState</code> value. If we wanted to count all non-quarter coins we see while also
announcing the state of the quarters, we could do that with a <code>match</code>
expression like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">let coin = Coin::Penny;
</span>let mut count = 0;
match coin {
    Coin::Quarter(state) =&gt; println!(&quot;State quarter from {:?}!&quot;, state),
    _ =&gt; count += 1,
}
<span class="boring">}
</span></code></pre></pre>
<p>Or we could use an <code>if let</code> and <code>else</code> expression like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">   Alabama,
</span><span class="boring">   Alaska,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">   Penny,
</span><span class="boring">   Nickel,
</span><span class="boring">   Dime,
</span><span class="boring">   Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">let coin = Coin::Penny;
</span>let mut count = 0;
if let Coin::Quarter(state) = coin {
    println!(&quot;State quarter from {:?}!&quot;, state);
} else {
    count += 1;
}
<span class="boring">}
</span></code></pre></pre>
<p>If you have a situation in which your program has logic that is too verbose to
express using a <code>match</code>, remember that <code>if let</code> is in your Rust toolbox as well.</p>
<h2><a class="header" href="#summary-5" id="summary-5">Summary</a></h2>
<p>We’ve now covered how to use enums to create custom types that can be one of a
set of enumerated values. We’ve shown how the standard library’s <code>Option&lt;T&gt;</code>
type helps you use the type system to prevent errors. When enum values have
data inside them, you can use <code>match</code> or <code>if let</code> to extract and use those
values, depending on how many cases you need to handle.</p>
<p>Your Rust programs can now express concepts in your domain using structs and
enums. Creating custom types to use in your API ensures type safety: the
compiler will make certain your functions get only values of the type each
function expects.</p>
<p>In order to provide a well-organized API to your users that is straightforward
to use and only exposes exactly what your users will need, let’s now turn to
Rust’s modules.</p>
<h1><a class="header" href="#managing-growing-projects-with-packages-crates-and-modules" id="managing-growing-projects-with-packages-crates-and-modules">Managing Growing Projects with Packages, Crates, and Modules</a></h1>
<p>As you write large programs, organizing your code will be important because
keeping track of your entire program in your head will become impossible. By
grouping related functionality and separating code with distinct features,
you’ll clarify where to find code that implements a particular feature and
where to go to change how a feature works.</p>
<p>The programs we’ve written so far have been in one module in one file. As a
project grows, you can organize code by splitting it into multiple modules and
then multiple files. A package can contain multiple binary crates and
optionally one library crate. As a package grows, you can extract parts into
separate crates that become external dependencies. This chapter covers all
these techniques. For very large projects of a set of interrelated packages
that evolve together, Cargo provides workspaces, which we’ll cover in the
<a href="rustbook/ch14-03-cargo-workspaces.html">“Cargo Workspaces”</a><!-- ignore --> section in Chapter 14.</p>
<p>In addition to grouping functionality, encapsulating implementation details
lets you reuse code at a higher level: once you’ve implemented an operation,
other code can call that code via the code’s public interface without knowing
how the implementation works. The way you write code defines which parts are
public for other code to use and which parts are private implementation details
that you reserve the right to change. This is another way to limit the amount
of detail you have to keep in your head.</p>
<p>A related concept is scope: the nested context in which code is written has a
set of names that are defined as “in scope.” When reading, writing, and
compiling code, programmers and compilers need to know whether a particular
name at a particular spot refers to a variable, function, struct, enum, module,
constant, or other item and what that item means. You can create scopes and
change which names are in or out of scope. You can’t have two items with the
same name in the same scope; tools are available to resolve name conflicts.</p>
<p>Rust has a number of features that allow you to manage your code’s
organization, including which details are exposed, which details are private,
and what names are in each scope in your programs. These features, sometimes
collectively referred to as the <em>module system</em>, and include:</p>
<ul>
<li><strong>Packages:</strong> A Cargo feature that lets you build, test, and share crates</li>
<li><strong>Crates:</strong> A tree of modules that produces a library or executable</li>
<li><strong>Modules</strong> and <strong>use:</strong> Let you control the organization, scope, and
privacy of paths</li>
<li><strong>Paths:</strong> A way of naming an item, such as a struct, function, or module</li>
</ul>
<p>In this chapter, we’ll cover all these features, discuss how they interact, and
explain how to use them to manage scope. By the end, you should have a solid
understanding of the module system and be able to work with scopes like a pro!</p>
<h2><a class="header" href="#packages-and-crates" id="packages-and-crates">Packages and Crates</a></h2>
<p>The first parts of the module system we’ll cover are packages and crates. A
crate is a binary or library. The <em>crate root</em> is a source file that the Rust
compiler starts from and makes up the root module of your crate (we’ll explain
modules in depth in the <a href="rustbook/ch07-02-defining-modules-to-control-scope-and-privacy.html">“Defining Modules to Control Scope and
Privacy”</a><!-- ignore -->) section. A <em>package</em> is one or more crates
that provide a set of functionality. A package contains a <em>Cargo.toml</em> file
that describes how to build those crates.</p>
<p>Several rules determine what a package can contain. A package <em>must</em> contain
zero or one library crates, and no more. It can contain as many binary crates
as you’d like, but it must contain at least one crate (either library or
binary).</p>
<p>Let’s walk through what happens when we create a package. First, we enter the
command <code>cargo new</code>:</p>
<pre><code class="language-text">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>When we entered the command, Cargo created a <em>Cargo.toml</em> file, giving us a
package. Looking at the contents of <em>Cargo.toml</em>, there’s no mention of
<em>src/main.rs</em> because Cargo follows a convention that <em>src/main.rs</em> is the
crate root of a binary crate with the same name as the package. Likewise, Cargo
knows that if the package directory contains <em>src/lib.rs</em>, the package contains
a library crate with the same name as the package, and <em>src/lib.rs</em> is its
crate root. Cargo passes the crate root files to <code>rustc</code> to build the library
or binary.</p>
<p>Here, we have a package that only contains <em>src/main.rs</em>, meaning it only
contains a binary crate named <code>my-project</code>. If a package contains <em>src/main.rs</em>
and <em>src/lib.rs</em>, it has two crates: a library and a binary, both with the same
name as the package. A package can have multiple binary crates by placing files
in the <em>src/bin</em> directory: each file will be a separate binary crate.</p>
<p>A crate will group related functionality together in a scope so the
functionality is easy to share between multiple projects. For example, the
<code>rand</code> crate we used in <a href="rustbook/ch02-00-guessing-game-tutorial.html#generating-a-random-number">Chapter 2</a><!-- ignore --> provides functionality
that generates random numbers. We can use that functionality in our own
projects by bringing the <code>rand</code> crate into our project’s scope. All the
functionality provided by the <code>rand</code> crate is accessible through the crate’s
name, <code>rand</code>.</p>
<p>Keeping a crate’s functionality in its own scope clarifies whether particular
functionality is defined in our crate or the <code>rand</code> crate and prevents
potential conflicts. For example, the <code>rand</code> crate provides a trait named
<code>Rng</code>. We can also define a <code>struct</code> named <code>Rng</code> in our own crate. Because a
crate’s functionality is namespaced in its own scope, when we add <code>rand</code> as a
dependency, the compiler isn’t confused about what the name <code>Rng</code> refers to. In
our crate, it refers to the <code>struct Rng</code> that we defined. We would access the
<code>Rng</code> trait from the <code>rand</code> crate as <code>rand::Rng</code>.</p>
<p>Let’s move on and talk about the module system!</p>
<h2><a class="header" href="#defining-modules-to-control-scope-and-privacy" id="defining-modules-to-control-scope-and-privacy">Defining Modules to Control Scope and Privacy</a></h2>
<p>In this section, we’ll talk about modules and other parts of the module system,
namely <em>paths</em> that allow you to name items; the <code>use</code> keyword that brings a
path into scope; and the <code>pub</code> keyword to make items public. We’ll also discuss
the <code>as</code> keyword, external packages, and the glob operator. For now, let’s
focus on modules!</p>
<p><em>Modules</em> let us organize code within a crate into groups for readability and
easy reuse. Modules also control the <em>privacy</em> of items, which is whether an
item can be used by outside code (<em>public</em>) or is an internal implementation
detail and not available for outside use (<em>private</em>).</p>
<p>As an example, let’s write a library crate that provides the functionality of a
restaurant. We’ll define the signatures of functions but leave their bodies
empty to concentrate on the organization of the code, rather than actually
implement a restaurant in code.</p>
<p>In the restaurant industry, some parts of a restaurant are referred to as
<em>front of house</em> and others as <em>back of house</em>. Front of house is where
customers are; this is where hosts seat customers, servers take orders and
payment, and bartenders make drinks. Back of house is where the chefs and cooks
work in the kitchen, dishwashers clean up, and managers do administrative work.</p>
<p>To structure our crate in the same way that a real restaurant works, we can
organize the functions into nested modules. Create a new library named
<code>restaurant</code> by running <code>cargo new --lib restaurant</code>; then put the code in
Listing 7-1 into <em>src/lib.rs</em> to define some modules and function signatures.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 7-1: A <code>front_of_house</code> module containing other
modules that then contain functions</span></p>
<p>We define a module by starting with the <code>mod</code> keyword and then specify the
name of the module (in this case, <code>front_of_house</code>) and place curly brackets
around the body of the module. Inside modules, we can have other modules, as in
this case with the modules <code>hosting</code> and <code>serving</code>. Modules can also hold
definitions for other items, such as structs, enums, constants, traits, or—as
in Listing 7-1—functions.</p>
<p>By using modules, we can group related definitions together and name why
they’re related. Programmers using this code would have an easier time finding
the definitions they wanted to use because they could navigate the code based
on the groups rather than having to read through all the definitions.
Programmers adding new functionality to this code would know where to place the
code to keep the program organized.</p>
<p>Earlier, we mentioned that <em>src/main.rs</em> and <em>src/lib.rs</em> are called crate
roots. The reason for their name is that the contents of either of these two
files form a module named <code>crate</code> at the root of the crate’s module structure,
known as the <em>module tree</em>.</p>
<p>Listing 7-2 shows the module tree for the structure in Listing 7-1.</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Listing 7-2: The module tree for the code in Listing
7-1</span></p>
<p>This tree shows how some of the modules nest inside one another (for example,
<code>hosting</code> nests inside <code>front_of_house</code>). The tree also shows that some modules
are <em>siblings</em> to each other, meaning they’re defined in the same module
(<code>hosting</code> and <code>serving</code> are defined within <code>front_of_house</code>). To continue the
family metaphor, if module A is contained inside module B, we say that module A
is the <em>child</em> of module B and that module B is the <em>parent</em> of module A.
Notice that the entire module tree is rooted under the implicit module named
<code>crate</code>.</p>
<p>The module tree might remind you of the filesystem’s directory tree on your
computer; this is a very apt comparison! Just like directories in a filesystem,
you use modules to organize your code. And just like files in a directory, we
need a way to find our modules.</p>
<h2><a class="header" href="#paths-for-referring-to-an-item-in-the-module-tree" id="paths-for-referring-to-an-item-in-the-module-tree">Paths for Referring to an Item in the Module Tree</a></h2>
<p>To show Rust where to find an item in a module tree, we use a path in the same
way we use a path when navigating a filesystem. If we want to call a function,
we need to know its path.</p>
<p>A path can take two forms:</p>
<ul>
<li>An <em>absolute path</em> starts from a crate root by using a crate name or a
literal <code>crate</code>.</li>
<li>A <em>relative path</em> starts from the current module and uses <code>self</code>, <code>super</code>, or
an identifier in the current module.</li>
</ul>
<p>Both absolute and relative paths are followed by one or more identifiers
separated by double colons (<code>::</code>).</p>
<p>Let’s return to the example in Listing 7-1. How do we call the
<code>add_to_waitlist</code> function? This is the same as asking, what’s the path of the
<code>add_to_waitlist</code> function? In Listing 7-3, we simplified our code a bit by
removing some of the modules and functions. We’ll show two ways to call the
<code>add_to_waitlist</code> function from a new function <code>eat_at_restaurant</code> defined in
the crate root. The <code>eat_at_restaurant</code> function is part of our library crate’s
public API, so we mark it with the <code>pub</code> keyword. In the <a href="rustbook/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#exposing-paths-with-the-pub-keyword">”Exposing Paths with
the <code>pub</code> Keyword”</a><!-- ignore --> section, we’ll go into more detail
about <code>pub</code>. Note that this example won’t compile just yet; we’ll explain why
in a bit.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-3: Calling the <code>add_to_waitlist</code> function using
absolute and relative paths</span></p>
<p>The first time we call the <code>add_to_waitlist</code> function in <code>eat_at_restaurant</code>,
we use an absolute path. The <code>add_to_waitlist</code> function is defined in the same
crate as <code>eat_at_restaurant</code>, which means we can use the <code>crate</code> keyword to
start an absolute path.</p>
<p>After <code>crate</code>, we include each of the successive modules until we make our way
to <code>add_to_waitlist</code>. You can imagine a filesystem with the same structure, and
we’d specify the path <code>/front_of_house/hosting/add_to_waitlist</code> to run the
<code>add_to_waitlist</code> program; using the <code>crate</code> name to start from the crate root
is like using <code>/</code> to start from the filesystem root in your shell.</p>
<p>The second time we call <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>, we use a
relative path. The path starts with <code>front_of_house</code>, the name of the module
defined at the same level of the module tree as <code>eat_at_restaurant</code>. Here the
filesystem equivalent would be using the path
<code>front_of_house/hosting/add_to_waitlist</code>. Starting with a name means that the
path is relative.</p>
<p>Choosing whether to use a relative or absolute path is a decision you’ll make
based on your project. The decision should depend on whether you’re more likely
to move item definition code separately from or together with the code that
uses the item. For example, if we move the <code>front_of_house</code> module and the
<code>eat_at_restaurant</code> function into a module named <code>customer_experience</code>, we’d
need to update the absolute path to <code>add_to_waitlist</code>, but the relative path
would still be valid. However, if we moved the <code>eat_at_restaurant</code> function
separately into a module named <code>dining</code>, the absolute path to the
<code>add_to_waitlist</code> call would stay the same, but the relative path would need to
be updated. Our preference is to specify absolute paths because it’s more
likely to move code definitions and item calls independently of each other.</p>
<p>Let’s try to compile Listing 7-3 and find out why it won’t compile yet! The
error we get is shown in Listing 7-4.</p>
<pre><code class="language-text">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^
</code></pre>
<p><span class="caption">Listing 7-4: Compiler errors from building the code in
Listing 7-3</span></p>
<p>The error messages say that module <code>hosting</code> is private. In other words, we
have the correct paths for the <code>hosting</code> module and the <code>add_to_waitlist</code>
function, but Rust won’t let us use them because it doesn’t have access to the
private sections.</p>
<p>Modules aren’t useful only for organizing your code. They also define Rust’s
<em>privacy boundary</em>: the line that encapsulates the implementation details
external code isn’t allowed to know about, call, or rely on. So, if you want to
make an item like a function or struct private, you put it in a module.</p>
<p>The way privacy works in Rust is that all items (functions, methods, structs,
enums, modules, and constants) are private by default. Items in a parent module
can’t use the private items inside child modules, but items in child modules
can use the items in their ancestor modules. The reason is that child modules
wrap and hide their implementation details, but the child modules can see the
context in which they’re defined. To continue with the restaurant metaphor,
think of the privacy rules as being like the back office of a restaurant: what
goes on in there is private to restaurant customers, but office managers can
see and do everything in the restaurant in which they operate.</p>
<p>Rust chose to have the module system function this way so that hiding inner
implementation details is the default. That way, you know which parts of the
inner code you can change without breaking outer code. But you can expose inner
parts of child modules code to outer ancestor modules by using the <code>pub</code>
keyword to make an item public.</p>
<h3><a class="header" href="#exposing-paths-with-the-pub-keyword" id="exposing-paths-with-the-pub-keyword">Exposing Paths with the <code>pub</code> Keyword</a></h3>
<p>Let’s return to the error in Listing 7-4 that told us the <code>hosting</code> module is
private. We want the <code>eat_at_restaurant</code> function in the parent module to have
access to the <code>add_to_waitlist</code> function in the child module, so we mark the
<code>hosting</code> module with the <code>pub</code> keyword, as shown in Listing 7-5.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-5: Declaring the <code>hosting</code> module as <code>pub</code> to
use it from <code>eat_at_restaurant</code></span></p>
<p>Unfortunately, the code in Listing 7-5 still results in an error, as shown in
Listing 7-6.</p>
<pre><code class="language-text">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^
</code></pre>
<p><span class="caption">Listing 7-6: Compiler errors from building the code in
Listing 7-5</span></p>
<p>What happened? Adding the <code>pub</code> keyword in front of <code>mod hosting</code> makes the
module public. With this change, if we can access <code>front_of_house</code>, we can
access <code>hosting</code>. But the <em>contents</em> of <code>hosting</code> are still private; making the
module public doesn’t make its contents public. The <code>pub</code> keyword on a module
only lets code in its ancestor modules refer to it.</p>
<p>The errors in Listing 7-6 say that the <code>add_to_waitlist</code> function is private.
The privacy rules apply to structs, enums, functions, and methods as well as
modules.</p>
<p>Let’s also make the <code>add_to_waitlist</code> function public by adding the <code>pub</code>
keyword before its definition, as in Listing 7-7.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 7-7: Adding the <code>pub</code> keyword to <code>mod hosting</code>
and <code>fn add_to_waitlist</code> lets us call the function from
<code>eat_at_restaurant</code></span></p>
<p>Now the code will compile! Let’s look at the absolute and the relative path and
double-check why adding the <code>pub</code> keyword lets us use these paths in
<code>add_to_waitlist</code> with respect to the privacy rules.</p>
<p>In the absolute path, we start with <code>crate</code>, the root of our crate’s module
tree. Then the <code>front_of_house</code> module is defined in the crate root. The
<code>front_of_house</code> module isn’t public, but because the <code>eat_at_restaurant</code>
function is defined in the same module as <code>front_of_house</code> (that is,
<code>eat_at_restaurant</code> and <code>front_of_house</code> are siblings), we can refer to
<code>front_of_house</code> from <code>eat_at_restaurant</code>. Next is the <code>hosting</code> module marked
with <code>pub</code>. We can access the parent module of <code>hosting</code>, so we can access
<code>hosting</code>. Finally, the <code>add_to_waitlist</code> function is marked with <code>pub</code> and we
can access its parent module, so this function call works!</p>
<p>In the relative path, the logic is the same as the absolute path except for the
first step: rather than starting from the crate root, the path starts from
<code>front_of_house</code>. The <code>front_of_house</code> module is defined within the same module
as <code>eat_at_restaurant</code>, so the relative path starting from the module in which
<code>eat_at_restaurant</code> is defined works. Then, because <code>hosting</code> and
<code>add_to_waitlist</code> are marked with <code>pub</code>, the rest of the path works, and this
function call is valid!</p>
<h3><a class="header" href="#starting-relative-paths-with-super" id="starting-relative-paths-with-super">Starting Relative Paths with <code>super</code></a></h3>
<p>We can also construct relative paths that begin in the parent module by using
<code>super</code> at the start of the path. This is like starting a filesystem path with
the <code>..</code> syntax. Why would we want to do this?</p>
<p>Consider the code in Listing 7-8 that models the situation in which a chef
fixes an incorrect order and personally brings it out to the customer. The
function <code>fix_incorrect_order</code> calls the function <code>serve_order</code> by specifying
the path to <code>serve_order</code> starting with <code>super</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 7-8: Calling a function using a relative path
starting with <code>super</code></span></p>
<p>The <code>fix_incorrect_order</code> function is in the <code>back_of_house</code> module, so we can
use <code>super</code> to go to the parent module of <code>back_of_house</code>, which in this case
is <code>crate</code>, the root. From there, we look for <code>serve_order</code> and find it.
Success! We think the <code>back_of_house</code> module and the <code>serve_order</code> function are
likely to stay in the same relationship to each other and get moved together
should we decide to reorganize the crate’s module tree. Therefore, we used
<code>super</code> so we’ll have fewer places to update code in the future if this code
gets moved to a different module.</p>
<h3><a class="header" href="#making-structs-and-enums-public" id="making-structs-and-enums-public">Making Structs and Enums Public</a></h3>
<p>We can also use <code>pub</code> to designate structs and enums as public, but there are a
few extra details. If we use <code>pub</code> before a struct definition, we make the
struct public, but the struct’s fields will still be private. We can make each
field public or not on a case-by-case basis. In Listing 7-9, we’ve defined a
public <code>back_of_house::Breakfast</code> struct with a public <code>toast</code> field but a
private <code>seasonal_fruit</code> field. This models the case in a restaurant where the
customer can pick the type of bread that comes with a meal, but the chef
decides which fruit accompanies the meal based on what’s in season and in
stock. The available fruit changes quickly, so customers can’t choose the fruit
or even see which fruit they’ll get.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;peaches&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Order a breakfast in the summer with Rye toast
    let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
    // Change our mind about what bread we'd like
    meal.toast = String::from(&quot;Wheat&quot;);
    println!(&quot;I'd like {} toast please&quot;, meal.toast);

    // The next line won't compile if we uncomment it; we're not allowed
    // to see or modify the seasonal fruit that comes with the meal
    // meal.seasonal_fruit = String::from(&quot;blueberries&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 7-9: A struct with some public fields and some
private fields</span></p>
<p>Because the <code>toast</code> field in the <code>back_of_house::Breakfast</code> struct is public,
in <code>eat_at_restaurant</code> we can write and read to the <code>toast</code> field using dot
notation. Notice that we can’t use the <code>seasonal_fruit</code> field in
<code>eat_at_restaurant</code> because <code>seasonal_fruit</code> is private. Try uncommenting the
line modifying the <code>seasonal_fruit</code> field value to see what error you get!</p>
<p>Also, note that because <code>back_of_house::Breakfast</code> has a private field, the
struct needs to provide a public associated function that constructs an
instance of <code>Breakfast</code> (we’ve named it <code>summer</code> here). If <code>Breakfast</code> didn’t
have such a function, we couldn’t create an instance of <code>Breakfast</code> in
<code>eat_at_restaurant</code> because we couldn’t set the value of the private
<code>seasonal_fruit</code> field in <code>eat_at_restaurant</code>.</p>
<p>In contrast, if we make an enum public, all of its variants are then public. We
only need the <code>pub</code> before the <code>enum</code> keyword, as shown in Listing 7-10.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 7-10: Designating an enum as public makes all its
variants public</span></p>
<p>Because we made the <code>Appetizer</code> enum public, we can use the <code>Soup</code> and <code>Salad</code>
variants in <code>eat_at_restaurant</code>. Enums aren’t very useful unless their variants
are public; it would be annoying to have to annotate all enum variants with
<code>pub</code> in every case, so the default for enum variants is to be public. Structs
are often useful without their fields being public, so struct fields follow the
general rule of everything being private by default unless annotated with <code>pub</code>.</p>
<p>There’s one more situation involving <code>pub</code> that we haven’t covered, and that is
our last module system feature: the <code>use</code> keyword. We’ll cover <code>use</code> by itself
first, and then we’ll show how to combine <code>pub</code> and <code>use</code>.</p>
<h2><a class="header" href="#bringing-paths-into-scope-with-the-use-keyword" id="bringing-paths-into-scope-with-the-use-keyword">Bringing Paths into Scope with the <code>use</code> Keyword</a></h2>
<p>It might seem like the paths we’ve written to call functions so far are
inconveniently long and repetitive. For example, in Listing 7-7, whether we
chose the absolute or relative path to the <code>add_to_waitlist</code> function, every
time we wanted to call <code>add_to_waitlist</code> we had to specify <code>front_of_house</code> and
<code>hosting</code> too. Fortunately, there’s a way to simplify this process. We can
bring a path into a scope once and then call the items in that path as if
they’re local items with the <code>use</code> keyword.</p>
<p>In Listing 7-11, we bring the <code>crate::front_of_house::hosting</code> module into the
scope of the <code>eat_at_restaurant</code> function so we only have to specify
<code>hosting::add_to_waitlist</code> to call the <code>add_to_waitlist</code> function in
<code>eat_at_restaurant</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 7-11: Bringing a module into scope with
<code>use</code></span></p>
<p>Adding <code>use</code> and a path in a scope is similar to creating a symbolic link in
the filesystem. By adding <code>use crate::front_of_house::hosting</code> in the crate
root, <code>hosting</code> is now a valid name in that scope, just as though the <code>hosting</code>
module had been defined in the crate root. Paths brought into scope with <code>use</code>
also check privacy, like any other paths.</p>
<p>Specifying a relative path with <code>use</code> is slightly different. Instead of
starting from a name in the current scope, we must start the path given to
<code>use</code> with the keyword <code>self</code>. Listing 7-12 shows how to specify a relative
path to get the same behavior as in Listing 7-11.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 7-12: Bringing a module into scope with <code>use</code> and
a relative path starting with <code>self</code></span></p>
<p>Note that using <code>self</code> in this way might not be necessary in the future; it’s
an inconsistency in the language that Rust developers are working to eliminate.</p>
<h3><a class="header" href="#creating-idiomatic-use-paths" id="creating-idiomatic-use-paths">Creating Idiomatic <code>use</code> Paths</a></h3>
<p>In Listing 7-11, you might have wondered why we specified <code>use crate::front_of_house::hosting</code> and then called <code>hosting::add_to_waitlist</code> in
<code>eat_at_restaurant</code> rather than specifying the <code>use</code> path all the way out to
the <code>add_to_waitlist</code> function to achieve the same result, as in Listing 7-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 7-13: Bringing the <code>add_to_waitlist</code> function
into scope with <code>use</code>, which is unidiomatic</span></p>
<p>Although both Listing 7-11 and 7-13 accomplish the same task, Listing 7-11 is
the idiomatic way to bring a function into scope with <code>use</code>. Bringing the
function’s parent module into scope with <code>use</code> so we have to specify the parent
module when calling the function makes it clear that the function isn’t locally
defined while still minimizing repetition of the full path. The code in Listing
7-13 is unclear as to where <code>add_to_waitlist</code> is defined.</p>
<p>On the other hand, when bringing in structs, enums, and other items with <code>use</code>,
it’s idiomatic to specify the full path. Listing 7-14 shows the idiomatic way
to bring the standard library’s <code>HashMap</code> struct into the scope of a binary
crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">Listing 7-14: Bringing <code>HashMap</code> into scope in an
idiomatic way</span></p>
<p>There’s no strong reason behind this idiom: it’s just the convention that has
emerged, and folks have gotten used to reading and writing Rust code this way.</p>
<p>The exception to this idiom is if we’re bringing two items with the same name
into scope with <code>use</code> statements, because Rust doesn’t allow that. Listing 7-15
shows how to bring two <code>Result</code> types into scope that have the same name but
different parent modules and how to refer to them.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 7-15: Bringing two types with the same name into
the same scope requires using their parent modules.</span></p>
<p>As you can see, using the parent modules distinguishes the two <code>Result</code> types.
If instead we specified <code>use std::fmt::Result</code> and <code>use std::io::Result</code>, we’d
have two <code>Result</code> types in the same scope and Rust wouldn’t know which one we
meant when we used <code>Result</code>.</p>
<h3><a class="header" href="#providing-new-names-with-the-as-keyword" id="providing-new-names-with-the-as-keyword">Providing New Names with the <code>as</code> Keyword</a></h3>
<p>There’s another solution to the problem of bringing two types of the same name
into the same scope with <code>use</code>: after the path, we can specify <code>as</code> and a new
local name, or alias, for the type. Listing 7-16 shows another way to write the
code in Listing 7-15 by renaming one of the two <code>Result</code> types using <code>as</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --snip--
<span class="boring">    Ok(())
</span>}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --snip--
<span class="boring">    Ok(())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 7-16: Renaming a type when it’s brought into
scope with the <code>as</code> keyword</span></p>
<p>In the second <code>use</code> statement, we chose the new name <code>IoResult</code> for the
<code>std::io::Result</code> type, which won’t conflict with the <code>Result</code> from <code>std::fmt</code>
that we’ve also brought into scope. Listing 7-15 and Listing 7-16 are
considered idiomatic, so the choice is up to you!</p>
<h3><a class="header" href="#re-exporting-names-with-pub-use" id="re-exporting-names-with-pub-use">Re-exporting Names with <code>pub use</code></a></h3>
<p>When we bring a name into scope with the <code>use</code> keyword, the name available in
the new scope is private. To enable the code that calls our code to refer to
that name as if it had been defined in that code’s scope, we can combine <code>pub</code>
and <code>use</code>. This technique is called <em>re-exporting</em> because we’re bringing
an item into scope but also making that item available for others to bring into
their scope.</p>
<p>Listing 7-17 shows the code in Listing 7-11 with <code>use</code> in the root module
changed to <code>pub use</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 7-17: Making a name available for any code to use
from a new scope with <code>pub use</code></span></p>
<p>By using <code>pub use</code>, external code can now call the <code>add_to_waitlist</code> function
using <code>hosting::add_to_waitlist</code>. If we hadn’t specified <code>pub use</code>, the
<code>eat_at_restaurant</code> function could call <code>hosting::add_to_waitlist</code> in its
scope, but external code couldn’t take advantage of this new path.</p>
<p>Re-exporting is useful when the internal structure of your code is different
from how programmers calling your code would think about the domain. For
example, in this restaurant metaphor, the people running the restaurant think
about “front of house” and “back of house.” But customers visiting a restaurant
probably won’t think about the parts of the restaurant in those terms. With
<code>pub use</code>, we can write our code with one structure but expose a different
structure. Doing so makes our library well organized for programmers working on
the library and programmers calling the library.</p>
<h3><a class="header" href="#using-external-packages" id="using-external-packages">Using External Packages</a></h3>
<p>In Chapter 2, we programmed a guessing game project that used an external
package called <code>rand</code> to get random numbers. To use <code>rand</code> in our project, we
added this line to <em>Cargo.toml</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p>Adding <code>rand</code> as a dependency in <em>Cargo.toml</em> tells Cargo to download the
<code>rand</code> package and any dependencies from <a href="https://crates.io/">crates.io</a> and
make <code>rand</code> available to our project.</p>
<p>Then, to bring <code>rand</code> definitions into the scope of our package, we added a
<code>use</code> line starting with the name of the package, <code>rand</code>, and listed the items
we wanted to bring into scope. Recall that in the <a href="rustbook/ch02-00-guessing-game-tutorial.html#generating-a-random-number">“Generating a Random
Number”</a><!-- ignore --> section in Chapter 2, we brought the <code>Rng</code> trait
into scope and called the <code>rand::thread_rng</code> function:</p>
<pre><code class="language-rust ignore">use rand::Rng;
fn main() {
    let secret_number = rand::thread_rng().gen_range(1, 101);
}
</code></pre>
<p>Members of the Rust community have made many packages available at
<a href="https://crates.io/">crates.io</a>, and pulling any of them into your package
involves these same steps: listing them in your package’s <em>Cargo.toml</em> file and
using <code>use</code> to bring items into scope.</p>
<p>Note that the standard library (<code>std</code>) is also a crate that’s external to our
package. Because the standard library is shipped with the Rust language, we
don’t need to change <em>Cargo.toml</em> to include <code>std</code>. But we do need to refer to
it with <code>use</code> to bring items from there into our package’s scope. For example,
with <code>HashMap</code> we would use this line:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<p>This is an absolute path starting with <code>std</code>, the name of the standard library
crate.</p>
<h3><a class="header" href="#using-nested-paths-to-clean-up-large-use-lists" id="using-nested-paths-to-clean-up-large-use-lists">Using Nested Paths to Clean Up Large <code>use</code> Lists</a></h3>
<p>If we’re using multiple items defined in the same package or same module,
listing each item on its own line can take up a lot of vertical space in our
files. For example, these two <code>use</code> statements we had in the Guessing Game in
Listing 2-4 bring items from <code>std</code> into scope:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::cmp::Ordering;
// ---snip---
<span class="boring">}
</span></code></pre></pre>
<p>Instead, we can use nested paths to bring the same items into scope in one
line. We do this by specifying the common part of the path, followed by two
colons, and then curly brackets around a list of the parts of the paths that
differ, as shown in Listing 7-18.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::{cmp::Ordering, io};
// ---snip---
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 7-18: Specifying a nested path to bring multiple
items with the same prefix into scope</span></p>
<p>In bigger programs, bringing many items into scope from the same package or
module using nested paths can reduce the number of separate <code>use</code> statements
needed by a lot!</p>
<p>We can use a nested path at any level in a path, which is useful when combining
two <code>use</code> statements that share a subpath. For example, Listing 7-19 shows two
<code>use</code> statements: one that brings <code>std::io</code> into scope and one that brings
<code>std::io::Write</code> into scope.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 7-19: Two <code>use</code> statements where one is a subpath
of the other</span></p>
<p>The common part of these two paths is <code>std::io</code>, and that’s the complete first
path. To merge these two paths into one <code>use</code> statement, we can use <code>self</code> in
the nested path, as shown in Listing 7-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 7-20: Combining the paths in Listing 7-19 into
one <code>use</code> statement</span></p>
<p>This line brings <code>std::io</code> and <code>std::io::Write</code> into scope.</p>
<h3><a class="header" href="#the-glob-operator" id="the-glob-operator">The Glob Operator</a></h3>
<p>If we want to bring <em>all</em> public items defined in a path into scope, we can
specify that path followed by <code>*</code>, the glob operator:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<p>This <code>use</code> statement brings all public items defined in <code>std::collections</code> into
the current scope. Be careful when using the glob operator! Glob can make it
harder to tell what names are in scope and where a name used in your program
was defined.</p>
<p>The glob operator is often used when testing to bring everything under test
into the <code>tests</code> module; we’ll talk about that in the <a href="rustbook/ch11-01-writing-tests.html#how-to-write-tests">“How to Write
Tests”</a><!-- ignore --> section in Chapter 11. The glob operator
is also sometimes used as part of the prelude pattern: see <a href="rustbook/../std/prelude/index.html#other-preludes">the standard
library documentation</a><!-- ignore -->
for more information on that pattern.</p>
<h2><a class="header" href="#separating-modules-into-different-files" id="separating-modules-into-different-files">Separating Modules into Different Files</a></h2>
<p>So far, all the examples in this chapter defined multiple modules in one file.
When modules get large, you might want to move their definitions to a separate
file to make the code easier to navigate.</p>
<p>For example, let’s start from the code in Listing 7-17 and move the
<code>front_of_house</code> module to its own file <em>src/front_of_house.rs</em> by changing the
crate root file so it contains the code shown in Listing 7-21. In this case,
the crate root file is <em>src/lib.rs</em>, but this procedure also works with binary
crates whose crate root file is <em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Listing 7-21: Declaring the <code>front_of_house</code> module whose
body will be in <em>src/front_of_house.rs</em></span></p>
<p>And <em>src/front_of_house.rs</em> gets the definitions from the body of the
<code>front_of_house</code> module, as shown in Listing 7-22.</p>
<p><span class="filename">Filename: src/front_of_house.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub mod hosting {
    pub fn add_to_waitlist() {}
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 7-22: Definitions inside the <code>front_of_house</code>
module in <em>src/front_of_house.rs</em></span></p>
<p>Using a semicolon after <code>mod front_of_house</code> rather than using a block tells
Rust to load the contents of the module from another file with the same name as
the module. To continue with our example and extract the <code>hosting</code> module to
its own file as well, we change <em>src/front_of_house.rs</em> to contain only the
declaration of the <code>hosting</code> module:</p>
<p><span class="filename">Filename: src/front_of_house.rs</span></p>
<pre><code>pub mod hosting;
</code></pre>
<p>Then we create a <em>src/front_of_house</em> directory and a file
<em>src/front_of_house/hosting.rs</em> to contain the definitions made in the
<code>hosting</code> module:</p>
<p><span class="filename">Filename: src/front_of_house/hosting.rs</span></p>
<pre><code>pub fn add_to_waitlist() {}
</code></pre>
<p>The module tree remains the same, and the function calls in <code>eat_at_restaurant</code>
will work without any modification, even though the definitions live in
different files. This technique lets you move modules to new files as they grow
in size.</p>
<p>Note that the <code>pub use crate::front_of_house::hosting</code> statement in
<em>src/lib.rs</em> also hasn’t changed, nor does <code>use</code> have any impact on what files
are compiled as part of the crate. The <code>mod</code> keyword declares modules, and Rust
looks in a file with the same name as the module for the code that goes into
that module.</p>
<h2><a class="header" href="#summary-6" id="summary-6">Summary</a></h2>
<p>Rust lets you organize your packages into crates and your crates into modules
so you can refer to items defined in one module from another module. You can do
this by specifying absolute or relative paths. These paths can be brought into
scope with a <code>use</code> statement so you can use a shorter path for multiple uses of
the item in that scope. Module code is private by default, but you can make
definitions public by adding the <code>pub</code> keyword.</p>
<p>In the next chapter, we’ll look at some collection data structures in the
standard library that you can use in your neatly organized code.</p>
<h1><a class="header" href="#common-collections" id="common-collections">Common Collections</a></h1>
<p>Rust’s standard library includes a number of very useful data structures called
<em>collections</em>. Most other data types represent one specific value, but
collections can contain multiple values. Unlike the built-in array and tuple
types, the data these collections point to is stored on the heap, which means
the amount of data does not need to be known at compile time and can grow or
shrink as the program runs. Each kind of collection has different capabilities
and costs, and choosing an appropriate one for your current situation is a
skill you’ll develop over time. In this chapter, we’ll discuss three
collections that are used very often in Rust programs:</p>
<ul>
<li>A <em>vector</em> allows you to store a variable number of values next to each other.</li>
<li>A <em>string</em> is a collection of characters. We’ve mentioned the <code>String</code> type
previously, but in this chapter we’ll talk about it in depth.</li>
<li>A <em>hash map</em> allows you to associate a value with a particular key. It’s a
particular implementation of the more general data structure called a <em>map</em>.</li>
</ul>
<p>To learn about the other kinds of collections provided by the standard library,
see <a href="rustbook/../std/collections/index.html">the documentation</a>.</p>
<p>We’ll discuss how to create and update vectors, strings, and hash maps, as well
as what makes each special.</p>
<h2><a class="header" href="#storing-lists-of-values-with-vectors" id="storing-lists-of-values-with-vectors">Storing Lists of Values with Vectors</a></h2>
<p>The first collection type we’ll look at is <code>Vec&lt;T&gt;</code>, also known as a <em>vector</em>.
Vectors allow you to store more than one value in a single data structure that
puts all the values next to each other in memory. Vectors can only store values
of the same type. They are useful when you have a list of items, such as the
lines of text in a file or the prices of items in a shopping cart.</p>
<h3><a class="header" href="#creating-a-new-vector" id="creating-a-new-vector">Creating a New Vector</a></h3>
<p>To create a new, empty vector, we can call the <code>Vec::new</code> function, as shown in
Listing 8-1.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-1: Creating a new, empty vector to hold values
of type <code>i32</code></span></p>
<p>Note that we added a type annotation here. Because we aren’t inserting any
values into this vector, Rust doesn’t know what kind of elements we intend to
store. This is an important point. Vectors are implemented using generics;
we’ll cover how to use generics with your own types in Chapter 10. For now,
know that the <code>Vec&lt;T&gt;</code> type provided by the standard library can hold any type,
and when a specific vector holds a specific type, the type is specified within
angle brackets. In Listing 8-1, we’ve told Rust that the <code>Vec&lt;T&gt;</code> in <code>v</code> will
hold elements of the <code>i32</code> type.</p>
<p>In more realistic code, Rust can often infer the type of value you want to
store once you insert values, so you rarely need to do this type annotation.
It’s more common to create a <code>Vec&lt;T&gt;</code> that has initial values, and Rust
provides the <code>vec!</code> macro for convenience. The macro will create a new vector
that holds the values you give it. Listing 8-2 creates a new <code>Vec&lt;i32&gt;</code> that
holds the values <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-2: Creating a new vector containing
values</span></p>
<p>Because we’ve given initial <code>i32</code> values, Rust can infer that the type of <code>v</code>
is <code>Vec&lt;i32&gt;</code>, and the type annotation isn’t necessary. Next, we’ll look at how
to modify a vector.</p>
<h3><a class="header" href="#updating-a-vector" id="updating-a-vector">Updating a Vector</a></h3>
<p>To create a vector and then add elements to it, we can use the <code>push</code> method,
as shown in Listing 8-3.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-3: Using the <code>push</code> method to add values to a
vector</span></p>
<p>As with any variable, if we want to be able to change its value, we need to
make it mutable using the <code>mut</code> keyword, as discussed in Chapter 3. The numbers
we place inside are all of type <code>i32</code>, and Rust infers this from the data, so
we don’t need the <code>Vec&lt;i32&gt;</code> annotation.</p>
<h3><a class="header" href="#dropping-a-vector-drops-its-elements" id="dropping-a-vector-drops-its-elements">Dropping a Vector Drops Its Elements</a></h3>
<p>Like any other <code>struct</code>, a vector is freed when it goes out of scope, as
annotated in Listing 8-4.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    let v = vec![1, 2, 3, 4];

    // do stuff with v

} // &lt;- v goes out of scope and is freed here
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-4: Showing where the vector and its elements
are dropped</span></p>
<p>When the vector gets dropped, all of its contents are also dropped, meaning
those integers it holds will be cleaned up. This may seem like a
straightforward point but can get a bit more complicated when you start to
introduce references to the elements of the vector. Let’s tackle that next!</p>
<h3><a class="header" href="#reading-elements-of-vectors" id="reading-elements-of-vectors">Reading Elements of Vectors</a></h3>
<p>Now that you know how to create, update, and destroy vectors, knowing how to
read their contents is a good next step. There are two ways to reference a
value stored in a vector. In the examples, we’ve annotated the types of the
values that are returned from these functions for extra clarity.</p>
<p>Listing 8-5 shows both methods of accessing a value in a vector, either with
indexing syntax or the <code>get</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!(&quot;The third element is {}&quot;, third);

match v.get(2) {
    Some(third) =&gt; println!(&quot;The third element is {}&quot;, third),
    None =&gt; println!(&quot;There is no third element.&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-5: Using indexing syntax or the <code>get</code> method to
access an item in a vector</span></p>
<p>Note two details here. First, we use the index value of <code>2</code> to get the third
element: vectors are indexed by number, starting at zero. Second, the two ways
to get the third element are by using <code>&amp;</code> and <code>[]</code>, which gives us a reference,
or by using the <code>get</code> method with the index passed as an argument, which gives
us an <code>Option&lt;&amp;T&gt;</code>.</p>
<p>Rust has two ways to reference an element so you can choose how the program
behaves when you try to use an index value that the vector doesn’t have an
element for. As an example, let’s see what a program will do if it has a vector
that holds five elements and then tries to access an element at index 100, as
shown in Listing 8-6.</p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-6: Attempting to access the element at index
100 in a vector containing five elements</span></p>
<p>When we run this code, the first <code>[]</code> method will cause the program to panic
because it references a nonexistent element. This method is best used when you
want your program to crash if there’s an attempt to access an element past the
end of the vector.</p>
<p>When the <code>get</code> method is passed an index that is outside the vector, it returns
<code>None</code> without panicking. You would use this method if accessing an element
beyond the range of the vector happens occasionally under normal circumstances.
Your code will then have logic to handle having either <code>Some(&amp;element)</code> or
<code>None</code>, as discussed in Chapter 6. For example, the index could be coming from
a person entering a number. If they accidentally enter a number that’s too
large and the program gets a <code>None</code> value, you could tell the user how many
items are in the current vector and give them another chance to enter a valid
value. That would be more user-friendly than crashing the program due to a typo!</p>
<p>When the program has a valid reference, the borrow checker enforces the
ownership and borrowing rules (covered in Chapter 4) to ensure this reference
and any other references to the contents of the vector remain valid. Recall the
rule that states you can’t have mutable and immutable references in the same
scope. That rule applies in Listing 8-7, where we hold an immutable reference to
the first element in a vector and try to add an element to the end, which won’t
work.</p>
<pre><code class="language-rust ignore does_not_compile">let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;The first element is: {}&quot;, first);
</code></pre>
<p><span class="caption">Listing 8-7: Attempting to add an element to a vector
while holding a reference to an item</span></p>
<p>Compiling this code will result in this error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 |
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 |
8 |     println!(&quot;The first element is: {}&quot;, first);
  |                                          ----- immutable borrow later used here
</code></pre>
<p>The code in Listing 8-7 might look like it should work: why should a reference
to the first element care about what changes at the end of the vector? This
error is due to the way vectors work: adding a new element onto the end of the
vector might require allocating new memory and copying the old elements to the
new space, if there isn’t enough room to put all the elements next to each
other where the vector currently is. In that case, the reference to the first
element would be pointing to deallocated memory. The borrowing rules prevent
programs from ending up in that situation.</p>
<blockquote>
<p>Note: For more on the implementation details of the <code>Vec&lt;T&gt;</code> type, see “The
Rustonomicon” at https://doc.rust-lang.org/stable/nomicon/vec.html.</p>
</blockquote>
<h3><a class="header" href="#iterating-over-the-values-in-a-vector" id="iterating-over-the-values-in-a-vector">Iterating over the Values in a Vector</a></h3>
<p>If we want to access each element in a vector in turn, we can iterate through
all of the elements rather than use indices to access one at a time. Listing
8-8 shows how to use a <code>for</code> loop to get immutable references to each element
in a vector of <code>i32</code> values and print them.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-8: Printing each element in a vector by
iterating over the elements using a <code>for</code> loop</span></p>
<p>We can also iterate over mutable references to each element in a mutable vector
in order to make changes to all the elements. The <code>for</code> loop in Listing 8-9
will add <code>50</code> to each element.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-9: Iterating over mutable references to
elements in a vector</span></p>
<p>To change the value that the mutable reference refers to, we have to use the
dereference operator (<code>*</code>) to get to the value in <code>i</code> before we can use the
<code>+=</code> operator. We’ll talk more about the dereference operator in the
<a href="rustbook/ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">“Following the Pointer to the Value with the Dereference Operator”</a>
section of Chapter 15.</p>
<h3><a class="header" href="#using-an-enum-to-store-multiple-types" id="using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></h3>
<p>At the beginning of this chapter, we said that vectors can only store values
that are the same type. This can be inconvenient; there are definitely use
cases for needing to store a list of items of different types. Fortunately, the
variants of an enum are defined under the same enum type, so when we need to
store elements of a different type in a vector, we can define and use an enum!</p>
<p>For example, say we want to get values from a row in a spreadsheet in which
some of the columns in the row contain integers, some floating-point numbers,
and some strings. We can define an enum whose variants will hold the different
value types, and then all the enum variants will be considered the same type:
that of the enum. Then we can create a vector that holds that enum and so,
ultimately, holds different types. We’ve demonstrated this in Listing 8-10.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell::Float(10.12),
];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-10: Defining an <code>enum</code> to store values of
different types in one vector</span></p>
<p>Rust needs to know what types will be in the vector at compile time so it knows
exactly how much memory on the heap will be needed to store each element. A
secondary advantage is that we can be explicit about what types are allowed in
this vector. If Rust allowed a vector to hold any type, there would be a chance
that one or more of the types would cause errors with the operations performed
on the elements of the vector. Using an enum plus a <code>match</code> expression means
that Rust will ensure at compile time that every possible case is handled, as
discussed in Chapter 6.</p>
<p>When you’re writing a program, if you don’t know the exhaustive set of types
the program will get at runtime to store in a vector, the enum technique won’t
work. Instead, you can use a trait object, which we’ll cover in Chapter 17.</p>
<p>Now that we’ve discussed some of the most common ways to use vectors, be sure
to review the API documentation for all the many useful methods defined on
<code>Vec&lt;T&gt;</code> by the standard library. For example, in addition to <code>push</code>, a <code>pop</code>
method removes and returns the last element. Let’s move on to the next
collection type: <code>String</code>!</p>
<h2><a class="header" href="#storing-utf-8-encoded-text-with-strings" id="storing-utf-8-encoded-text-with-strings">Storing UTF-8 Encoded Text with Strings</a></h2>
<p>We talked about strings in Chapter 4, but we’ll look at them in more depth now.
New Rustaceans commonly get stuck on strings for a combination of three
reasons: Rust’s propensity for exposing possible errors, strings being a more
complicated data structure than many programmers give them credit for, and
UTF-8. These factors combine in a way that can seem difficult when you’re
coming from other programming languages.</p>
<p>It’s useful to discuss strings in the context of collections because strings
are implemented as a collection of bytes, plus some methods to provide useful
functionality when those bytes are interpreted as text. In this section, we’ll
talk about the operations on <code>String</code> that every collection type has, such as
creating, updating, and reading. We’ll also discuss the ways in which <code>String</code>
is different from the other collections, namely how indexing into a <code>String</code> is
complicated by the differences between how people and computers interpret
<code>String</code> data.</p>
<h3><a class="header" href="#what-is-a-string" id="what-is-a-string">What Is a String?</a></h3>
<p>We’ll first define what we mean by the term <em>string</em>. Rust has only one string
type in the core language, which is the string slice <code>str</code> that is usually seen
in its borrowed form <code>&amp;str</code>. In Chapter 4, we talked about <em>string slices</em>,
which are references to some UTF-8 encoded string data stored elsewhere. String
literals, for example, are stored in the program’s binary and are therefore
string slices.</p>
<p>The <code>String</code> type, which is provided by Rust’s standard library rather than
coded into the core language, is a growable, mutable, owned, UTF-8 encoded
string type. When Rustaceans refer to “strings” in Rust, they usually mean the
<code>String</code> and the string slice <code>&amp;str</code> types, not just one of those types.
Although this section is largely about <code>String</code>, both types are used heavily in
Rust’s standard library, and both <code>String</code> and string slices are UTF-8 encoded.</p>
<p>Rust’s standard library also includes a number of other string types, such as
<code>OsString</code>, <code>OsStr</code>, <code>CString</code>, and <code>CStr</code>. Library crates can provide even
more options for storing string data. See how those names all end in <code>String</code>
or <code>Str</code>? They refer to owned and borrowed variants, just like the <code>String</code> and
<code>str</code> types you’ve seen previously. These string types can store text in
different encodings or be represented in memory in a different way, for
example. We won’t discuss these other string types in this chapter; see their
API documentation for more about how to use them and when each is appropriate.</p>
<h3><a class="header" href="#creating-a-new-string" id="creating-a-new-string">Creating a New String</a></h3>
<p>Many of the same operations available with <code>Vec&lt;T&gt;</code> are available with <code>String</code>
as well, starting with the <code>new</code> function to create a string, shown in Listing
8-11.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-11: Creating a new, empty <code>String</code></span></p>
<p>This line creates a new empty string called <code>s</code>, which we can then load data
into. Often, we’ll have some initial data that we want to start the string
with. For that, we use the <code>to_string</code> method, which is available on any type
that implements the <code>Display</code> trait, as string literals do. Listing 8-12 shows
two examples.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let data = &quot;initial contents&quot;;

let s = data.to_string();

// the method also works on a literal directly:
let s = &quot;initial contents&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-12: Using the <code>to_string</code> method to create a
<code>String</code> from a string literal</span></p>
<p>This code creates a string containing <code>initial contents</code>.</p>
<p>We can also use the function <code>String::from</code> to create a <code>String</code> from a string
literal. The code in Listing 8-13 is equivalent to the code from Listing 8-12
that uses <code>to_string</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;initial contents&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-13: Using the <code>String::from</code> function to create
a <code>String</code> from a string literal</span></p>
<p>Because strings are used for so many things, we can use many different generic
APIs for strings, providing us with a lot of options. Some of them can seem
redundant, but they all have their place! In this case, <code>String::from</code> and
<code>to_string</code> do the same thing, so which you choose is a matter of style.</p>
<p>Remember that strings are UTF-8 encoded, so we can include any properly encoded
data in them, as shown in Listing 8-14.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-14: Storing greetings in different languages in
strings</span></p>
<p>All of these are valid <code>String</code> values.</p>
<h3><a class="header" href="#updating-a-string" id="updating-a-string">Updating a String</a></h3>
<p>A <code>String</code> can grow in size and its contents can change, just like the contents
of a <code>Vec&lt;T&gt;</code>, if you push more data into it. In addition, you can conveniently
use the <code>+</code> operator or the <code>format!</code> macro to concatenate <code>String</code> values.</p>
<h4><a class="header" href="#appending-to-a-string-with-push_str-and-push" id="appending-to-a-string-with-push_str-and-push">Appending to a String with <code>push_str</code> and <code>push</code></a></h4>
<p>We can grow a <code>String</code> by using the <code>push_str</code> method to append a string slice,
as shown in Listing 8-15.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-15: Appending a string slice to a <code>String</code>
using the <code>push_str</code> method</span></p>
<p>After these two lines, <code>s</code> will contain <code>foobar</code>. The <code>push_str</code> method takes a
string slice because we don’t necessarily want to take ownership of the
parameter. For example, the code in Listing 8-16 shows that it would be
unfortunate if we weren’t able to use <code>s2</code> after appending its contents to <code>s1</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 is {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-16: Using a string slice after appending its
contents to a <code>String</code></span></p>
<p>If the <code>push_str</code> method took ownership of <code>s2</code>, we wouldn’t be able to print
its value on the last line. However, this code works as we’d expect!</p>
<p>The <code>push</code> method takes a single character as a parameter and adds it to the
<code>String</code>. Listing 8-17 shows code that adds the letter <em>l</em> to a <code>String</code> using
the <code>push</code> method.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;lo&quot;);
s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-17: Adding one character to a <code>String</code> value
using <code>push</code></span></p>
<p>As a result of this code, <code>s</code> will contain <code>lol</code>.</p>
<h4><a class="header" href="#concatenation-with-the--operator-or-the-format-macro" id="concatenation-with-the--operator-or-the-format-macro">Concatenation with the <code>+</code> Operator or the <code>format!</code> Macro</a></h4>
<p>Often, you’ll want to combine two existing strings. One way is to use the <code>+</code>
operator, as shown in Listing 8-18.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hello, &quot;);
let s2 = String::from(&quot;world!&quot;);
let s3 = s1 + &amp;s2; // note s1 has been moved here and can no longer be used
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-18: Using the <code>+</code> operator to combine two
<code>String</code> values into a new <code>String</code> value</span></p>
<p>The string <code>s3</code> will contain <code>Hello, world!</code> as a result of this code. The
reason <code>s1</code> is no longer valid after the addition and the reason we used a
reference to <code>s2</code> has to do with the signature of the method that gets called
when we use the <code>+</code> operator. The <code>+</code> operator uses the <code>add</code> method, whose
signature looks something like this:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>This isn’t the exact signature that’s in the standard library: in the standard
library, <code>add</code> is defined using generics. Here, we’re looking at the signature
of <code>add</code> with concrete types substituted for the generic ones, which is what
happens when we call this method with <code>String</code> values. We’ll discuss generics
in Chapter 10. This signature gives us the clues we need to understand the
tricky bits of the <code>+</code> operator.</p>
<p>First, <code>s2</code> has an <code>&amp;</code>, meaning that we’re adding a <em>reference</em> of the second
string to the first string because of the <code>s</code> parameter in the <code>add</code> function:
we can only add a <code>&amp;str</code> to a <code>String</code>; we can’t add two <code>String</code> values
together. But wait—the type of <code>&amp;s2</code> is <code>&amp;String</code>, not <code>&amp;str</code>, as specified in
the second parameter to <code>add</code>. So why does Listing 8-18 compile?</p>
<p>The reason we’re able to use <code>&amp;s2</code> in the call to <code>add</code> is that the compiler
can <em>coerce</em> the <code>&amp;String</code> argument into a <code>&amp;str</code>. When we call the <code>add</code>
method, Rust uses a <em>deref coercion</em>, which here turns <code>&amp;s2</code> into <code>&amp;s2[..]</code>.
We’ll discuss deref coercion in more depth in Chapter 15. Because <code>add</code> does
not take ownership of the <code>s</code> parameter, <code>s2</code> will still be a valid <code>String</code>
after this operation.</p>
<p>Second, we can see in the signature that <code>add</code> takes ownership of <code>self</code>,
because <code>self</code> does <em>not</em> have an <code>&amp;</code>. This means <code>s1</code> in Listing 8-18 will be
moved into the <code>add</code> call and no longer be valid after that. So although <code>let s3 = s1 + &amp;s2;</code> looks like it will copy both strings and create a new one, this
statement actually takes ownership of <code>s1</code>, appends a copy of the contents of
<code>s2</code>, and then returns ownership of the result. In other words, it looks like
it’s making a lot of copies but isn’t; the implementation is more efficient
than copying.</p>
<p>If we need to concatenate multiple strings, the behavior of the <code>+</code> operator
gets unwieldy:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>At this point, <code>s</code> will be <code>tic-tac-toe</code>. With all of the <code>+</code> and <code>&quot;</code>
characters, it’s difficult to see what’s going on. For more complicated string
combining, we can use the <code>format!</code> macro:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<p>This code also sets <code>s</code> to <code>tic-tac-toe</code>. The <code>format!</code> macro works in the same
way as <code>println!</code>, but instead of printing the output to the screen, it returns
a <code>String</code> with the contents. The version of the code using <code>format!</code> is much
easier to read and doesn’t take ownership of any of its parameters.</p>
<h3><a class="header" href="#indexing-into-strings" id="indexing-into-strings">Indexing into Strings</a></h3>
<p>In many other programming languages, accessing individual characters in a
string by referencing them by index is a valid and common operation. However,
if you try to access parts of a <code>String</code> using indexing syntax in Rust, you’ll
get an error. Consider the invalid code in Listing 8-19.</p>
<pre><code class="language-rust ignore does_not_compile">let s1 = String::from(&quot;hello&quot;);
let h = s1[0];
</code></pre>
<p><span class="caption">Listing 8-19: Attempting to use indexing syntax with a
String</span></p>
<p>This code will result in the following error:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: std::ops::Index&lt;{integer}&gt;` is not satisfied
 --&gt;
  |
3 |     let h = s1[0];
  |             ^^^^^ the type `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`
</code></pre>
<p>The error and the note tell the story: Rust strings don’t support indexing. But
why not? To answer that question, we need to discuss how Rust stores strings in
memory.</p>
<h4><a class="header" href="#internal-representation" id="internal-representation">Internal Representation</a></h4>
<p>A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>. Let’s look at some of our properly
encoded UTF-8 example strings from Listing 8-14. First, this one:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let len = String::from(&quot;Hola&quot;).len();
<span class="boring">}
</span></code></pre></pre>
<p>In this case, <code>len</code> will be 4, which means the vector storing the string “Hola”
is 4 bytes long. Each of these letters takes 1 byte when encoded in UTF-8. But
what about the following line? (Note that this string begins with the capital
Cyrillic letter Ze, not the Arabic number 3.)</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let len = String::from(&quot;Здравствуйте&quot;).len();
<span class="boring">}
</span></code></pre></pre>
<p>Asked how long the string is, you might say 12. However, Rust’s answer is 24:
that’s the number of bytes it takes to encode “Здравствуйте” in UTF-8, because
each Unicode scalar value in that string takes 2 bytes of storage. Therefore,
an index into the string’s bytes will not always correlate to a valid Unicode
scalar value. To demonstrate, consider this invalid Rust code:</p>
<pre><code class="language-rust ignore does_not_compile">let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];
</code></pre>
<p>What should the value of <code>answer</code> be? Should it be <code>З</code>, the first letter? When
encoded in UTF-8, the first byte of <code>З</code> is <code>208</code> and the second is <code>151</code>, so
<code>answer</code> should in fact be <code>208</code>, but <code>208</code> is not a valid character on its
own. Returning <code>208</code> is likely not what a user would want if they asked for the
first letter of this string; however, that’s the only data that Rust has at
byte index 0. Users generally don’t want the byte value returned, even if the
string contains only Latin letters: if <code>&amp;&quot;hello&quot;[0]</code> were valid code that
returned the byte value, it would return <code>104</code>, not <code>h</code>. To avoid returning an
unexpected value and causing bugs that might not be discovered immediately,
Rust doesn’t compile this code at all and prevents misunderstandings early in
the development process.</p>
<h4><a class="header" href="#bytes-and-scalar-values-and-grapheme-clusters-oh-my" id="bytes-and-scalar-values-and-grapheme-clusters-oh-my">Bytes and Scalar Values and Grapheme Clusters! Oh My!</a></h4>
<p>Another point about UTF-8 is that there are actually three relevant ways to
look at strings from Rust’s perspective: as bytes, scalar values, and grapheme
clusters (the closest thing to what we would call <em>letters</em>).</p>
<p>If we look at the Hindi word “नमस्ते” written in the Devanagari script, it is
stored as a vector of <code>u8</code> values that looks like this:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>That’s 18 bytes and is how computers ultimately store this data. If we look at
them as Unicode scalar values, which are what Rust’s <code>char</code> type is, those
bytes look like this:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>There are six <code>char</code> values here, but the fourth and sixth are not letters:
they’re diacritics that don’t make sense on their own. Finally, if we look at
them as grapheme clusters, we’d get what a person would call the four letters
that make up the Hindi word:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust provides different ways of interpreting the raw string data that computers
store so that each program can choose the interpretation it needs, no matter
what human language the data is in.</p>
<p>A final reason Rust doesn’t allow us to index into a <code>String</code> to get a
character is that indexing operations are expected to always take constant time
(O(1)). But it isn’t possible to guarantee that performance with a <code>String</code>,
because Rust would have to walk through the contents from the beginning to the
index to determine how many valid characters there were.</p>
<h3><a class="header" href="#slicing-strings" id="slicing-strings">Slicing Strings</a></h3>
<p>Indexing into a string is often a bad idea because it’s not clear what the
return type of the string-indexing operation should be: a byte value, a
character, a grapheme cluster, or a string slice. Therefore, Rust asks you to
be more specific if you really need to use indices to create string slices. To
be more specific in your indexing and indicate that you want a string slice,
rather than indexing using <code>[]</code> with a single number, you can use <code>[]</code> with a
range to create a string slice containing particular bytes:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p>Here, <code>s</code> will be a <code>&amp;str</code> that contains the first 4 bytes of the string.
Earlier, we mentioned that each of these characters was 2 bytes, which means
<code>s</code> will be <code>Зд</code>.</p>
<p>What would happen if we used <code>&amp;hello[0..1]</code>? The answer: Rust would panic at
runtime in the same way as if an invalid index were accessed in a vector:</p>
<pre><code class="language-text">thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2188:4
</code></pre>
<p>You should use ranges to create string slices with caution, because doing so
can crash your program.</p>
<h3><a class="header" href="#methods-for-iterating-over-strings" id="methods-for-iterating-over-strings">Methods for Iterating Over Strings</a></h3>
<p>Fortunately, you can access elements in a string in other ways.</p>
<p>If you need to perform operations on individual Unicode scalar values, the best
way to do so is to use the <code>chars</code> method. Calling <code>chars</code> on “नमस्ते” separates
out and returns six values of type <code>char</code>, and you can iterate over the result
to access each element:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p>This code will print the following:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>The <code>bytes</code> method returns each raw byte, which might be appropriate for your
domain:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>This code will print the 18 bytes that make up this <code>String</code>:</p>
<pre><code class="language-text">224
164
// --snip--
165
135
</code></pre>
<p>But be sure to remember that valid Unicode scalar values may be made up of more
than 1 byte.</p>
<p>Getting grapheme clusters from strings is complex, so this functionality is not
provided by the standard library. Crates are available on
<a href="https://crates.io/">crates.io</a> if this is the functionality you need.</p>
<h3><a class="header" href="#strings-are-not-so-simple" id="strings-are-not-so-simple">Strings Are Not So Simple</a></h3>
<p>To summarize, strings are complicated. Different programming languages make
different choices about how to present this complexity to the programmer. Rust
has chosen to make the correct handling of <code>String</code> data the default behavior
for all Rust programs, which means programmers have to put more thought into
handling UTF-8 data upfront. This trade-off exposes more of the complexity of
strings than is apparent in other programming languages, but it prevents you
from having to handle errors involving non-ASCII characters later in your
development life cycle.</p>
<p>Let’s switch to something a bit less complex: hash maps!</p>
<h2><a class="header" href="#storing-keys-with-associated-values-in-hash-maps" id="storing-keys-with-associated-values-in-hash-maps">Storing Keys with Associated Values in Hash Maps</a></h2>
<p>The last of our common collections is the <em>hash map</em>. The type <code>HashMap&lt;K, V&gt;</code>
stores a mapping of keys of type <code>K</code> to values of type <code>V</code>. It does this via a
<em>hashing function</em>, which determines how it places these keys and values into
memory. Many programming languages support this kind of data structure, but
they often use a different name, such as hash, map, object, hash table,
dictionary, or associative array, just to name a few.</p>
<p>Hash maps are useful when you want to look up data not by using an index, as
you can with vectors, but by using a key that can be of any type. For example,
in a game, you could keep track of each team’s score in a hash map in which
each key is a team’s name and the values are each team’s score. Given a team
name, you can retrieve its score.</p>
<p>We’ll go over the basic API of hash maps in this section, but many more goodies
are hiding in the functions defined on <code>HashMap&lt;K, V&gt;</code> by the standard library.
As always, check the standard library documentation for more information.</p>
<h3><a class="header" href="#creating-a-new-hash-map" id="creating-a-new-hash-map">Creating a New Hash Map</a></h3>
<p>You can create an empty hash map with <code>new</code> and add elements with <code>insert</code>. In
Listing 8-20, we’re keeping track of the scores of two teams whose names are
Blue and Yellow. The Blue team starts with 10 points, and the Yellow team
starts with 50.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-20: Creating a new hash map and inserting some
keys and values</span></p>
<p>Note that we need to first <code>use</code> the <code>HashMap</code> from the collections portion of
the standard library. Of our three common collections, this one is the least
often used, so it’s not included in the features brought into scope
automatically in the prelude. Hash maps also have less support from the
standard library; there’s no built-in macro to construct them, for example.</p>
<p>Just like vectors, hash maps store their data on the heap. This <code>HashMap</code> has
keys of type <code>String</code> and values of type <code>i32</code>. Like vectors, hash maps are
homogeneous: all of the keys must have the same type, and all of the values
must have the same type.</p>
<p>Another way of constructing a hash map is by using the <code>collect</code> method on a
vector of tuples, where each tuple consists of a key and its value. The
<code>collect</code> method gathers data into a number of collection types, including
<code>HashMap</code>. For example, if we had the team names and initial scores in two
separate vectors, we could use the <code>zip</code> method to create a vector of tuples
where “Blue” is paired with 10, and so forth. Then we could use the <code>collect</code>
method to turn that vector of tuples into a hash map, as shown in Listing 8-21.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let teams  = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-21: Creating a hash map from a list of teams
and a list of scores</span></p>
<p>The type annotation <code>HashMap&lt;_, _&gt;</code> is needed here because it’s possible to
<code>collect</code> into many different data structures and Rust doesn’t know which you
want unless you specify. For the parameters for the key and value types,
however, we use underscores, and Rust can infer the types that the hash map
contains based on the types of the data in the vectors.</p>
<h3><a class="header" href="#hash-maps-and-ownership" id="hash-maps-and-ownership">Hash Maps and Ownership</a></h3>
<p>For types that implement the <code>Copy</code> trait, like <code>i32</code>, the values are copied
into the hash map. For owned values like <code>String</code>, the values will be moved and
the hash map will be the owner of those values, as demonstrated in Listing 8-22.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let field_name = String::from(&quot;Favorite color&quot;);
let field_value = String::from(&quot;Blue&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name and field_value are invalid at this point, try using them and
// see what compiler error you get!
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-22: Showing that keys and values are owned by
the hash map once they’re inserted</span></p>
<p>We aren’t able to use the variables <code>field_name</code> and <code>field_value</code> after
they’ve been moved into the hash map with the call to <code>insert</code>.</p>
<p>If we insert references to values into the hash map, the values won’t be moved
into the hash map. The values that the references point to must be valid for at
least as long as the hash map is valid. We’ll talk more about these issues in
the <a href="rustbook/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“Validating References with
Lifetimes”</a><!-- ignore --> section in
Chapter 10.</p>
<h3><a class="header" href="#accessing-values-in-a-hash-map" id="accessing-values-in-a-hash-map">Accessing Values in a Hash Map</a></h3>
<p>We can get a value out of the hash map by providing its key to the <code>get</code>
method, as shown in Listing 8-23.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

let team_name = String::from(&quot;Blue&quot;);
let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-23: Accessing the score for the Blue team
stored in the hash map</span></p>
<p>Here, <code>score</code> will have the value that’s associated with the Blue team, and the
result will be <code>Some(&amp;10)</code>. The result is wrapped in <code>Some</code> because <code>get</code>
returns an <code>Option&lt;&amp;V&gt;</code>; if there’s no value for that key in the hash map,
<code>get</code> will return <code>None</code>. The program will need to handle the <code>Option</code> in one
of the ways that we covered in Chapter 6.</p>
<p>We can iterate over each key/value pair in a hash map in a similar manner as we
do with vectors, using a <code>for</code> loop:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<p>This code will print each pair in an arbitrary order:</p>
<pre><code class="language-text">Yellow: 50
Blue: 10
</code></pre>
<h3><a class="header" href="#updating-a-hash-map" id="updating-a-hash-map">Updating a Hash Map</a></h3>
<p>Although the number of keys and values is growable, each key can only have one
value associated with it at a time. When you want to change the data in a hash
map, you have to decide how to handle the case when a key already has a value
assigned. You could replace the old value with the new value, completely
disregarding the old value. You could keep the old value and ignore the new
value, only adding the new value if the key <em>doesn’t</em> already have a value. Or
you could combine the old value and the new value. Let’s look at how to do each
of these!</p>
<h4><a class="header" href="#overwriting-a-value" id="overwriting-a-value">Overwriting a Value</a></h4>
<p>If we insert a key and a value into a hash map and then insert that same key
with a different value, the value associated with that key will be replaced.
Even though the code in Listing 8-24 calls <code>insert</code> twice, the hash map will
only contain one key/value pair because we’re inserting the value for the Blue
team’s key both times.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Blue&quot;), 25);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-24: Replacing a value stored with a particular
key</span></p>
<p>This code will print <code>{&quot;Blue&quot;: 25}</code>. The original value of <code>10</code> has been
overwritten.</p>
<h4><a class="header" href="#only-inserting-a-value-if-the-key-has-no-value" id="only-inserting-a-value-if-the-key-has-no-value">Only Inserting a Value If the Key Has No Value</a></h4>
<p>It’s common to check whether a particular key has a value and, if it doesn’t,
insert a value for it. Hash maps have a special API for this called <code>entry</code>
that takes the key you want to check as a parameter. The return value of the
<code>entry</code> method is an enum called <code>Entry</code> that represents a value that might or
might not exist. Let’s say we want to check whether the key for the Yellow team
has a value associated with it. If it doesn’t, we want to insert the value 50,
and the same for the Blue team. Using the <code>entry</code> API, the code looks like
Listing 8-25.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-25: Using the <code>entry</code> method to only insert if
the key does not already have a value</span></p>
<p>The <code>or_insert</code> method on <code>Entry</code> is defined to return a mutable reference to
the value for the corresponding <code>Entry</code> key if that key exists, and if not,
inserts the parameter as the new value for this key and returns a mutable
reference to the new value. This technique is much cleaner than writing the
logic ourselves and, in addition, plays more nicely with the borrow checker.</p>
<p>Running the code in Listing 8-25 will print <code>{&quot;Yellow&quot;: 50, &quot;Blue&quot;: 10}</code>. The
first call to <code>entry</code> will insert the key for the Yellow team with the value
50 because the Yellow team doesn’t have a value already. The second call to
<code>entry</code> will not change the hash map because the Blue team already has the
value 10.</p>
<h4><a class="header" href="#updating-a-value-based-on-the-old-value" id="updating-a-value-based-on-the-old-value">Updating a Value Based on the Old Value</a></h4>
<p>Another common use case for hash maps is to look up a key’s value and then
update it based on the old value. For instance, Listing 8-26 shows code that
counts how many times each word appears in some text. We use a hash map with
the words as keys and increment the value to keep track of how many times we’ve
seen that word. If it’s the first time we’ve seen a word, we’ll first insert
the value 0.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = &quot;hello world wonderful world&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 8-26: Counting occurrences of words using a hash
map that stores words and counts</span></p>
<p>This code will print <code>{&quot;world&quot;: 2, &quot;hello&quot;: 1, &quot;wonderful&quot;: 1}</code>. The
<code>or_insert</code> method actually returns a mutable reference (<code>&amp;mut V</code>) to the value
for this key. Here we store that mutable reference in the <code>count</code> variable, so
in order to assign to that value, we must first dereference <code>count</code> using the
asterisk (<code>*</code>). The mutable reference goes out of scope at the end of the <code>for</code>
loop, so all of these changes are safe and allowed by the borrowing rules.</p>
<h3><a class="header" href="#hashing-functions" id="hashing-functions">Hashing Functions</a></h3>
<p>By default, <code>HashMap</code> uses a “cryptographically strong”<sup class="footnote-reference"><a href="#siphash">1</a></sup> hashing
function that can provide resistance to Denial of Service (DoS) attacks. This
is not the fastest hashing algorithm available, but the trade-off for better
security that comes with the drop in performance is worth it. If you profile
your code and find that the default hash function is too slow for your
purposes, you can switch to another function by specifying a different
<em>hasher</em>. A hasher is a type that implements the <code>BuildHasher</code> trait. We’ll
talk about traits and how to implement them in Chapter 10. You don’t
necessarily have to implement your own hasher from scratch;
<a href="https://crates.io/">crates.io</a> has libraries shared by other Rust users that
provide hashers implementing many common hashing algorithms.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.131002.net/siphash/siphash.pdf">https://www.131002.net/siphash/siphash.pdf</a></p>
</div>
<h2><a class="header" href="#summary-7" id="summary-7">Summary</a></h2>
<p>Vectors, strings, and hash maps will provide a large amount of functionality
necessary in programs when you need to store, access, and modify data. Here are
some exercises you should now be equipped to solve:</p>
<ul>
<li>Given a list of integers, use a vector and return the mean (the average
value), median (when sorted, the value in the middle position), and mode (the
value that occurs most often; a hash map will be helpful here) of the list.</li>
<li>Convert strings to pig latin. The first consonant of each word is moved to
the end of the word and “ay” is added, so “first” becomes “irst-fay.” Words
that start with a vowel have “hay” added to the end instead (“apple” becomes
“apple-hay”). Keep in mind the details about UTF-8 encoding!</li>
<li>Using a hash map and vectors, create a text interface to allow a user to add
employee names to a department in a company. For example, “Add Sally to
Engineering” or “Add Amir to Sales.” Then let the user retrieve a list of all
people in a department or all people in the company by department, sorted
alphabetically.</li>
</ul>
<p>The standard library API documentation describes methods that vectors, strings,
and hash maps have that will be helpful for these exercises!</p>
<p>We’re getting into more complex programs in which operations can fail, so, it’s
a perfect time to discuss error handling. We’ll do that next!</p>
<h1><a class="header" href="#error-handling-1" id="error-handling-1">Error Handling</a></h1>
<p>Rust’s commitment to reliability extends to error handling. Errors are a fact
of life in software, so Rust has a number of features for handling situations
in which something goes wrong. In many cases, Rust requires you to acknowledge
the possibility of an error and take some action before your code will compile.
This requirement makes your program more robust by ensuring that you’ll
discover errors and handle them appropriately before you’ve deployed your code
to production!</p>
<p>Rust groups errors into two major categories: <em>recoverable</em> and <em>unrecoverable</em>
errors. For a recoverable error, such as a file not found error, it’s
reasonable to report the problem to the user and retry the operation.
Unrecoverable errors are always symptoms of bugs, like trying to access a
location beyond the end of an array.</p>
<p>Most languages don’t distinguish between these two kinds of errors and handle
both in the same way, using mechanisms such as exceptions. Rust doesn’t have
exceptions. Instead, it has the type <code>Result&lt;T, E&gt;</code> for recoverable errors and
the <code>panic!</code> macro that stops execution when the program encounters an
unrecoverable error. This chapter covers calling <code>panic!</code> first and then talks
about returning <code>Result&lt;T, E&gt;</code> values. Additionally, we’ll explore
considerations when deciding whether to try to recover from an error or to stop
execution.</p>
<h2><a class="header" href="#unrecoverable-errors-with-panic" id="unrecoverable-errors-with-panic">Unrecoverable Errors with <code>panic!</code></a></h2>
<p>Sometimes, bad things happen in your code, and there’s nothing you can do about
it. In these cases, Rust has the <code>panic!</code> macro. When the <code>panic!</code> macro
executes, your program will print a failure message, unwind and clean up the
stack, and then quit. This most commonly occurs when a bug of some kind has
been detected and it’s not clear to the programmer how to handle the error.</p>
<blockquote>
<h3><a class="header" href="#unwinding-the-stack-or-aborting-in-response-to-a-panic" id="unwinding-the-stack-or-aborting-in-response-to-a-panic">Unwinding the Stack or Aborting in Response to a Panic</a></h3>
<p>By default, when a panic occurs, the program starts <em>unwinding</em>, which
means Rust walks back up the stack and cleans up the data from each function
it encounters. But this walking back and cleanup is a lot of work. The
alternative is to immediately <em>abort</em>, which ends the program without
cleaning up. Memory that the program was using will then need to be cleaned
up by the operating system. If in your project you need to make the resulting
binary as small as possible, you can switch from unwinding to aborting upon a
panic by adding <code>panic = 'abort'</code> to the appropriate <code>[profile]</code> sections in
your <em>Cargo.toml</em> file. For example, if you want to abort on panic in release
mode, add this:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Let’s try calling <code>panic!</code> in a simple program:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;crash and burn&quot;);
}
</code></pre></pre>
<p>When you run the program, you’ll see something like this:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'crash and burn', src/main.rs:2:5
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>The call to <code>panic!</code> causes the error message contained in the last two lines.
The first line shows our panic message and the place in our source code where
the panic occurred: <em>src/main.rs:2:5</em> indicates that it’s the second line,
fifth character of our <em>src/main.rs</em> file.</p>
<p>In this case, the line indicated is part of our code, and if we go to that
line, we see the <code>panic!</code> macro call. In other cases, the <code>panic!</code> call might
be in code that our code calls, and the filename and line number reported by
the error message will be someone else’s code where the <code>panic!</code> macro is
called, not the line of our code that eventually led to the <code>panic!</code> call. We
can use the backtrace of the functions the <code>panic!</code> call came from to figure
out the part of our code that is causing the problem. We’ll discuss what a
backtrace is in more detail next.</p>
<h3><a class="header" href="#using-a-panic-backtrace" id="using-a-panic-backtrace">Using a <code>panic!</code> Backtrace</a></h3>
<p>Let’s look at another example to see what it’s like when a <code>panic!</code> call comes
from a library because of a bug in our code instead of from our code calling
the macro directly. Listing 9-1 has some code that attempts to access an
element by index in a vector.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Listing 9-1: Attempting to access an element beyond the
end of a vector, which will cause a call to <code>panic!</code></span></p>
<p>Here, we’re attempting to access the 100th element of our vector (which is at
index 99 because indexing starts at zero), but it has only 3 elements. In this
situation, Rust will panic. Using <code>[]</code> is supposed to return an element, but if
you pass an invalid index, there’s no element that Rust could return here that
would be correct.</p>
<p>Other languages, like C, will attempt to give you exactly what you asked for in
this situation, even though it isn’t what you want: you’ll get whatever is at
the location in memory that would correspond to that element in the vector,
even though the memory doesn’t belong to the vector. This is called a <em>buffer
overread</em> and can lead to security vulnerabilities if an attacker is able to
manipulate the index in such a way as to read data they shouldn’t be allowed to
that is stored after the array.</p>
<p>To protect your program from this sort of vulnerability, if you try to read an
element at an index that doesn’t exist, Rust will stop execution and refuse to
continue. Let’s try it and see:</p>
<pre><code class="language-text">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', libcore/slice/mod.rs:2448:10
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>This error points at a file we didn’t write, <em>libcore/slice/mod.rs</em>. That’s the
implementation of <code>slice</code> in the Rust source code. The code that gets run when
we use <code>[]</code> on our vector <code>v</code> is in <em>libcore/slice/mod.rs</em>, and that is where
the <code>panic!</code> is actually happening.</p>
<p>The next note line tells us that we can set the <code>RUST_BACKTRACE</code> environment
variable to get a backtrace of exactly what happened to cause the error. A
<em>backtrace</em> is a list of all the functions that have been called to get to this
point. Backtraces in Rust work as they do in other languages: the key to
reading the backtrace is to start from the top and read until you see files you
wrote. That’s the spot where the problem originated. The lines above the lines
mentioning your files are code that your code called; the lines below are code
that called your code. These lines might include core Rust code, standard
library code, or crates that you’re using. Let’s try getting a backtrace by
setting the <code>RUST_BACKTRACE</code> environment variable to any value except 0.
Listing 9-2 shows output similar to what you’ll see.</p>
<pre><code class="language-text">$ RUST_BACKTRACE=1 cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', libcore/slice/mod.rs:2448:10
stack backtrace:
   0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace
             at libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::print
             at libstd/sys_common/backtrace.rs:71
             at libstd/sys_common/backtrace.rs:59
   2: std::panicking::default_hook::{{closure}}
             at libstd/panicking.rs:211
   3: std::panicking::default_hook
             at libstd/panicking.rs:227
   4: &lt;std::panicking::begin_panic::PanicPayload&lt;A&gt; as core::panic::BoxMeUp&gt;::get
             at libstd/panicking.rs:476
   5: std::panicking::continue_panic_fmt
             at libstd/panicking.rs:390
   6: std::panicking::try::do_call
             at libstd/panicking.rs:325
   7: core::ptr::drop_in_place
             at libcore/panicking.rs:77
   8: core::ptr::drop_in_place
             at libcore/panicking.rs:59
   9: &lt;usize as core::slice::SliceIndex&lt;[T]&gt;&gt;::index
             at libcore/slice/mod.rs:2448
  10: core::slice::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at libcore/slice/mod.rs:2316
  11: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at liballoc/vec.rs:1653
  12: panic::main
             at src/main.rs:4
  13: std::rt::lang_start::{{closure}}
             at libstd/rt.rs:74
  14: std::panicking::try::do_call
             at libstd/rt.rs:59
             at libstd/panicking.rs:310
  15: macho_symbol_search
             at libpanic_unwind/lib.rs:102
  16: std::alloc::default_alloc_error_hook
             at libstd/panicking.rs:289
             at libstd/panic.rs:392
             at libstd/rt.rs:58
  17: std::rt::lang_start
             at libstd/rt.rs:74
  18: panic::main
</code></pre>
<p><span class="caption">Listing 9-2: The backtrace generated by a call to
<code>panic!</code> displayed when the environment variable <code>RUST_BACKTRACE</code> is set</span></p>
<p>That’s a lot of output! The exact output you see might be different depending
on your operating system and Rust version. In order to get backtraces with this
information, debug symbols must be enabled. Debug symbols are enabled by
default when using <code>cargo build</code> or <code>cargo run</code> without the <code>--release</code> flag,
as we have here.</p>
<p>In the output in Listing 9-2, line 12 of the backtrace points to the line in
our project that’s causing the problem: line 4 of <em>src/main.rs</em>. If we don’t
want our program to panic, the location pointed to by the first line mentioning
a file we wrote is where we should start investigating. In Listing 9-1, where
we deliberately wrote code that would panic in order to demonstrate how to use
backtraces, the way to fix the panic is to not request an element at index 99
from a vector that only contains 3 items. When your code panics in the future,
you’ll need to figure out what action the code is taking with what values to
cause the panic and what the code should do instead.</p>
<p>We’ll come back to <code>panic!</code> and when we should and should not use <code>panic!</code> to
handle error conditions in the <a href="rustbook/ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">“To <code>panic!</code> or Not to
<code>panic!</code>”</a><!-- ignore --> section later in this
chapter. Next, we’ll look at how to recover from an error using <code>Result</code>.</p>
<h2><a class="header" href="#recoverable-errors-with-result" id="recoverable-errors-with-result">Recoverable Errors with <code>Result</code></a></h2>
<p>Most errors aren’t serious enough to require the program to stop entirely.
Sometimes, when a function fails, it’s for a reason that you can easily
interpret and respond to. For example, if you try to open a file and that
operation fails because the file doesn’t exist, you might want to create the
file instead of terminating the process.</p>
<p>Recall from <a href="rustbook/ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">“Handling Potential Failure with the <code>Result</code>
Type”</a><!-- ignore --> in Chapter 2 that the <code>Result</code> enum is
defined as having two variants, <code>Ok</code> and <code>Err</code>, as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>T</code> and <code>E</code> are generic type parameters: we’ll discuss generics in more
detail in Chapter 10. What you need to know right now is that <code>T</code> represents
the type of the value that will be returned in a success case within the <code>Ok</code>
variant, and <code>E</code> represents the type of the error that will be returned in a
failure case within the <code>Err</code> variant. Because <code>Result</code> has these generic type
parameters, we can use the <code>Result</code> type and the functions that the standard
library has defined on it in many different situations where the successful
value and error value we want to return may differ.</p>
<p>Let’s call a function that returns a <code>Result</code> value because the function could
fail. In Listing 9-3 we try to open a file.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 9-3: Opening a file</span></p>
<p>How do we know <code>File::open</code> returns a <code>Result</code>? We could look at the <a href="rustbook/../std/index.html">standard
library API documentation</a><!-- ignore -->, or we could ask
the compiler! If we give <code>f</code> a type annotation that we know is <em>not</em> the return
type of the function and then try to compile the code, the compiler will tell
us that the types don’t match. The error message will then tell us what the
type of <code>f</code> <em>is</em>. Let’s try it! We know that the return type of <code>File::open</code>
isn’t of type <code>u32</code>, so let’s change the <code>let f</code> statement to this:</p>
<pre><code class="language-rust ignore">let f: u32 = File::open(&quot;hello.txt&quot;);
</code></pre>
<p>Attempting to compile now gives us the following output:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hello.txt&quot;);
  |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected u32, found enum
`std::result::Result`
  |
  = note: expected type `u32`
             found type `std::result::Result&lt;std::fs::File, std::io::Error&gt;`
</code></pre>
<p>This tells us the return type of the <code>File::open</code> function is a <code>Result&lt;T, E&gt;</code>.
The generic parameter <code>T</code> has been filled in here with the type of the success
value, <code>std::fs::File</code>, which is a file handle. The type of <code>E</code> used in the
error value is <code>std::io::Error</code>.</p>
<p>This return type means the call to <code>File::open</code> might succeed and return a file
handle that we can read from or write to. The function call also might fail:
for example, the file might not exist, or we might not have permission to
access the file. The <code>File::open</code> function needs to have a way to tell us
whether it succeeded or failed and at the same time give us either the file
handle or error information. This information is exactly what the <code>Result</code> enum
conveys.</p>
<p>In the case where <code>File::open</code> succeeds, the value in the variable <code>f</code> will be
an instance of <code>Ok</code> that contains a file handle. In the case where it fails,
the value in <code>f</code> will be an instance of <code>Err</code> that contains more information
about the kind of error that happened.</p>
<p>We need to add to the code in Listing 9-3 to take different actions depending
on the value <code>File::open</code> returns. Listing 9-4 shows one way to handle the
<code>Result</code> using a basic tool, the <code>match</code> expression that we discussed in
Chapter 6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; {
            panic!(&quot;Problem opening the file: {:?}&quot;, error)
        },
    };
}
</code></pre></pre>
<p><span class="caption">Listing 9-4: Using a <code>match</code> expression to handle the
<code>Result</code> variants that might be returned</span></p>
<p>Note that, like the <code>Option</code> enum, the <code>Result</code> enum and its variants have been
brought into scope by the prelude, so we don’t need to specify <code>Result::</code>
before the <code>Ok</code> and <code>Err</code> variants in the <code>match</code> arms.</p>
<p>Here we tell Rust that when the result is <code>Ok</code>, return the inner <code>file</code> value
out of the <code>Ok</code> variant, and we then assign that file handle value to the
variable <code>f</code>. After the <code>match</code>, we can use the file handle for reading or
writing.</p>
<p>The other arm of the <code>match</code> handles the case where we get an <code>Err</code> value from
<code>File::open</code>. In this example, we’ve chosen to call the <code>panic!</code> macro. If
there’s no file named <em>hello.txt</em> in our current directory and we run this
code, we’ll see the following output from the <code>panic!</code> macro:</p>
<pre><code class="language-text">thread 'main' panicked at 'Problem opening the file: Error { repr:
Os { code: 2, message: &quot;No such file or directory&quot; } }', src/main.rs:9:12
</code></pre>
<p>As usual, this output tells us exactly what has gone wrong.</p>
<h3><a class="header" href="#matching-on-different-errors" id="matching-on-different-errors">Matching on Different Errors</a></h3>
<p>The code in Listing 9-4 will <code>panic!</code> no matter why <code>File::open</code> failed. What
we want to do instead is take different actions for different failure reasons:
if <code>File::open</code> failed because the file doesn’t exist, we want to create the
file and return the handle to the new file. If <code>File::open</code> failed for any
other reason—for example, because we didn’t have permission to open the file—we
still want the code to <code>panic!</code> in the same way as it did in Listing 9-4. Look
at Listing 9-5, which adds an inner <code>match</code> expression.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hello.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem creating the file: {:?}&quot;, e),
            },
            other_error =&gt; panic!(&quot;Problem opening the file: {:?}&quot;, other_error),
        },
    };
}
</code></pre>
<p><span class="caption">Listing 9-5: Handling different kinds of errors in
different ways</span></p>
<p>The type of the value that <code>File::open</code> returns inside the <code>Err</code> variant is
<code>io::Error</code>, which is a struct provided by the standard library. This struct
has a method <code>kind</code> that we can call to get an <code>io::ErrorKind</code> value. The enum
<code>io::ErrorKind</code> is provided by the standard library and has variants
representing the different kinds of errors that might result from an <code>io</code>
operation. The variant we want to use is <code>ErrorKind::NotFound</code>, which indicates
the file we’re trying to open doesn’t exist yet. So we match on <code>f</code>, but we
also have an inner match on <code>error.kind()</code>.</p>
<p>The condition we want to check in the inner match is whether the value returned
by <code>error.kind()</code> is the <code>NotFound</code> variant of the <code>ErrorKind</code> enum. If it is,
we try to create the file with <code>File::create</code>. However, because <code>File::create</code>
could also fail, we need a second arm in the inner <code>match</code> expression. When the
file can’t be created, a different error message is printed. The second arm of
the outer <code>match</code> stays the same, so the program panics on any error besides
the missing file error.</p>
<p>That’s a lot of <code>match</code>! The <code>match</code> expression is very useful but also very
much a primitive. In Chapter 13, you’ll learn about closures; the <code>Result&lt;T, E&gt;</code> type has many methods that accept a closure and are implemented using
<code>match</code> expressions. Using those methods will make your code more concise. A
more seasoned Rustacean might write this code instead of Listing 9-5:</p>
<pre><code class="language-rust ignore">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hello.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem creating the file: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem opening the file: {:?}&quot;, error);
        }
    });
}
</code></pre>
<p>Although this code has the same behavior as Listing 9-5, it doesn’t contain any
<code>match</code> expressions and is cleaner to read. Come back to this example after
you’ve read Chapter 13, and look up the <code>unwrap_or_else</code> method in the standard
library documentation. Many more of these methods can clean up huge nested
<code>match</code> expressions when you’re dealing with errors.</p>
<h3><a class="header" href="#shortcuts-for-panic-on-error-unwrap-and-expect" id="shortcuts-for-panic-on-error-unwrap-and-expect">Shortcuts for Panic on Error: <code>unwrap</code> and <code>expect</code></a></h3>
<p>Using <code>match</code> works well enough, but it can be a bit verbose and doesn’t always
communicate intent well. The <code>Result&lt;T, E&gt;</code> type has many helper methods
defined on it to do various tasks. One of those methods, called <code>unwrap</code>, is a
shortcut method that is implemented just like the <code>match</code> expression we wrote in
Listing 9-4. If the <code>Result</code> value is the <code>Ok</code> variant, <code>unwrap</code> will return
the value inside the <code>Ok</code>. If the <code>Result</code> is the <code>Err</code> variant, <code>unwrap</code> will
call the <code>panic!</code> macro for us. Here is an example of <code>unwrap</code> in action:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).unwrap();
}
</code></pre></pre>
<p>If we run this code without a <em>hello.txt</em> file, we’ll see an error message from
the <code>panic!</code> call that the <code>unwrap</code> method makes:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Another method, <code>expect</code>, which is similar to <code>unwrap</code>, lets us also choose the
<code>panic!</code> error message. Using <code>expect</code> instead of <code>unwrap</code> and providing good
error messages can convey your intent and make tracking down the source of a
panic easier. The syntax of <code>expect</code> looks like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
}
</code></pre></pre>
<p>We use <code>expect</code> in the same way as <code>unwrap</code>: to return the file handle or call
the <code>panic!</code> macro. The error message used by <code>expect</code> in its call to <code>panic!</code>
will be the parameter that we pass to <code>expect</code>, rather than the default
<code>panic!</code> message that <code>unwrap</code> uses. Here’s what it looks like:</p>
<pre><code class="language-text">thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: &quot;No such file or directory&quot; } }', src/libcore/result.rs:906:4
</code></pre>
<p>Because this error message starts with the text we specified, <code>Failed to open hello.txt</code>, it will be easier to find where in the code this error message is
coming from. If we use <code>unwrap</code> in multiple places, it can take more time to
figure out exactly which <code>unwrap</code> is causing the panic because all <code>unwrap</code>
calls that panic print the same message.</p>
<h3><a class="header" href="#propagating-errors" id="propagating-errors">Propagating Errors</a></h3>
<p>When you’re writing a function whose implementation calls something that might
fail, instead of handling the error within this function, you can return the
error to the calling code so that it can decide what to do. This is known as
<em>propagating</em> the error and gives more control to the calling code, where there
might be more information or logic that dictates how the error should be
handled than what you have available in the context of your code.</p>
<p>For example, Listing 9-6 shows a function that reads a username from a file. If
the file doesn’t exist or can’t be read, this function will return those errors
to the code that called this function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hello.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-6: A function that returns errors to the
calling code using <code>match</code></span></p>
<p>This function can be written in a much shorter way, but we’re going to start by
doing a lot of it manually in order to explore error handling; at the end,
we’ll show the shorter way. Let’s look at the return type of the function first:
<code>Result&lt;String, io::Error&gt;</code>. This means the function is returning a value of
the type <code>Result&lt;T, E&gt;</code> where the generic parameter <code>T</code> has been filled in
with the concrete type <code>String</code> and the generic type <code>E</code> has been filled in
with the concrete type <code>io::Error</code>. If this function succeeds without any
problems, the code that calls this function will receive an <code>Ok</code> value that
holds a <code>String</code>—the username that this function read from the file. If this
function encounters any problems, the code that calls this function will
receive an <code>Err</code> value that holds an instance of <code>io::Error</code> that contains
more information about what the problems were. We chose <code>io::Error</code> as the
return type of this function because that happens to be the type of the error
value returned from both of the operations we’re calling in this function’s
body that might fail: the <code>File::open</code> function and the <code>read_to_string</code>
method.</p>
<p>The body of the function starts by calling the <code>File::open</code> function. Then we
handle the <code>Result</code> value returned with a <code>match</code> similar to the <code>match</code> in
Listing 9-4, only instead of calling <code>panic!</code> in the <code>Err</code> case, we return
early from this function and pass the error value from <code>File::open</code> back to the
calling code as this function’s error value. If <code>File::open</code> succeeds, we store
the file handle in the variable <code>f</code> and continue.</p>
<p>Then we create a new <code>String</code> in variable <code>s</code> and call the <code>read_to_string</code>
method on the file handle in <code>f</code> to read the contents of the file into <code>s</code>. The
<code>read_to_string</code> method also returns a <code>Result</code> because it might fail, even
though <code>File::open</code> succeeded. So we need another <code>match</code> to handle that
<code>Result</code>: if <code>read_to_string</code> succeeds, then our function has succeeded, and we
return the username from the file that’s now in <code>s</code> wrapped in an <code>Ok</code>. If
<code>read_to_string</code> fails, we return the error value in the same way that we
returned the error value in the <code>match</code> that handled the return value of
<code>File::open</code>. However, we don’t need to explicitly say <code>return</code>, because this
is the last expression in the function.</p>
<p>The code that calls this code will then handle getting either an <code>Ok</code> value
that contains a username or an <code>Err</code> value that contains an <code>io::Error</code>. We
don’t know what the calling code will do with those values. If the calling code
gets an <code>Err</code> value, it could call <code>panic!</code> and crash the program, use a
default username, or look up the username from somewhere other than a file, for
example. We don’t have enough information on what the calling code is actually
trying to do, so we propagate all the success or error information upward for
it to handle appropriately.</p>
<p>This pattern of propagating errors is so common in Rust that Rust provides the
question mark operator <code>?</code> to make this easier.</p>
<h4><a class="header" href="#a-shortcut-for-propagating-errors-the--operator" id="a-shortcut-for-propagating-errors-the--operator">A Shortcut for Propagating Errors: the <code>?</code> Operator</a></h4>
<p>Listing 9-7 shows an implementation of <code>read_username_from_file</code> that has the
same functionality as it had in Listing 9-6, but this implementation uses the
<code>?</code> operator.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-7: A function that returns errors to the
calling code using the <code>?</code> operator</span></p>
<p>The <code>?</code> placed after a <code>Result</code> value is defined to work in almost the same way
as the <code>match</code> expressions we defined to handle the <code>Result</code> values in Listing
9-6. If the value of the <code>Result</code> is an <code>Ok</code>, the value inside the <code>Ok</code> will
get returned from this expression, and the program will continue. If the value
is an <code>Err</code>, the <code>Err</code> will be returned from the whole function as if we had
used the <code>return</code> keyword so the error value gets propagated to the calling
code.</p>
<p>There is a difference between what the <code>match</code> expression from Listing 9-6 and
the <code>?</code> operator do: error values that have the <code>?</code> operator called on them go
through the <code>from</code> function, defined in the <code>From</code> trait in the standard
library, which is used to convert errors from one type into another. When the
<code>?</code> operator calls the <code>from</code> function, the error type received is converted
into the error type defined in the return type of the current function. This is
useful when a function returns one error type to represent all the ways a
function might fail, even if parts might fail for many different reasons. As
long as each error type implements the <code>from</code> function to define how to convert
itself to the returned error type, the <code>?</code> operator takes care of the
conversion automatically.</p>
<p>In the context of Listing 9-7, the <code>?</code> at the end of the <code>File::open</code> call will
return the value inside an <code>Ok</code> to the variable <code>f</code>. If an error occurs, the
<code>?</code> operator will return early out of the whole function and give any <code>Err</code>
value to the calling code. The same thing applies to the <code>?</code> at the end of the
<code>read_to_string</code> call.</p>
<p>The <code>?</code> operator eliminates a lot of boilerplate and makes this function’s
implementation simpler. We could even shorten this code further by chaining
method calls immediately after the <code>?</code>, as shown in Listing 9-8.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Read;
use std::fs::File;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-8: Chaining method calls after the <code>?</code>
operator</span></p>
<p>We’ve moved the creation of the new <code>String</code> in <code>s</code> to the beginning of the
function; that part hasn’t changed. Instead of creating a variable <code>f</code>, we’ve
chained the call to <code>read_to_string</code> directly onto the result of
<code>File::open(&quot;hello.txt&quot;)?</code>. We still have a <code>?</code> at the end of the
<code>read_to_string</code> call, and we still return an <code>Ok</code> value containing the
username in <code>s</code> when both <code>File::open</code> and <code>read_to_string</code> succeed rather than
returning errors. The functionality is again the same as in Listing 9-6 and
Listing 9-7; this is just a different, more ergonomic way to write it.</p>
<p>Speaking of different ways to write this function, Listing 9-9 shows that
there’s a way to make this even shorter.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::fs;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-9: Using <code>fs::read_to_string</code> instead of
opening and then reading the file</span></p>
<p>Reading a file into a string is a fairly common operation, so Rust provides the
convenient <code>fs::read_to_string</code> function that opens the file, creates a new
<code>String</code>, reads the contents of the file, puts the contents into that <code>String</code>,
and returns it. Of course, using <code>fs::read_to_string</code> doesn’t give us the
opportunity to explain all the error handling, so we did it the longer way
first.</p>
<h4><a class="header" href="#the--operator-can-only-be-used-in-functions-that-return-result" id="the--operator-can-only-be-used-in-functions-that-return-result">The <code>?</code> Operator Can Only Be Used in Functions That Return <code>Result</code></a></h4>
<p>The <code>?</code> operator can only be used in functions that have a return type of
<code>Result</code>, because it is defined to work in the same way as the <code>match</code>
expression we defined in Listing 9-6. The part of the <code>match</code> that requires a
return type of <code>Result</code> is <code>return Err(e)</code>, so the return type of the function
must be a <code>Result</code> to be compatible with this <code>return</code>.</p>
<p>Let’s look at what happens if we use the <code>?</code> operator in the <code>main</code> function,
which you’ll recall has a return type of <code>()</code>:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;hello.txt&quot;)?;
}
</code></pre>
<p>When we compile this code, we get the following error message:</p>
<pre><code class="language-text">error[E0277]: the `?` operator can only be used in a function that returns
`Result` or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
4 |     let f = File::open(&quot;hello.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a
  function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>This error points out that we’re only allowed to use the <code>?</code> operator in a
function that returns <code>Result&lt;T, E&gt;</code>. When you’re writing code in a function
that doesn’t return <code>Result&lt;T, E&gt;</code>, and you want to use <code>?</code> when you call other
functions that return <code>Result&lt;T, E&gt;</code>, you have two choices to fix this problem.
One technique is to change the return type of your function to be <code>Result&lt;T, E&gt;</code> if you have no restrictions preventing that. The other technique is to use
a <code>match</code> or one of the <code>Result&lt;T, E&gt;</code> methods to handle the <code>Result&lt;T, E&gt;</code> in
whatever way is appropriate.</p>
<p>The <code>main</code> function is special, and there are restrictions on what its return
type must be. One valid return type for main is <code>()</code>, and conveniently, another
valid return type is <code>Result&lt;T, E&gt;</code>, as shown here:</p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hello.txt&quot;)?;

    Ok(())
}
</code></pre>
<p>The <code>Box&lt;dyn Error&gt;</code> type is called a trait object, which we’ll talk about in
the <a href="rustbook/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects that Allow for Values of Different
Types”</a><!-- ignore --> section in Chapter 17. For now, you can
read <code>Box&lt;dyn Error&gt;</code> to mean “any kind of error.” Using <code>?</code> in a <code>main</code>
function with this return type is allowed.</p>
<p>Now that we’ve discussed the details of calling <code>panic!</code> or returning <code>Result</code>,
let’s return to the topic of how to decide which is appropriate to use in which
cases.</p>
<h2><a class="header" href="#to-panic-or-not-to-panic" id="to-panic-or-not-to-panic">To <code>panic!</code> or Not to <code>panic!</code></a></h2>
<p>So how do you decide when you should call <code>panic!</code> and when you should return
<code>Result</code>? When code panics, there’s no way to recover. You could call <code>panic!</code>
for any error situation, whether there’s a possible way to recover or not, but
then you’re making the decision on behalf of the code calling your code that a
situation is unrecoverable. When you choose to return a <code>Result</code> value, you
give the calling code options rather than making the decision for it. The
calling code could choose to attempt to recover in a way that’s appropriate for
its situation, or it could decide that an <code>Err</code> value in this case is
unrecoverable, so it can call <code>panic!</code> and turn your recoverable error into an
unrecoverable one. Therefore, returning <code>Result</code> is a good default choice when
you’re defining a function that might fail.</p>
<p>In rare situations, it’s more appropriate to write code that panics instead of
returning a <code>Result</code>. Let’s explore why it’s appropriate to panic in examples,
prototype code, and tests. Then we’ll discuss situations in which the compiler
can’t tell that failure is impossible, but you as a human can. The chapter will
conclude with some general guidelines on how to decide whether to panic in
library code.</p>
<h3><a class="header" href="#examples-prototype-code-and-tests" id="examples-prototype-code-and-tests">Examples, Prototype Code, and Tests</a></h3>
<p>When you’re writing an example to illustrate some concept, having robust
error-handling code in the example as well can make the example less clear. In
examples, it’s understood that a call to a method like <code>unwrap</code> that could
panic is meant as a placeholder for the way you’d want your application to
handle errors, which can differ based on what the rest of your code is doing.</p>
<p>Similarly, the <code>unwrap</code> and <code>expect</code> methods are very handy when prototyping,
before you’re ready to decide how to handle errors. They leave clear markers in
your code for when you’re ready to make your program more robust.</p>
<p>If a method call fails in a test, you’d want the whole test to fail, even if
that method isn’t the functionality under test. Because <code>panic!</code> is how a test
is marked as a failure, calling <code>unwrap</code> or <code>expect</code> is exactly what should
happen.</p>
<h3><a class="header" href="#cases-in-which-you-have-more-information-than-the-compiler" id="cases-in-which-you-have-more-information-than-the-compiler">Cases in Which You Have More Information Than the Compiler</a></h3>
<p>It would also be appropriate to call <code>unwrap</code> when you have some other logic
that ensures the <code>Result</code> will have an <code>Ok</code> value, but the logic isn’t
something the compiler understands. You’ll still have a <code>Result</code> value that you
need to handle: whatever operation you’re calling still has the possibility of
failing in general, even though it’s logically impossible in your particular
situation. If you can ensure by manually inspecting the code that you’ll never
have an <code>Err</code> variant, it’s perfectly acceptable to call <code>unwrap</code>. Here’s an
example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>We’re creating an <code>IpAddr</code> instance by parsing a hardcoded string. We can see
that <code>127.0.0.1</code> is a valid IP address, so it’s acceptable to use <code>unwrap</code>
here. However, having a hardcoded, valid string doesn’t change the return type
of the <code>parse</code> method: we still get a <code>Result</code> value, and the compiler will
still make us handle the <code>Result</code> as if the <code>Err</code> variant is a possibility
because the compiler isn’t smart enough to see that this string is always a
valid IP address. If the IP address string came from a user rather than being
hardcoded into the program and therefore <em>did</em> have a possibility of failure,
we’d definitely want to handle the <code>Result</code> in a more robust way instead.</p>
<h3><a class="header" href="#guidelines-for-error-handling" id="guidelines-for-error-handling">Guidelines for Error Handling</a></h3>
<p>It’s advisable to have your code panic when it’s possible that your code
could end up in a bad state. In this context, a <em>bad state</em> is when some
assumption, guarantee, contract, or invariant has been broken, such as when
invalid values, contradictory values, or missing values are passed to your
code—plus one or more of the following:</p>
<ul>
<li>The bad state is not something that’s <em>expected</em> to happen occasionally.</li>
<li>Your code after this point needs to rely on not being in this bad state.</li>
<li>There’s not a good way to encode this information in the types you use.</li>
</ul>
<p>If someone calls your code and passes in values that don’t make sense, the best
choice might be to call <code>panic!</code> and alert the person using your library to the
bug in their code so they can fix it during development. Similarly, <code>panic!</code> is
often appropriate if you’re calling external code that is out of your control
and it returns an invalid state that you have no way of fixing.</p>
<p>However, when failure is expected, it’s more appropriate to return a <code>Result</code>
than to make a <code>panic!</code> call. Examples include a parser being given malformed
data or an HTTP request returning a status that indicates you have hit a rate
limit. In these cases, returning a <code>Result</code> indicates that failure is an
expected possibility that the calling code must decide how to handle.</p>
<p>When your code performs operations on values, your code should verify the
values are valid first and panic if the values aren’t valid. This is mostly for
safety reasons: attempting to operate on invalid data can expose your code to
vulnerabilities. This is the main reason the standard library will call
<code>panic!</code> if you attempt an out-of-bounds memory access: trying to access memory
that doesn’t belong to the current data structure is a common security problem.
Functions often have <em>contracts</em>: their behavior is only guaranteed if the
inputs meet particular requirements. Panicking when the contract is violated
makes sense because a contract violation always indicates a caller-side bug and
it’s not a kind of error you want the calling code to have to explicitly
handle. In fact, there’s no reasonable way for calling code to recover; the
calling <em>programmers</em> need to fix the code. Contracts for a function,
especially when a violation will cause a panic, should be explained in the API
documentation for the function.</p>
<p>However, having lots of error checks in all of your functions would be verbose
and annoying. Fortunately, you can use Rust’s type system (and thus the type
checking the compiler does) to do many of the checks for you. If your function
has a particular type as a parameter, you can proceed with your code’s logic
knowing that the compiler has already ensured you have a valid value. For
example, if you have a type rather than an <code>Option</code>, your program expects to
have <em>something</em> rather than <em>nothing</em>. Your code then doesn’t have to handle
two cases for the <code>Some</code> and <code>None</code> variants: it will only have one case for
definitely having a value. Code trying to pass nothing to your function won’t
even compile, so your function doesn’t have to check for that case at runtime.
Another example is using an unsigned integer type such as <code>u32</code>, which ensures
the parameter is never negative.</p>
<h3><a class="header" href="#creating-custom-types-for-validation" id="creating-custom-types-for-validation">Creating Custom Types for Validation</a></h3>
<p>Let’s take the idea of using Rust’s type system to ensure we have a valid value
one step further and look at creating a custom type for validation. Recall the
guessing game in Chapter 2 in which our code asked the user to guess a number
between 1 and 100. We never validated that the user’s guess was between those
numbers before checking it against our secret number; we only validated that
the guess was positive. In this case, the consequences were not very dire: our
output of “Too high” or “Too low” would still be correct. But it would be a
useful enhancement to guide the user toward valid guesses and have different
behavior when a user guesses a number that’s out of range versus when a user
types, for example, letters instead.</p>
<p>One way to do this would be to parse the guess as an <code>i32</code> instead of only a
<code>u32</code> to allow potentially negative numbers, and then add a check for the
number being in range, like so:</p>
<pre><code class="language-rust ignore">loop {
    // --snip--

    let guess: i32 = match guess.trim().parse() {
        Ok(num) =&gt; num,
        Err(_) =&gt; continue,
    };

    if guess &lt; 1 || guess &gt; 100 {
        println!(&quot;The secret number will be between 1 and 100.&quot;);
        continue;
    }

    match guess.cmp(&amp;secret_number) {
    // --snip--
}
</code></pre>
<p>The <code>if</code> expression checks whether our value is out of range, tells the user
about the problem, and calls <code>continue</code> to start the next iteration of the loop
and ask for another guess. After the <code>if</code> expression, we can proceed with the
comparisons between <code>guess</code> and the secret number knowing that <code>guess</code> is
between 1 and 100.</p>
<p>However, this is not an ideal solution: if it was absolutely critical that the
program only operated on values between 1 and 100, and it had many functions
with this requirement, having a check like this in every function would be
tedious (and might impact performance).</p>
<p>Instead, we can make a new type and put the validations in a function to create
an instance of the type rather than repeating the validations everywhere. That
way, it’s safe for functions to use the new type in their signatures and
confidently use the values they receive. Listing 9-10 shows one way to define a
<code>Guess</code> type that will only create an instance of <code>Guess</code> if the <code>new</code> function
receives a value between 1 and 100.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 9-10: A <code>Guess</code> type that will only continue with
values between 1 and 100</span></p>
<p>First, we define a struct named <code>Guess</code> that has a field named <code>value</code> that
holds an <code>i32</code>. This is where the number will be stored.</p>
<p>Then we implement an associated function named <code>new</code> on <code>Guess</code> that creates
instances of <code>Guess</code> values. The <code>new</code> function is defined to have one
parameter named <code>value</code> of type <code>i32</code> and to return a <code>Guess</code>. The code in the
body of the <code>new</code> function tests <code>value</code> to make sure it’s between 1 and 100.
If <code>value</code> doesn’t pass this test, we make a <code>panic!</code> call, which will alert
the programmer who is writing the calling code that they have a bug they need
to fix, because creating a <code>Guess</code> with a <code>value</code> outside this range would
violate the contract that <code>Guess::new</code> is relying on. The conditions in which
<code>Guess::new</code> might panic should be discussed in its public-facing API
documentation; we’ll cover documentation conventions indicating the possibility
of a <code>panic!</code> in the API documentation that you create in Chapter 14. If
<code>value</code> does pass the test, we create a new <code>Guess</code> with its <code>value</code> field set
to the <code>value</code> parameter and return the <code>Guess</code>.</p>
<p>Next, we implement a method named <code>value</code> that borrows <code>self</code>, doesn’t have any
other parameters, and returns an <code>i32</code>. This kind of method is sometimes called
a <em>getter</em>, because its purpose is to get some data from its fields and return
it. This public method is necessary because the <code>value</code> field of the <code>Guess</code>
struct is private. It’s important that the <code>value</code> field be private so code
using the <code>Guess</code> struct is not allowed to set <code>value</code> directly: code outside
the module <em>must</em> use the <code>Guess::new</code> function to create an instance of
<code>Guess</code>, thereby ensuring there’s no way for a <code>Guess</code> to have a <code>value</code> that
hasn’t been checked by the conditions in the <code>Guess::new</code> function.</p>
<p>A function that has a parameter or returns only numbers between 1 and 100 could
then declare in its signature that it takes or returns a <code>Guess</code> rather than an
<code>i32</code> and wouldn’t need to do any additional checks in its body.</p>
<h2><a class="header" href="#summary-8" id="summary-8">Summary</a></h2>
<p>Rust’s error handling features are designed to help you write more robust code.
The <code>panic!</code> macro signals that your program is in a state it can’t handle and
lets you tell the process to stop instead of trying to proceed with invalid or
incorrect values. The <code>Result</code> enum uses Rust’s type system to indicate that
operations might fail in a way that your code could recover from. You can use
<code>Result</code> to tell code that calls your code that it needs to handle potential
success or failure as well. Using <code>panic!</code> and <code>Result</code> in the appropriate
situations will make your code more reliable in the face of inevitable problems.</p>
<p>Now that you’ve seen useful ways that the standard library uses generics with
the <code>Option</code> and <code>Result</code> enums, we’ll talk about how generics work and how you
can use them in your code.</p>
<h1><a class="header" href="#generic-types-traits-and-lifetimes" id="generic-types-traits-and-lifetimes">Generic Types, Traits, and Lifetimes</a></h1>
<p>Every programming language has tools for effectively handling the duplication
of concepts. In Rust, one such tool is <em>generics</em>. Generics are abstract
stand-ins for concrete types or other properties. When we’re writing code, we
can express the behavior of generics or how they relate to other generics
without knowing what will be in their place when compiling and running the code.</p>
<p>Similar to the way a function takes parameters with unknown values to run the
same code on multiple concrete values, functions can take parameters of some
generic type instead of a concrete type, like <code>i32</code> or <code>String</code>. In fact, we’ve
already used generics in Chapter 6 with <code>Option&lt;T&gt;</code>, Chapter 8 with <code>Vec&lt;T&gt;</code>
and <code>HashMap&lt;K, V&gt;</code>, and Chapter 9 with <code>Result&lt;T, E&gt;</code>. In this chapter, you’ll
explore how to define your own types, functions, and methods with generics!</p>
<p>First, we’ll review how to extract a function to reduce code duplication. Next,
we’ll use the same technique to make a generic function from two functions that
differ only in the types of their parameters. We’ll also explain how to use
generic types in struct and enum definitions.</p>
<p>Then you’ll learn how to use <em>traits</em> to define behavior in a generic way. You
can combine traits with generic types to constrain a generic type to only
those types that have a particular behavior, as opposed to just any type.</p>
<p>Finally, we’ll discuss <em>lifetimes</em>, a variety of generics that give the
compiler information about how references relate to each other. Lifetimes allow
us to borrow values in many situations while still enabling the compiler to
check that the references are valid.</p>
<h2><a class="header" href="#removing-duplication-by-extracting-a-function" id="removing-duplication-by-extracting-a-function">Removing Duplication by Extracting a Function</a></h2>
<p>Before diving into generics syntax, let’s first look at how to remove
duplication that doesn’t involve generic types by extracting a function. Then
we’ll apply this technique to extract a generic function! In the same way that
you recognize duplicated code to extract into a function, you’ll start to
recognize duplicated code that can use generics.</p>
<p>Consider a short program that finds the largest number in a list, as shown in
Listing 10-1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
<span class="boring"> assert_eq!(largest, 100);
</span>}
</code></pre></pre>
<p><span class="caption">Listing 10-1: Code to find the largest number in a list
of numbers</span></p>
<p>This code stores a list of integers in the variable <code>number_list</code> and places
the first number in the list in a variable named <code>largest</code>. Then it iterates
through all the numbers in the list, and if the current number is greater than
the number stored in <code>largest</code>, it replaces the number in that variable.
However, if the current number is less than or equal to the largest number seen
so far, the variable doesn’t change, and the code moves on to the next number
in the list. After considering all the numbers in the list, <code>largest</code> should
hold the largest number, which in this case is 100.</p>
<p>To find the largest number in two different lists of numbers, we can duplicate
the code in Listing 10-1 and use the same logic at two different places in the
program, as shown in Listing 10-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;The largest number is {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">Listing 10-2: Code to find the largest number in <em>two</em>
lists of numbers</span></p>
<p>Although this code works, duplicating code is tedious and error prone. We also
have to update the code in multiple places when we want to change it.</p>
<p>To eliminate this duplication, we can create an abstraction by defining a
function that operates on any list of integers given to it in a parameter. This
solution makes our code clearer and lets us express the concept of finding the
largest number in a list abstractly.</p>
<p>In Listing 10-3, we extracted the code that finds the largest number into a
function named <code>largest</code>. Unlike the code in Listing 10-1, which can find the
largest number in only one particular list, this program can find the largest
number in two different lists.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 6000);
</span>}
</code></pre></pre>
<p><span class="caption">Listing 10-3: Abstracted code to find the largest number
in two lists</span></p>
<p>The <code>largest</code> function has a parameter called <code>list</code>, which represents any
concrete slice of <code>i32</code> values that we might pass into the function. As a
result, when we call the function, the code runs on the specific values that we
pass in.</p>
<p>In sum, here are the steps we took to change the code from Listing 10-2 to
Listing 10-3:</p>
<ol>
<li>Identify duplicate code.</li>
<li>Extract the duplicate code into the body of the function and specify the
inputs and return values of that code in the function signature.</li>
<li>Update the two instances of duplicated code to call the function instead.</li>
</ol>
<p>Next, we’ll use these same steps with generics to reduce code duplication in
different ways. In the same way that the function body can operate on an
abstract <code>list</code> instead of specific values, generics allow code to operate on
abstract types.</p>
<p>For example, say we had two functions: one that finds the largest item in a
slice of <code>i32</code> values and one that finds the largest item in a slice of <code>char</code>
values. How would we eliminate that duplication? Let’s find out!</p>
<h2><a class="header" href="#generic-data-types" id="generic-data-types">Generic Data Types</a></h2>
<p>We can use generics to create definitions for items like function signatures or
structs, which we can then use with many different concrete data types. Let’s
first look at how to define functions, structs, enums, and methods using
generics. Then we’ll discuss how generics affect code performance.</p>
<h3><a class="header" href="#in-function-definitions" id="in-function-definitions">In Function Definitions</a></h3>
<p>When defining a function that uses generics, we place the generics in the
signature of the function where we would usually specify the data types of the
parameters and return value. Doing so makes our code more flexible and provides
more functionality to callers of our function while preventing code duplication.</p>
<p>Continuing with our <code>largest</code> function, Listing 10-4 shows two functions that
both find the largest value in a slice.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);
<span class="boring">   assert_eq!(result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
<span class="boring">   assert_eq!(result, 'y');
</span>}
</code></pre></pre>
<p><span class="caption">Listing 10-4: Two functions that differ only in their
names and the types in their signatures</span></p>
<p>The <code>largest_i32</code> function is the one we extracted in Listing 10-3 that finds
the largest <code>i32</code> in a slice. The <code>largest_char</code> function finds the largest
<code>char</code> in a slice. The function bodies have the same code, so let’s eliminate
the duplication by introducing a generic type parameter in a single function.</p>
<p>To parameterize the types in the new function we’ll define, we need to name the
type parameter, just as we do for the value parameters to a function. You can
use any identifier as a type parameter name. But we’ll use <code>T</code> because, by
convention, parameter names in Rust are short, often just a letter, and Rust’s
type-naming convention is CamelCase. Short for “type,” <code>T</code> is the default
choice of most Rust programmers.</p>
<p>When we use a parameter in the body of the function, we have to declare the
parameter name in the signature so the compiler knows what that name means.
Similarly, when we use a type parameter name in a function signature, we have
to declare the type parameter name before we use it. To define the generic
<code>largest</code> function, place type name declarations inside angle brackets, <code>&lt;&gt;</code>,
between the name of the function and the parameter list, like this:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>We read this definition as: the function <code>largest</code> is generic over some type
<code>T</code>. This function has one parameter named <code>list</code>, which is a slice of values
of type <code>T</code>. The <code>largest</code> function will return a value of the same type <code>T</code>.</p>
<p>Listing 10-5 shows the combined <code>largest</code> function definition using the generic
data type in its signature. The listing also shows how we can call the function
with either a slice of <code>i32</code> values or <code>char</code> values. Note that this code won’t
compile yet, but we’ll fix it later in this chapter.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-5: A definition of the <code>largest</code> function that
uses generic type parameters but doesn’t compile yet</span></p>
<p>If we compile this code right now, we’ll get this error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>The note mentions <code>std::cmp::PartialOrd</code>, which is a <em>trait</em>. We’ll talk about
traits in the next section. For now, this error states that the body of
<code>largest</code> won’t work for all possible types that <code>T</code> could be. Because we want
to compare values of type <code>T</code> in the body, we can only use types whose values
can be ordered. To enable comparisons, the standard library has the
<code>std::cmp::PartialOrd</code> trait that you can implement on types (see Appendix C
for more on this trait). You’ll learn how to specify that a generic type has a
particular trait in the <a href="rustbook/ch10-02-traits.html#traits-as-parameters">“Traits as Parameters”</a><!--
ignore --> section, but let’s first explore other ways of using generic type
parameters.</p>
<h3><a class="header" href="#in-struct-definitions" id="in-struct-definitions">In Struct Definitions</a></h3>
<p>We can also define structs to use a generic type parameter in one or more
fields using the <code>&lt;&gt;</code> syntax. Listing 10-6 shows how to define a <code>Point&lt;T&gt;</code>
struct to hold <code>x</code> and <code>y</code> coordinate values of any type.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-6: A <code>Point&lt;T&gt;</code> struct that holds <code>x</code> and <code>y</code>
values of type <code>T</code></span></p>
<p>The syntax for using generics in struct definitions is similar to that used in
function definitions. First, we declare the name of the type parameter inside
angle brackets just after the name of the struct. Then we can use the generic
type in the struct definition where we would otherwise specify concrete data
types.</p>
<p>Note that because we’ve used only one generic type to define <code>Point&lt;T&gt;</code>, this
definition says that the <code>Point&lt;T&gt;</code> struct is generic over some type <code>T</code>, and
the fields <code>x</code> and <code>y</code> are <em>both</em> that same type, whatever that type may be. If
we create an instance of a <code>Point&lt;T&gt;</code> that has values of different types, as in
Listing 10-7, our code won’t compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre>
<p><span class="caption">Listing 10-7: The fields <code>x</code> and <code>y</code> must be the same
type because both have the same generic data type <code>T</code>.</span></p>
<p>In this example, when we assign the integer value 5 to <code>x</code>, we let the
compiler know that the generic type <code>T</code> will be an integer for this instance of
<code>Point&lt;T&gt;</code>. Then when we specify 4.0 for <code>y</code>, which we’ve defined to have the
same type as <code>x</code>, we’ll get a type mismatch error like this:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integral variable, found
floating-point variable
  |
  = note: expected type `{integer}`
             found type `{float}`
</code></pre>
<p>To define a <code>Point</code> struct where <code>x</code> and <code>y</code> are both generics but could have
different types, we can use multiple generic type parameters. For example, in
Listing 10-8, we can change the definition of <code>Point</code> to be generic over types
<code>T</code> and <code>U</code> where <code>x</code> is of type <code>T</code> and <code>y</code> is of type <code>U</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Listing 10-8: A <code>Point&lt;T, U&gt;</code> generic over two types so
that <code>x</code> and <code>y</code> can be values of different types</span></p>
<p>Now all the instances of <code>Point</code> shown are allowed! You can use as many generic
type parameters in a definition as you want, but using more than a few makes
your code hard to read. When you need lots of generic types in your code, it
could indicate that your code needs restructuring into smaller pieces.</p>
<h3><a class="header" href="#in-enum-definitions" id="in-enum-definitions">In Enum Definitions</a></h3>
<p>As we did with structs, we can define enums to hold generic data types in their
variants. Let’s take another look at the <code>Option&lt;T&gt;</code> enum that the standard
library provides, which we used in Chapter 6:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>This definition should now make more sense to you. As you can see, <code>Option&lt;T&gt;</code>
is an enum that is generic over type <code>T</code> and has two variants: <code>Some</code>, which
holds one value of type <code>T</code>, and a <code>None</code> variant that doesn’t hold any value.
By using the <code>Option&lt;T&gt;</code> enum, we can express the abstract concept of having an
optional value, and because <code>Option&lt;T&gt;</code> is generic, we can use this abstraction
no matter what the type of the optional value is.</p>
<p>Enums can use multiple generic types as well. The definition of the <code>Result</code>
enum that we used in Chapter 9 is one example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Result</code> enum is generic over two types, <code>T</code> and <code>E</code>, and has two variants:
<code>Ok</code>, which holds a value of type <code>T</code>, and <code>Err</code>, which holds a value of type
<code>E</code>. This definition makes it convenient to use the <code>Result</code> enum anywhere we
have an operation that might succeed (return a value of some type <code>T</code>) or fail
(return an error of some type <code>E</code>). In fact, this is what we used to open a
file in Listing 9-3, where <code>T</code> was filled in with the type <code>std::fs::File</code> when
the file was opened successfully and <code>E</code> was filled in with the type
<code>std::io::Error</code> when there were problems opening the file.</p>
<p>When you recognize situations in your code with multiple struct or enum
definitions that differ only in the types of the values they hold, you can
avoid duplication by using generic types instead.</p>
<h3><a class="header" href="#in-method-definitions" id="in-method-definitions">In Method Definitions</a></h3>
<p>We can implement methods on structs and enums (as we did in Chapter 5) and use
generic types in their definitions, too. Listing 10-9 shows the <code>Point&lt;T&gt;</code>
struct we defined in Listing 10-6 with a method named <code>x</code> implemented on it.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Listing 10-9: Implementing a method named <code>x</code> on the
<code>Point&lt;T&gt;</code> struct that will return a reference to the <code>x</code> field of type
<code>T</code></span></p>
<p>Here, we’ve defined a method named <code>x</code> on <code>Point&lt;T&gt;</code> that returns a reference
to the data in the field <code>x</code>.</p>
<p>Note that we have to declare <code>T</code> just after <code>impl</code> so we can use it to specify
that we’re implementing methods on the type <code>Point&lt;T&gt;</code>.  By declaring <code>T</code> as a
generic type after <code>impl</code>, Rust can identify that the type in the angle
brackets in <code>Point</code> is a generic type rather than a concrete type.</p>
<p>We could, for example, implement methods only on <code>Point&lt;f32&gt;</code> instances rather
than on <code>Point&lt;T&gt;</code> instances with any generic type. In Listing 10-10 we use the
concrete type <code>f32</code>, meaning we don’t declare any types after <code>impl</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-10: An <code>impl</code> block that only applies to a
struct with a particular concrete type for the generic type parameter <code>T</code></span></p>
<p>This code means the type <code>Point&lt;f32&gt;</code> will have a method named
<code>distance_from_origin</code> and other instances of <code>Point&lt;T&gt;</code> where <code>T</code> is not of
type <code>f32</code> will not have this method defined. The method measures how far our
point is from the point at coordinates (0.0, 0.0) and uses mathematical
operations that are available only for floating point types.</p>
<p>Generic type parameters in a struct definition aren’t always the same as those
you use in that struct’s method signatures. For example, Listing 10-11 defines
the method <code>mixup</code> on the <code>Point&lt;T, U&gt;</code> struct from Listing 10-8. The method
takes another <code>Point</code> as a parameter, which might have different types from the
<code>self</code> <code>Point</code> we’re calling <code>mixup</code> on. The method creates a new <code>Point</code>
instance with the <code>x</code> value from the <code>self</code> <code>Point</code> (of type <code>T</code>) and the <code>y</code>
value from the passed-in <code>Point</code> (of type <code>W</code>).</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'c'};

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Listing 10-11: A method that uses different generic types
from its struct’s definition</span></p>
<p>In <code>main</code>, we’ve defined a <code>Point</code> that has an <code>i32</code> for <code>x</code> (with value <code>5</code>)
and an <code>f64</code> for <code>y</code> (with value <code>10.4</code>). The <code>p2</code> variable is a <code>Point</code> struct
that has a string slice for <code>x</code> (with value <code>&quot;Hello&quot;</code>) and a <code>char</code> for <code>y</code>
(with value <code>c</code>). Calling <code>mixup</code> on <code>p1</code> with the argument <code>p2</code> gives us <code>p3</code>,
which will have an <code>i32</code> for <code>x</code>, because <code>x</code> came from <code>p1</code>. The <code>p3</code> variable
will have a <code>char</code> for <code>y</code>, because <code>y</code> came from <code>p2</code>. The <code>println!</code> macro
call will print <code>p3.x = 5, p3.y = c</code>.</p>
<p>The purpose of this example is to demonstrate a situation in which some generic
parameters are declared with <code>impl</code> and some are declared with the method
definition. Here, the generic parameters <code>T</code> and <code>U</code> are declared after <code>impl</code>,
because they go with the struct definition. The generic parameters <code>V</code> and <code>W</code>
are declared after <code>fn mixup</code>, because they’re only relevant to the method.</p>
<h3><a class="header" href="#performance-of-code-using-generics" id="performance-of-code-using-generics">Performance of Code Using Generics</a></h3>
<p>You might be wondering whether there is a runtime cost when you’re using
generic type parameters. The good news is that Rust implements generics in such
a way that your code doesn’t run any slower using generic types than it would
with concrete types.</p>
<p>Rust accomplishes this by performing monomorphization of the code that is using
generics at compile time. <em>Monomorphization</em> is the process of turning generic
code into specific code by filling in the concrete types that are used when
compiled.</p>
<p>In this process, the compiler does the opposite of the steps we used to create
the generic function in Listing 10-5: the compiler looks at all the places
where generic code is called and generates code for the concrete types the
generic code is called with.</p>
<p>Let’s look at how this works with an example that uses the standard library’s
<code>Option&lt;T&gt;</code> enum:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>When Rust compiles this code, it performs monomorphization. During that
process, the compiler reads the values that have been used in <code>Option&lt;T&gt;</code>
instances and identifies two kinds of <code>Option&lt;T&gt;</code>: one is <code>i32</code> and the other
is <code>f64</code>. As such, it expands the generic definition of <code>Option&lt;T&gt;</code> into
<code>Option_i32</code> and <code>Option_f64</code>, thereby replacing the generic definition with
the specific ones.</p>
<p>The monomorphized version of the code looks like the following. The generic
<code>Option&lt;T&gt;</code> is replaced with the specific definitions created by the compiler:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Because Rust compiles generic code into code that specifies the type in each
instance, we pay no runtime cost for using generics. When the code runs, it
performs just as it would if we had duplicated each definition by hand. The
process of monomorphization makes Rust’s generics extremely efficient at
runtime.</p>
<h2><a class="header" href="#traits-defining-shared-behavior" id="traits-defining-shared-behavior">Traits: Defining Shared Behavior</a></h2>
<p>A <em>trait</em> tells the Rust compiler about functionality a particular type has and
can share with other types. We can use traits to define shared behavior in an
abstract way. We can use trait bounds to specify that a generic can be any type
that has certain behavior.</p>
<blockquote>
<p>Note: Traits are similar to a feature often called <em>interfaces</em> in other
languages, although with some differences.</p>
</blockquote>
<h3><a class="header" href="#defining-a-trait" id="defining-a-trait">Defining a Trait</a></h3>
<p>A type’s behavior consists of the methods we can call on that type. Different
types share the same behavior if we can call the same methods on all of those
types. Trait definitions are a way to group method signatures together to
define a set of behaviors necessary to accomplish some purpose.</p>
<p>For example, let’s say we have multiple structs that hold various kinds and
amounts of text: a <code>NewsArticle</code> struct that holds a news story filed in a
particular location and a <code>Tweet</code> that can have at most 280 characters along
with metadata that indicates whether it was a new tweet, a retweet, or a reply
to another tweet.</p>
<p>We want to make a media aggregator library that can display summaries of data
that might be stored in a <code>NewsArticle</code> or <code>Tweet</code> instance. To do this, we
need a summary from each type, and we need to request that summary by calling a
<code>summarize</code> method on an instance. Listing 10-12 shows the definition of a
<code>Summary</code> trait that expresses this behavior.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-12: A <code>Summary</code> trait that consists of the
behavior provided by a <code>summarize</code> method</span></p>
<p>Here, we declare a trait using the <code>trait</code> keyword and then the trait’s name,
which is <code>Summary</code> in this case. Inside the curly brackets, we declare the
method signatures that describe the behaviors of the types that implement this
trait, which in this case is <code>fn summarize(&amp;self) -&gt; String</code>.</p>
<p>After the method signature, instead of providing an implementation within curly
brackets, we use a semicolon. Each type implementing this trait must provide
its own custom behavior for the body of the method. The compiler will enforce
that any type that has the <code>Summary</code> trait will have the method <code>summarize</code>
defined with this signature exactly.</p>
<p>A trait can have multiple methods in its body: the method signatures are listed
one per line and each line ends in a semicolon.</p>
<h3><a class="header" href="#implementing-a-trait-on-a-type" id="implementing-a-trait-on-a-type">Implementing a Trait on a Type</a></h3>
<p>Now that we’ve defined the desired behavior using the <code>Summary</code> trait, we can
implement it on the types in our media aggregator. Listing 10-13 shows an
implementation of the <code>Summary</code> trait on the <code>NewsArticle</code> struct that uses the
headline, the author, and the location to create the return value of
<code>summarize</code>. For the <code>Tweet</code> struct, we define <code>summarize</code> as the username
followed by the entire text of the tweet, assuming that tweet content is
already limited to 280 characters.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, by {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-13: Implementing the <code>Summary</code> trait on the
<code>NewsArticle</code> and <code>Tweet</code> types</span></p>
<p>Implementing a trait on a type is similar to implementing regular methods. The
difference is that after <code>impl</code>, we put the trait name that we want to
implement, then use the <code>for</code> keyword, and then specify the name of the type we
want to implement the trait for. Within the <code>impl</code> block, we put the method
signatures that the trait definition has defined. Instead of adding a semicolon
after each signature, we use curly brackets and fill in the method body with
the specific behavior that we want the methods of the trait to have for the
particular type.</p>
<p>After implementing the trait, we can call the methods on instances of
<code>NewsArticle</code> and <code>Tweet</code> in the same way we call regular methods, like this:</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>This code prints <code>1 new tweet: horse_ebooks: of course, as you probably already know, people</code>.</p>
<p>Note that because we defined the <code>Summary</code> trait and the <code>NewsArticle</code> and
<code>Tweet</code> types in the same <em>lib.rs</em> in Listing 10-13, they’re all in the same
scope. Let’s say this <em>lib.rs</em> is for a crate we’ve called <code>aggregator</code> and
someone else wants to use our crate’s functionality to implement the <code>Summary</code>
trait on a struct defined within their library’s scope. They would need to
bring the trait into their scope first. They would do so by specifying <code>use aggregator::Summary;</code>, which then would enable them to implement <code>Summary</code> for
their type. The <code>Summary</code> trait would also need to be a public trait for
another crate to implement it, which it is because we put the <code>pub</code> keyword
before <code>trait</code> in Listing 10-12.</p>
<p>One restriction to note with trait implementations is that we can implement a
trait on a type only if either the trait or the type is local to our crate.
For example, we can implement standard library traits like <code>Display</code> on a
custom type like <code>Tweet</code> as part of our <code>aggregator</code> crate functionality,
because the type <code>Tweet</code> is local to our <code>aggregator</code> crate. We can also
implement <code>Summary</code> on <code>Vec&lt;T&gt;</code> in our <code>aggregator</code> crate, because the
trait <code>Summary</code> is local to our <code>aggregator</code> crate.</p>
<p>But we can’t implement external traits on external types. For example, we can’t
implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our <code>aggregator</code> crate,
because <code>Display</code> and <code>Vec&lt;T&gt;</code> are defined in the standard library and aren’t
local to our <code>aggregator</code> crate. This restriction is part of a property of
programs called <em>coherence</em>, and more specifically the <em>orphan rule</em>, so named
because the parent type is not present. This rule ensures that other people’s
code can’t break your code and vice versa. Without the rule, two crates could
implement the same trait for the same type, and Rust wouldn’t know which
implementation to use.</p>
<h3><a class="header" href="#default-implementations" id="default-implementations">Default Implementations</a></h3>
<p>Sometimes it’s useful to have default behavior for some or all of the methods
in a trait instead of requiring implementations for all methods on every type.
Then, as we implement the trait on a particular type, we can keep or override
each method’s default behavior.</p>
<p>Listing 10-14 shows how to specify a default string for the <code>summarize</code> method
of the <code>Summary</code> trait instead of only defining the method signature, as we did
in Listing 10-12.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-14: Definition of a <code>Summary</code> trait with a
default implementation of the <code>summarize</code> method</span></p>
<p>To use a default implementation to summarize instances of <code>NewsArticle</code> instead
of defining a custom implementation, we specify an empty <code>impl</code> block with
<code>impl Summary for NewsArticle {}</code>.</p>
<p>Even though we’re no longer defining the <code>summarize</code> method on <code>NewsArticle</code>
directly, we’ve provided a default implementation and specified that
<code>NewsArticle</code> implements the <code>Summary</code> trait. As a result, we can still call
the <code>summarize</code> method on an instance of <code>NewsArticle</code>, like this:</p>
<pre><code class="language-rust ignore">let article = NewsArticle {
    headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
    location: String::from(&quot;Pittsburgh, PA, USA&quot;),
    author: String::from(&quot;Iceburgh&quot;),
    content: String::from(&quot;The Pittsburgh Penguins once again are the best
    hockey team in the NHL.&quot;),
};

println!(&quot;New article available! {}&quot;, article.summarize());
</code></pre>
<p>This code prints <code>New article available! (Read more...)</code>.</p>
<p>Creating a default implementation for <code>summarize</code> doesn’t require us to change
anything about the implementation of <code>Summary</code> on <code>Tweet</code> in Listing 10-13. The
reason is that the syntax for overriding a default implementation is the same
as the syntax for implementing a trait method that doesn’t have a default
implementation.</p>
<p>Default implementations can call other methods in the same trait, even if those
other methods don’t have a default implementation. In this way, a trait can
provide a lot of useful functionality and only require implementors to specify
a small part of it. For example, we could define the <code>Summary</code> trait to have a
<code>summarize_author</code> method whose implementation is required, and then define a
<code>summarize</code> method that has a default implementation that calls the
<code>summarize_author</code> method:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Read more from {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>To use this version of <code>Summary</code>, we only need to define <code>summarize_author</code>
when we implement the trait on a type:</p>
<pre><code class="language-rust ignore">impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
</code></pre>
<p>After we define <code>summarize_author</code>, we can call <code>summarize</code> on instances of the
<code>Tweet</code> struct, and the default implementation of <code>summarize</code> will call the
definition of <code>summarize_author</code> that we’ve provided. Because we’ve implemented
<code>summarize_author</code>, the <code>Summary</code> trait has given us the behavior of the
<code>summarize</code> method without requiring us to write any more code.</p>
<pre><code class="language-rust ignore">let tweet = Tweet {
    username: String::from(&quot;horse_ebooks&quot;),
    content: String::from(&quot;of course, as you probably already know, people&quot;),
    reply: false,
    retweet: false,
};

println!(&quot;1 new tweet: {}&quot;, tweet.summarize());
</code></pre>
<p>This code prints <code>1 new tweet: (Read more from @horse_ebooks...)</code>.</p>
<p>Note that it isn’t possible to call the default implementation from an
overriding implementation of that same method.</p>
<h3><a class="header" href="#traits-as-parameters" id="traits-as-parameters">Traits as Parameters</a></h3>
<p>Now that you know how to define and implement traits, we can explore how to use
traits to define functions that accept many different types.</p>
<p>For example, in Listing 10-13, we implemented the <code>Summary</code> trait on the
<code>NewsArticle</code> and <code>Tweet</code> types. We can define a <code>notify</code> function that calls
the <code>summarize</code> method on its <code>item</code> parameter, which is of some type that
implements the <code>Summary</code> trait. To do this, we can use the <code>impl Trait</code>
syntax, like this:</p>
<pre><code class="language-rust ignore">pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>Instead of a concrete type for the <code>item</code> parameter, we specify the <code>impl</code>
keyword and the trait name. This parameter accepts any type that implements the
specified trait. In the body of <code>notify</code>, we can call any methods on <code>item</code>
that come from the <code>Summary</code> trait, such as <code>summarize</code>. We can call <code>notify</code>
and pass in any instance of <code>NewsArticle</code> or <code>Tweet</code>. Code that calls the
function with any other type, such as a <code>String</code> or an <code>i32</code>, won’t compile
because those types don’t implement <code>Summary</code>.</p>
<h4><a class="header" href="#trait-bound-syntax" id="trait-bound-syntax">Trait Bound Syntax</a></h4>
<p>The <code>impl Trait</code> syntax works for straightforward cases but is actually
syntax sugar for a longer form, which is called a <em>trait bound</em>; it looks like
this:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
</code></pre>
<p>This longer form is equivalent to the example in the previous section but is
more verbose. We place trait bounds with the declaration of the generic type
parameter after a colon and inside angle brackets.</p>
<p>The <code>impl Trait</code> syntax is convenient and makes for more concise code in simple
cases. The trait bound syntax can express more complexity in other cases. For
example, we can have two parameters that implement <code>Summary</code>. Using the <code>impl Trait</code> syntax looks like this:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: impl Summary, item2: impl Summary) {
</code></pre>
<p>If we wanted this function to allow <code>item1</code> and <code>item2</code> to have different
types, using <code>impl Trait</code> would be appropriate (as long as both types implement
<code>Summary</code>). If we wanted to force both parameters to have the same type, that’s
only possible to express using a trait bound, like this:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: T, item2: T) {
</code></pre>
<p>The generic type <code>T</code> specified as the type of the <code>item1</code> and <code>item2</code>
parameters constrains the function such that the concrete type of the value
passed as an argument for <code>item1</code> and <code>item2</code> must be the same.</p>
<h4><a class="header" href="#specifying-multiple-trait-bounds-with-the--syntax" id="specifying-multiple-trait-bounds-with-the--syntax">Specifying Multiple Trait Bounds with the <code>+</code> Syntax</a></h4>
<p>We can also specify more than one trait bound. Say we wanted <code>notify</code> to use
display formatting on <code>item</code> as well as the <code>summarize</code> method: we specify in
the <code>notify</code> definition that <code>item</code> must implement both <code>Display</code> and
<code>Summary</code>. We can do so using the <code>+</code> syntax:</p>
<pre><code class="language-rust ignore">pub fn notify(item: impl Summary + Display) {
</code></pre>
<p>The <code>+</code> syntax is also valid with trait bounds on generic types:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: T) {
</code></pre>
<p>With the two trait bounds specified, the body of <code>notify</code> can call <code>summarize</code>
and use <code>{}</code> to format <code>item</code>.</p>
<h4><a class="header" href="#clearer-trait-bounds-with-where-clauses" id="clearer-trait-bounds-with-where-clauses">Clearer Trait Bounds with <code>where</code> Clauses</a></h4>
<p>Using too many trait bounds has its downsides. Each generic has its own trait
bounds, so functions with multiple generic type parameters can contain lots of
trait bound information between the function’s name and its parameter list,
making the function signature hard to read. For this reason, Rust has alternate
syntax for specifying trait bounds inside a <code>where</code> clause after the function
signature. So instead of writing this:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {
</code></pre>
<p>we can use a <code>where</code> clause, like this:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>This function’s signature is less cluttered: the function name, parameter list,
and return type are close together, similar to a function without lots of trait
bounds.</p>
<h3><a class="header" href="#returning-types-that-implement-traits" id="returning-types-that-implement-traits">Returning Types that Implement Traits</a></h3>
<p>We can also use the <code>impl Trait</code> syntax in the return position to return a
value of some type that implements a trait, as shown here:</p>
<pre><code class="language-rust ignore">fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;of course, as you probably already know, people&quot;),
        reply: false,
        retweet: false,
    }
}
</code></pre>
<p>By using <code>impl Summary</code> for the return type, we specify that the
<code>returns_summarizable</code> function returns some type that implements the <code>Summary</code>
trait without naming the concrete type. In this case, <code>returns_summarizable</code>
returns a <code>Tweet</code>, but the code calling this function doesn’t know that.</p>
<p>The ability to return a type that is only specified by the trait it implements
is especially useful in the context of closures and iterators, which we cover
in Chapter 13. Closures and iterators create types that only the compiler knows
or types that are very long to specify. The <code>impl Trait</code> syntax lets you
concisely specify that a function returns some type that implements the
<code>Iterator</code> trait without needing to write out a very long type.</p>
<p>However, you can only use <code>impl Trait</code> if you’re returning a single type. For
example, this code that returns either a <code>NewsArticle</code> or a <code>Tweet</code> with the
return type specified as <code>impl Summary</code> wouldn’t work:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(&quot;The Pittsburgh Penguins once again are the best
            hockey team in the NHL.&quot;),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(&quot;of course, as you probably already know, people&quot;),
            reply: false,
            retweet: false,
        }
    }
}
</code></pre>
<p>Returning either a <code>NewsArticle</code> or a <code>Tweet</code> isn’t allowed due to restrictions
around how the <code>impl Trait</code> syntax is implemented in the compiler. We’ll cover
how to write a function with this behavior in the <a href="rustbook/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects That
Allow for Values of Different
Types”</a><!--
ignore --> section of Chapter 17.</p>
<h3><a class="header" href="#fixing-the-largest-function-with-trait-bounds" id="fixing-the-largest-function-with-trait-bounds">Fixing the <code>largest</code> Function with Trait Bounds</a></h3>
<p>Now that you know how to specify the behavior you want to use using the generic
type parameter’s bounds, let’s return to Listing 10-5 to fix the definition of
the <code>largest</code> function that uses a generic type parameter! Last time we tried
to run that code, we received this error:</p>
<pre><code class="language-text">error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:12
  |
5 |         if item &gt; largest {
  |            ^^^^^^^^^^^^^^
  |
  = note: an implementation of `std::cmp::PartialOrd` might be missing for `T`
</code></pre>
<p>In the body of <code>largest</code> we wanted to compare two values of type <code>T</code> using the
greater than (<code>&gt;</code>) operator. Because that operator is defined as a default
method on the standard library trait <code>std::cmp::PartialOrd</code>, we need to specify
<code>PartialOrd</code> in the trait bounds for <code>T</code> so the <code>largest</code> function can work on
slices of any type that we can compare. We don’t need to bring <code>PartialOrd</code>
into scope because it’s in the prelude. Change the signature of <code>largest</code> to
look like this:</p>
<pre><code class="language-rust ignore">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>This time when we compile the code, we get a different set of errors:</p>
<pre><code class="language-text">error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       help: consider using a reference instead: `&amp;list[0]`

error[E0507]: cannot move out of borrowed content
 --&gt; src/main.rs:4:9
  |
4 |     for &amp;item in list.iter() {
  |         ^----
  |         ||
  |         |hint: to prevent move, use `ref item` or `ref mut item`
  |         cannot move out of borrowed content
</code></pre>
<p>The key line in this error is <code>cannot move out of type [T], a non-copy slice</code>.
With our non-generic versions of the <code>largest</code> function, we were only trying to
find the largest <code>i32</code> or <code>char</code>. As discussed in the <a href="rustbook/ch04-01-what-is-ownership.html#stack-only-data-copy">“Stack-Only Data:
Copy”</a><!-- ignore --> section in Chapter 4, types like
<code>i32</code> and <code>char</code> that have a known size can be stored on the stack, so they
implement the <code>Copy</code> trait. But when we made the <code>largest</code> function generic,
it became possible for the <code>list</code> parameter to have types in it that don’t
implement the <code>Copy</code> trait. Consequently, we wouldn’t be able to move the
value out of <code>list[0]</code> and into the <code>largest</code> variable, resulting in this
error.</p>
<p>To call this code with only those types that implement the <code>Copy</code> trait, we can
add <code>Copy</code> to the trait bounds of <code>T</code>! Listing 10-15 shows the complete code of
a generic <code>largest</code> function that will compile as long as the types of the
values in the slice that we pass into the function implement the <code>PartialOrd</code>
<em>and</em> <code>Copy</code> traits, like <code>i32</code> and <code>char</code> do.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list.iter() {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;The largest number is {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;The largest char is {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Listing 10-15: A working definition of the <code>largest</code>
function that works on any generic type that implements the <code>PartialOrd</code> and
<code>Copy</code> traits</span></p>
<p>If we don’t want to restrict the <code>largest</code> function to the types that implement
the <code>Copy</code> trait, we could specify that <code>T</code> has the trait bound <code>Clone</code> instead
of <code>Copy</code>. Then we could clone each value in the slice when we want the
<code>largest</code> function to have ownership. Using the <code>clone</code> function means we’re
potentially making more heap allocations in the case of types that own heap
data like <code>String</code>, and heap allocations can be slow if we’re working with
large amounts of data.</p>
<p>Another way we could implement <code>largest</code> is for the function to return a
reference to a <code>T</code> value in the slice. If we change the return type to <code>&amp;T</code>
instead of <code>T</code>, thereby changing the body of the function to return a
reference, we wouldn’t need the <code>Clone</code> or <code>Copy</code> trait bounds and we could
avoid heap allocations. Try implementing these alternate solutions on your own!</p>
<h3><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods" id="using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods</a></h3>
<p>By using a trait bound with an <code>impl</code> block that uses generic type parameters,
we can implement methods conditionally for types that implement the specified
traits. For example, the type <code>Pair&lt;T&gt;</code> in Listing 10-16 always implements the
<code>new</code> function. But <code>Pair&lt;T&gt;</code> only implements the <code>cmp_display</code> method if its
inner type <code>T</code> implements the <code>PartialOrd</code> trait that enables comparison <em>and</em>
the <code>Display</code> trait that enables printing.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-16: Conditionally implement methods on a
generic type depending on trait bounds</span></p>
<p>We can also conditionally implement a trait for any type that implements
another trait. Implementations of a trait on any type that satisfies the trait
bounds are called <em>blanket implementations</em> and are extensively used in the
Rust standard library. For example, the standard library implements the
<code>ToString</code> trait on any type that implements the <code>Display</code> trait. The <code>impl</code>
block in the standard library looks similar to this code:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
</code></pre>
<p>Because the standard library has this blanket implementation, we can call the
<code>to_string</code> method defined by the <code>ToString</code> trait on any type that implements
the <code>Display</code> trait. For example, we can turn integers into their corresponding
<code>String</code> values like this because integers implement <code>Display</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>Blanket implementations appear in the documentation for the trait in the
“Implementors” section.</p>
<p>Traits and trait bounds let us write code that uses generic type parameters to
reduce duplication but also specify to the compiler that we want the generic
type to have particular behavior. The compiler can then use the trait bound
information to check that all the concrete types used with our code provide the
correct behavior. In dynamically typed languages, we would get an error at
runtime if we called a method on a type that the type didn’t implement. But
Rust moves these errors to compile time so we’re forced to fix the problems
before our code is even able to run. Additionally, we don’t have to write code
that checks for behavior at runtime because we’ve already checked at compile
time. Doing so improves performance without having to give up the flexibility
of generics.</p>
<p>Another kind of generic that we’ve already been using is called <em>lifetimes</em>.
Rather than ensuring that a type has the behavior we want, lifetimes ensure
that references are valid as long as we need them to be. Let’s look at how
lifetimes do that.</p>
<h2><a class="header" href="#validating-references-with-lifetimes" id="validating-references-with-lifetimes">Validating References with Lifetimes</a></h2>
<p>One detail we didn’t discuss in the <a href="rustbook/ch04-02-references-and-borrowing.html#references-and-borrowing">“References and
Borrowing”</a><!-- ignore --> section in Chapter 4 is
that every reference in Rust has a <em>lifetime</em>, which is the scope for which
that reference is valid. Most of the time, lifetimes are implicit and
inferred, just like most of the time, types are inferred. We must annotate
types when multiple types are possible. In a similar way, we must annotate
lifetimes when the lifetimes of references could be related in a few different
ways. Rust requires us to annotate the relationships using generic lifetime
parameters to ensure the actual references used at runtime will definitely be
valid.</p>
<p>The concept of lifetimes is somewhat different from tools in other programming
languages, arguably making lifetimes Rust’s most distinctive feature. Although
we won’t cover lifetimes in their entirety in this chapter, we’ll discuss
common ways you might encounter lifetime syntax so you can become familiar with
the concepts.</p>
<h3><a class="header" href="#preventing-dangling-references-with-lifetimes" id="preventing-dangling-references-with-lifetimes">Preventing Dangling References with Lifetimes</a></h3>
<p>The main aim of lifetimes is to prevent dangling references, which cause a
program to reference data other than the data it’s intended to reference.
Consider the program in Listing 10-17, which has an outer scope and an inner
scope.</p>
<pre><code class="language-rust ignore does_not_compile">{
    let r;

    {
        let x = 5;
        r = &amp;x;
    }

    println!(&quot;r: {}&quot;, r);
}
</code></pre>
<p><span class="caption">Listing 10-17: An attempt to use a reference whose value
has gone out of scope</span></p>
<blockquote>
<p>Note: The examples in Listings 10-17, 10-18, and 10-24 declare variables
without giving them an initial value, so the variable name exists in the
outer scope. At first glance, this might appear to be in conflict with Rust’s
having no null values. However, if we try to use a variable before giving it
a value, we’ll get a compile-time error, which shows that Rust indeed does
not allow null values.</p>
</blockquote>
<p>The outer scope declares a variable named <code>r</code> with no initial value, and the
inner scope declares a variable named <code>x</code> with the initial value of 5. Inside
the inner scope, we attempt to set the value of <code>r</code> as a reference to <code>x</code>. Then
the inner scope ends, and we attempt to print the value in <code>r</code>. This code won’t
compile because the value <code>r</code> is referring to has gone out of scope before we
try to use it. Here is the error message:</p>
<pre><code class="language-text">error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:5
   |
6  |         r = &amp;x;
   |              - borrow occurs here
7  |     }
   |     ^ `x` dropped here while still borrowed
...
10 | }
   | - borrowed value needs to live until here
</code></pre>
<p>The variable <code>x</code> doesn’t “live long enough.” The reason is that <code>x</code> will be out
of scope when the inner scope ends on line 7. But <code>r</code> is still valid for the
outer scope; because its scope is larger, we say that it “lives longer.” If
Rust allowed this code to work, <code>r</code> would be referencing memory that was
deallocated when <code>x</code> went out of scope, and anything we tried to do with <code>r</code>
wouldn’t work correctly. So how does Rust determine that this code is invalid?
It uses a borrow checker.</p>
<h3><a class="header" href="#the-borrow-checker" id="the-borrow-checker">The Borrow Checker</a></h3>
<p>The Rust compiler has a <em>borrow checker</em> that compares scopes to determine
whether all borrows are valid. Listing 10-18 shows the same code as Listing
10-17 but with annotations showing the lifetimes of the variables.</p>
<pre><code class="language-rust ignore does_not_compile">{
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &amp;x;           //  |       |
    }                     // -+       |
                          //          |
    println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre>
<p><span class="caption">Listing 10-18: Annotations of the lifetimes of <code>r</code> and
<code>x</code>, named <code>'a</code> and <code>'b</code>, respectively</span></p>
<p>Here, we’ve annotated the lifetime of <code>r</code> with <code>'a</code> and the lifetime of <code>x</code>
with <code>'b</code>. As you can see, the inner <code>'b</code> block is much smaller than the outer
<code>'a</code> lifetime block. At compile time, Rust compares the size of the two
lifetimes and sees that <code>r</code> has a lifetime of <code>'a</code> but that it refers to memory
with a lifetime of <code>'b</code>. The program is rejected because <code>'b</code> is shorter than
<code>'a</code>: the subject of the reference doesn’t live as long as the reference.</p>
<p>Listing 10-19 fixes the code so it doesn’t have a dangling reference and
compiles without any errors.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &amp;x;           // --+-- 'a  |
                          //   |       |
    println!(&quot;r: {}&quot;, r); //   |       |
                          // --+       |
}                         // ----------+
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-19: A valid reference because the data has a
longer lifetime than the reference</span></p>
<p>Here, <code>x</code> has the lifetime <code>'b</code>, which in this case is larger than <code>'a</code>. This
means <code>r</code> can reference <code>x</code> because Rust knows that the reference in <code>r</code> will
always be valid while <code>x</code> is valid.</p>
<p>Now that you know where the lifetimes of references are and how Rust analyzes
lifetimes to ensure references will always be valid, let’s explore generic
lifetimes of parameters and return values in the context of functions.</p>
<h3><a class="header" href="#generic-lifetimes-in-functions" id="generic-lifetimes-in-functions">Generic Lifetimes in Functions</a></h3>
<p>Let’s write a function that returns the longer of two string slices. This
function will take two string slices and return a string slice. After we’ve
implemented the <code>longest</code> function, the code in Listing 10-20 should print <code>The longest string is abcd</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-20: A <code>main</code> function that calls the <code>longest</code>
function to find the longer of two string slices</span></p>
<p>Note that we want the function to take string slices, which are references,
because we don’t want the <code>longest</code> function to take ownership of its
parameters. We want to allow the function to accept slices of a <code>String</code> (the
type stored in the variable <code>string1</code>) as well as string literals (which is
what variable <code>string2</code> contains).</p>
<p>Refer to the <a href="rustbook/ch04-03-slices.html#string-slices-as-parameters">“String Slices as Parameters”</a><!--
ignore --> section in Chapter 4 for more discussion about why the parameters we
use in Listing 10-20 are the ones we want.</p>
<p>If we try to implement the <code>longest</code> function as shown in Listing 10-21, it
won’t compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre>
<p><span class="caption">Listing 10-21: An implementation of the <code>longest</code>
function that returns the longer of two string slices but does not yet
compile</span></p>
<p>Instead, we get the following error that talks about lifetimes:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:1:33
  |
1 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the
signature does not say whether it is borrowed from `x` or `y`
</code></pre>
<p>The help text reveals that the return type needs a generic lifetime parameter
on it because Rust can’t tell whether the reference being returned refers to
<code>x</code> or <code>y</code>. Actually, we don’t know either, because the <code>if</code> block in the body
of this function returns a reference to <code>x</code> and the <code>else</code> block returns a
reference to <code>y</code>!</p>
<p>When we’re defining this function, we don’t know the concrete values that will
be passed into this function, so we don’t know whether the <code>if</code> case or the
<code>else</code> case will execute. We also don’t know the concrete lifetimes of the
references that will be passed in, so we can’t look at the scopes as we did in
Listings 10-18 and 10-19 to determine whether the reference we return will
always be valid. The borrow checker can’t determine this either, because it
doesn’t know how the lifetimes of <code>x</code> and <code>y</code> relate to the lifetime of the
return value. To fix this error, we’ll add generic lifetime parameters that
define the relationship between the references so the borrow checker can
perform its analysis.</p>
<h3><a class="header" href="#lifetime-annotation-syntax" id="lifetime-annotation-syntax">Lifetime Annotation Syntax</a></h3>
<p>Lifetime annotations don’t change how long any of the references live. Just
as functions can accept any type when the signature specifies a generic type
parameter, functions can accept references with any lifetime by specifying a
generic lifetime parameter. Lifetime annotations describe the relationships of
the lifetimes of multiple references to each other without affecting the
lifetimes.</p>
<p>Lifetime annotations have a slightly unusual syntax: the names of lifetime
parameters must start with an apostrophe (<code>'</code>) and are usually all lowercase and
very short, like generic types. Most people use the name <code>'a</code>. We place
lifetime parameter annotations after the <code>&amp;</code> of a reference, using a space to
separate the annotation from the reference’s type.</p>
<p>Here are some examples: a reference to an <code>i32</code> without a lifetime parameter, a
reference to an <code>i32</code> that has a lifetime parameter named <code>'a</code>, and a mutable
reference to an <code>i32</code> that also has the lifetime <code>'a</code>.</p>
<pre><code class="language-rust ignore">&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
</code></pre>
<p>One lifetime annotation by itself doesn’t have much meaning, because the
annotations are meant to tell Rust how generic lifetime parameters of multiple
references relate to each other. For example, let’s say we have a function with
the parameter <code>first</code> that is a reference to an <code>i32</code> with lifetime <code>'a</code>. The
function also has another parameter named <code>second</code> that is another reference to
an <code>i32</code> that also has the lifetime <code>'a</code>. The lifetime annotations indicate
that the references <code>first</code> and <code>second</code> must both live as long as that generic
lifetime.</p>
<h3><a class="header" href="#lifetime-annotations-in-function-signatures" id="lifetime-annotations-in-function-signatures">Lifetime Annotations in Function Signatures</a></h3>
<p>Now let’s examine lifetime annotations in the context of the <code>longest</code>
function. As with generic type parameters, we need to declare generic lifetime
parameters inside angle brackets between the function name and the parameter
list. The constraint we want to express in this signature is that all the
references in the parameters and the return value must have the same lifetime.
We’ll name the lifetime <code>'a</code> and then add it to each reference, as shown in
Listing 10-22.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-22: The <code>longest</code> function definition
specifying that all the references in the signature must have the same lifetime
<code>'a</code></span></p>
<p>This code should compile and produce the result we want when we use it with the
<code>main</code> function in Listing 10-20.</p>
<p>The function signature now tells Rust that for some lifetime <code>'a</code>, the function
takes two parameters, both of which are string slices that live at least as
long as lifetime <code>'a</code>. The function signature also tells Rust that the string
slice returned from the function will live at least as long as lifetime <code>'a</code>.
In practice, it means that the lifetime of the reference returned by the
<code>longest</code> function is the same as the smaller of the lifetimes of the
references passed in. These constraints are what we want Rust to enforce.
Remember, when we specify the lifetime parameters in this function signature,
we’re not changing the lifetimes of any values passed in or returned. Rather,
we’re specifying that the borrow checker should reject any values that don’t
adhere to these constraints. Note that the <code>longest</code> function doesn’t need to
know exactly how long <code>x</code> and <code>y</code> will live, only that some scope can be
substituted for <code>'a</code> that will satisfy this signature.</p>
<p>When annotating lifetimes in functions, the annotations go in the function
signature, not in the function body. Rust can analyze the code within the
function without any help. However, when a function has references to or from
code outside that function, it becomes almost impossible for Rust to figure out
the lifetimes of the parameters or return values on its own. The lifetimes
might be different each time the function is called. This is why we need to
annotate the lifetimes manually.</p>
<p>When we pass concrete references to <code>longest</code>, the concrete lifetime that is
substituted for <code>'a</code> is the part of the scope of <code>x</code> that overlaps with the
scope of <code>y</code>. In other words, the generic lifetime <code>'a</code> will get the concrete
lifetime that is equal to the smaller of the lifetimes of <code>x</code> and <code>y</code>. Because
we’ve annotated the returned reference with the same lifetime parameter <code>'a</code>,
the returned reference will also be valid for the length of the smaller of the
lifetimes of <code>x</code> and <code>y</code>.</p>
<p>Let’s look at how the lifetime annotations restrict the <code>longest</code> function by
passing in references that have different concrete lifetimes. Listing 10-23 is
a straightforward example.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let string1 = String::from(&quot;long string is long&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;The longest string is {}&quot;, result);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 10-23: Using the <code>longest</code> function with
references to <code>String</code> values that have different concrete lifetimes</span></p>
<p>In this example, <code>string1</code> is valid until the end of the outer scope, <code>string2</code>
is valid until the end of the inner scope, and <code>result</code> references something
that is valid until the end of the inner scope. Run this code, and you’ll see
that the borrow checker approves of this code; it will compile and print <code>The longest string is long string is long</code>.</p>
<p>Next, let’s try an example that shows that the lifetime of the reference in
<code>result</code> must be the smaller lifetime of the two arguments. We’ll move the
declaration of the <code>result</code> variable outside the inner scope but leave the
assignment of the value to the <code>result</code> variable inside the scope with
<code>string2</code>. Then we’ll move the <code>println!</code> that uses <code>result</code> outside the inner
scope, after the inner scope has ended. The code in Listing 10-24 will not
compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let string1 = String::from(&quot;long string is long&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;The longest string is {}&quot;, result);
}
</code></pre>
<p><span class="caption">Listing 10-24: Attempting to use <code>result</code> after <code>string2</code>
has gone out of scope</span></p>
<p>When we try to compile this code, we’ll get this error:</p>
<pre><code class="language-text">error[E0597]: `string2` does not live long enough
  --&gt; src/main.rs:15:5
   |
14 |         result = longest(string1.as_str(), string2.as_str());
   |                                            ------- borrow occurs here
15 |     }
   |     ^ `string2` dropped here while still borrowed
16 |     println!(&quot;The longest string is {}&quot;, result);
17 | }
   | - borrowed value needs to live until here
</code></pre>
<p>The error shows that for <code>result</code> to be valid for the <code>println!</code> statement,
<code>string2</code> would need to be valid until the end of the outer scope. Rust knows
this because we annotated the lifetimes of the function parameters and return
values using the same lifetime parameter <code>'a</code>.</p>
<p>As humans, we can look at this code and see that <code>string1</code> is longer than
<code>string2</code> and therefore <code>result</code> will contain a reference to <code>string1</code>.
Because <code>string1</code> has not gone out of scope yet, a reference to <code>string1</code> will
still be valid for the <code>println!</code> statement. However, the compiler can’t see
that the reference is valid in this case. We’ve told Rust that the lifetime of
the reference returned by the <code>longest</code> function is the same as the smaller of
the lifetimes of the references passed in. Therefore, the borrow checker
disallows the code in Listing 10-24 as possibly having an invalid reference.</p>
<p>Try designing more experiments that vary the values and lifetimes of the
references passed in to the <code>longest</code> function and how the returned reference
is used. Make hypotheses about whether or not your experiments will pass the
borrow checker before you compile; then check to see if you’re right!</p>
<h3><a class="header" href="#thinking-in-terms-of-lifetimes" id="thinking-in-terms-of-lifetimes">Thinking in Terms of Lifetimes</a></h3>
<p>The way in which you need to specify lifetime parameters depends on what your
function is doing. For example, if we changed the implementation of the
<code>longest</code> function to always return the first parameter rather than the longest
string slice, we wouldn’t need to specify a lifetime on the <code>y</code> parameter. The
following code will compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example, we’ve specified a lifetime parameter <code>'a</code> for the parameter
<code>x</code> and the return type, but not for the parameter <code>y</code>, because the lifetime of
<code>y</code> does not have any relationship with the lifetime of <code>x</code> or the return value.</p>
<p>When returning a reference from a function, the lifetime parameter for the
return type needs to match the lifetime parameter for one of the parameters. If
the reference returned does <em>not</em> refer to one of the parameters, it must refer
to a value created within this function, which would be a dangling reference
because the value will go out of scope at the end of the function. Consider
this attempted implementation of the <code>longest</code> function that won’t compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;really long string&quot;);
    result.as_str()
}
</code></pre>
<p>Here, even though we’ve specified a lifetime parameter <code>'a</code> for the return
type, this implementation will fail to compile because the return value
lifetime is not related to the lifetime of the parameters at all. Here is the
error message we get:</p>
<pre><code class="language-text">error[E0597]: `result` does not live long enough
 --&gt; src/main.rs:3:5
  |
3 |     result.as_str()
  |     ^^^^^^ does not live long enough
4 | }
  | - borrowed value only lives until here
  |
note: borrowed value must be valid for the lifetime 'a as defined on the
function body at 1:1...
 --&gt; src/main.rs:1:1
  |
1 | / fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
2 | |     let result = String::from(&quot;really long string&quot;);
3 | |     result.as_str()
4 | | }
  | |_^
</code></pre>
<p>The problem is that <code>result</code> goes out of scope and gets cleaned up at the end
of the <code>longest</code> function. We’re also trying to return a reference to <code>result</code>
from the function. There is no way we can specify lifetime parameters that
would change the dangling reference, and Rust won’t let us create a dangling
reference. In this case, the best fix would be to return an owned data type
rather than a reference so the calling function is then responsible for
cleaning up the value.</p>
<p>Ultimately, lifetime syntax is about connecting the lifetimes of various
parameters and return values of functions. Once they’re connected, Rust has
enough information to allow memory-safe operations and disallow operations that
would create dangling pointers or otherwise violate memory safety.</p>
<h3><a class="header" href="#lifetime-annotations-in-struct-definitions" id="lifetime-annotations-in-struct-definitions">Lifetime Annotations in Struct Definitions</a></h3>
<p>So far, we’ve only defined structs to hold owned types. It’s possible for
structs to hold references, but in that case we would need to add a lifetime
annotation on every reference in the struct’s definition. Listing 10-25 has a
struct named <code>ImportantExcerpt</code> that holds a string slice.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Call me Ishmael. Some years ago...&quot;);
    let first_sentence = novel.split('.')
        .next()
        .expect(&quot;Could not find a '.'&quot;);
    let i = ImportantExcerpt { part: first_sentence };
}
</code></pre></pre>
<p><span class="caption">Listing 10-25: A struct that holds a reference, so its
definition needs a lifetime annotation</span></p>
<p>This struct has one field, <code>part</code>, that holds a string slice, which is a
reference. As with generic data types, we declare the name of the generic
lifetime parameter inside angle brackets after the name of the struct so we can
use the lifetime parameter in the body of the struct definition. This
annotation means an instance of <code>ImportantExcerpt</code> can’t outlive the reference
it holds in its <code>part</code> field.</p>
<p>The <code>main</code> function here creates an instance of the <code>ImportantExcerpt</code> struct
that holds a reference to the first sentence of the <code>String</code> owned by the
variable <code>novel</code>. The data in <code>novel</code> exists before the <code>ImportantExcerpt</code>
instance is created. In addition, <code>novel</code> doesn’t go out of scope until after
the <code>ImportantExcerpt</code> goes out of scope, so the reference in the
<code>ImportantExcerpt</code> instance is valid.</p>
<h3><a class="header" href="#lifetime-elision" id="lifetime-elision">Lifetime Elision</a></h3>
<p>You’ve learned that every reference has a lifetime and that you need to specify
lifetime parameters for functions or structs that use references. However, in
Chapter 4 we had a function in Listing 4-9, which is shown again in Listing
10-26, that compiled without lifetime annotations.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 10-26: A function we defined in Listing 4-9 that
compiled without lifetime annotations, even though the parameter and return
type are references</span></p>
<p>The reason this function compiles without lifetime annotations is historical:
in early versions (pre-1.0) of Rust, this code wouldn’t have compiled because
every reference needed an explicit lifetime. At that time, the function
signature would have been written like this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>After writing a lot of Rust code, the Rust team found that Rust programmers
were entering the same lifetime annotations over and over in particular
situations. These situations were predictable and followed a few deterministic
patterns. The developers programmed these patterns into the compiler’s code so
the borrow checker could infer the lifetimes in these situations and wouldn’t
need explicit annotations.</p>
<p>This piece of Rust history is relevant because it’s possible that more
deterministic patterns will emerge and be added to the compiler. In the future,
even fewer lifetime annotations might be required.</p>
<p>The patterns programmed into Rust’s analysis of references are called the
<em>lifetime elision rules</em>. These aren’t rules for programmers to follow; they’re
a set of particular cases that the compiler will consider, and if your code
fits these cases, you don’t need to write the lifetimes explicitly.</p>
<p>The elision rules don’t provide full inference. If Rust deterministically
applies the rules but there is still ambiguity as to what lifetimes the
references have, the compiler won’t guess what the lifetime of the remaining
references should be. In this case, instead of guessing, the compiler will give
you an error that you can resolve by adding the lifetime annotations that
specify how the references relate to each other.</p>
<p>Lifetimes on function or method parameters are called <em>input lifetimes</em>, and
lifetimes on return values are called <em>output lifetimes</em>.</p>
<p>The compiler uses three rules to figure out what lifetimes references have when
there aren’t explicit annotations. The first rule applies to input lifetimes,
and the second and third rules apply to output lifetimes. If the compiler gets
to the end of the three rules and there are still references for which it can’t
figure out lifetimes, the compiler will stop with an error. These rules apply
to <code>fn</code> definitions as well as <code>impl</code> blocks.</p>
<p>The first rule is that each parameter that is a reference gets its own lifetime
parameter. In other words, a function with one parameter gets one lifetime
parameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>; a function with two parameters gets two
separate lifetime parameters: <code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; and so
on.</p>
<p>The second rule is if there is exactly one input lifetime parameter, that
lifetime is assigned to all output lifetime parameters: <code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>The third rule is if there are multiple input lifetime parameters, but one of
them is <code>&amp;self</code> or <code>&amp;mut self</code> because this is a method, the lifetime of <code>self</code>
is assigned to all output lifetime parameters. This third rule makes methods
much nicer to read and write because fewer symbols are necessary.</p>
<p>Let’s pretend we’re the compiler. We’ll apply these rules to figure out what
the lifetimes of the references in the signature of the <code>first_word</code> function
in Listing 10-26 are. The signature starts without any lifetimes associated
with the references:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Then the compiler applies the first rule, which specifies that each parameter
gets its own lifetime. We’ll call it <code>'a</code> as usual, so now the signature is
this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>The second rule applies because there is exactly one input lifetime. The second
rule specifies that the lifetime of the one input parameter gets assigned to
the output lifetime, so the signature is now this:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Now all the references in this function signature have lifetimes, and the
compiler can continue its analysis without needing the programmer to annotate
the lifetimes in this function signature.</p>
<p>Let’s look at another example, this time using the <code>longest</code> function that had
no lifetime parameters when we started working with it in Listing 10-21:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Let’s apply the first rule: each parameter gets its own lifetime. This time we
have two parameters instead of one, so we have two lifetimes:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>You can see that the second rule doesn’t apply because there is more than one
input lifetime. The third rule doesn’t apply either, because <code>longest</code> is a
function rather than a method, so none of the parameters are <code>self</code>. After
working through all three rules, we still haven’t figured out what the return
type’s lifetime is. This is why we got an error trying to compile the code in
Listing 10-21: the compiler worked through the lifetime elision rules but still
couldn’t figure out all the lifetimes of the references in the signature.</p>
<p>Because the third rule really only applies in method signatures, we’ll look at
lifetimes in that context next to see why the third rule means we don’t have to
annotate lifetimes in method signatures very often.</p>
<h3><a class="header" href="#lifetime-annotations-in-method-definitions" id="lifetime-annotations-in-method-definitions">Lifetime Annotations in Method Definitions</a></h3>
<p>When we implement methods on a struct with lifetimes, we use the same syntax as
that of generic type parameters shown in Listing 10-11. Where we declare and
use the lifetime parameters depends on whether they’re related to the struct
fields or the method parameters and return values.</p>
<p>Lifetime names for struct fields always need to be declared after the <code>impl</code>
keyword and then used after the struct’s name, because those lifetimes are part
of the struct’s type.</p>
<p>In method signatures inside the <code>impl</code> block, references might be tied to the
lifetime of references in the struct’s fields, or they might be independent. In
addition, the lifetime elision rules often make it so that lifetime annotations
aren’t necessary in method signatures. Let’s look at some examples using the
struct named <code>ImportantExcerpt</code> that we defined in Listing 10-25.</p>
<p>First, we’ll use a method named <code>level</code> whose only parameter is a reference to
<code>self</code> and whose return value is an <code>i32</code>, which is not a reference to anything:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The lifetime parameter declaration after <code>impl</code> and its use after the type name
are required, but we’re not required to annotate the lifetime of the reference
to <code>self</code> because of the first elision rule.</p>
<p>Here is an example where the third lifetime elision rule applies:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Attention please: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>There are two input lifetimes, so Rust applies the first lifetime elision rule
and gives both <code>&amp;self</code> and <code>announcement</code> their own lifetimes. Then, because
one of the parameters is <code>&amp;self</code>, the return type gets the lifetime of <code>&amp;self</code>,
and all lifetimes have been accounted for.</p>
<h3><a class="header" href="#the-static-lifetime" id="the-static-lifetime">The Static Lifetime</a></h3>
<p>One special lifetime we need to discuss is <code>'static</code>, which means that this
reference <em>can</em> live for the entire duration of the program. All string
literals have the <code>'static</code> lifetime, which we can annotate as follows:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>The text of this string is stored directly in the program’s binary, which
is always available. Therefore, the lifetime of all string literals is
<code>'static</code>.</p>
<p>You might see suggestions to use the <code>'static</code> lifetime in error messages. But
before specifying <code>'static</code> as the lifetime for a reference, think about
whether the reference you have actually lives the entire lifetime of your
program or not. You might consider whether you want it to live that long, even
if it could. Most of the time, the problem results from attempting to create a
dangling reference or a mismatch of the available lifetimes. In such cases, the
solution is fixing those problems, not specifying the <code>'static</code> lifetime.</p>
<h2><a class="header" href="#generic-type-parameters-trait-bounds-and-lifetimes-together" id="generic-type-parameters-trait-bounds-and-lifetimes-together">Generic Type Parameters, Trait Bounds, and Lifetimes Together</a></h2>
<p>Let’s briefly look at the syntax of specifying generic type parameters, trait
bounds, and lifetimes all in one function!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a str
    where T: Display
{
    println!(&quot;Announcement! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the <code>longest</code> function from Listing 10-22 that returns the longer of
two string slices. But now it has an extra parameter named <code>ann</code> of the generic
type <code>T</code>, which can be filled in by any type that implements the <code>Display</code>
trait as specified by the <code>where</code> clause. This extra parameter will be printed
before the function compares the lengths of the string slices, which is why the
<code>Display</code> trait bound is necessary. Because lifetimes are a type of generic,
the declarations of the lifetime parameter <code>'a</code> and the generic type parameter
<code>T</code> go in the same list inside the angle brackets after the function name.</p>
<h2><a class="header" href="#summary-9" id="summary-9">Summary</a></h2>
<p>We covered a lot in this chapter! Now that you know about generic type
parameters, traits and trait bounds, and generic lifetime parameters, you’re
ready to write code without repetition that works in many different situations.
Generic type parameters let you apply the code to different types. Traits and
trait bounds ensure that even though the types are generic, they’ll have the
behavior the code needs. You learned how to use lifetime annotations to ensure
that this flexible code won’t have any dangling references. And all of this
analysis happens at compile time, which doesn’t affect runtime performance!</p>
<p>Believe it or not, there is much more to learn on the topics we discussed in
this chapter: Chapter 17 discusses trait objects, which are another way to use
traits. Chapter 19 covers more complex scenarios involving lifetime annotations
as well as some advanced type system features. But next, you’ll learn how to
write tests in Rust so you can make sure your code is working the way it should.</p>
<h1><a class="header" href="#writing-automated-tests" id="writing-automated-tests">Writing Automated Tests</a></h1>
<p>In his 1972 essay “The Humble Programmer,” Edsger W. Dijkstra said that
“Program testing can be a very effective way to show the presence of bugs, but
it is hopelessly inadequate for showing their absence.” That doesn’t mean we
shouldn’t try to test as much as we can!</p>
<p>Correctness in our programs is the extent to which our code does what we intend
it to do. Rust is designed with a high degree of concern about the correctness
of programs, but correctness is complex and not easy to prove. Rust’s type
system shoulders a huge part of this burden, but the type system cannot catch
every kind of incorrectness. As such, Rust includes support for writing
automated software tests within the language.</p>
<p>As an example, say we write a function called <code>add_two</code> that adds 2 to whatever
number is passed to it. This function’s signature accepts an integer as a
parameter and returns an integer as a result. When we implement and compile
that function, Rust does all the type checking and borrow checking that you’ve
learned so far to ensure that, for instance, we aren’t passing a <code>String</code> value
or an invalid reference to this function. But Rust <em>can’t</em> check that this
function will do precisely what we intend, which is return the parameter plus 2
rather than, say, the parameter plus 10 or the parameter minus 50! That’s where
tests come in.</p>
<p>We can write tests that assert, for example, that when we pass <code>3</code> to the
<code>add_two</code> function, the returned value is <code>5</code>. We can run these tests whenever
we make changes to our code to make sure any existing correct behavior has not
changed.</p>
<p>Testing is a complex skill: although we can’t cover every detail about how to
write good tests in one chapter, we’ll discuss the mechanics of Rust’s testing
facilities. We’ll talk about the annotations and macros available to you when
writing your tests, the default behavior and options provided for running your
tests, and how to organize tests into unit tests and integration tests.</p>
<h2><a class="header" href="#how-to-write-tests" id="how-to-write-tests">How to Write Tests</a></h2>
<p>Tests are Rust functions that verify that the non-test code is functioning in
the expected manner. The bodies of test functions typically perform these three
actions:</p>
<ol>
<li>Set up any needed data or state.</li>
<li>Run the code you want to test.</li>
<li>Assert the results are what you expect.</li>
</ol>
<p>Let’s look at the features Rust provides specifically for writing tests that
take these actions, which include the <code>test</code> attribute, a few macros, and the
<code>should_panic</code> attribute.</p>
<h3><a class="header" href="#the-anatomy-of-a-test-function" id="the-anatomy-of-a-test-function">The Anatomy of a Test Function</a></h3>
<p>At its simplest, a test in Rust is a function that’s annotated with the <code>test</code>
attribute. Attributes are metadata about pieces of Rust code; one example is
the <code>derive</code> attribute we used with structs in Chapter 5. To change a function
into a test function, add <code>#[test]</code> on the line before <code>fn</code>. When you run your
tests with the <code>cargo test</code> command, Rust builds a test runner binary that runs
the functions annotated with the <code>test</code> attribute and reports on whether each
test function passes or fails.</p>
<p>When we make a new library project with Cargo, a test module with a test
function in it is automatically generated for us. This module helps you start
writing your tests so you don’t have to look up the exact structure and syntax
of test functions every time you start a new project. You can add as many
additional test functions and as many test modules as you want!</p>
<p>We’ll explore some aspects of how tests work by experimenting with the template
test generated for us without actually testing any code. Then we’ll write some
real-world tests that call some code that we’ve written and assert that its
behavior is correct.</p>
<p>Let’s create a new library project called <code>adder</code>:</p>
<pre><code class="language-text">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>The contents of the <em>src/lib.rs</em> file in your <code>adder</code> library should look like
Listing 11-1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 11-1: The test module and function generated
automatically by <code>cargo new</code></span></p>
<p>For now, let’s ignore the top two lines and focus on the function to see how it
works. Note the <code>#[test]</code> annotation before the <code>fn</code> line: this attribute
indicates this is a test function, so the test runner knows to treat this
function as a test. We could also have non-test functions in the <code>tests</code> module
to help set up common scenarios or perform common operations, so we need to
indicate which functions are tests by using the <code>#[test]</code> attribute.</p>
<p>The function body uses the <code>assert_eq!</code> macro to assert that 2 + 2 equals 4.
This assertion serves as an example of the format for a typical test. Let’s run
it to see that this test passes.</p>
<p>The <code>cargo test</code> command runs all tests in our project, as shown in Listing
11-2.</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.22 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><span class="caption">Listing 11-2: The output from running the automatically
generated test</span></p>
<p>Cargo compiled and ran the test. After the <code>Compiling</code>, <code>Finished</code>, and
<code>Running</code> lines is the line <code>running 1 test</code>. The next line shows the name
of the generated test function, called <code>it_works</code>, and the result of running
that test, <code>ok</code>. The overall summary of running the tests appears next. The
text <code>test result: ok.</code> means that all the tests passed, and the portion that
reads <code>1 passed; 0 failed</code> totals the number of tests that passed or failed.</p>
<p>Because we don’t have any tests we’ve marked as ignored, the summary shows <code>0 ignored</code>. We also haven’t filtered the tests being run, so the end of the
summary shows <code>0 filtered out</code>. We’ll talk about ignoring and filtering out
tests in the next section, <a href="rustbook/ch11-02-running-tests.html#controlling-how-tests-are-run">“Controlling How Tests Are
Run.”</a><!-- ignore --></p>
<p>The <code>0 measured</code> statistic is for benchmark tests that measure performance.
Benchmark tests are, as of this writing, only available in nightly Rust. See
<a href="rustbook/../unstable-book/library-features/test.html">the documentation about benchmark tests</a> to learn more.</p>
<p>The next part of the test output, which starts with <code>Doc-tests adder</code>, is for
the results of any documentation tests. We don’t have any documentation tests
yet, but Rust can compile any code examples that appear in our API
documentation. This feature helps us keep our docs and our code in sync! We’ll
discuss how to write documentation tests in the <a href="rustbook/ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">“Documentation Comments as
Tests”</a><!-- ignore --> section of Chapter 14. For now, we’ll
ignore the <code>Doc-tests</code> output.</p>
<p>Let’s change the name of our test to see how that changes the test output.
Change the <code>it_works</code> function to a different name, such as <code>exploration</code>, like
so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
</code></pre></pre>
<p>Then run <code>cargo test</code> again. The output now shows <code>exploration</code> instead of
<code>it_works</code>:</p>
<pre><code class="language-text">running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Let’s add another test, but this time we’ll make a test that fails! Tests fail
when something in the test function panics. Each test is run in a new thread,
and when the main thread sees that a test thread has died, the test is marked
as failed. We talked about the simplest way to cause a panic in Chapter 9,
which is to call the <code>panic!</code> macro. Enter the new test, <code>another</code>, so your
<em>src/lib.rs</em> file looks like Listing 11-3.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust panics"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Make this test fail&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 11-3: Adding a second test that will fail because
we call the <code>panic!</code> macro</span></p>
<p>Run the tests again using <code>cargo test</code>. The output should look like Listing
11-4, which shows that our <code>exploration</code> test passed and <code>another</code> failed.</p>
<pre><code class="language-text">running 2 tests
test tests::exploration ... ok
test tests::another ... FAILED

failures:

---- tests::another stdout ----
thread 'tests::another' panicked at 'Make this test fail', src/lib.rs:10:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed
</code></pre>
<p><span class="caption">Listing 11-4: Test results when one test passes and one
test fails</span></p>
<p>Instead of <code>ok</code>, the line <code>test tests::another</code> shows <code>FAILED</code>. Two new
sections appear between the individual results and the summary: the first
section displays the detailed reason for each test failure. In this case,
<code>another</code> failed because it <code>panicked at 'Make this test fail'</code>, which happened
on line 10 in the <em>src/lib.rs</em> file. The next section lists just the names of
all the failing tests, which is useful when there are lots of tests and lots of
detailed failing test output. We can use the name of a failing test to run just
that test to more easily debug it; we’ll talk more about ways to run tests in
the <a href="rustbook/ch11-02-running-tests.html#controlling-how-tests-are-run">“Controlling How Tests Are Run”</a><!-- ignore
--> section.</p>
<p>The summary line displays at the end: overall, our test result is <code>FAILED</code>.
We had one test pass and one test fail.</p>
<p>Now that you’ve seen what the test results look like in different scenarios,
let’s look at some macros other than <code>panic!</code> that are useful in tests.</p>
<h3><a class="header" href="#checking-results-with-the-assert-macro" id="checking-results-with-the-assert-macro">Checking Results with the <code>assert!</code> Macro</a></h3>
<p>The <code>assert!</code> macro, provided by the standard library, is useful when you want
to ensure that some condition in a test evaluates to <code>true</code>. We give the
<code>assert!</code> macro an argument that evaluates to a Boolean. If the value is
<code>true</code>, <code>assert!</code> does nothing and the test passes. If the value is <code>false</code>,
the <code>assert!</code> macro calls the <code>panic!</code> macro, which causes the test to fail.
Using the <code>assert!</code> macro helps us check that our code is functioning in the
way we intend.</p>
<p>In Chapter 5, Listing 5-15, we used a <code>Rectangle</code> struct and a <code>can_hold</code>
method, which are repeated here in Listing 11-5. Let’s put this code in the
<em>src/lib.rs</em> file and write some tests for it using the <code>assert!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre></pre>
<p><span class="caption">Listing 11-5: Using the <code>Rectangle</code> struct and its
<code>can_hold</code> method from Chapter 5</span></p>
<p>The <code>can_hold</code> method returns a Boolean, which means it’s a perfect use case
for the <code>assert!</code> macro. In Listing 11-6, we write a test that exercises the
<code>can_hold</code> method by creating a <code>Rectangle</code> instance that has a width of 8 and
a height of 7 and asserting that it can hold another <code>Rectangle</code> instance that
has a width of 5 and a height of 1.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle { width: 8, height: 7 };
        let smaller = Rectangle { width: 5, height: 1 };

        assert!(larger.can_hold(&amp;smaller));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 11-6: A test for <code>can_hold</code> that checks whether a
larger rectangle can indeed hold a smaller rectangle</span></p>
<p>Note that we’ve added a new line inside the <code>tests</code> module: <code>use super::*;</code>.
The <code>tests</code> module is a regular module that follows the usual visibility rules
we covered in Chapter 7 in the <a href="rustbook/ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">“Paths for Referring to an Item in the Module
Tree”</a><!-- ignore -->
section. Because the <code>tests</code> module is an inner module, we need to bring the
code under test in the outer module into the scope of the inner module. We use
a glob here so anything we define in the outer module is available to this
<code>tests</code> module.</p>
<p>We’ve named our test <code>larger_can_hold_smaller</code>, and we’ve created the two
<code>Rectangle</code> instances that we need. Then we called the <code>assert!</code> macro and
passed it the result of calling <code>larger.can_hold(&amp;smaller)</code>. This expression
is supposed to return <code>true</code>, so our test should pass. Let’s find out!</p>
<pre><code class="language-text">running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>It does pass! Let’s add another test, this time asserting that a smaller
rectangle cannot hold a larger rectangle:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --snip--
    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle { width: 8, height: 7 };
        let smaller = Rectangle { width: 5, height: 1 };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
</code></pre></pre>
<p>Because the correct result of the <code>can_hold</code> function in this case is <code>false</code>,
we need to negate that result before we pass it to the <code>assert!</code> macro. As a
result, our test will pass if <code>can_hold</code> returns <code>false</code>:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Two tests that pass! Now let’s see what happens to our test results when we
introduce a bug in our code. Let’s change the implementation of the <code>can_hold</code>
method by replacing the greater than sign with a less than sign when it
compares the widths:</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {}
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span>// --snip--

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
</code></pre></pre>
<p>Running the tests now produces the following:</p>
<pre><code class="language-text">running 2 tests
test tests::smaller_cannot_hold_larger ... ok
test tests::larger_can_hold_smaller ... FAILED

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'tests::larger_can_hold_smaller' panicked at 'assertion failed:
larger.can_hold(&amp;smaller)', src/lib.rs:22:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Our tests caught the bug! Because <code>larger.width</code> is 8 and <code>smaller.width</code> is
5, the comparison of the widths in <code>can_hold</code> now returns <code>false</code>: 8 is not
less than 5.</p>
<h3><a class="header" href="#testing-equality-with-the-assert_eq-and-assert_ne-macros" id="testing-equality-with-the-assert_eq-and-assert_ne-macros">Testing Equality with the <code>assert_eq!</code> and <code>assert_ne!</code> Macros</a></h3>
<p>A common way to test functionality is to compare the result of the code under
test to the value you expect the code to return to make sure they’re equal. You
could do this using the <code>assert!</code> macro and passing it an expression using the
<code>==</code> operator. However, this is such a common test that the standard library
provides a pair of macros—<code>assert_eq!</code> and <code>assert_ne!</code>—to perform this test
more conveniently. These macros compare two arguments for equality or
inequality, respectively. They’ll also print the two values if the assertion
fails, which makes it easier to see <em>why</em> the test failed; conversely, the
<code>assert!</code> macro only indicates that it got a <code>false</code> value for the <code>==</code>
expression, not the values that lead to the <code>false</code> value.</p>
<p>In Listing 11-7, we write a function named <code>add_two</code> that adds <code>2</code> to its
parameter and returns the result. Then we test this function using the
<code>assert_eq!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 11-7: Testing the function <code>add_two</code> using the
<code>assert_eq!</code> macro</span></p>
<p>Let’s check that it passes!</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The first argument we gave to the <code>assert_eq!</code> macro, <code>4</code>, is equal to the
result of calling <code>add_two(2)</code>. The line for this test is <code>test tests::it_adds_two ... ok</code>, and the <code>ok</code> text indicates that our test passed!</p>
<p>Let’s introduce a bug into our code to see what it looks like when a test that
uses <code>assert_eq!</code> fails. Change the implementation of the <code>add_two</code> function to
instead add <code>3</code>:</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {}
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}
</code></pre></pre>
<p>Run the tests again:</p>
<pre><code class="language-text">running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'tests::it_adds_two' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Our test caught the bug! The <code>it_adds_two</code> test failed, displaying the message
<code>assertion failed: `(left == right)`</code> and showing that <code>left</code> was <code>4</code> and
<code>right</code> was <code>5</code>. This message is useful and helps us start debugging: it means
the <code>left</code> argument to <code>assert_eq!</code> was <code>4</code> but the <code>right</code> argument, where we
had <code>add_two(2)</code>, was <code>5</code>.</p>
<p>Note that in some languages and test frameworks, the parameters to the
functions that assert two values are equal are called <code>expected</code> and <code>actual</code>,
and the order in which we specify the arguments matters. However, in Rust,
they’re called <code>left</code> and <code>right</code>, and the order in which we specify the value
we expect and the value that the code under test produces doesn’t matter. We
could write the assertion in this test as <code>assert_eq!(add_two(2), 4)</code>, which
would result in a failure message that displays <code>assertion failed: `(left == right)`</code> and that <code>left</code> was <code>5</code> and <code>right</code> was <code>4</code>.</p>
<p>The <code>assert_ne!</code> macro will pass if the two values we give it are not equal and
fail if they’re equal. This macro is most useful for cases when we’re not sure
what a value <em>will</em> be, but we know what the value definitely <em>won’t</em> be if our
code is functioning as we intend. For example, if we’re testing a function that
is guaranteed to change its input in some way, but the way in which the input
is changed depends on the day of the week that we run our tests, the best thing
to assert might be that the output of the function is not equal to the input.</p>
<p>Under the surface, the <code>assert_eq!</code> and <code>assert_ne!</code> macros use the operators
<code>==</code> and <code>!=</code>, respectively. When the assertions fail, these macros print their
arguments using debug formatting, which means the values being compared must
implement the <code>PartialEq</code> and <code>Debug</code> traits. All the primitive types and most
of the standard library types implement these traits. For structs and enums
that you define, you’ll need to implement <code>PartialEq</code> to assert that values of
those types are equal or not equal. You’ll need to implement <code>Debug</code> to print
the values when the assertion fails. Because both traits are derivable traits,
as mentioned in Listing 5-12 in Chapter 5, this is usually as straightforward
as adding the <code>#[derive(PartialEq, Debug)]</code> annotation to your struct or enum
definition. See Appendix C, <a href="rustbook/appendix-03-derivable-traits.html">“Derivable Traits,”</a><!-- ignore
--> for more details about these and other derivable traits.</p>
<h3><a class="header" href="#adding-custom-failure-messages" id="adding-custom-failure-messages">Adding Custom Failure Messages</a></h3>
<p>You can also add a custom message to be printed with the failure message as
optional arguments to the <code>assert!</code>, <code>assert_eq!</code>, and <code>assert_ne!</code> macros. Any
arguments specified after the one required argument to <code>assert!</code> or the two
required arguments to <code>assert_eq!</code> and <code>assert_ne!</code> are passed along to the
<code>format!</code> macro (discussed in Chapter 8 in the <a href="rustbook/ch08-02-strings.html#concatenation-with-the--operator-or-the-format-macro">“Concatenation with the <code>+</code>
Operator or the <code>format!</code>
Macro”</a><!-- ignore -->
section), so you can pass a format string that contains <code>{}</code> placeholders and
values to go in those placeholders. Custom messages are useful to document
what an assertion means; when a test fails, you’ll have a better idea of what
the problem is with the code.</p>
<p>For example, let’s say we have a function that greets people by name and we
want to test that the name we pass into the function appears in the output:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hello {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
</code></pre></pre>
<p>The requirements for this program haven’t been agreed upon yet, and we’re
pretty sure the <code>Hello</code> text at the beginning of the greeting will change. We
decided we don’t want to have to update the test when the requirements change,
so instead of checking for exact equality to the value returned from the
<code>greeting</code> function, we’ll just assert that the output contains the text of the
input parameter.</p>
<p>Let’s introduce a bug into this code by changing <code>greeting</code> to not include
<code>name</code> to see what this test failure looks like:</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {}
</span>pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hello!&quot;)
}
</code></pre></pre>
<p>Running this test produces the following:</p>
<pre><code class="language-text">running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at 'assertion failed:
result.contains(&quot;Carol&quot;)', src/lib.rs:12:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::greeting_contains_name
</code></pre>
<p>This result just indicates that the assertion failed and which line the
assertion is on. A more useful failure message in this case would print the
value we got from the <code>greeting</code> function. Let’s change the test function,
giving it a custom failure message made from a format string with a placeholder
filled in with the actual value we got from the <code>greeting</code> function:</p>
<pre><code class="language-rust ignore">#[test]
fn greeting_contains_name() {
    let result = greeting(&quot;Carol&quot;);
    assert!(
        result.contains(&quot;Carol&quot;),
        &quot;Greeting did not contain name, value was `{}`&quot;, result
    );
}
</code></pre>
<p>Now when we run the test, we’ll get a more informative error message:</p>
<pre><code class="language-text">---- tests::greeting_contains_name stdout ----
thread 'tests::greeting_contains_name' panicked at 'Greeting did not
contain name, value was `Hello!`', src/lib.rs:12:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>We can see the value we actually got in the test output, which would help us
debug what happened instead of what we were expecting to happen.</p>
<h3><a class="header" href="#checking-for-panics-with-should_panic" id="checking-for-panics-with-should_panic">Checking for Panics with <code>should_panic</code></a></h3>
<p>In addition to checking that our code returns the correct values we expect,
it’s also important to check that our code handles error conditions as we
expect. For example, consider the <code>Guess</code> type that we created in Chapter 9,
Listing 9-10. Other code that uses <code>Guess</code> depends on the guarantee that <code>Guess</code>
instances will contain only values between 1 and 100. We can write a test that
ensures that attempting to create a <code>Guess</code> instance with a value outside that
range panics.</p>
<p>We do this by adding another attribute, <code>should_panic</code>, to our test function.
This attribute makes a test pass if the code inside the function panics; the
test will fail if the code inside the function doesn’t panic.</p>
<p>Listing 11-8 shows a test that checks that the error conditions of <code>Guess::new</code>
happen when we expect them to.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 11-8: Testing that a condition will cause a
<code>panic!</code></span></p>
<p>We place the <code>#[should_panic]</code> attribute after the <code>#[test]</code> attribute and
before the test function it applies to. Let’s look at the result when this test
passes:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Looks good! Now let’s introduce a bug in our code by removing the condition
that the <code>new</code> function will panic if the value is greater than 100:</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"><span class="boring">fn main() {}
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1  {
            panic!(&quot;Guess value must be between 1 and 100, got {}.&quot;, value);
        }

        Guess {
            value
        }
    }
}
</code></pre></pre>
<p>When we run the test in Listing 11-8, it will fail:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>We don’t get a very helpful message in this case, but when we look at the test
function, we see that it’s annotated with <code>#[should_panic]</code>. The failure we got
means that the code in the test function did not cause a panic.</p>
<p>Tests that use <code>should_panic</code> can be imprecise because they only indicate that
the code has caused some panic. A <code>should_panic</code> test would pass even if the
test panics for a different reason from the one we were expecting to happen. To
make <code>should_panic</code> tests more precise, we can add an optional <code>expected</code>
parameter to the <code>should_panic</code> attribute. The test harness will make sure that
the failure message contains the provided text. For example, consider the
modified code for <code>Guess</code> in Listing 11-9 where the <code>new</code> function panics with
different messages depending on whether the value is too small or too large.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;,
                   value);
        }

        Guess {
            value
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 11-9: Testing that a condition will cause a
<code>panic!</code> with a particular panic message</span></p>
<p>This test will pass because the value we put in the <code>should_panic</code> attribute’s
<code>expected</code> parameter is a substring of the message that the <code>Guess::new</code>
function panics with. We could have specified the entire panic message that we
expect, which in this case would be <code>Guess value must be less than or equal to 100, got 200.</code> What you choose to specify in the expected parameter for
<code>should_panic</code> depends on how much of the panic message is unique or dynamic
and how precise you want your test to be. In this case, a substring of the
panic message is enough to ensure that the code in the test function executes
the <code>else if value &gt; 100</code> case.</p>
<p>To see what happens when a <code>should_panic</code> test with an <code>expected</code> message
fails, let’s again introduce a bug into our code by swapping the bodies of the
<code>if value &lt; 1</code> and the <code>else if value &gt; 100</code> blocks:</p>
<pre><code class="language-rust ignore not_desired_behavior">if value &lt; 1 {
    panic!(&quot;Guess value must be less than or equal to 100, got {}.&quot;, value);
} else if value &gt; 100 {
    panic!(&quot;Guess value must be greater than or equal to 1, got {}.&quot;, value);
}
</code></pre>
<p>This time when we run the <code>should_panic</code> test, it will fail:</p>
<pre><code class="language-text">running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'tests::greater_than_100' panicked at 'Guess value must be
greater than or equal to 1, got 200.', src/lib.rs:11:13
note: Run with `RUST_BACKTRACE=1` for a backtrace.
note: Panic did not include expected string 'Guess value must be less than or
equal to 100'

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The failure message indicates that this test did indeed panic as we expected,
but the panic message did not include the expected string <code>'Guess value must be less than or equal to 100'</code>. The panic message that we did get in this case was
<code>Guess value must be greater than or equal to 1, got 200.</code> Now we can start
figuring out where our bug is!</p>
<h3><a class="header" href="#using-resultt-e-in-tests" id="using-resultt-e-in-tests">Using <code>Result&lt;T, E&gt;</code> in Tests</a></h3>
<p>So far, we’ve written tests that panic when they fail. We can also write tests
that use <code>Result&lt;T, E&gt;</code>! Here’s the test from Listing 11-1, rewritten to use
<code>Result&lt;T, E&gt;</code> and return an <code>Err</code> instead of panicking:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;two plus two does not equal four&quot;))
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>it_works</code> function now has a return type, <code>Result&lt;(), String&gt;</code>. In the
body of the function, rather than calling the <code>assert_eq!</code> macro, we return
<code>Ok(())</code> when the test passes and an <code>Err</code> with a <code>String</code> inside when the test
fails.</p>
<p>Writing tests so they return a <code>Result&lt;T, E&gt;</code> enables you to use the question
mark operator in the body of tests, which can be a convenient way to write
tests that should fail if any operation within them returns an <code>Err</code> variant.</p>
<p>You can’t use the <code>#[should_panic]</code> annotation on tests that use <code>Result&lt;T, E&gt;</code>. Instead, you should return an <code>Err</code> value directly when the test should
fail.</p>
<p>Now that you know several ways to write tests, let’s look at what is happening
when we run our tests and explore the different options we can use with <code>cargo test</code>.</p>
<h2><a class="header" href="#controlling-how-tests-are-run" id="controlling-how-tests-are-run">Controlling How Tests Are Run</a></h2>
<p>Just as <code>cargo run</code> compiles your code and then runs the resulting binary,
<code>cargo test</code> compiles your code in test mode and runs the resulting test
binary. You can specify command line options to change the default behavior of
<code>cargo test</code>. For example, the default behavior of the binary produced by
<code>cargo test</code> is to run all the tests in parallel and capture output generated
during test runs, preventing the output from being displayed and making it
easier to read the output related to the test results.</p>
<p>Some command line options go to <code>cargo test</code>, and some go to the resulting test
binary. To separate these two types of arguments, you list the arguments that
go to <code>cargo test</code> followed by the separator <code>--</code> and then the ones that go to
the test binary. Running <code>cargo test --help</code> displays the options you can use
with <code>cargo test</code>, and running <code>cargo test -- --help</code> displays the options you
can use after the separator <code>--</code>.</p>
<h3><a class="header" href="#running-tests-in-parallel-or-consecutively" id="running-tests-in-parallel-or-consecutively">Running Tests in Parallel or Consecutively</a></h3>
<p>When you run multiple tests, by default they run in parallel using threads.
This means the tests will finish running faster so you can get feedback quicker
on whether or not your code is working. Because the tests are running at the
same time, make sure your tests don’t depend on each other or on any shared
state, including a shared environment, such as the current working directory or
environment variables.</p>
<p>For example, say each of your tests runs some code that creates a file on disk
named <em>test-output.txt</em> and writes some data to that file. Then each test reads
the data in that file and asserts that the file contains a particular value,
which is different in each test. Because the tests run at the same time, one
test might overwrite the file between when another test writes and reads the
file. The second test will then fail, not because the code is incorrect but
because the tests have interfered with each other while running in parallel.
One solution is to make sure each test writes to a different file; another
solution is to run the tests one at a time.</p>
<p>If you don’t want to run the tests in parallel or if you want more fine-grained
control over the number of threads used, you can send the <code>--test-threads</code> flag
and the number of threads you want to use to the test binary. Take a look at
the following example:</p>
<pre><code class="language-text">$ cargo test -- --test-threads=1
</code></pre>
<p>We set the number of test threads to <code>1</code>, telling the program not to use any
parallelism. Running the tests using one thread will take longer than running
them in parallel, but the tests won’t interfere with each other if they share
state.</p>
<h3><a class="header" href="#showing-function-output" id="showing-function-output">Showing Function Output</a></h3>
<p>By default, if a test passes, Rust’s test library captures anything printed to
standard output. For example, if we call <code>println!</code> in a test and the test
passes, we won’t see the <code>println!</code> output in the terminal; we’ll see only the
line that indicates the test passed. If a test fails, we’ll see whatever was
printed to standard output with the rest of the failure message.</p>
<p>As an example, Listing 11-10 has a silly function that prints the value of its
parameter and returns 10, as well as a test that passes and a test that fails.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust panics">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;I got the value {}&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 11-10: Tests for a function that calls
<code>println!</code></span></p>
<p>When we run these tests with <code>cargo test</code>, we’ll see the following output:</p>
<pre><code class="language-text">running 2 tests
test tests::this_test_will_pass ... ok
test tests::this_test_will_fail ... FAILED

failures:

---- tests::this_test_will_fail stdout ----
I got the value 8
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Note that nowhere in this output do we see <code>I got the value 4</code>, which is what
is printed when the test that passes runs. That output has been captured. The
output from the test that failed, <code>I got the value 8</code>, appears in the section
of the test summary output, which also shows the cause of the test failure.</p>
<p>If we want to see printed values for passing tests as well, we can disable the
output capture behavior by using the <code>--nocapture</code> flag:</p>
<pre><code class="language-text">$ cargo test -- --nocapture
</code></pre>
<p>When we run the tests in Listing 11-10 again with the <code>--nocapture</code> flag, we
see the following output:</p>
<pre><code class="language-text">running 2 tests
I got the value 4
I got the value 8
test tests::this_test_will_pass ... ok
thread 'tests::this_test_will_fail' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: Run with `RUST_BACKTRACE=1` for a backtrace.
test tests::this_test_will_fail ... FAILED

failures:

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Note that the output for the tests and the test results are interleaved; the
reason is that the tests are running in parallel, as we talked about in the
previous section. Try using the <code>--test-threads=1</code> option and the <code>--nocapture</code>
flag, and see what the output looks like then!</p>
<h3><a class="header" href="#running-a-subset-of-tests-by-name" id="running-a-subset-of-tests-by-name">Running a Subset of Tests by Name</a></h3>
<p>Sometimes, running a full test suite can take a long time. If you’re working on
code in a particular area, you might want to run only the tests pertaining to
that code. You can choose which tests to run by passing <code>cargo test</code> the name
or names of the test(s) you want to run as an argument.</p>
<p>To demonstrate how to run a subset of tests, we’ll create three tests for our
<code>add_two</code> function, as shown in Listing 11-11, and choose which ones to run.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 11-11: Three tests with three different
names</span></p>
<p>If we run the tests without passing any arguments, as we saw earlier, all the
tests will run in parallel:</p>
<pre><code class="language-text">running 3 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h4><a class="header" href="#running-single-tests" id="running-single-tests">Running Single Tests</a></h4>
<p>We can pass the name of any test function to <code>cargo test</code> to run only that test:</p>
<pre><code class="language-text">$ cargo test one_hundred
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>Only the test with the name <code>one_hundred</code> ran; the other two tests didn’t match
that name. The test output lets us know we had more tests than what this
command ran by displaying <code>2 filtered out</code> at the end of the summary line.</p>
<p>We can’t specify the names of multiple tests in this way; only the first value
given to <code>cargo test</code> will be used. But there is a way to run multiple tests.</p>
<h4><a class="header" href="#filtering-to-run-multiple-tests" id="filtering-to-run-multiple-tests">Filtering to Run Multiple Tests</a></h4>
<p>We can specify part of a test name, and any test whose name matches that value
will be run. For example, because two of our tests’ names contain <code>add</code>, we can
run those two by running <code>cargo test add</code>:</p>
<pre><code class="language-text">$ cargo test add
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-06a75b4a1f2515e9

running 2 tests
test tests::add_two_and_two ... ok
test tests::add_three_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>This command ran all tests with <code>add</code> in the name and filtered out the test
named <code>one_hundred</code>. Also note that the module in which a test appears becomes
part of the test’s name, so we can run all the tests in a module by filtering
on the module’s name.</p>
<h3><a class="header" href="#ignoring-some-tests-unless-specifically-requested" id="ignoring-some-tests-unless-specifically-requested">Ignoring Some Tests Unless Specifically Requested</a></h3>
<p>Sometimes a few specific tests can be very time-consuming to execute, so you
might want to exclude them during most runs of <code>cargo test</code>. Rather than
listing as arguments all tests you do want to run, you can instead annotate the
time-consuming tests using the <code>ignore</code> attribute to exclude them, as shown
here:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // code that takes an hour to run
}
<span class="boring">}
</span></code></pre></pre>
<p>After <code>#[test]</code> we add the <code>#[ignore]</code> line to the test we want to exclude. Now
when we run our tests, <code>it_works</code> runs, but <code>expensive_test</code> doesn’t:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.24 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The <code>expensive_test</code> function is listed as <code>ignored</code>. If we want to run only
the ignored tests, we can use <code>cargo test -- --ignored</code>:</p>
<pre><code class="language-text">$ cargo test -- --ignored
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/adder-ce99bcc2479f4607

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>By controlling which tests run, you can make sure your <code>cargo test</code> results
will be fast. When you’re at a point where it makes sense to check the results
of the <code>ignored</code> tests and you have time to wait for the results, you can run
<code>cargo test -- --ignored</code> instead.</p>
<h2><a class="header" href="#test-organization" id="test-organization">Test Organization</a></h2>
<p>As mentioned at the start of the chapter, testing is a complex discipline, and
different people use different terminology and organization. The Rust community
thinks about tests in terms of two main categories: <em>unit tests</em> and
<em>integration tests</em>. Unit tests are small and more focused, testing one module
in isolation at a time, and can test private interfaces. Integration tests are
entirely external to your library and use your code in the same way any other
external code would, using only the public interface and potentially exercising
multiple modules per test.</p>
<p>Writing both kinds of tests is important to ensure that the pieces of your
library are doing what you expect them to, separately and together.</p>
<h3><a class="header" href="#unit-tests" id="unit-tests">Unit Tests</a></h3>
<p>The purpose of unit tests is to test each unit of code in isolation from the
rest of the code to quickly pinpoint where code is and isn’t working as
expected. You’ll put unit tests in the <em>src</em> directory in each file with the
code that they’re testing. The convention is to create a module named <code>tests</code>
in each file to contain the test functions and to annotate the module with
<code>cfg(test)</code>.</p>
<h4><a class="header" href="#the-tests-module-and-cfgtest" id="the-tests-module-and-cfgtest">The Tests Module and <code>#[cfg(test)]</code></a></h4>
<p>The <code>#[cfg(test)]</code> annotation on the tests module tells Rust to compile and run
the test code only when you run <code>cargo test</code>, not when you run <code>cargo build</code>.
This saves compile time when you only want to build the library and saves space
in the resulting compiled artifact because the tests are not included. You’ll
see that because integration tests go in a different directory, they don’t need
the <code>#[cfg(test)]</code> annotation. However, because unit tests go in the same files
as the code, you’ll use <code>#[cfg(test)]</code> to specify that they shouldn’t be
included in the compiled result.</p>
<p>Recall that when we generated the new <code>adder</code> project in the first section of
this chapter, Cargo generated this code for us:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>This code is the automatically generated test module. The attribute <code>cfg</code>
stands for <em>configuration</em> and tells Rust that the following item should only
be included given a certain configuration option. In this case, the
configuration option is <code>test</code>, which is provided by Rust for compiling and
running tests. By using the <code>cfg</code> attribute, Cargo compiles our test code only
if we actively run the tests with <code>cargo test</code>. This includes any helper
functions that might be within this module, in addition to the functions
annotated with <code>#[test]</code>.</p>
<h4><a class="header" href="#testing-private-functions" id="testing-private-functions">Testing Private Functions</a></h4>
<p>There’s debate within the testing community about whether or not private
functions should be tested directly, and other languages make it difficult or
impossible to test private functions. Regardless of which testing ideology you
adhere to, Rust’s privacy rules do allow you to test private functions.
Consider the code in Listing 11-12 with the private function <code>internal_adder</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>
pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 11-12: Testing a private function</span></p>
<p>Note that the <code>internal_adder</code> function is not marked as <code>pub</code>, but because
tests are just Rust code and the <code>tests</code> module is just another module, you can
bring <code>internal_adder</code> into a test’s scope and call it. If you don’t think
private functions should be tested, there’s nothing in Rust that will compel
you to do so.</p>
<h3><a class="header" href="#integration-tests" id="integration-tests">Integration Tests</a></h3>
<p>In Rust, integration tests are entirely external to your library. They use your
library in the same way any other code would, which means they can only call
functions that are part of your library’s public API. Their purpose is to test
whether many parts of your library work together correctly. Units of code that
work correctly on their own could have problems when integrated, so test
coverage of the integrated code is important as well. To create integration
tests, you first need a <em>tests</em> directory.</p>
<h4><a class="header" href="#the-tests-directory" id="the-tests-directory">The <em>tests</em> Directory</a></h4>
<p>We create a <em>tests</em> directory at the top level of our project directory, next
to <em>src</em>. Cargo knows to look for integration test files in this directory. We
can then make as many test files as we want to in this directory, and Cargo
will compile each of the files as an individual crate.</p>
<p>Let’s create an integration test. With the code in Listing 11-12 still in the
<em>src/lib.rs</em> file, make a <em>tests</em> directory, create a new file named
<em>tests/integration_test.rs</em>, and enter the code in Listing 11-13.</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Listing 11-13: An integration test of a function in the
<code>adder</code> crate</span></p>
<p>We’ve added <code>use adder</code> at the top of the code, which we didn’t need in the
unit tests. The reason is that each test in the <code>tests</code> directory is a separate
crate, so we need to bring our library into each test crate’s scope.</p>
<p>We don’t need to annotate any code in <em>tests/integration_test.rs</em> with
<code>#[cfg(test)]</code>. Cargo treats the <code>tests</code> directory specially and compiles files
in this directory only when we run <code>cargo test</code>. Run <code>cargo test</code> now:</p>
<pre><code class="language-text">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running target/debug/deps/adder-abcabcabc

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-ce99bcc2479f4607

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The three sections of output include the unit tests, the integration test, and
the doc tests. The first section for the unit tests is the same as we’ve been
seeing: one line for each unit test (one named <code>internal</code> that we added in
Listing 11-12) and then a summary line for the unit tests.</p>
<p>The integration tests section starts with the line <code>Running target/debug/deps/integration_test-ce99bcc2479f4607</code> (the hash at the end of
your output will be different). Next, there is a line for each test function in
that integration test and a summary line for the results of the integration
test just before the <code>Doc-tests adder</code> section starts.</p>
<p>Similarly to how adding more unit test functions adds more result lines to the
unit tests section, adding more test functions to the integration test file
adds more result lines to this integration test file’s section. Each
integration test file has its own section, so if we add more files in the
<em>tests</em> directory, there will be more integration test sections.</p>
<p>We can still run a particular integration test function by specifying the test
function’s name as an argument to <code>cargo test</code>. To run all the tests in a
particular integration test file, use the <code>--test</code> argument of <code>cargo test</code>
followed by the name of the file:</p>
<pre><code class="language-text">$ cargo test --test integration_test
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/integration_test-952a27e0126bb565

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>This command runs only the tests in the <em>tests/integration_test.rs</em> file.</p>
<h4><a class="header" href="#submodules-in-integration-tests" id="submodules-in-integration-tests">Submodules in Integration Tests</a></h4>
<p>As you add more integration tests, you might want to make more than one file in
the <em>tests</em> directory to help organize them; for example, you can group the
test functions by the functionality they’re testing. As mentioned earlier, each
file in the <em>tests</em> directory is compiled as its own separate crate.</p>
<p>Treating each integration test file as its own crate is useful to create
separate scopes that are more like the way end users will be using your crate.
However, this means files in the <em>tests</em> directory don’t share the same
behavior as files in <em>src</em> do, as you learned in Chapter 7 regarding how to
separate code into modules and files.</p>
<p>The different behavior of files in the <em>tests</em> directory is most noticeable
when you have a set of helper functions that would be useful in multiple
integration test files and you try to follow the steps in the <a href="rustbook/ch07-05-separating-modules-into-different-files.html">“Separating
Modules into Different Files”</a><!-- ignore -->
section of Chapter 7 to extract them into a common module. For example, if we
create <em>tests/common.rs</em> and place a function named <code>setup</code> in it, we can add
some code to <code>setup</code> that we want to call from multiple test functions in
multiple test files:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn setup() {
    // setup code specific to your library's tests would go here
}
<span class="boring">}
</span></code></pre></pre>
<p>When we run the tests again, we’ll see a new section in the test output for the
<em>common.rs</em> file, even though this file doesn’t contain any test functions nor
did we call the <code>setup</code> function from anywhere:</p>
<pre><code class="language-text">running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-b8b07b6f1be2db70

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-d993c68b431d39df

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Having <code>common</code> appear in the test results with <code>running 0 tests</code> displayed for
it is not what we wanted. We just wanted to share some code with the other
integration test files.</p>
<p>To avoid having <code>common</code> appear in the test output, instead of creating
<em>tests/common.rs</em>, we’ll create <em>tests/common/mod.rs</em>. This is an alternate
naming convention that Rust also understands. Naming the file this way tells
Rust not to treat the <code>common</code> module as an integration test file. When we move
the <code>setup</code> function code into <em>tests/common/mod.rs</em> and delete the
<em>tests/common.rs</em> file, the section in the test output will no longer appear.
Files in subdirectories of the <em>tests</em> directory don’t get compiled as separate
crates or have sections in the test output.</p>
<p>After we’ve created <em>tests/common/mod.rs</em>, we can use it from any of the
integration test files as a module. Here’s an example of calling the <code>setup</code>
function from the <code>it_adds_two</code> test in <em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Note that the <code>mod common;</code> declaration is the same as the module declaration
we demonstrated in Listing 7-21. Then in the test function, we can call the
<code>common::setup()</code> function.</p>
<h4><a class="header" href="#integration-tests-for-binary-crates" id="integration-tests-for-binary-crates">Integration Tests for Binary Crates</a></h4>
<p>If our project is a binary crate that only contains a <em>src/main.rs</em> file and
doesn’t have a <em>src/lib.rs</em> file, we can’t create integration tests in the
<em>tests</em> directory and bring functions defined in the <em>src/main.rs</em> file into
scope with a <code>use</code> statement. Only library crates expose functions that other
crates can use; binary crates are meant to be run on their own.</p>
<p>This is one of the reasons Rust projects that provide a binary have a
straightforward <em>src/main.rs</em> file that calls logic that lives in the
<em>src/lib.rs</em> file. Using that structure, integration tests <em>can</em> test the
library crate with <code>use</code> to make the important functionality available.
If the important functionality works, the small amount of code in the
<em>src/main.rs</em> file will work as well, and that small amount of code doesn’t
need to be tested.</p>
<h2><a class="header" href="#summary-10" id="summary-10">Summary</a></h2>
<p>Rust’s testing features provide a way to specify how code should function to
ensure it continues to work as you expect, even as you make changes. Unit tests
exercise different parts of a library separately and can test private
implementation details. Integration tests check that many parts of the library
work together correctly, and they use the library’s public API to test the code
in the same way external code will use it. Even though Rust’s type system and
ownership rules help prevent some kinds of bugs, tests are still important to
reduce logic bugs having to do with how your code is expected to behave.</p>
<p>Let’s combine the knowledge you learned in this chapter and in previous
chapters to work on a project!</p>
<h1><a class="header" href="#an-io-project-building-a-command-line-program" id="an-io-project-building-a-command-line-program">An I/O Project: Building a Command Line Program</a></h1>
<p>This chapter is a recap of the many skills you’ve learned so far and an
exploration of a few more standard library features. We’ll build a command line
tool that interacts with file and command line input/output to practice some of
the Rust concepts you now have under your belt.</p>
<p>Rust’s speed, safety, single binary output, and cross-platform support make it
an ideal language for creating command line tools, so for our project, we’ll
make our own version of the classic command line tool <code>grep</code> (<strong>g</strong>lobally
search a <strong>r</strong>egular <strong>e</strong>xpression and <strong>p</strong>rint). In the simplest use case,
<code>grep</code> searches a specified file for a specified string. To do so, <code>grep</code> takes
as its arguments a filename and a string. Then it reads the file, finds lines
in that file that contain the string argument, and prints those lines.</p>
<p>Along the way, we’ll show how to make our command line tool use features of the
terminal that many command line tools use. We’ll read the value of an
environment variable to allow the user to configure the behavior of our tool.
We’ll also print error messages to the standard error console stream (<code>stderr</code>)
instead of standard output (<code>stdout</code>), so, for example, the user can redirect
successful output to a file while still seeing error messages onscreen.</p>
<p>One Rust community member, Andrew Gallant, has already created a fully
featured, very fast version of <code>grep</code>, called <code>ripgrep</code>. By comparison, our
version of <code>grep</code> will be fairly simple, but this chapter will give you some of
the background knowledge you need to understand a real-world project such as
<code>ripgrep</code>.</p>
<p>Our <code>grep</code> project will combine a number of concepts you’ve learned so far:</p>
<ul>
<li>Organizing code (using what you learned about modules in <a href="rustbook/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">Chapter 7</a><!--
  ignore -->)</li>
<li>Using vectors and strings (collections, <a href="rustbook/ch08-00-common-collections.html">Chapter 8</a><!-- ignore -->)</li>
<li>Handling errors (<a href="rustbook/ch09-00-error-handling.html">Chapter 9</a><!-- ignore -->)</li>
<li>Using traits and lifetimes where appropriate (<a href="rustbook/ch10-00-generics.html">Chapter 10</a><!-- ignore
  -->)</li>
<li>Writing tests (<a href="rustbook/ch11-00-testing.html">Chapter 11</a><!-- ignore -->)</li>
</ul>
<p>We’ll also briefly introduce closures, iterators, and trait objects, which
Chapters <a href="rustbook/ch13-00-functional-features.html">13</a><!-- ignore --> and <a href="rustbook/ch17-00-oop.html">17</a><!-- ignore --> will cover in
detail.</p>
<h2><a class="header" href="#accepting-command-line-arguments" id="accepting-command-line-arguments">Accepting Command Line Arguments</a></h2>
<p>Let’s create a new project with, as always, <code>cargo new</code>. We’ll call our project
<code>minigrep</code> to distinguish it from the <code>grep</code> tool that you might already have
on your system.</p>
<pre><code class="language-text">$ cargo new minigrep
     Created binary (application) `minigrep` project
$ cd minigrep
</code></pre>
<p>The first task is to make <code>minigrep</code> accept its two command line arguments: the
filename and a string to search for. That is, we want to be able to run our
program with <code>cargo run</code>, a string to search for, and a path to a file to
search in, like so:</p>
<pre><code class="language-text">$ cargo run searchstring example-filename.txt
</code></pre>
<p>Right now, the program generated by <code>cargo new</code> cannot process arguments we
give it. Some existing libraries on <a href="https://crates.io/">crates.io</a> can help
with writing a program that accepts command line arguments, but because you’re
just learning this concept, let’s implement this capability ourselves.</p>
<h3><a class="header" href="#reading-the-argument-values" id="reading-the-argument-values">Reading the Argument Values</a></h3>
<p>To enable <code>minigrep</code> to read the values of command line arguments we pass to
it, we’ll need a function provided in Rust’s standard library, which is
<code>std::env::args</code>. This function returns an iterator of the command line
arguments that were given to <code>minigrep</code>. We’ll cover iterators fully in
<a href="rustbook/ch13-00-functional-features.html">Chapter 13</a><!-- ignore -->. For now, you only need to know two details
about iterators: iterators produce a series of values, and we can call the
<code>collect</code> method on an iterator to turn it into a collection, such as a vector,
containing all the elements the iterator produces.</p>
<p>Use the code in Listing 12-1 to allow your <code>minigrep</code> program to read any
command line arguments passed to it and then collect the values into a vector.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();
    println!(&quot;{:?}&quot;, args);
}
</code></pre></pre>
<p><span class="caption">Listing 12-1: Collecting the command line arguments into
a vector and printing them</span></p>
<p>First, we bring the <code>std::env</code> module into scope with a <code>use</code> statement so we
can use its <code>args</code> function. Notice that the <code>std::env::args</code> function is
nested in two levels of modules. As we discussed in <a href="rustbook/ch07-04-bringing-paths-into-scope-with-the-use-keyword.html#creating-idiomatic-use-paths">Chapter
7</a><!-- ignore -->, in cases where the desired function is
nested in more than one module, it’s conventional to bring the parent module
into scope rather than the function. By doing so, we can easily use other
functions from <code>std::env</code>. It’s also less ambiguous than adding <code>use std::env::args</code> and then calling the function with just <code>args</code>, because <code>args</code>
might easily be mistaken for a function that’s defined in the current module.</p>
<blockquote>
<h3><a class="header" href="#the-args-function-and-invalid-unicode" id="the-args-function-and-invalid-unicode">The <code>args</code> Function and Invalid Unicode</a></h3>
<p>Note that <code>std::env::args</code> will panic if any argument contains invalid
Unicode. If your program needs to accept arguments containing invalid
Unicode, use <code>std::env::args_os</code> instead. That function returns an iterator
that produces <code>OsString</code> values instead of <code>String</code> values. We’ve chosen to
use <code>std::env::args</code> here for simplicity, because <code>OsString</code> values differ
per platform and are more complex to work with than <code>String</code> values.</p>
</blockquote>
<p>On the first line of <code>main</code>, we call <code>env::args</code>, and we immediately use
<code>collect</code> to turn the iterator into a vector containing all the values produced
by the iterator. We can use the <code>collect</code> function to create many kinds of
collections, so we explicitly annotate the type of <code>args</code> to specify that we
want a vector of strings. Although we very rarely need to annotate types in
Rust, <code>collect</code> is one function you do often need to annotate because Rust
isn’t able to infer the kind of collection you want.</p>
<p>Finally, we print the vector using the debug formatter, <code>:?</code>. Let’s try running
the code first with no arguments and then with two arguments:</p>
<pre><code class="language-text">$ cargo run
--snip--
[&quot;target/debug/minigrep&quot;]

$ cargo run needle haystack
--snip--
[&quot;target/debug/minigrep&quot;, &quot;needle&quot;, &quot;haystack&quot;]
</code></pre>
<p>Notice that the first value in the vector is <code>&quot;target/debug/minigrep&quot;</code>, which
is the name of our binary. This matches the behavior of the arguments list in
C, letting programs use the name by which they were invoked in their execution.
It’s often convenient to have access to the program name in case you want to
print it in messages or change behavior of the program based on what command
line alias was used to invoke the program. But for the purposes of this
chapter, we’ll ignore it and save only the two arguments we need.</p>
<h3><a class="header" href="#saving-the-argument-values-in-variables" id="saving-the-argument-values-in-variables">Saving the Argument Values in Variables</a></h3>
<p>Printing the value of the vector of arguments illustrated that the program is
able to access the values specified as command line arguments. Now we need to
save the values of the two arguments in variables so we can use the values
throughout the rest of the program. We do that in Listing 12-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let query = &amp;args[1];
    let filename = &amp;args[2];

    println!(&quot;Searching for {}&quot;, query);
    println!(&quot;In file {}&quot;, filename);
}
</code></pre></pre>
<p><span class="caption">Listing 12-2: Creating variables to hold the query
argument and filename argument</span></p>
<p>As we saw when we printed the vector, the program’s name takes up the first
value in the vector at <code>args[0]</code>, so we’re starting at index <code>1</code>. The first
argument <code>minigrep</code> takes is the string we’re searching for, so we put a
reference to the first argument in the variable <code>query</code>. The second argument
will be the filename, so we put a reference to the second argument in the
variable <code>filename</code>.</p>
<p>We temporarily print the values of these variables to prove that the code is
working as we intend. Let’s run this program again with the arguments <code>test</code>
and <code>sample.txt</code>:</p>
<pre><code class="language-text">$ cargo run test sample.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep test sample.txt`
Searching for test
In file sample.txt
</code></pre>
<p>Great, the program is working! The values of the arguments we need are being
saved into the right variables. Later we’ll add some error handling to deal
with certain potential erroneous situations, such as when the user provides no
arguments; for now, we’ll ignore that situation and work on adding file-reading
capabilities instead.</p>
<h2><a class="header" href="#reading-a-file" id="reading-a-file">Reading a File</a></h2>
<p>Now we’ll add functionality to read the file that is specified in the
<code>filename</code> command line argument. First, we need a sample file to test it with:
the best kind of file to use to make sure <code>minigrep</code> is working is one with a
small amount of text over multiple lines with some repeated words. Listing 12-3
has an Emily Dickinson poem that will work well! Create a file called
<em>poem.txt</em> at the root level of your project, and enter the poem “I’m Nobody!
Who are you?”</p>
<p><span class="filename">Filename: poem.txt</span></p>
<pre><code class="language-text">I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us - don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p><span class="caption">Listing 12-3: A poem by Emily Dickinson makes a good test
case</span></p>
<p>With the text in place, edit <em>src/main.rs</em> and add code to read the file, as
shown in Listing 12-4.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::env;
use std::fs;

fn main() {
<span class="boring">    let args: Vec&lt;String&gt; = env::args().collect();
</span><span class="boring">
</span><span class="boring">    let query = &amp;args[1];
</span><span class="boring">    let filename = &amp;args[2];
</span><span class="boring">
</span><span class="boring">    println!(&quot;Searching for {}&quot;, query);
</span>    // --snip--
    println!(&quot;In file {}&quot;, filename);

    let contents = fs::read_to_string(filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}
</code></pre></pre>
<p><span class="caption">Listing 12-4: Reading the contents of the file specified
by the second argument</span></p>
<p>First, we add another <code>use</code> statement to bring in a relevant part of the
standard library: we need <code>std::fs</code> to handle files.</p>
<p>In <code>main</code>, we’ve added a new statement: <code>fs::read_to_string</code> takes the
<code>filename</code>, opens that file, and returns a <code>Result&lt;String&gt;</code> of the file’s
contents.</p>
<p>After that statement, we’ve again added a temporary <code>println!</code> statement that
prints the value of <code>contents</code> after the file is read, so we can check that the
program is working so far.</p>
<p>Let’s run this code with any string as the first command line argument (because
we haven’t implemented the searching part yet) and the <em>poem.txt</em> file as the
second argument:</p>
<pre><code class="language-text">$ cargo run the poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep the poem.txt`
Searching for the
In file poem.txt
With text:
I'm nobody! Who are you?
Are you nobody, too?
Then there's a pair of us — don't tell!
They'd banish us, you know.

How dreary to be somebody!
How public, like a frog
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Great! The code read and then printed the contents of the file. But the code
has a few flaws. The <code>main</code> function has multiple responsibilities: generally,
functions are clearer and easier to maintain if each function is responsible
for only one idea. The other problem is that we’re not handling errors as well
as we could. The program is still small, so these flaws aren’t a big problem,
but as the program grows, it will be harder to fix them cleanly. It’s good
practice to begin refactoring early on when developing a program, because it’s
much easier to refactor smaller amounts of code. We’ll do that next.</p>
<h2><a class="header" href="#refactoring-to-improve-modularity-and-error-handling" id="refactoring-to-improve-modularity-and-error-handling">Refactoring to Improve Modularity and Error Handling</a></h2>
<p>To improve our program, we’ll fix four problems that have to do with the
program’s structure and how it’s handling potential errors.</p>
<p>First, our <code>main</code> function now performs two tasks: it parses arguments and
reads files. For such a small function, this isn’t a major problem. However, if
we continue to grow our program inside <code>main</code>, the number of separate tasks the
<code>main</code> function handles will increase. As a function gains responsibilities, it
becomes more difficult to reason about, harder to test, and harder to change
without breaking one of its parts. It’s best to separate functionality so each
function is responsible for one task.</p>
<p>This issue also ties into the second problem: although <code>query</code> and <code>filename</code>
are configuration variables to our program, variables like <code>contents</code> are used
to perform the program’s logic. The longer <code>main</code> becomes, the more variables
we’ll need to bring into scope; the more variables we have in scope, the harder
it will be to keep track of the purpose of each. It’s best to group the
configuration variables into one structure to make their purpose clear.</p>
<p>The third problem is that we’ve used <code>expect</code> to print an error message when
reading the file fails, but the error message just prints <code>Something went wrong reading the file</code>. Reading a file can fail in a number of ways: for example,
the file could be missing, or we might not have permission to open it. Right
now, regardless of the situation, we’d print the <code>Something went wrong reading the file</code> error message, which wouldn’t give the user any information!</p>
<p>Fourth, we use <code>expect</code> repeatedly to handle different errors, and if the user
runs our program without specifying enough arguments, they’ll get an <code>index out of bounds</code> error from Rust that doesn’t clearly explain the problem. It would
be best if all the error-handling code were in one place so future maintainers
had only one place to consult in the code if the error-handling logic needed to
change. Having all the error-handling code in one place will also ensure that
we’re printing messages that will be meaningful to our end users.</p>
<p>Let’s address these four problems by refactoring our project.</p>
<h3><a class="header" href="#separation-of-concerns-for-binary-projects" id="separation-of-concerns-for-binary-projects">Separation of Concerns for Binary Projects</a></h3>
<p>The organizational problem of allocating responsibility for multiple tasks to
the <code>main</code> function is common to many binary projects. As a result, the Rust
community has developed a process to use as a guideline for splitting the
separate concerns of a binary program when <code>main</code> starts getting large. The
process has the following steps:</p>
<ul>
<li>Split your program into a <em>main.rs</em> and a <em>lib.rs</em> and move your program’s
logic to <em>lib.rs</em>.</li>
<li>As long as your command line parsing logic is small, it can remain in
<em>main.rs</em>.</li>
<li>When the command line parsing logic starts getting complicated, extract it
from <em>main.rs</em> and move it to <em>lib.rs</em>.</li>
</ul>
<p>The responsibilities that remain in the <code>main</code> function after this process
should be limited to the following:</p>
<ul>
<li>Calling the command line parsing logic with the argument values</li>
<li>Setting up any other configuration</li>
<li>Calling a <code>run</code> function in <em>lib.rs</em></li>
<li>Handling the error if <code>run</code> returns an error</li>
</ul>
<p>This pattern is about separating concerns: <em>main.rs</em> handles running the
program, and <em>lib.rs</em> handles all the logic of the task at hand. Because you
can’t test the <code>main</code> function directly, this structure lets you test all of
your program’s logic by moving it into functions in <em>lib.rs</em>. The only code
that remains in <em>main.rs</em> will be small enough to verify its correctness by
reading it. Let’s rework our program by following this process.</p>
<h4><a class="header" href="#extracting-the-argument-parser" id="extracting-the-argument-parser">Extracting the Argument Parser</a></h4>
<p>We’ll extract the functionality for parsing arguments into a function that
<code>main</code> will call to prepare for moving the command line parsing logic to
<em>src/lib.rs</em>. Listing 12-5 shows the new start of <code>main</code> that calls a new
function <code>parse_config</code>, which we’ll define in <em>src/main.rs</em> for the moment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let (query, filename) = parse_config(&amp;args);

    // --snip--
}

fn parse_config(args: &amp;[String]) -&gt; (&amp;str, &amp;str) {
    let query = &amp;args[1];
    let filename = &amp;args[2];

    (query, filename)
}
</code></pre>
<p><span class="caption">Listing 12-5: Extracting a <code>parse_config</code> function from
<code>main</code></span></p>
<p>We’re still collecting the command line arguments into a vector, but instead of
assigning the argument value at index 1 to the variable <code>query</code> and the
argument value at index 2 to the variable <code>filename</code> within the <code>main</code>
function, we pass the whole vector to the <code>parse_config</code> function. The
<code>parse_config</code> function then holds the logic that determines which argument
goes in which variable and passes the values back to <code>main</code>. We still create
the <code>query</code> and <code>filename</code> variables in <code>main</code>, but <code>main</code> no longer has the
responsibility of determining how the command line arguments and variables
correspond.</p>
<p>This rework may seem like overkill for our small program, but we’re refactoring
in small, incremental steps. After making this change, run the program again to
verify that the argument parsing still works. It’s good to check your progress
often, to help identify the cause of problems when they occur.</p>
<h4><a class="header" href="#grouping-configuration-values" id="grouping-configuration-values">Grouping Configuration Values</a></h4>
<p>We can take another small step to improve the <code>parse_config</code> function further.
At the moment, we’re returning a tuple, but then we immediately break that
tuple into individual parts again. This is a sign that perhaps we don’t have
the right abstraction yet.</p>
<p>Another indicator that shows there’s room for improvement is the <code>config</code> part
of <code>parse_config</code>, which implies that the two values we return are related and
are both part of one configuration value. We’re not currently conveying this
meaning in the structure of the data other than by grouping the two values into
a tuple; we could put the two values into one struct and give each of the
struct fields a meaningful name. Doing so will make it easier for future
maintainers of this code to understand how the different values relate to each
other and what their purpose is.</p>
<blockquote>
<p>Note: Using primitive values when a complex type would be more appropriate is
an anti-pattern known as <em>primitive obsession</em>.</p>
</blockquote>
<p>Listing 12-6 shows the improvements to the <code>parse_config</code> function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">use std::fs;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = parse_config(&amp;args);

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    // --snip--
}

struct Config {
    query: String,
    filename: String,
}

fn parse_config(args: &amp;[String]) -&gt; Config {
    let query = args[1].clone();
    let filename = args[2].clone();

    Config { query, filename }
}
</code></pre></pre>
<p><span class="caption">Listing 12-6: Refactoring <code>parse_config</code> to return an
instance of a <code>Config</code> struct</span></p>
<p>We’ve added a struct named <code>Config</code> defined to have fields named <code>query</code> and
<code>filename</code>. The signature of <code>parse_config</code> now indicates that it returns a
<code>Config</code> value. In the body of <code>parse_config</code>, where we used to return string
slices that reference <code>String</code> values in <code>args</code>, we now define <code>Config</code> to
contain owned <code>String</code> values. The <code>args</code> variable in <code>main</code> is the owner of
the argument values and is only letting the <code>parse_config</code> function borrow
them, which means we’d violate Rust’s borrowing rules if <code>Config</code> tried to take
ownership of the values in <code>args</code>.</p>
<p>We could manage the <code>String</code> data in a number of different ways, but the
easiest, though somewhat inefficient, route is to call the <code>clone</code> method on
the values. This will make a full copy of the data for the <code>Config</code> instance to
own, which takes more time and memory than storing a reference to the string
data. However, cloning the data also makes our code very straightforward
because we don’t have to manage the lifetimes of the references; in this
circumstance, giving up a little performance to gain simplicity is a worthwhile
trade-off.</p>
<blockquote>
<h3><a class="header" href="#the-trade-offs-of-using-clone" id="the-trade-offs-of-using-clone">The Trade-Offs of Using <code>clone</code></a></h3>
<p>There’s a tendency among many Rustaceans to avoid using <code>clone</code> to fix
ownership problems because of its runtime cost. In
<a href="rustbook/ch13-00-functional-features.html">Chapter 13</a><!-- ignore -->, you’ll learn how to use more efficient
methods in this type of situation. But for now, it’s okay to copy a few
strings to continue making progress because you’ll make these copies only
once and your filename and query string are very small. It’s better to have
a working program that’s a bit inefficient than to try to hyperoptimize code
on your first pass. As you become more experienced with Rust, it’ll be
easier to start with the most efficient solution, but for now, it’s
perfectly acceptable to call <code>clone</code>.</p>
</blockquote>
<p>We’ve updated <code>main</code> so it places the instance of <code>Config</code> returned by
<code>parse_config</code> into a variable named <code>config</code>, and we updated the code that
previously used the separate <code>query</code> and <code>filename</code> variables so it now uses
the fields on the <code>Config</code> struct instead.</p>
<p>Now our code more clearly conveys that <code>query</code> and <code>filename</code> are related and
that their purpose is to configure how the program will work. Any code that
uses these values knows to find them in the <code>config</code> instance in the fields
named for their purpose.</p>
<h4><a class="header" href="#creating-a-constructor-for-config" id="creating-a-constructor-for-config">Creating a Constructor for <code>Config</code></a></h4>
<p>So far, we’ve extracted the logic responsible for parsing the command line
arguments from <code>main</code> and placed it in the <code>parse_config</code> function. Doing so
helped us to see that the <code>query</code> and <code>filename</code> values were related and that
relationship should be conveyed in our code. We then added a <code>Config</code> struct to
name the related purpose of <code>query</code> and <code>filename</code> and to be able to return the
values’ names as struct field names from the <code>parse_config</code> function.</p>
<p>So now that the purpose of the <code>parse_config</code> function is to create a <code>Config</code>
instance, we can change <code>parse_config</code> from a plain function to a function
named <code>new</code> that is associated with the <code>Config</code> struct. Making this change
will make the code more idiomatic. We can create instances of types in the
standard library, such as <code>String</code>, by calling <code>String::new</code>. Similarly, by
changing <code>parse_config</code> into a <code>new</code> function associated with <code>Config</code>, we’ll
be able to create instances of <code>Config</code> by calling <code>Config::new</code>. Listing 12-7
shows the changes we need to make.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic"><span class="boring">use std::env;
</span><span class="boring">
</span>fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args);

    // --snip--
}

<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">}
</span><span class="boring">
</span>// --snip--

impl Config {
    fn new(args: &amp;[String]) -&gt; Config {
        let query = args[1].clone();
        let filename = args[2].clone();

        Config { query, filename }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 12-7: Changing <code>parse_config</code> into
<code>Config::new</code></span></p>
<p>We’ve updated <code>main</code> where we were calling <code>parse_config</code> to instead call
<code>Config::new</code>. We’ve changed the name of <code>parse_config</code> to <code>new</code> and moved it
within an <code>impl</code> block, which associates the <code>new</code> function with <code>Config</code>. Try
compiling this code again to make sure it works.</p>
<h3><a class="header" href="#fixing-the-error-handling" id="fixing-the-error-handling">Fixing the Error Handling</a></h3>
<p>Now we’ll work on fixing our error handling. Recall that attempting to access
the values in the <code>args</code> vector at index 1 or index 2 will cause the program to
panic if the vector contains fewer than three items. Try running the program
without any arguments; it will look like this:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'index out of bounds: the len is 1
but the index is 1', src/main.rs:25:21
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>The line <code>index out of bounds: the len is 1 but the index is 1</code> is an error
message intended for programmers. It won’t help our end users understand what
happened and what they should do instead. Let’s fix that now.</p>
<h4><a class="header" href="#improving-the-error-message" id="improving-the-error-message">Improving the Error Message</a></h4>
<p>In Listing 12-8, we add a check in the <code>new</code> function that will verify that the
slice is long enough before accessing index 1 and 2. If the slice isn’t long
enough, the program panics and displays a better error message than the <code>index out of bounds</code> message.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">// --snip--
fn new(args: &amp;[String]) -&gt; Config {
    if args.len() &lt; 3 {
        panic!(&quot;not enough arguments&quot;);
    }
    // --snip--
</code></pre>
<p><span class="caption">Listing 12-8: Adding a check for the number of
arguments</span></p>
<p>This code is similar to <a href="rustbook/ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation">the <code>Guess::new</code> function we wrote in Listing
9-10</a><!-- ignore -->, where we called <code>panic!</code> when the
<code>value</code> argument was out of the range of valid values. Instead of checking for
a range of values here, we’re checking that the length of <code>args</code> is at least 3
and the rest of the function can operate under the assumption that this
condition has been met. If <code>args</code> has fewer than three items, this condition
will be true, and we call the <code>panic!</code> macro to end the program immediately.</p>
<p>With these extra few lines of code in <code>new</code>, let’s run the program without any
arguments again to see what the error looks like now:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep`
thread 'main' panicked at 'not enough arguments', src/main.rs:26:13
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>This output is better: we now have a reasonable error message. However, we also
have extraneous information we don’t want to give to our users. Perhaps using
the technique we used in Listing 9-10 isn’t the best to use here: a call to
<code>panic!</code> is more appropriate for a programming problem than a usage problem,
<a href="rustbook/ch09-03-to-panic-or-not-to-panic.html#guidelines-for-error-handling">as discussed in Chapter 9</a><!-- ignore -->. Instead, we
can use the other technique you learned about in Chapter 9—<a href="rustbook/ch09-02-recoverable-errors-with-result.html">returning a
<code>Result</code></a><!-- ignore --> that indicates either success or an error.</p>
<h4><a class="header" href="#returning-a-result-from-new-instead-of-calling-panic" id="returning-a-result-from-new-instead-of-calling-panic">Returning a <code>Result</code> from <code>new</code> Instead of Calling <code>panic!</code></a></h4>
<p>We can instead return a <code>Result</code> value that will contain a <code>Config</code> instance in
the successful case and will describe the problem in the error case. When
<code>Config::new</code> is communicating to <code>main</code>, we can use the <code>Result</code> type to
signal there was a problem. Then we can change <code>main</code> to convert an <code>Err</code>
variant into a more practical error for our users without the surrounding text
about <code>thread 'main'</code> and <code>RUST_BACKTRACE</code> that a call to <code>panic!</code> causes.</p>
<p>Listing 12-9 shows the changes we need to make to the return value of
<code>Config::new</code> and the body of the function needed to return a <code>Result</code>. Note
that this won’t compile until we update <code>main</code> as well, which we’ll do in the
next listing.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        Ok(Config { query, filename })
    }
}
</code></pre>
<p><span class="caption">Listing 12-9: Returning a <code>Result</code> from
<code>Config::new</code></span></p>
<p>Our <code>new</code> function now returns a <code>Result</code> with a <code>Config</code> instance in the
success case and a <code>&amp;'static str</code> in the error case. Recall from <a href="rustbook/ch10-03-lifetime-syntax.html#the-static-lifetime">“The Static
Lifetime”</a><!-- ignore --> section in Chapter 10 that
<code>&amp;'static str</code> is the type of string literals, which is our error message type
for now.</p>
<p>We’ve made two changes in the body of the <code>new</code> function: instead of calling
<code>panic!</code> when the user doesn’t pass enough arguments, we now return an <code>Err</code>
value, and we’ve wrapped the <code>Config</code> return value in an <code>Ok</code>. These changes
make the function conform to its new type signature.</p>
<p>Returning an <code>Err</code> value from <code>Config::new</code> allows the <code>main</code> function to
handle the <code>Result</code> value returned from the <code>new</code> function and exit the process
more cleanly in the error case.</p>
<h4><a class="header" href="#calling-confignew-and-handling-errors" id="calling-confignew-and-handling-errors">Calling <code>Config::new</code> and Handling Errors</a></h4>
<p>To handle the error case and print a user-friendly message, we need to update
<code>main</code> to handle the <code>Result</code> being returned by <code>Config::new</code>, as shown in
Listing 12-10. We’ll also take the responsibility of exiting the command line
tool with a nonzero error code from <code>panic!</code> and implement it by hand. A
nonzero exit status is a convention to signal to the process that called our
program that the program exited with an error state.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::process;

fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        println!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
</code></pre>
<p><span class="caption">Listing 12-10: Exiting with an error code if creating a
new <code>Config</code> fails</span></p>
<p>In this listing, we’ve used a method we haven’t covered before:
<code>unwrap_or_else</code>, which is defined on <code>Result&lt;T, E&gt;</code> by the standard library.
Using <code>unwrap_or_else</code> allows us to define some custom, non-<code>panic!</code> error
handling. If the <code>Result</code> is an <code>Ok</code> value, this method’s behavior is similar
to <code>unwrap</code>: it returns the inner value <code>Ok</code> is wrapping. However, if the value
is an <code>Err</code> value, this method calls the code in the <em>closure</em>, which is an
anonymous function we define and pass as an argument to <code>unwrap_or_else</code>. We’ll
cover closures in more detail in <a href="rustbook/ch13-00-functional-features.html">Chapter 13</a><!-- ignore -->. For now,
you just need to know that <code>unwrap_or_else</code> will pass the inner value of the
<code>Err</code>, which in this case is the static string <code>not enough arguments</code> that we
added in Listing 12-9, to our closure in the argument <code>err</code> that appears
between the vertical pipes. The code in the closure can then use the <code>err</code>
value when it runs.</p>
<p>We’ve added a new <code>use</code> line to bring <code>process</code> from the standard library into
scope. The code in the closure that will be run in the error case is only two
lines: we print the <code>err</code> value and then call <code>process::exit</code>. The
<code>process::exit</code> function will stop the program immediately and return the
number that was passed as the exit status code. This is similar to the
<code>panic!</code>-based handling we used in Listing 12-8, but we no longer get all the
extra output. Let’s try it:</p>
<pre><code class="language-text">$ cargo run
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48 secs
     Running `target/debug/minigrep`
Problem parsing arguments: not enough arguments
</code></pre>
<p>Great! This output is much friendlier for our users.</p>
<h3><a class="header" href="#extracting-logic-from-main" id="extracting-logic-from-main">Extracting Logic from <code>main</code></a></h3>
<p>Now that we’ve finished refactoring the configuration parsing, let’s turn to
the program’s logic. As we stated in <a href="rustbook/ch12-03-improving-error-handling-and-modularity.html#separation-of-concerns-for-binary-projects">“Separation of Concerns for Binary
Projects”</a><!-- ignore -->, we’ll
extract a function named <code>run</code> that will hold all the logic currently in the
<code>main</code> function that isn’t involved with setting up configuration or handling
errors. When we’re done, <code>main</code> will be concise and easy to verify by
inspection, and we’ll be able to write tests for all the other logic.</p>
<p>Listing 12-11 shows the extracted <code>run</code> function. For now, we’re just making
the small, incremental improvement of extracting the function. We’re still
defining the function in <em>src/main.rs</em>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    run(config);
}

fn run(config: Config) {
    let contents = fs::read_to_string(config.filename)
        .expect(&quot;Something went wrong reading the file&quot;);

    println!(&quot;With text:\n{}&quot;, contents);
}

// --snip--
</code></pre>
<p><span class="caption">Listing 12-11: Extracting a <code>run</code> function containing the
rest of the program logic</span></p>
<p>The <code>run</code> function now contains all the remaining logic from <code>main</code>, starting
from reading the file. The <code>run</code> function takes the <code>Config</code> instance as an
argument.</p>
<h4><a class="header" href="#returning-errors-from-the-run-function" id="returning-errors-from-the-run-function">Returning Errors from the <code>run</code> Function</a></h4>
<p>With the remaining program logic separated into the <code>run</code> function, we can
improve the error handling, as we did with <code>Config::new</code> in Listing 12-9.
Instead of allowing the program to panic by calling <code>expect</code>, the <code>run</code>
function will return a <code>Result&lt;T, E&gt;</code> when something goes wrong. This will let
us further consolidate into <code>main</code> the logic around handling errors in a
user-friendly way. Listing 12-12 shows the changes we need to make to the
signature and body of <code>run</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;

// --snip--

fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    println!(&quot;With text:\n{}&quot;, contents);

    Ok(())
}
</code></pre>
<p><span class="caption">Listing 12-12: Changing the <code>run</code> function to return
<code>Result</code></span></p>
<p>We’ve made three significant changes here. First, we changed the return type of
the <code>run</code> function to <code>Result&lt;(), Box&lt;dyn Error&gt;&gt;</code>. This function previously
returned the unit type, <code>()</code>, and we keep that as the value returned in the
<code>Ok</code> case.</p>
<p>For the error type, we used the <em>trait object</em> <code>Box&lt;dyn Error&gt;</code> (and we’ve
brought <code>std::error::Error</code> into scope with a <code>use</code> statement at the top).
We’ll cover trait objects in <a href="rustbook/ch17-00-oop.html">Chapter 17</a><!-- ignore -->. For now, just
know that <code>Box&lt;dyn Error&gt;</code> means the function will return a type that
implements the <code>Error</code> trait, but we don’t have to specify what particular type
the return value will be. This gives us flexibility to return error values that
may be of different types in different error cases. The <code>dyn</code> keyword is short
for “dynamic.”</p>
<p>Second, we’ve removed the call to <code>expect</code> in favor of the <code>?</code> operator, as we
talked about in <a href="rustbook/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator">Chapter 9</a><!-- ignore -->. Rather than
<code>panic!</code> on an error, <code>?</code> will return the error value from the current function
for the caller to handle.</p>
<p>Third, the <code>run</code> function now returns an <code>Ok</code> value in the success case. We’ve
declared the <code>run</code> function’s success type as <code>()</code> in the signature, which
means we need to wrap the unit type value in the <code>Ok</code> value. This <code>Ok(())</code>
syntax might look a bit strange at first, but using <code>()</code> like this is the
idiomatic way to indicate that we’re calling <code>run</code> for its side effects only;
it doesn’t return a value we need.</p>
<p>When you run this code, it will compile but will display a warning:</p>
<pre><code class="language-text">warning: unused `std::result::Result` that must be used
  --&gt; src/main.rs:17:5
   |
17 |     run(config);
   |     ^^^^^^^^^^^^
   |
   = note: #[warn(unused_must_use)] on by default
   = note: this `Result` may be an `Err` variant, which should be handled
</code></pre>
<p>Rust tells us that our code ignored the <code>Result</code> value and the <code>Result</code> value
might indicate that an error occurred. But we’re not checking to see whether or
not there was an error, and the compiler reminds us that we probably meant to
have some error-handling code here! Let’s rectify that problem now.</p>
<h4><a class="header" href="#handling-errors-returned-from-run-in-main" id="handling-errors-returned-from-run-in-main">Handling Errors Returned from <code>run</code> in <code>main</code></a></h4>
<p>We’ll check for errors and handle them using a technique similar to one we used
with <code>Config::new</code> in Listing 12-10, but with a slight difference:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    // --snip--

    println!(&quot;Searching for {}&quot;, config.query);
    println!(&quot;In file {}&quot;, config.filename);

    if let Err(e) = run(config) {
        println!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p>We use <code>if let</code> rather than <code>unwrap_or_else</code> to check whether <code>run</code> returns an
<code>Err</code> value and call <code>process::exit(1)</code> if it does. The <code>run</code> function doesn’t
return a value that we want to <code>unwrap</code> in the same way that <code>Config::new</code>
returns the <code>Config</code> instance. Because <code>run</code> returns <code>()</code> in the success case,
we only care about detecting an error, so we don’t need <code>unwrap_or_else</code> to
return the unwrapped value because it would only be <code>()</code>.</p>
<p>The bodies of the <code>if let</code> and the <code>unwrap_or_else</code> functions are the same in
both cases: we print the error and exit.</p>
<h3><a class="header" href="#splitting-code-into-a-library-crate" id="splitting-code-into-a-library-crate">Splitting Code into a Library Crate</a></h3>
<p>Our <code>minigrep</code> project is looking good so far! Now we’ll split the
<em>src/main.rs</em> file and put some code into the <em>src/lib.rs</em> file so we can test
it and have a <em>src/main.rs</em> file with fewer responsibilities.</p>
<p>Let’s move all the code that isn’t the <code>main</code> function from <em>src/main.rs</em> to
<em>src/lib.rs</em>:</p>
<ul>
<li>The <code>run</code> function definition</li>
<li>The relevant <code>use</code> statements</li>
<li>The definition of <code>Config</code></li>
<li>The <code>Config::new</code> function definition</li>
</ul>
<p>The contents of <em>src/lib.rs</em> should have the signatures shown in Listing 12-13
(we’ve omitted the bodies of the functions for brevity). Note that this won’t
compile until we modify <em>src/main.rs</em> in Listing 12-14.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use std::error::Error;
use std::fs;

pub struct Config {
    pub query: String,
    pub filename: String,
}

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
    }
}

pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // --snip--
}
</code></pre>
<p><span class="caption">Listing 12-13: Moving <code>Config</code> and <code>run</code> into
<em>src/lib.rs</em></span></p>
<p>We’ve made liberal use of the <code>pub</code> keyword: on <code>Config</code>, on its fields and its
<code>new</code> method, and on the <code>run</code> function. We now have a library crate that has a
public API that we can test!</p>
<p>Now we need to bring the code we moved to <em>src/lib.rs</em> into the scope of the
binary crate in <em>src/main.rs</em>, as shown in Listing 12-14.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use std::env;
use std::process;

use minigrep::Config;

fn main() {
    // --snip--
    if let Err(e) = minigrep::run(config) {
        // --snip--
    }
}
</code></pre>
<p><span class="caption">Listing 12-14: Using the <code>minigrep</code> library crate in
<em>src/main.rs</em></span></p>
<p>We add a <code>use minigrep::Config</code> line to bring the <code>Config</code> type from the
library crate into the binary crate’s scope, and we prefix the <code>run</code> function
with our crate name. Now all the functionality should be connected and should
work. Run the program with <code>cargo run</code> and make sure everything works
correctly.</p>
<p>Whew! That was a lot of work, but we’ve set ourselves up for success in the
future. Now it’s much easier to handle errors, and we’ve made the code more
modular. Almost all of our work will be done in <em>src/lib.rs</em> from here on out.</p>
<p>Let’s take advantage of this newfound modularity by doing something that would
have been difficult with the old code but is easy with the new code: we’ll
write some tests!</p>
<h2><a class="header" href="#developing-the-librarys-functionality-with-test-driven-development" id="developing-the-librarys-functionality-with-test-driven-development">Developing the Library’s Functionality with Test-Driven Development</a></h2>
<p>Now that we’ve extracted the logic into <em>src/lib.rs</em> and left the argument
collecting and error handling in <em>src/main.rs</em>, it’s much easier to write tests
for the core functionality of our code. We can call functions directly with
various arguments and check return values without having to call our binary
from the command line. Feel free to write some tests for the functionality in
the <code>Config::new</code> and <code>run</code> functions on your own.</p>
<p>In this section, we’ll add the searching logic to the <code>minigrep</code> program by
using the Test-driven development (TDD) process. This software development
technique follows these steps:</p>
<ol>
<li>Write a test that fails and run it to make sure it fails for the reason you
expect.</li>
<li>Write or modify just enough code to make the new test pass.</li>
<li>Refactor the code you just added or changed and make sure the tests
continue to pass.</li>
<li>Repeat from step 1!</li>
</ol>
<p>This process is just one of many ways to write software, but TDD can help drive
code design as well. Writing the test before you write the code that makes the
test pass helps to maintain high test coverage throughout the process.</p>
<p>We’ll test drive the implementation of the functionality that will actually do
the searching for the query string in the file contents and produce a list of
lines that match the query. We’ll add this functionality in a function called
<code>search</code>.</p>
<h3><a class="header" href="#writing-a-failing-test" id="writing-a-failing-test">Writing a Failing Test</a></h3>
<p>Because we don’t need them anymore, let’s remove the <code>println!</code> statements from
<em>src/lib.rs</em> and <em>src/main.rs</em> that we used to check the program’s behavior.
Then, in <em>src/lib.rs</em>, we’ll add a <code>tests</code> module with a test function, as we
did in <a href="rustbook/ch11-01-writing-tests.html#the-anatomy-of-a-test-function">Chapter 11</a><!-- ignore -->. The test function specifies
the behavior we want the <code>search</code> function to have: it will take a query and
the text to search for the query in, and it will return only the lines from the
text that contain the query. Listing 12-15 shows this test, which won’t compile
yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">     vec![]
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn one_result() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 12-15: Creating a failing test for the <code>search</code>
function we wish we had</span></p>
<p>This test searches for the string <code>&quot;duct&quot;</code>. The text we’re searching is three
lines, only one of which contains <code>&quot;duct&quot;</code>. We assert that the value returned
from the <code>search</code> function contains only the line we expect.</p>
<p>We aren’t able to run this test and watch it fail because the test doesn’t even
compile: the <code>search</code> function doesn’t exist yet! So now we’ll add just enough
code to get the test to compile and run by adding a definition of the <code>search</code>
function that always returns an empty vector, as shown in Listing 12-16. Then
the test should compile and fail because an empty vector doesn’t match a vector
containing the line <code>&quot;safe, fast, productive.&quot;</code></p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    vec![]
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 12-16: Defining just enough of the <code>search</code>
function so our test will compile</span></p>
<p>Notice that we need an explicit lifetime <code>'a</code> defined in the signature of
<code>search</code> and used with the <code>contents</code> argument and the return value. Recall in
<a href="rustbook/ch10-03-lifetime-syntax.html">Chapter 10</a><!-- ignore --> that the lifetime parameters
specify which argument lifetime is connected to the lifetime of the return
value. In this case, we indicate that the returned vector should contain string
slices that reference slices of the argument <code>contents</code> (rather than the
argument <code>query</code>).</p>
<p>In other words, we tell Rust that the data returned by the <code>search</code> function
will live as long as the data passed into the <code>search</code> function in the
<code>contents</code> argument. This is important! The data referenced <em>by</em> a slice needs
to be valid for the reference to be valid; if the compiler assumes we’re making
string slices of <code>query</code> rather than <code>contents</code>, it will do its safety checking
incorrectly.</p>
<p>If we forget the lifetime annotations and try to compile this function, we’ll
get this error:</p>
<pre><code class="language-text">error[E0106]: missing lifetime specifier
 --&gt; src/lib.rs:5:51
  |
5 | pub fn search(query: &amp;str, contents: &amp;str) -&gt; Vec&lt;&amp;str&gt; {
  |                                                   ^ expected lifetime
parameter
  |
  = help: this function's return type contains a borrowed value, but the
  signature does not say whether it is borrowed from `query` or `contents`
</code></pre>
<p>Rust can’t possibly know which of the two arguments we need, so we need to tell
it. Because <code>contents</code> is the argument that contains all of our text and we
want to return the parts of that text that match, we know <code>contents</code> is the
argument that should be connected to the return value using the lifetime syntax.</p>
<p>Other programming languages don’t require you to connect arguments to return
values in the signature. Although this might seem strange, it will get easier
over time. You might want to compare this example with the <a href="rustbook/ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">“Validating
References with Lifetimes”</a><!-- ignore
--> section in Chapter 10.</p>
<p>Now let’s run the test:</p>
<pre><code class="language-text">$ cargo test
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
--warnings--
    Finished dev [unoptimized + debuginfo] target(s) in 0.43 secs
     Running target/debug/deps/minigrep-abcabcabc

running 1 test
test tests::one_result ... FAILED

failures:

---- tests::one_result stdout ----
        thread 'tests::one_result' panicked at 'assertion failed: `(left ==
right)`
left: `[&quot;safe, fast, productive.&quot;]`,
right: `[]`)', src/lib.rs:48:8
note: Run with `RUST_BACKTRACE=1` for a backtrace.


failures:
    tests::one_result

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Great, the test fails, exactly as we expected. Let’s get the test to pass!</p>
<h3><a class="header" href="#writing-code-to-pass-the-test" id="writing-code-to-pass-the-test">Writing Code to Pass the Test</a></h3>
<p>Currently, our test is failing because we always return an empty vector. To fix
that and implement <code>search</code>, our program needs to follow these steps:</p>
<ul>
<li>Iterate through each line of the contents.</li>
<li>Check whether the line contains our query string.</li>
<li>If it does, add it to the list of values we’re returning.</li>
<li>If it doesn’t, do nothing.</li>
<li>Return the list of results that match.</li>
</ul>
<p>Let’s work through each step, starting with iterating through lines.</p>
<h4><a class="header" href="#iterating-through-lines-with-the-lines-method" id="iterating-through-lines-with-the-lines-method">Iterating Through Lines with the <code>lines</code> Method</a></h4>
<p>Rust has a helpful method to handle line-by-line iteration of strings,
conveniently named <code>lines</code>, that works as shown in Listing 12-17. Note this
won’t compile yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        // do something with line
    }
}
</code></pre>
<p><span class="caption">Listing 12-17: Iterating through each line in <code>contents</code>
</span></p>
<p>The <code>lines</code> method returns an iterator. We’ll talk about iterators in depth in
[Chapter 13][ch13]<!-- ignore -->, but recall that you saw this way of using an
iterator in <a href="rustbook/ch03-05-control-flow.html#looping-through-a-collection-with-for">Listing 3-5</a><!-- ignore -->, where we used a <code>for</code> loop
with an iterator to run some code on each item in a collection.</p>
<h4><a class="header" href="#searching-each-line-for-the-query" id="searching-each-line-for-the-query">Searching Each Line for the Query</a></h4>
<p>Next, we’ll check whether the current line contains our query string.
Fortunately, strings have a helpful method named <code>contains</code> that does this for
us! Add a call to the <code>contains</code> method in the <code>search</code> function, as shown in
Listing 12-18. Note this still won’t compile yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    for line in contents.lines() {
        if line.contains(query) {
            // do something with line
        }
    }
}
</code></pre>
<p><span class="caption">Listing 12-18: Adding functionality to see whether the
line contains the string in <code>query</code></span></p>
<h4><a class="header" href="#storing-matching-lines" id="storing-matching-lines">Storing Matching Lines</a></h4>
<p>We also need a way to store the lines that contain our query string. For that,
we can make a mutable vector before the <code>for</code> loop and call the <code>push</code> method
to store a <code>line</code> in the vector. After the <code>for</code> loop, we return the vector, as
shown in Listing 12-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listing 12-19: Storing the lines that match so we can
return them</span></p>
<p>Now the <code>search</code> function should return only the lines that contain <code>query</code>,
and our test should pass. Let’s run the test:</p>
<pre><code class="language-text">$ cargo test
--snip--
running 1 test
test tests::one_result ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Our test passed, so we know it works!</p>
<p>At this point, we could consider opportunities for refactoring the
implementation of the search function while keeping the tests passing to
maintain the same functionality. The code in the search function isn’t too bad,
but it doesn’t take advantage of some useful features of iterators. We’ll
return to this example in [Chapter 13][ch13]<!-- ignore -->, where we’ll
explore iterators in detail, and look at how to improve it.</p>
<h4><a class="header" href="#using-the-search-function-in-the-run-function" id="using-the-search-function-in-the-run-function">Using the <code>search</code> Function in the <code>run</code> Function</a></h4>
<p>Now that the <code>search</code> function is working and tested, we need to call <code>search</code>
from our <code>run</code> function. We need to pass the <code>config.query</code> value and the
<code>contents</code> that <code>run</code> reads from the file to the <code>search</code> function. Then <code>run</code>
will print each line returned from <code>search</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    for line in search(&amp;config.query, &amp;contents) {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
</code></pre>
<p>We’re still using a <code>for</code> loop to return each line from <code>search</code> and print it.</p>
<p>Now the entire program should work! Let’s try it out, first with a word that
should return exactly one line from the Emily Dickinson poem, “frog”:</p>
<pre><code class="language-text">$ cargo run frog poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.38 secs
     Running `target/debug/minigrep frog poem.txt`
How public, like a frog
</code></pre>
<p>Cool! Now let’s try a word that will match multiple lines, like “body”:</p>
<pre><code class="language-text">$ cargo run body poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep body poem.txt`
I’m nobody! Who are you?
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>And finally, let’s make sure that we don’t get any lines when we search for a
word that isn’t anywhere in the poem, such as “monomorphization”:</p>
<pre><code class="language-text">$ cargo run monomorphization poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep monomorphization poem.txt`
</code></pre>
<p>Excellent! We’ve built our own mini version of a classic tool and learned a lot
about how to structure applications. We’ve also learned a bit about file input
and output, lifetimes, testing, and command line parsing.</p>
<p>To round out this project, we’ll briefly demonstrate how to work with
environment variables and how to print to standard error, both of which are
useful when you’re writing command line programs.</p>
<h2><a class="header" href="#working-with-environment-variables" id="working-with-environment-variables">Working with Environment Variables</a></h2>
<p>We’ll improve <code>minigrep</code> by adding an extra feature: an option for
case-insensitive searching that the user can turn on via an environment
variable. We could make this feature a command line option and require that
users enter it each time they want it to apply, but instead we’ll use an
environment variable. Doing so allows our users to set the environment variable
once and have all their searches be case insensitive in that terminal session.</p>
<h3><a class="header" href="#writing-a-failing-test-for-the-case-insensitive-search-function" id="writing-a-failing-test-for-the-case-insensitive-search-function">Writing a Failing Test for the Case-Insensitive <code>search</code> Function</a></h3>
<p>We want to add a new <code>search_case_insensitive</code> function that we’ll call when
the environment variable is on. We’ll continue to follow the TDD process, so
the first step is again to write a failing test. We’ll add a new test for the
new <code>search_case_insensitive</code> function and rename our old test from
<code>one_result</code> to <code>case_sensitive</code> to clarify the differences between the two
tests, as shown in Listing 12-20.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn case_sensitive() {
        let query = &quot;duct&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Duct tape.&quot;;

        assert_eq!(
            vec![&quot;safe, fast, productive.&quot;],
            search(query, contents)
        );
    }

    #[test]
    fn case_insensitive() {
        let query = &quot;rUsT&quot;;
        let contents = &quot;\
Rust:
safe, fast, productive.
Pick three.
Trust me.&quot;;

        assert_eq!(
            vec![&quot;Rust:&quot;, &quot;Trust me.&quot;],
            search_case_insensitive(query, contents)
        );
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 12-20: Adding a new failing test for the
case-insensitive function we’re about to add</span></p>
<p>Note that we’ve edited the old test’s <code>contents</code> too. We’ve added a new line
with the text <code>&quot;Duct tape.&quot;</code> using a capital D that shouldn’t match the query
<code>&quot;duct&quot;</code> when we’re searching in a case-sensitive manner. Changing the old test
in this way helps ensure that we don’t accidentally break the case-sensitive
search functionality that we’ve already implemented. This test should pass now
and should continue to pass as we work on the case-insensitive search.</p>
<p>The new test for the case-<em>insensitive</em> search uses <code>&quot;rUsT&quot;</code> as its query. In
the <code>search_case_insensitive</code> function we’re about to add, the query <code>&quot;rUsT&quot;</code>
should match the line containing <code>&quot;Rust:&quot;</code> with a capital R and match the line
<code>&quot;Trust me.&quot;</code> even though both have different casing from the query. This is
our failing test, and it will fail to compile because we haven’t yet defined
the <code>search_case_insensitive</code> function. Feel free to add a skeleton
implementation that always returns an empty vector, similar to the way we did
for the <code>search</code> function in Listing 12-16 to see the test compile and fail.</p>
<h3><a class="header" href="#implementing-the-search_case_insensitive-function" id="implementing-the-search_case_insensitive-function">Implementing the <code>search_case_insensitive</code> Function</a></h3>
<p>The <code>search_case_insensitive</code> function, shown in Listing 12-21, will be almost
the same as the <code>search</code> function. The only difference is that we’ll lowercase
the <code>query</code> and each <code>line</code> so whatever the case of the input arguments,
they’ll be the same case when we check whether the line contains the query.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let query = query.to_lowercase();
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.to_lowercase().contains(&amp;query) {
            results.push(line);
        }
    }

    results
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 12-21: Defining the <code>search_case_insensitive</code>
function to lowercase the query and the line before comparing them</span></p>
<p>First, we lowercase the <code>query</code> string and store it in a shadowed variable with
the same name. Calling <code>to_lowercase</code> on the query is necessary so no matter
whether the user’s query is <code>&quot;rust&quot;</code>, <code>&quot;RUST&quot;</code>, <code>&quot;Rust&quot;</code>, or <code>&quot;rUsT&quot;</code>, we’ll
treat the query as if it were <code>&quot;rust&quot;</code> and be insensitive to the case.</p>
<p>Note that <code>query</code> is now a <code>String</code> rather than a string slice, because calling
<code>to_lowercase</code> creates new data rather than referencing existing data. Say the
query is <code>&quot;rUsT&quot;</code>, as an example: that string slice doesn’t contain a lowercase
<code>u</code> or <code>t</code> for us to use, so we have to allocate a new <code>String</code> containing
<code>&quot;rust&quot;</code>. When we pass <code>query</code> as an argument to the <code>contains</code> method now, we
need to add an ampersand because the signature of <code>contains</code> is defined to take
a string slice.</p>
<p>Next, we add a call to <code>to_lowercase</code> on each <code>line</code> before we check whether it
contains <code>query</code> to lowercase all characters. Now that we’ve converted <code>line</code>
and <code>query</code> to lowercase, we’ll find matches no matter what the case of the
query is.</p>
<p>Let’s see if this implementation passes the tests:</p>
<pre><code class="language-text">running 2 tests
test tests::case_insensitive ... ok
test tests::case_sensitive ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Great! They passed. Now, let’s call the new <code>search_case_insensitive</code> function
from the <code>run</code> function. First, we’ll add a configuration option to the
<code>Config</code> struct to switch between case-sensitive and case-insensitive search.
Adding this field will cause compiler errors because we aren’t initializing
this field anywhere yet:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Config {
    pub query: String,
    pub filename: String,
    pub case_sensitive: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that we added the <code>case_sensitive</code> field that holds a Boolean. Next, we
need the <code>run</code> function to check the <code>case_sensitive</code> field’s value and use
that to decide whether to call the <code>search</code> function or the
<code>search_case_insensitive</code> function, as shown in Listing 12-22. Note this still
won’t compile yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::error::Error;
</span><span class="boring">use std::fs::{self, File};
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">
</span><span class="boring">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">     vec![]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn search_case_insensitive&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">     vec![]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">    case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>pub fn run(config: Config) -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let contents = fs::read_to_string(config.filename)?;

    let results = if config.case_sensitive {
        search(&amp;config.query, &amp;contents)
    } else {
        search_case_insensitive(&amp;config.query, &amp;contents)
    };

    for line in results {
        println!(&quot;{}&quot;, line);
    }

    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 12-22: Calling either <code>search</code> or
<code>search_case_insensitive</code> based on the value in <code>config.case_sensitive</code></span></p>
<p>Finally, we need to check for the environment variable. The functions for
working with environment variables are in the <code>env</code> module in the standard
library, so we want to bring that module into scope with a <code>use std::env;</code> line
at the top of <em>src/lib.rs</em>. Then we’ll use the <code>var</code> function from the <code>env</code>
module to check for an environment variable named <code>CASE_INSENSITIVE</code>, as shown
in Listing 12-23.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::env;
<span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">    case_sensitive: bool,
</span><span class="boring">}
</span>
// --snip--

impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 12-23: Checking for an environment variable named
<code>CASE_INSENSITIVE</code></span></p>
<p>Here, we create a new variable <code>case_sensitive</code>. To set its value, we call the
<code>env::var</code> function and pass it the name of the <code>CASE_INSENSITIVE</code> environment
variable. The <code>env::var</code> function returns a <code>Result</code> that will be the successful
<code>Ok</code> variant that contains the value of the environment variable if the
environment variable is set. It will return the <code>Err</code> variant if the
environment variable is not set.</p>
<p>We’re using the <code>is_err</code> method on the <code>Result</code> to check whether it’s an error
and therefore unset, which means it <em>should</em> do a case-sensitive search. If the
<code>CASE_INSENSITIVE</code> environment variable is set to anything, <code>is_err</code> will
return false and the program will perform a case-insensitive search. We don’t
care about the <em>value</em> of the environment variable, just whether it’s set or
unset, so we’re checking <code>is_err</code> rather than using <code>unwrap</code>, <code>expect</code>, or any
of the other methods we’ve seen on <code>Result</code>.</p>
<p>We pass the value in the <code>case_sensitive</code> variable to the <code>Config</code> instance so
the <code>run</code> function can read that value and decide whether to call <code>search</code> or
<code>search_case_insensitive</code>, as we implemented in Listing 12-22.</p>
<p>Let’s give it a try! First, we’ll run our program without the environment
variable set and with the query <code>to</code>, which should match any line that contains
the word “to” in all lowercase:</p>
<pre><code class="language-text">$ cargo run to poem.txt
   Compiling minigrep v0.1.0 (file:///projects/minigrep)
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>Looks like that still works! Now, let’s run the program with <code>CASE_INSENSITIVE</code>
set to <code>1</code> but with the same query <code>to</code>.</p>
<p>If you’re using PowerShell, you will need to set the environment variable and
run the program in two commands rather than one:</p>
<pre><code class="language-text">$ $env:CASE_INSENSITIVE=1
$ cargo run to poem.txt
</code></pre>
<p>We should get lines that contain “to” that might have uppercase letters:</p>
<pre><code class="language-text">$ CASE_INSENSITIVE=1 cargo run to poem.txt
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/minigrep to poem.txt`
Are you nobody, too?
How dreary to be somebody!
To tell your name the livelong day
To an admiring bog!
</code></pre>
<p>Excellent, we also got lines containing “To”! Our <code>minigrep</code> program can now do
case-insensitive searching controlled by an environment variable. Now you know
how to manage options set using either command line arguments or environment
variables.</p>
<p>Some programs allow arguments <em>and</em> environment variables for the same
configuration. In those cases, the programs decide that one or the other takes
precedence. For another exercise on your own, try controlling case
insensitivity through either a command line argument or an environment
variable. Decide whether the command line argument or the environment variable
should take precedence if the program is run with one set to case sensitive and
one set to case insensitive.</p>
<p>The <code>std::env</code> module contains many more useful features for dealing with
environment variables: check out its documentation to see what is available.</p>
<h2><a class="header" href="#writing-error-messages-to-standard-error-instead-of-standard-output" id="writing-error-messages-to-standard-error-instead-of-standard-output">Writing Error Messages to Standard Error Instead of Standard Output</a></h2>
<p>At the moment, we’re writing all of our output to the terminal using the
<code>println!</code> function. Most terminals provide two kinds of output: <em>standard
output</em> (<code>stdout</code>) for general information and <em>standard error</em> (<code>stderr</code>)
for error messages. This distinction enables users to choose to direct the
successful output of a program to a file but still print error messages to the
screen.</p>
<p>The <code>println!</code> function is only capable of printing to standard output, so we
have to use something else to print to standard error.</p>
<h3><a class="header" href="#checking-where-errors-are-written" id="checking-where-errors-are-written">Checking Where Errors Are Written</a></h3>
<p>First, let’s observe how the content printed by <code>minigrep</code> is currently being
written to standard output, including any error messages we want to write to
standard error instead. We’ll do that by redirecting the standard output stream
to a file while also intentionally causing an error. We won’t redirect the
standard error stream, so any content sent to standard error will continue to
display on the screen.</p>
<p>Command line programs are expected to send error messages to the standard error
stream so we can still see error messages on the screen even if we redirect the
standard output stream to a file. Our program is not currently well-behaved:
we’re about to see that it saves the error message output to a file instead!</p>
<p>The way to demonstrate this behavior is by running the program with <code>&gt;</code> and the
filename, <em>output.txt</em>, that we want to redirect the standard output stream to.
We won’t pass any arguments, which should cause an error:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
</code></pre>
<p>The <code>&gt;</code> syntax tells the shell to write the contents of standard output to
<em>output.txt</em> instead of the screen. We didn’t see the error message we were
expecting printed to the screen, so that means it must have ended up in the
file. This is what <em>output.txt</em> contains:</p>
<pre><code class="language-text">Problem parsing arguments: not enough arguments
</code></pre>
<p>Yup, our error message is being printed to standard output. It’s much more
useful for error messages like this to be printed to standard error so only
data from a successful run ends up in the file. We’ll change that.</p>
<h3><a class="header" href="#printing-errors-to-standard-error" id="printing-errors-to-standard-error">Printing Errors to Standard Error</a></h3>
<p>We’ll use the code in Listing 12-24 to change how error messages are printed.
Because of the refactoring we did earlier in this chapter, all the code that
prints error messages is in one function, <code>main</code>. The standard library provides
the <code>eprintln!</code> macro that prints to the standard error stream, so let’s change
the two places we were calling <code>println!</code> to print errors to use <code>eprintln!</code>
instead.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    if let Err(e) = minigrep::run(config) {
        eprintln!(&quot;Application error: {}&quot;, e);

        process::exit(1);
    }
}
</code></pre>
<p><span class="caption">Listing 12-24: Writing error messages to standard error
instead of standard output using <code>eprintln!</code></span></p>
<p>After changing <code>println!</code> to <code>eprintln!</code>, let’s run the program again in the
same way, without any arguments and redirecting standard output with <code>&gt;</code>:</p>
<pre><code class="language-text">$ cargo run &gt; output.txt
Problem parsing arguments: not enough arguments
</code></pre>
<p>Now we see the error onscreen and <em>output.txt</em> contains nothing, which is the
behavior we expect of command line programs.</p>
<p>Let’s run the program again with arguments that don’t cause an error but still
redirect standard output to a file, like so:</p>
<pre><code class="language-text">$ cargo run to poem.txt &gt; output.txt
</code></pre>
<p>We won’t see any output to the terminal, and <em>output.txt</em> will contain our
results:</p>
<p><span class="filename">Filename: output.txt</span></p>
<pre><code class="language-text">Are you nobody, too?
How dreary to be somebody!
</code></pre>
<p>This demonstrates that we’re now using standard output for successful output
and standard error for error output as appropriate.</p>
<h2><a class="header" href="#summary-11" id="summary-11">Summary</a></h2>
<p>This chapter recapped some of the major concepts you’ve learned so far and
covered how to perform common I/O operations in Rust. By using command line
arguments, files, environment variables, and the <code>eprintln!</code> macro for printing
errors, you’re now prepared to write command line applications. By using the
concepts in previous chapters, your code will be well organized, store data
effectively in the appropriate data structures, handle errors nicely, and be
well tested.</p>
<p>Next, we’ll explore some Rust features that were influenced by functional
languages: closures and iterators.</p>
<h1><a class="header" href="#functional-language-features-iterators-and-closures" id="functional-language-features-iterators-and-closures">Functional Language Features: Iterators and Closures</a></h1>
<p>Rust’s design has taken inspiration from many existing languages and
techniques, and one significant influence is <em>functional programming</em>.
Programming in a functional style often includes using functions as values by
passing them in arguments, returning them from other functions, assigning them
to variables for later execution, and so forth.</p>
<p>In this chapter, we won’t debate the issue of what functional programming is or
isn’t but will instead discuss some features of Rust that are similar to
features in many languages often referred to as functional.</p>
<p>More specifically, we’ll cover:</p>
<ul>
<li><em>Closures</em>, a function-like construct you can store in a variable</li>
<li><em>Iterators</em>, a way of processing a series of elements</li>
<li>How to use these two features to improve the I/O project in Chapter 12</li>
<li>The performance of these two features (Spoiler alert: they’re faster than you
might think!)</li>
</ul>
<p>Other Rust features, such as pattern matching and enums, which we’ve covered in
other chapters, are influenced by the functional style as well. Mastering
closures and iterators is an important part of writing idiomatic, fast Rust
code, so we’ll devote this entire chapter to them.</p>
<h2><a class="header" href="#closures-anonymous-functions-that-can-capture-their-environment" id="closures-anonymous-functions-that-can-capture-their-environment">Closures: Anonymous Functions that Can Capture Their Environment</a></h2>
<p>Rust’s closures are anonymous functions you can save in a variable or pass as
arguments to other functions. You can create the closure in one place and then
call the closure to evaluate it in a different context. Unlike functions,
closures can capture values from the scope in which they’re defined. We’ll
demonstrate how these closure features allow for code reuse and behavior
customization.</p>
<h3><a class="header" href="#creating-an-abstraction-of-behavior-with-closures" id="creating-an-abstraction-of-behavior-with-closures">Creating an Abstraction of Behavior with Closures</a></h3>
<p>Let’s work on an example of a situation in which it’s useful to store a closure
to be executed later. Along the way, we’ll talk about the syntax of closures,
type inference, and traits.</p>
<p>Consider this hypothetical situation: we work at a startup that’s making an app
to generate custom exercise workout plans. The backend is written in Rust, and
the algorithm that generates the workout plan takes into account many factors,
such as the app user’s age, body mass index, exercise preferences, recent
workouts, and an intensity number they specify. The actual algorithm used isn’t
important in this example; what’s important is that this calculation takes a
few seconds. We want to call this algorithm only when we need to and only call
it once so we don’t make the user wait more than necessary.</p>
<p>We’ll simulate calling this hypothetical algorithm with the function
<code>simulated_expensive_calculation</code> shown in Listing 13-1, which will print
<code>calculating slowly...</code>, wait for two seconds, and then return whatever number
we passed in.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::time::Duration;

fn simulated_expensive_calculation(intensity: u32) -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    intensity
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-1: A function to stand in for a hypothetical
calculation that takes about 2 seconds to run</span></p>
<p>Next is the <code>main</code> function, which contains the parts of the workout app
important for this example. This function represents the code that the app will
call when a user asks for a workout plan. Because the interaction with the
app’s frontend isn’t relevant to the use of closures, we’ll hardcode values
representing inputs to our program and print the outputs.</p>
<p>The required inputs are these:</p>
<ul>
<li>An intensity number from the user, which is specified when they request
a workout to indicate whether they want a low-intensity workout or a
high-intensity workout</li>
<li>A random number that will generate some variety in the workout plans</li>
</ul>
<p>The output will be the recommended workout plan. Listing 13-2 shows the <code>main</code>
function we’ll use.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let simulated_user_specified_value = 10;
    let simulated_random_number = 7;

    generate_workout(
        simulated_user_specified_value,
        simulated_random_number
    );
}
<span class="boring">fn generate_workout(intensity: u32, random_number: u32) {}
</span></code></pre></pre>
<p><span class="caption">Listing 13-2: A <code>main</code> function with hardcoded values to
simulate user input and random number generation</span></p>
<p>We’ve hardcoded the variable <code>simulated_user_specified_value</code> as 10 and the
variable <code>simulated_random_number</code> as 7 for simplicity’s sake; in an actual
program, we’d get the intensity number from the app frontend, and we’d use the
<code>rand</code> crate to generate a random number, as we did in the Guessing Game
example in Chapter 2. The <code>main</code> function calls a <code>generate_workout</code> function
with the simulated input values.</p>
<p>Now that we have the context, let’s get to the algorithm. The function
<code>generate_workout</code> in Listing 13-3 contains the business logic of the
app that we’re most concerned with in this example. The rest of the code
changes in this example will be made to this function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(num: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calculating slowly...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    num
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            simulated_expensive_calculation(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            simulated_expensive_calculation(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                simulated_expensive_calculation(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-3: The business logic that prints the workout
plans based on the inputs and calls to the <code>simulated_expensive_calculation</code>
function</span></p>
<p>The code in Listing 13-3 has multiple calls to the slow calculation function.
The first <code>if</code> block calls <code>simulated_expensive_calculation</code> twice, the <code>if</code>
inside the outer <code>else</code> doesn’t call it at all, and the code inside the
second <code>else</code> case calls it once.</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>The desired behavior of the <code>generate_workout</code> function is to first check
whether the user wants a low-intensity workout (indicated by a number less
than 25) or a high-intensity workout (a number of 25 or greater).</p>
<p>Low-intensity workout plans will recommend a number of push-ups and sit-ups
based on the complex algorithm we’re simulating.</p>
<p>If the user wants a high-intensity workout, there’s some additional logic: if
the value of the random number generated by the app happens to be 3, the app
will recommend a break and hydration. If not, the user will get a number of
minutes of running based on the complex algorithm.</p>
<p>This code works the way the business wants it to now, but let’s say the data
science team decides that we need to make some changes to the way we call the
<code>simulated_expensive_calculation</code> function in the future. To simplify the
update when those changes happen, we want to refactor this code so it calls the
<code>simulated_expensive_calculation</code> function only once. We also want to cut the
place where we’re currently unnecessarily calling the function twice without
adding any other calls to that function in the process. That is, we don’t want
to call it if the result isn’t needed, and we still want to call it only once.</p>
<h4><a class="header" href="#refactoring-using-functions" id="refactoring-using-functions">Refactoring Using Functions</a></h4>
<p>We could restructure the workout program in many ways. First, we’ll try
extracting the duplicated call to the <code>simulated_expensive_calculation</code>
function into a variable, as shown in Listing 13-4.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn simulated_expensive_calculation(num: u32) -&gt; u32 {
</span><span class="boring">    println!(&quot;calculating slowly...&quot;);
</span><span class="boring">    thread::sleep(Duration::from_secs(2));
</span><span class="boring">    num
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_result =
        simulated_expensive_calculation(intensity);

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-4: Extracting the calls to
<code>simulated_expensive_calculation</code> to one place and storing the result in the
<code>expensive_result</code> variable</span></p>
<p>This change unifies all the calls to <code>simulated_expensive_calculation</code> and
solves the problem of the first <code>if</code> block unnecessarily calling the function
twice. Unfortunately, we’re now calling this function and waiting for the
result in all cases, which includes the inner <code>if</code> block that doesn’t use the
result value at all.</p>
<p>We want to define code in one place in our program, but only <em>execute</em> that
code where we actually need the result. This is a use case for closures!</p>
<h4><a class="header" href="#refactoring-with-closures-to-store-code" id="refactoring-with-closures-to-store-code">Refactoring with Closures to Store Code</a></h4>
<p>Instead of always calling the <code>simulated_expensive_calculation</code> function before
the <code>if</code> blocks, we can define a closure and store the <em>closure</em> in a variable
rather than storing the result of the function call, as shown in Listing 13-5.
We can actually move the whole body of <code>simulated_expensive_calculation</code> within
the closure we’re introducing here.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>let expensive_closure = |num| {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
<span class="boring">expensive_closure(5);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-5: Defining a closure and storing it in the
<code>expensive_closure</code> variable</span></p>
<p>The closure definition comes after the <code>=</code> to assign it to the variable
<code>expensive_closure</code>. To define a closure, we start with a pair of vertical
pipes (<code>|</code>), inside which we specify the parameters to the closure; this syntax
was chosen because of its similarity to closure definitions in Smalltalk and
Ruby. This closure has one parameter named <code>num</code>: if we had more than one
parameter, we would separate them with commas, like <code>|param1, param2|</code>.</p>
<p>After the parameters, we place curly brackets that hold the body of the
closure—these are optional if the closure body is a single expression. The end
of the closure, after the curly brackets, needs a semicolon to complete the
<code>let</code> statement. The value returned from the last line in the closure body
(<code>num</code>) will be the value returned from the closure when it’s called, because
that line doesn’t end in a semicolon; just as in function bodies.</p>
<p>Note that this <code>let</code> statement means <code>expensive_closure</code> contains the
<em>definition</em> of an anonymous function, not the <em>resulting value</em> of calling the
anonymous function. Recall that we’re using a closure because we want to define
the code to call at one point, store that code, and call it at a later point;
the code we want to call is now stored in <code>expensive_closure</code>.</p>
<p>With the closure defined, we can change the code in the <code>if</code> blocks to call the
closure to execute the code and get the resulting value. We call a closure like
we do a function: we specify the variable name that holds the closure
definition and follow it with parentheses containing the argument values we
want to use, as shown in Listing 13-6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let expensive_closure = |num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    };

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_closure(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_closure(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_closure(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-6: Calling the <code>expensive_closure</code> we’ve
defined</span></p>
<p>Now the expensive calculation is called in only one place, and we’re only
executing that code where we need the results.</p>
<p>However, we’ve reintroduced one of the problems from Listing 13-3: we’re still
calling the closure twice in the first <code>if</code> block, which will call the
expensive code twice and make the user wait twice as long as they need to. We
could fix this problem by creating a variable local to that <code>if</code> block to hold
the result of calling the closure, but closures provide us with another
solution. We’ll talk about that solution in a bit. But first let’s talk about
why there aren’t type annotations in the closure definition and the traits
involved with closures.</p>
<h3><a class="header" href="#closure-type-inference-and-annotation" id="closure-type-inference-and-annotation">Closure Type Inference and Annotation</a></h3>
<p>Closures don’t require you to annotate the types of the parameters or the
return value like <code>fn</code> functions do. Type annotations are required on functions
because they’re part of an explicit interface exposed to your users. Defining
this interface rigidly is important for ensuring that everyone agrees on what
types of values a function uses and returns. But closures aren’t used in an
exposed interface like this: they’re stored in variables and used without
naming them and exposing them to users of our library.</p>
<p>Closures are usually short and relevant only within a narrow context rather
than in any arbitrary scenario. Within these limited contexts, the compiler is
reliably able to infer the types of the parameters and the return type, similar
to how it’s able to infer the types of most variables.</p>
<p>Making programmers annotate the types in these small, anonymous functions would
be annoying and largely redundant with the information the compiler already has
available.</p>
<p>As with variables, we can add type annotations if we want to increase
explicitness and clarity at the cost of being more verbose than is strictly
necessary. Annotating the types for the closure we defined in Listing 13-5
would look like the definition shown in Listing 13-7.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span>let expensive_closure = |num: u32| -&gt; u32 {
    println!(&quot;calculating slowly...&quot;);
    thread::sleep(Duration::from_secs(2));
    num
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-7: Adding optional type annotations of the
parameter and return value types in the closure</span></p>
<p>With type annotations added, the syntax of closures looks more similar to the
syntax of functions. The following is a vertical comparison of the syntax for
the definition of a function that adds 1 to its parameter and a closure that
has the same behavior. We’ve added some spaces to line up the relevant parts.
This illustrates how closure syntax is similar to function syntax except for
the use of pipes and the amount of syntax that is optional:</p>
<pre><code class="language-rust ignore">fn  add_one_v1   (x: u32) -&gt; u32 { x + 1 }
let add_one_v2 = |x: u32| -&gt; u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
</code></pre>
<p>The first line shows a function definition, and the second line shows a fully
annotated closure definition. The third line removes the type annotations from
the closure definition, and the fourth line removes the brackets, which are
optional because the closure body has only one expression. These are all valid
definitions that will produce the same behavior when they’re called.</p>
<p>Closure definitions will have one concrete type inferred for each of their
parameters and for their return value. For instance, Listing 13-8 shows the
definition of a short closure that just returns the value it receives as a
parameter. This closure isn’t very useful except for the purposes of this
example. Note that we haven’t added any type annotations to the definition: if
we then try to call the closure twice, using a <code>String</code> as an argument the
first time and a <code>u32</code> the second time, we’ll get an error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">let example_closure = |x| x;

let s = example_closure(String::from(&quot;hello&quot;));
let n = example_closure(5);
</code></pre>
<p><span class="caption">Listing 13-8: Attempting to call a closure whose types
are inferred with two different types</span></p>
<p>The compiler gives us this error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs
  |
  | let n = example_closure(5);
  |                         ^ expected struct `std::string::String`, found
  integral variable
  |
  = note: expected type `std::string::String`
             found type `{integer}`
</code></pre>
<p>The first time we call <code>example_closure</code> with the <code>String</code> value, the compiler
infers the type of <code>x</code> and the return type of the closure to be <code>String</code>. Those
types are then locked in to the closure in <code>example_closure</code>, and we get a type
error if we try to use a different type with the same closure.</p>
<h3><a class="header" href="#storing-closures-using-generic-parameters-and-the-fn-traits" id="storing-closures-using-generic-parameters-and-the-fn-traits">Storing Closures Using Generic Parameters and the <code>Fn</code> Traits</a></h3>
<p>Let’s return to our workout generation app. In Listing 13-6, our code was still
calling the expensive calculation closure more times than it needed to. One
option to solve this issue is to save the result of the expensive closure in a
variable for reuse and use the variable in each place we need the result,
instead of calling the closure again. However, this method could result in a
lot of repeated code.</p>
<p>Fortunately, another solution is available to us. We can create a struct that
will hold the closure and the resulting value of calling the closure. The
struct will execute the closure only if we need the resulting value, and it
will cache the resulting value so the rest of our code doesn’t have to be
responsible for saving and reusing the result. You may know this pattern as
<em>memoization</em> or <em>lazy evaluation</em>.</p>
<p>To make a struct that holds a closure, we need to specify the type of the
closure, because a struct definition needs to know the types of each of its
fields. Each closure instance has its own unique anonymous type: that is, even
if two closures have the same signature, their types are still considered
different. To define structs, enums, or function parameters that use closures,
we use generics and trait bounds, as we discussed in Chapter 10.</p>
<p>The <code>Fn</code> traits are provided by the standard library. All closures implement at
least one of the traits: <code>Fn</code>, <code>FnMut</code>, or <code>FnOnce</code>. We’ll discuss the
difference between these traits in the <a href="rustbook/ch13-01-closures.html#capturing-the-environment-with-closures">“Capturing the Environment with
Closures”</a><!-- ignore --> section; in
this example, we can use the <code>Fn</code> trait.</p>
<p>We add types to the <code>Fn</code> trait bound to represent the types of the parameters
and return values the closures must have to match this trait bound. In this
case, our closure has a parameter of type <code>u32</code> and returns a <code>u32</code>, so the
trait bound we specify is <code>Fn(u32) -&gt; u32</code>.</p>
<p>Listing 13-9 shows the definition of the <code>Cacher</code> struct that holds a closure
and an optional result value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    calculation: T,
    value: Option&lt;u32&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-9: Defining a <code>Cacher</code> struct that holds a
closure in <code>calculation</code> and an optional result in <code>value</code></span></p>
<p>The <code>Cacher</code> struct has a <code>calculation</code> field of the generic type <code>T</code>. The
trait bounds on <code>T</code> specify that it’s a closure by using the <code>Fn</code> trait. Any
closure we want to store in the <code>calculation</code> field must have one <code>u32</code>
parameter (specified within the parentheses after <code>Fn</code>) and must return a
<code>u32</code> (specified after the <code>-&gt;</code>).</p>
<blockquote>
<p>Note: Functions can implement all three of the <code>Fn</code> traits too. If what we
want to do doesn’t require capturing a value from the environment, we can use
a function rather than a closure where we need something that implements an
<code>Fn</code> trait.</p>
</blockquote>
<p>The <code>value</code> field is of type <code>Option&lt;u32&gt;</code>. Before we execute the closure,
<code>value</code> will be <code>None</code>. When code using a <code>Cacher</code> asks for the <em>result</em> of the
closure, the <code>Cacher</code> will execute the closure at that time and store the
result within a <code>Some</code> variant in the <code>value</code> field. Then if the code asks for
the result of the closure again, instead of executing the closure again, the
<code>Cacher</code> will return the result held in the <code>Some</code> variant.</p>
<p>The logic around the <code>value</code> field we’ve just described is defined in Listing
13-10.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">    where T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;T&gt; Cacher&lt;T&gt;
    where T: Fn(u32) -&gt; u32
{
    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
        Cacher {
            calculation,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: u32) -&gt; u32 {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
            },
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-10: The caching logic of <code>Cacher</code></span></p>
<p>We want <code>Cacher</code> to manage the struct fields’ values rather than letting the
calling code potentially change the values in these fields directly, so these
fields are private.</p>
<p>The <code>Cacher::new</code> function takes a generic parameter <code>T</code>, which we’ve defined
as having the same trait bound as the <code>Cacher</code> struct. Then <code>Cacher::new</code>
returns a <code>Cacher</code> instance that holds the closure specified in the
<code>calculation</code> field and a <code>None</code> value in the <code>value</code> field, because we haven’t
executed the closure yet.</p>
<p>When the calling code needs the result of evaluating the closure, instead of
calling the closure directly, it will call the <code>value</code> method. This method
checks whether we already have a resulting value in <code>self.value</code> in a <code>Some</code>;
if we do, it returns the value within the <code>Some</code> without executing the closure
again.</p>
<p>If <code>self.value</code> is <code>None</code>, the code calls the closure stored in
<code>self.calculation</code>, saves the result in <code>self.value</code> for future use, and
returns the value as well.</p>
<p>Listing 13-11 shows how we can use this <code>Cacher</code> struct in the function
<code>generate_workout</code> from Listing 13-6.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">struct Cacher&lt;T&gt;
</span><span class="boring">    where T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    calculation: T,
</span><span class="boring">    value: Option&lt;u32&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Cacher&lt;T&gt;
</span><span class="boring">    where T: Fn(u32) -&gt; u32
</span><span class="boring">{
</span><span class="boring">    fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
</span><span class="boring">        Cacher {
</span><span class="boring">            calculation,
</span><span class="boring">            value: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn value(&amp;mut self, arg: u32) -&gt; u32 {
</span><span class="boring">        match self.value {
</span><span class="boring">            Some(v) =&gt; v,
</span><span class="boring">            None =&gt; {
</span><span class="boring">                let v = (self.calculation)(arg);
</span><span class="boring">                self.value = Some(v);
</span><span class="boring">                v
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn generate_workout(intensity: u32, random_number: u32) {
    let mut expensive_result = Cacher::new(|num| {
        println!(&quot;calculating slowly...&quot;);
        thread::sleep(Duration::from_secs(2));
        num
    });

    if intensity &lt; 25 {
        println!(
            &quot;Today, do {} pushups!&quot;,
            expensive_result.value(intensity)
        );
        println!(
            &quot;Next, do {} situps!&quot;,
            expensive_result.value(intensity)
        );
    } else {
        if random_number == 3 {
            println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
        } else {
            println!(
                &quot;Today, run for {} minutes!&quot;,
                expensive_result.value(intensity)
            );
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-11: Using <code>Cacher</code> in the <code>generate_workout</code>
function to abstract away the caching logic</span></p>
<p>Instead of saving the closure in a variable directly, we save a new instance of
<code>Cacher</code> that holds the closure. Then, in each place we want the result, we
call the <code>value</code> method on the <code>Cacher</code> instance. We can call the <code>value</code>
method as many times as we want, or not call it at all, and the expensive
calculation will be run a maximum of once.</p>
<p>Try running this program with the <code>main</code> function from Listing 13-2. Change the
values in the <code>simulated_user_specified_value</code> and <code>simulated_random_number</code>
variables to verify that in all the cases in the various <code>if</code> and <code>else</code>
blocks, <code>calculating slowly...</code> appears only once and only when needed. The
<code>Cacher</code> takes care of the logic necessary to ensure we aren’t calling the
expensive calculation more than we need to so <code>generate_workout</code> can focus on
the business logic.</p>
<h3><a class="header" href="#limitations-of-the-cacher-implementation" id="limitations-of-the-cacher-implementation">Limitations of the <code>Cacher</code> Implementation</a></h3>
<p>Caching values is a generally useful behavior that we might want to use in
other parts of our code with different closures. However, there are two
problems with the current implementation of <code>Cacher</code> that would make reusing it
in different contexts difficult.</p>
<p>The first problem is that a <code>Cacher</code> instance assumes it will always get the
same value for the parameter <code>arg</code> to the <code>value</code> method. That is, this test of
<code>Cacher</code> will fail:</p>
<pre><code class="language-rust ignore panics">#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 2);
}
</code></pre>
<p>This test creates a new <code>Cacher</code> instance with a closure that returns the value
passed into it. We call the <code>value</code> method on this <code>Cacher</code> instance with an
<code>arg</code> value of 1 and then an <code>arg</code> value of 2, and we expect the call to
<code>value</code> with the <code>arg</code> value of 2 to return 2.</p>
<p>Run this test with the <code>Cacher</code> implementation in Listing 13-9 and Listing
13-10, and the test will fail on the <code>assert_eq!</code> with this message:</p>
<pre><code class="language-text">thread 'call_with_different_values' panicked at 'assertion failed: `(left == right)`
  left: `1`,
 right: `2`', src/main.rs
</code></pre>
<p>The problem is that the first time we called <code>c.value</code> with 1, the <code>Cacher</code>
instance saved <code>Some(1)</code> in <code>self.value</code>. Thereafter, no matter what we pass in
to the <code>value</code> method, it will always return 1.</p>
<p>Try modifying <code>Cacher</code> to hold a hash map rather than a single value. The keys
of the hash map will be the <code>arg</code> values that are passed in, and the values of
the hash map will be the result of calling the closure on that key. Instead of
looking at whether <code>self.value</code> directly has a <code>Some</code> or a <code>None</code> value, the
<code>value</code> function will look up the <code>arg</code> in the hash map and return the value if
it’s present. If it’s not present, the <code>Cacher</code> will call the closure and save
the resulting value in the hash map associated with its <code>arg</code> value.</p>
<p>The second problem with the current <code>Cacher</code> implementation is that it only
accepts closures that take one parameter of type <code>u32</code> and return a <code>u32</code>. We
might want to cache the results of closures that take a string slice and return
<code>usize</code> values, for example. To fix this issue, try introducing more generic
parameters to increase the flexibility of the <code>Cacher</code> functionality.</p>
<h3><a class="header" href="#capturing-the-environment-with-closures" id="capturing-the-environment-with-closures">Capturing the Environment with Closures</a></h3>
<p>In the workout generator example, we only used closures as inline anonymous
functions. However, closures have an additional capability that functions don’t
have: they can capture their environment and access variables from the scope in
which they’re defined.</p>
<p>Listing 13-12 has an example of a closure stored in the <code>equal_to_x</code> variable
that uses the <code>x</code> variable from the closure’s surrounding environment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 4;

    let equal_to_x = |z| z == x;

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre></pre>
<p><span class="caption">Listing 13-12: Example of a closure that refers to a
variable in its enclosing scope</span></p>
<p>Here, even though <code>x</code> is not one of the parameters of <code>equal_to_x</code>, the
<code>equal_to_x</code> closure is allowed to use the <code>x</code> variable that’s defined in the
same scope that <code>equal_to_x</code> is defined in.</p>
<p>We can’t do the same with functions; if we try with the following example, our
code won’t compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 4;

    fn equal_to_x(z: i32) -&gt; bool { z == x }

    let y = 4;

    assert!(equal_to_x(y));
}
</code></pre>
<p>We get an error:</p>
<pre><code class="language-text">error[E0434]: can't capture dynamic environment in a fn item; use the || { ...
} closure form instead
 --&gt; src/main.rs
  |
4 |     fn equal_to_x(z: i32) -&gt; bool { z == x }
  |                                          ^
</code></pre>
<p>The compiler even reminds us that this only works with closures!</p>
<p>When a closure captures a value from its environment, it uses memory to store
the values for use in the closure body. This use of memory is overhead that we
don’t want to pay in more common cases where we want to execute code that
doesn’t capture its environment. Because functions are never allowed to capture
their environment, defining and using functions will never incur this overhead.</p>
<p>Closures can capture values from their environment in three ways, which
directly map to the three ways a function can take a parameter: taking
ownership, borrowing mutably, and borrowing immutably. These are encoded in the
three <code>Fn</code> traits as follows:</p>
<ul>
<li><code>FnOnce</code> consumes the variables it captures from its enclosing scope, known
as the closure’s <em>environment</em>. To consume the captured variables, the
closure must take ownership of these variables and move them into the closure
when it is defined. The <code>Once</code> part of the name represents the fact that the
closure can’t take ownership of the same variables more than once, so it can
be called only once.</li>
<li><code>FnMut</code> can change the environment because it mutably borrows values.</li>
<li><code>Fn</code> borrows values from the environment immutably.</li>
</ul>
<p>When you create a closure, Rust infers which trait to use based on how the
closure uses the values from the environment. All closures implement <code>FnOnce</code>
because they can all be called at least once. Closures that don’t move the
captured variables also implement <code>FnMut</code>, and closures that don’t need mutable
access to the captured variables also implement <code>Fn</code>. In Listing 13-12, the
<code>equal_to_x</code> closure borrows <code>x</code> immutably (so <code>equal_to_x</code> has the <code>Fn</code> trait)
because the body of the closure only needs to read the value in <code>x</code>.</p>
<p>If you want to force the closure to take ownership of the values it uses in the
environment, you can use the <code>move</code> keyword before the parameter list. This
technique is mostly useful when passing a closure to a new thread to move the
data so it’s owned by the new thread.</p>
<p>We’ll have more examples of <code>move</code> closures in Chapter 16 when we talk about
concurrency. For now, here’s the code from Listing 13-12 with the <code>move</code>
keyword added to the closure definition and using vectors instead of integers,
because integers can be copied rather than moved; note that this code will not
yet compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = vec![1, 2, 3];

    let equal_to_x = move |z| z == x;

    println!(&quot;can't use x here: {:?}&quot;, x);

    let y = vec![1, 2, 3];

    assert!(equal_to_x(y));
}
</code></pre>
<p>We receive the following error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `x`
 --&gt; src/main.rs:6:40
  |
4 |     let equal_to_x = move |z| z == x;
  |                      -------- value moved (into closure) here
5 |
6 |     println!(&quot;can't use x here: {:?}&quot;, x);
  |                                        ^ value used here after move
  |
  = note: move occurs because `x` has type `std::vec::Vec&lt;i32&gt;`, which does not
  implement the `Copy` trait
</code></pre>
<p>The <code>x</code> value is moved into the closure when the closure is defined, because we
added the <code>move</code> keyword. The closure then has ownership of <code>x</code>, and <code>main</code>
isn’t allowed to use <code>x</code> anymore in the <code>println!</code> statement. Removing
<code>println!</code> will fix this example.</p>
<p>Most of the time when specifying one of the <code>Fn</code> trait bounds, you can start
with <code>Fn</code> and the compiler will tell you if you need <code>FnMut</code> or <code>FnOnce</code> based
on what happens in the closure body.</p>
<p>To illustrate situations where closures that can capture their environment are
useful as function parameters, let’s move on to our next topic: iterators.</p>
<h2><a class="header" href="#processing-a-series-of-items-with-iterators" id="processing-a-series-of-items-with-iterators">Processing a Series of Items with Iterators</a></h2>
<p>The iterator pattern allows you to perform some task on a sequence of items in
turn. An iterator is responsible for the logic of iterating over each item and
determining when the sequence has finished. When you use iterators, you don’t
have to reimplement that logic yourself.</p>
<p>In Rust, iterators are <em>lazy</em>, meaning they have no effect until you call
methods that consume the iterator to use it up. For example, the code in
Listing 13-13 creates an iterator over the items in the vector <code>v1</code> by calling
the <code>iter</code> method defined on <code>Vec&lt;T&gt;</code>. This code by itself doesn’t do anything
useful.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-13: Creating an iterator</span></p>
<p>Once we’ve created an iterator, we can use it in a variety of ways. In Listing
3-5 in Chapter 3, we used iterators with <code>for</code> loops to execute some code on
each item, although we glossed over what the call to <code>iter</code> did until now.</p>
<p>The example in Listing 13-14 separates the creation of the iterator from the
use of the iterator in the <code>for</code> loop. The iterator is stored in the <code>v1_iter</code>
variable, and no iteration takes place at that time. When the <code>for</code> loop is
called using the iterator in <code>v1_iter</code>, each element in the iterator is used in
one iteration of the loop, which prints out each value.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v1 = vec![1, 2, 3];

let v1_iter = v1.iter();

for val in v1_iter {
    println!(&quot;Got: {}&quot;, val);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-14: Using an iterator in a <code>for</code> loop</span></p>
<p>In languages that don’t have iterators provided by their standard libraries,
you would likely write this same functionality by starting a variable at index
0, using that variable to index into the vector to get a value, and
incrementing the variable value in a loop until it reached the total number of
items in the vector.</p>
<p>Iterators handle all that logic for you, cutting down on repetitive code you
could potentially mess up. Iterators give you more flexibility to use the same
logic with many different kinds of sequences, not just data structures you can
index into, like vectors. Let’s examine how iterators do that.</p>
<h3><a class="header" href="#the-iterator-trait-and-the-next-method" id="the-iterator-trait-and-the-next-method">The <code>Iterator</code> Trait and the <code>next</code> Method</a></h3>
<p>All iterators implement a trait named <code>Iterator</code> that is defined in the
standard library. The definition of the trait looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

    // methods with default implementations elided
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice this definition uses some new syntax: <code>type Item</code> and <code>Self::Item</code>,
which are defining an <em>associated type</em> with this trait. We’ll talk about
associated types in depth in Chapter 19. For now, all you need to know is that
this code says implementing the <code>Iterator</code> trait requires that you also define
an <code>Item</code> type, and this <code>Item</code> type is used in the return type of the <code>next</code>
method. In other words, the <code>Item</code> type will be the type returned from the
iterator.</p>
<p>The <code>Iterator</code> trait only requires implementors to define one method: the
<code>next</code> method, which returns one item of the iterator at a time wrapped in
<code>Some</code> and, when iteration is over, returns <code>None</code>.</p>
<p>We can call the <code>next</code> method on iterators directly; Listing 13-15 demonstrates
what values are returned from repeated calls to <code>next</code> on the iterator created
from the vector.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[test]
fn iterator_demonstration() {
    let v1 = vec![1, 2, 3];

    let mut v1_iter = v1.iter();

    assert_eq!(v1_iter.next(), Some(&amp;1));
    assert_eq!(v1_iter.next(), Some(&amp;2));
    assert_eq!(v1_iter.next(), Some(&amp;3));
    assert_eq!(v1_iter.next(), None);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-15: Calling the <code>next</code> method on an
iterator</span></p>
<p>Note that we needed to make <code>v1_iter</code> mutable: calling the <code>next</code> method on an
iterator changes internal state that the iterator uses to keep track of where
it is in the sequence. In other words, this code <em>consumes</em>, or uses up, the
iterator. Each call to <code>next</code> eats up an item from the iterator. We didn’t need
to make <code>v1_iter</code> mutable when we used a <code>for</code> loop because the loop took
ownership of <code>v1_iter</code> and made it mutable behind the scenes.</p>
<p>Also note that the values we get from the calls to <code>next</code> are immutable
references to the values in the vector. The <code>iter</code> method produces an iterator
over immutable references. If we want to create an iterator that takes
ownership of <code>v1</code> and returns owned values, we can call <code>into_iter</code> instead of
<code>iter</code>. Similarly, if we want to iterate over mutable references, we can call
<code>iter_mut</code> instead of <code>iter</code>.</p>
<h3><a class="header" href="#methods-that-consume-the-iterator" id="methods-that-consume-the-iterator">Methods that Consume the Iterator</a></h3>
<p>The <code>Iterator</code> trait has a number of different methods with default
implementations provided by the standard library; you can find out about these
methods by looking in the standard library API documentation for the <code>Iterator</code>
trait. Some of these methods call the <code>next</code> method in their definition, which
is why you’re required to implement the <code>next</code> method when implementing the
<code>Iterator</code> trait.</p>
<p>Methods that call <code>next</code> are called <em>consuming adaptors</em>, because calling them
uses up the iterator. One example is the <code>sum</code> method, which takes ownership of
the iterator and iterates through the items by repeatedly calling <code>next</code>, thus
consuming the iterator. As it iterates through, it adds each item to a running
total and returns the total when iteration is complete. Listing 13-16 has a
test illustrating a use of the <code>sum</code> method:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[test]
fn iterator_sum() {
    let v1 = vec![1, 2, 3];

    let v1_iter = v1.iter();

    let total: i32 = v1_iter.sum();

    assert_eq!(total, 6);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-16: Calling the <code>sum</code> method to get the total
of all items in the iterator</span></p>
<p>We aren’t allowed to use <code>v1_iter</code> after the call to <code>sum</code> because <code>sum</code> takes
ownership of the iterator we call it on.</p>
<h3><a class="header" href="#methods-that-produce-other-iterators" id="methods-that-produce-other-iterators">Methods that Produce Other Iterators</a></h3>
<p>Other methods defined on the <code>Iterator</code> trait, known as <em>iterator adaptors</em>,
allow you to change iterators into different kinds of iterators. You can chain
multiple calls to iterator adaptors to perform complex actions in a readable
way. But because all iterators are lazy, you have to call one of the consuming
adaptor methods to get results from calls to iterator adaptors.</p>
<p>Listing 13-17 shows an example of calling the iterator adaptor method <code>map</code>,
which takes a closure to call on each item to produce a new iterator. The
closure here creates a new iterator in which each item from the vector has been
incremented by 1. However, this code produces a warning:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

v1.iter().map(|x| x + 1);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-17: Calling the iterator adaptor <code>map</code> to
create a new iterator</span></p>
<p>The warning we get is this:</p>
<pre><code class="language-text">warning: unused `std::iter::Map` which must be used: iterator adaptors are lazy
and do nothing unless consumed
 --&gt; src/main.rs:4:5
  |
4 |     v1.iter().map(|x| x + 1);
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(unused_must_use)] on by default
</code></pre>
<p>The code in Listing 13-17 doesn’t do anything; the closure we’ve specified
never gets called. The warning reminds us why: iterator adaptors are lazy, and
we need to consume the iterator here.</p>
<p>To fix this and consume the iterator, we’ll use the <code>collect</code> method, which we
used in Chapter 12 with <code>env::args</code> in Listing 12-1. This method consumes the
iterator and collects the resulting values into a collection data type.</p>
<p>In Listing 13-18, we collect the results of iterating over the iterator that’s
returned from the call to <code>map</code> into a vector. This vector will end up
containing each item from the original vector incremented by 1.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v1: Vec&lt;i32&gt; = vec![1, 2, 3];

let v2: Vec&lt;_&gt; = v1.iter().map(|x| x + 1).collect();

assert_eq!(v2, vec![2, 3, 4]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-18: Calling the <code>map</code> method to create a new
iterator and then calling the <code>collect</code> method to consume the new iterator and
create a vector</span></p>
<p>Because <code>map</code> takes a closure, we can specify any operation we want to perform
on each item. This is a great example of how closures let you customize some
behavior while reusing the iteration behavior that the <code>Iterator</code> trait
provides.</p>
<h3><a class="header" href="#using-closures-that-capture-their-environment" id="using-closures-that-capture-their-environment">Using Closures that Capture Their Environment</a></h3>
<p>Now that we’ve introduced iterators, we can demonstrate a common use of
closures that capture their environment by using the <code>filter</code> iterator adaptor.
The <code>filter</code> method on an iterator takes a closure that takes each item from
the iterator and returns a Boolean. If the closure returns <code>true</code>, the value
will be included in the iterator produced by <code>filter</code>. If the closure returns
<code>false</code>, the value won’t be included in the resulting iterator.</p>
<p>In Listing 13-19, we use <code>filter</code> with a closure that captures the <code>shoe_size</code>
variable from its environment to iterate over a collection of <code>Shoe</code> struct
instances. It will return only shoes that are the specified size.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(PartialEq, Debug)]
struct Shoe {
    size: u32,
    style: String,
}

fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    shoes.into_iter()
        .filter(|s| s.size == shoe_size)
        .collect()
}

#[test]
fn filters_by_size() {
    let shoes = vec![
        Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
        Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
        Shoe { size: 10, style: String::from(&quot;boot&quot;) },
    ];

    let in_my_size = shoes_in_my_size(shoes, 10);

    assert_eq!(
        in_my_size,
        vec![
            Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
            Shoe { size: 10, style: String::from(&quot;boot&quot;) },
        ]
    );
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-19: Using the <code>filter</code> method with a closure
that captures <code>shoe_size</code></span></p>
<p>The <code>shoes_in_my_size</code> function takes ownership of a vector of shoes and a shoe
size as parameters. It returns a vector containing only shoes of the specified
size.</p>
<p>In the body of <code>shoes_in_my_size</code>, we call <code>into_iter</code> to create an iterator
that takes ownership of the vector. Then we call <code>filter</code> to adapt that
iterator into a new iterator that only contains elements for which the closure
returns <code>true</code>.</p>
<p>The closure captures the <code>shoe_size</code> parameter from the environment and
compares the value with each shoe’s size, keeping only shoes of the size
specified. Finally, calling <code>collect</code> gathers the values returned by the
adapted iterator into a vector that’s returned by the function.</p>
<p>The test shows that when we call <code>shoes_in_my_size</code>, we get back only shoes
that have the same size as the value we specified.</p>
<h3><a class="header" href="#creating-our-own-iterators-with-the-iterator-trait" id="creating-our-own-iterators-with-the-iterator-trait">Creating Our Own Iterators with the <code>Iterator</code> Trait</a></h3>
<p>We’ve shown that you can create an iterator by calling <code>iter</code>, <code>into_iter</code>, or
<code>iter_mut</code> on a vector. You can create iterators from the other collection
types in the standard library, such as hash map. You can also create iterators
that do anything you want by implementing the <code>Iterator</code> trait on your own
types. As previously mentioned, the only method you’re required to provide a
definition for is the <code>next</code> method. Once you’ve done that, you can use all
other methods that have default implementations provided by the <code>Iterator</code>
trait!</p>
<p>To demonstrate, let’s create an iterator that will only ever count from 1 to 5.
First, we’ll create a struct to hold some values. Then we’ll make this struct
into an iterator by implementing the <code>Iterator</code> trait and using the values in
that implementation.</p>
<p>Listing 13-20 has the definition of the <code>Counter</code> struct and an associated
<code>new</code> function to create instances of <code>Counter</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Counter {
    count: u32,
}

impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-20: Defining the <code>Counter</code> struct and a <code>new</code>
function that creates instances of <code>Counter</code> with an initial value of 0 for
<code>count</code></span></p>
<p>The <code>Counter</code> struct has one field named <code>count</code>. This field holds a <code>u32</code>
value that will keep track of where we are in the process of iterating from 1
to 5. The <code>count</code> field is private because we want the implementation of
<code>Counter</code> to manage its value. The <code>new</code> function enforces the behavior of
always starting new instances with a value of 0 in the <code>count</code> field.</p>
<p>Next, we’ll implement the <code>Iterator</code> trait for our <code>Counter</code> type by defining
the body of the <code>next</code> method to specify what we want to happen when this
iterator is used, as shown in Listing 13-21:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        self.count += 1;

        if self.count &lt; 6 {
            Some(self.count)
        } else {
            None
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-21: Implementing the <code>Iterator</code> trait on our
<code>Counter</code> struct</span></p>
<p>We set the associated <code>Item</code> type for our iterator to <code>u32</code>, meaning the
iterator will return <code>u32</code> values. Again, don’t worry about associated types
yet, we’ll cover them in Chapter 19.</p>
<p>We want our iterator to add 1 to the current state, so we initialized <code>count</code>
to 0 so it would return 1 first. If the value of <code>count</code> is less than 6, <code>next</code>
will return the current value wrapped in <code>Some</code>, but if <code>count</code> is 6 or higher,
our iterator will return <code>None</code>.</p>
<h4><a class="header" href="#using-our-counter-iterators-next-method" id="using-our-counter-iterators-next-method">Using Our <code>Counter</code> Iterator’s <code>next</code> Method</a></h4>
<p>Once we’ve implemented the <code>Iterator</code> trait, we have an iterator! Listing 13-22
shows a test demonstrating that we can use the iterator functionality of our
<code>Counter</code> struct by calling the <code>next</code> method on it directly, just as we did
with the iterator created from a vector in Listing 13-15.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        self.count += 1;
</span><span class="boring">
</span><span class="boring">        if self.count &lt; 6 {
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn calling_next_directly() {
    let mut counter = Counter::new();

    assert_eq!(counter.next(), Some(1));
    assert_eq!(counter.next(), Some(2));
    assert_eq!(counter.next(), Some(3));
    assert_eq!(counter.next(), Some(4));
    assert_eq!(counter.next(), Some(5));
    assert_eq!(counter.next(), None);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-22: Testing the functionality of the <code>next</code>
method implementation</span></p>
<p>This test creates a new <code>Counter</code> instance in the <code>counter</code> variable and then
calls <code>next</code> repeatedly, verifying that we have implemented the behavior we
want this iterator to have: returning the values from 1 to 5.</p>
<h4><a class="header" href="#using-other-iterator-trait-methods" id="using-other-iterator-trait-methods">Using Other <code>Iterator</code> Trait Methods</a></h4>
<p>We implemented the <code>Iterator</code> trait by defining the <code>next</code> method, so we
can now use any <code>Iterator</code> trait method’s default implementations as defined in
the standard library, because they all use the <code>next</code> method’s functionality.</p>
<p>For example, if for some reason we wanted to take the values produced by an
instance of <code>Counter</code>, pair them with values produced by another <code>Counter</code>
instance after skipping the first value, multiply each pair together, keep only
those results that are divisible by 3, and add all the resulting values
together, we could do so, as shown in the test in Listing 13-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Counter {
</span><span class="boring">    count: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Counter {
</span><span class="boring">    fn new() -&gt; Counter {
</span><span class="boring">        Counter { count: 0 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for Counter {
</span><span class="boring">    // Our iterator will produce u32s
</span><span class="boring">    type Item = u32;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        // increment our count. This is why we started at zero.
</span><span class="boring">        self.count += 1;
</span><span class="boring">
</span><span class="boring">        // check to see if we've finished counting or not.
</span><span class="boring">        if self.count &lt; 6 {
</span><span class="boring">            Some(self.count)
</span><span class="boring">        } else {
</span><span class="boring">            None
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[test]
fn using_other_iterator_trait_methods() {
    let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    assert_eq!(18, sum);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 13-23: Using a variety of <code>Iterator</code> trait
methods on our <code>Counter</code> iterator</span></p>
<p>Note that <code>zip</code> produces only four pairs; the theoretical fifth pair <code>(5, None)</code> is never produced because <code>zip</code> returns <code>None</code> when either of its input
iterators return <code>None</code>.</p>
<p>All of these method calls are possible because we specified how the <code>next</code>
method works, and the standard library provides default implementations for
other methods that call <code>next</code>.</p>
<h2><a class="header" href="#improving-our-io-project" id="improving-our-io-project">Improving Our I/O Project</a></h2>
<p>With this new knowledge about iterators, we can improve the I/O project in
Chapter 12 by using iterators to make places in the code clearer and more
concise. Let’s look at how iterators can improve our implementation of the
<code>Config::new</code> function and the <code>search</code> function.</p>
<h3><a class="header" href="#removing-a-clone-using-an-iterator" id="removing-a-clone-using-an-iterator">Removing a <code>clone</code> Using an Iterator</a></h3>
<p>In Listing 12-6, we added code that took a slice of <code>String</code> values and created
an instance of the <code>Config</code> struct by indexing into the slice and cloning the
values, allowing the <code>Config</code> struct to own those values. In Listing 13-24,
we’ve reproduced the implementation of the <code>Config::new</code> function as it was in
Listing 12-23:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(args: &amp;[String]) -&gt; Result&lt;Config, &amp;'static str&gt; {
        if args.len() &lt; 3 {
            return Err(&quot;not enough arguments&quot;);
        }

        let query = args[1].clone();
        let filename = args[2].clone();

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre>
<p><span class="caption">Listing 13-24: Reproduction of the <code>Config::new</code> function
from Listing 12-23</span></p>
<p>At the time, we said not to worry about the inefficient <code>clone</code> calls because
we would remove them in the future. Well, that time is now!</p>
<p>We needed <code>clone</code> here because we have a slice with <code>String</code> elements in the
parameter <code>args</code>, but the <code>new</code> function doesn’t own <code>args</code>. To return
ownership of a <code>Config</code> instance, we had to clone the values from the <code>query</code>
and <code>filename</code> fields of <code>Config</code> so the <code>Config</code> instance can own its values.</p>
<p>With our new knowledge about iterators, we can change the <code>new</code> function to
take ownership of an iterator as its argument instead of borrowing a slice.
We’ll use the iterator functionality instead of the code that checks the length
of the slice and indexes into specific locations. This will clarify what the
<code>Config::new</code> function is doing because the iterator will access the values.</p>
<p>Once <code>Config::new</code> takes ownership of the iterator and stops using indexing
operations that borrow, we can move the <code>String</code> values from the iterator into
<code>Config</code> rather than calling <code>clone</code> and making a new allocation.</p>
<h4><a class="header" href="#using-the-returned-iterator-directly" id="using-the-returned-iterator-directly">Using the Returned Iterator Directly</a></h4>
<p>Open your I/O project’s <em>src/main.rs</em> file, which should look like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;String&gt; = env::args().collect();

    let config = Config::new(&amp;args).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p>We’ll change the start of the <code>main</code> function that we had in Listing 12-24 to
the code in Listing 13-25. This won’t compile until we update <code>Config::new</code> as
well.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let config = Config::new(env::args()).unwrap_or_else(|err| {
        eprintln!(&quot;Problem parsing arguments: {}&quot;, err);
        process::exit(1);
    });

    // --snip--
}
</code></pre>
<p><span class="caption">Listing 13-25: Passing the return value of <code>env::args</code> to
<code>Config::new</code></span></p>
<p>The <code>env::args</code> function returns an iterator! Rather than collecting the
iterator values into a vector and then passing a slice to <code>Config::new</code>, now
we’re passing ownership of the iterator returned from <code>env::args</code> to
<code>Config::new</code> directly.</p>
<p>Next, we need to update the definition of <code>Config::new</code>. In your I/O project’s
<em>src/lib.rs</em> file, let’s change the signature of <code>Config::new</code> to look like
Listing 13-26. This still won’t compile because we need to update the function
body.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        // --snip--
</code></pre>
<p><span class="caption">Listing 13-26: Updating the signature of <code>Config::new</code> to
expect an iterator</span></p>
<p>The standard library documentation for the <code>env::args</code> function shows that the
type of the iterator it returns is <code>std::env::Args</code>. We’ve updated the
signature of the <code>Config::new</code> function so the parameter <code>args</code> has the type
<code>std::env::Args</code> instead of <code>&amp;[String]</code>. Because we’re taking ownership of
<code>args</code> and we’ll be mutating <code>args</code> by iterating over it, we can add the <code>mut</code>
keyword into the specification of the <code>args</code> parameter to make it mutable.</p>
<h4><a class="header" href="#using-iterator-trait-methods-instead-of-indexing" id="using-iterator-trait-methods-instead-of-indexing">Using <code>Iterator</code> Trait Methods Instead of Indexing</a></h4>
<p>Next, we’ll fix the body of <code>Config::new</code>. The standard library documentation
also mentions that <code>std::env::Args</code> implements the <code>Iterator</code> trait, so we know
we can call the <code>next</code> method on it! Listing 13-27 updates the code from
Listing 12-23 to use the <code>next</code> method:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span><span class="boring">use std::env;
</span><span class="boring">
</span><span class="boring">struct Config {
</span><span class="boring">    query: String,
</span><span class="boring">    filename: String,
</span><span class="boring">    case_sensitive: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Config {
    pub fn new(mut args: std::env::Args) -&gt; Result&lt;Config, &amp;'static str&gt; {
        args.next();

        let query = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a query string&quot;),
        };

        let filename = match args.next() {
            Some(arg) =&gt; arg,
            None =&gt; return Err(&quot;Didn't get a file name&quot;),
        };

        let case_sensitive = env::var(&quot;CASE_INSENSITIVE&quot;).is_err();

        Ok(Config { query, filename, case_sensitive })
    }
}
</code></pre></pre>
<p><span class="caption">Listing 13-27: Changing the body of <code>Config::new</code> to use
iterator methods</span></p>
<p>Remember that the first value in the return value of <code>env::args</code> is the name of
the program. We want to ignore that and get to the next value, so first we call
<code>next</code> and do nothing with the return value. Second, we call <code>next</code> to get the
value we want to put in the <code>query</code> field of <code>Config</code>. If <code>next</code> returns a
<code>Some</code>, we use a <code>match</code> to extract the value. If it returns <code>None</code>, it means
not enough arguments were given and we return early with an <code>Err</code> value. We do
the same thing for the <code>filename</code> value.</p>
<h3><a class="header" href="#making-code-clearer-with-iterator-adaptors" id="making-code-clearer-with-iterator-adaptors">Making Code Clearer with Iterator Adaptors</a></h3>
<p>We can also take advantage of iterators in the <code>search</code> function in our I/O
project, which is reproduced here in Listing 13-28 as it was in Listing 12-19:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut results = Vec::new();

    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre>
<p><span class="caption">Listing 13-28: The implementation of the <code>search</code>
function from Listing 12-19</span></p>
<p>We can write this code in a more concise way using iterator adaptor methods.
Doing so also lets us avoid having a mutable intermediate <code>results</code> vector. The
functional programming style prefers to minimize the amount of mutable state to
make code clearer. Removing the mutable state might enable a future enhancement
to make searching happen in parallel, because we wouldn’t have to manage
concurrent access to the <code>results</code> vector. Listing 13-29 shows this change:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub fn search&lt;'a&gt;(query: &amp;str, contents: &amp;'a str) -&gt; Vec&lt;&amp;'a str&gt; {
    contents.lines()
        .filter(|line| line.contains(query))
        .collect()
}
</code></pre>
<p><span class="caption">Listing 13-29: Using iterator adaptor methods in the
implementation of the <code>search</code> function</span></p>
<p>Recall that the purpose of the <code>search</code> function is to return all lines in
<code>contents</code> that contain the <code>query</code>. Similar to the <code>filter</code> example in Listing
13-19, this code uses the <code>filter</code> adaptor to keep only the lines that
<code>line.contains(query)</code> returns <code>true</code> for. We then collect the matching lines
into another vector with <code>collect</code>. Much simpler! Feel free to make the same
change to use iterator methods in the <code>search_case_insensitive</code> function as
well.</p>
<p>The next logical question is which style you should choose in your own code and
why: the original implementation in Listing 13-28 or the version using
iterators in Listing 13-29. Most Rust programmers prefer to use the iterator
style. It’s a bit tougher to get the hang of at first, but once you get a feel
for the various iterator adaptors and what they do, iterators can be easier to
understand. Instead of fiddling with the various bits of looping and building
new vectors, the code focuses on the high-level objective of the loop. This
abstracts away some of the commonplace code so it’s easier to see the concepts
that are unique to this code, such as the filtering condition each element in
the iterator must pass.</p>
<p>But are the two implementations truly equivalent? The intuitive assumption
might be that the more low-level loop will be faster. Let’s talk about
performance.</p>
<h2><a class="header" href="#comparing-performance-loops-vs-iterators" id="comparing-performance-loops-vs-iterators">Comparing Performance: Loops vs. Iterators</a></h2>
<p>To determine whether to use loops or iterators, you need to know which version
of our <code>search</code> functions is faster: the version with an explicit <code>for</code> loop or
the version with iterators.</p>
<p>We ran a benchmark by loading the entire contents of <em>The Adventures of
Sherlock Holmes</em> by Sir Arthur Conan Doyle into a <code>String</code> and looking for the
word <em>the</em> in the contents. Here are the results of the benchmark on the
version of <code>search</code> using the <code>for</code> loop and the version using iterators:</p>
<pre><code class="language-text">test bench_search_for  ... bench:  19,620,300 ns/iter (+/- 915,700)
test bench_search_iter ... bench:  19,234,900 ns/iter (+/- 657,200)
</code></pre>
<p>The iterator version was slightly faster! We won’t explain the benchmark code
here, because the point is not to prove that the two versions are equivalent
but to get a general sense of how these two implementations compare
performance-wise.</p>
<p>For a more comprehensive benchmark, you should check using various texts of
various sizes as the <code>contents</code>, different words and words of different lengths
as the <code>query</code>, and all kinds of other variations. The point is this:
iterators, although a high-level abstraction, get compiled down to roughly the
same code as if you’d written the lower-level code yourself. Iterators are one
of Rust’s <em>zero-cost abstractions</em>, by which we mean using the abstraction
imposes no additional runtime overhead. This is analogous to how Bjarne
Stroustrup, the original designer and implementor of C++, defines
<em>zero-overhead</em> in “Foundations of C++” (2012):</p>
<blockquote>
<p>In general, C++ implementations obey the zero-overhead principle: What you
don’t use, you don’t pay for. And further: What you do use, you couldn’t hand
code any better.</p>
</blockquote>
<p>As another example, the following code is taken from an audio decoder. The
decoding algorithm uses the linear prediction mathematical operation to
estimate future values based on a linear function of the previous samples. This
code uses an iterator chain to do some math on three variables in scope: a
<code>buffer</code> slice of data, an array of 12 <code>coefficients</code>, and an amount by which
to shift data in <code>qlp_shift</code>. We’ve declared the variables within this example
but not given them any values; although this code doesn’t have much meaning
outside of its context, it’s still a concise, real-world example of how Rust
translates high-level ideas to low-level code.</p>
<pre><code class="language-rust ignore">let buffer: &amp;mut [i32];
let coefficients: [i64; 12];
let qlp_shift: i16;

for i in 12..buffer.len() {
    let prediction = coefficients.iter()
                                 .zip(&amp;buffer[i - 12..i])
                                 .map(|(&amp;c, &amp;s)| c * s as i64)
                                 .sum::&lt;i64&gt;() &gt;&gt; qlp_shift;
    let delta = buffer[i];
    buffer[i] = prediction as i32 + delta;
}
</code></pre>
<p>To calculate the value of <code>prediction</code>, this code iterates through each of the
12 values in <code>coefficients</code> and uses the <code>zip</code> method to pair the coefficient
values with the previous 12 values in <code>buffer</code>. Then, for each pair, we
multiply the values together, sum all the results, and shift the bits in the
sum <code>qlp_shift</code> bits to the right.</p>
<p>Calculations in applications like audio decoders often prioritize performance
most highly. Here, we’re creating an iterator, using two adaptors, and then
consuming the value. What assembly code would this Rust code compile to? Well,
as of this writing, it compiles down to the same assembly you’d write by hand.
There’s no loop at all corresponding to the iteration over the values in
<code>coefficients</code>: Rust knows that there are 12 iterations, so it “unrolls” the
loop. <em>Unrolling</em> is an optimization that removes the overhead of the loop
controlling code and instead generates repetitive code for each iteration of
the loop.</p>
<p>All of the coefficients get stored in registers, which means accessing the
values is very fast. There are no bounds checks on the array access at runtime.
All these optimizations that Rust is able to apply make the resulting code
extremely efficient. Now that you know this, you can use iterators and closures
without fear! They make code seem like it’s higher level but don’t impose a
runtime performance penalty for doing so.</p>
<h2><a class="header" href="#summary-12" id="summary-12">Summary</a></h2>
<p>Closures and iterators are Rust features inspired by functional programming
language ideas. They contribute to Rust’s capability to clearly express
high-level ideas at low-level performance. The implementations of closures and
iterators are such that runtime performance is not affected. This is part of
Rust’s goal to strive to provide zero-cost abstractions.</p>
<p>Now that we’ve improved the expressiveness of our I/O project, let’s look at
some more features of <code>cargo</code> that will help us share the project with the
world.</p>
<h1><a class="header" href="#more-about-cargo-and-cratesio" id="more-about-cargo-and-cratesio">More About Cargo and Crates.io</a></h1>
<p>So far we’ve used only the most basic features of Cargo to build, run, and test
our code, but it can do a lot more. In this chapter, we’ll discuss some of its
other, more advanced features to show you how to do the following:</p>
<ul>
<li>Customize your build through release profiles</li>
<li>Publish libraries on <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Organize large projects with workspaces</li>
<li>Install binaries from <a href="https://crates.io/">crates.io</a><!-- ignore --></li>
<li>Extend Cargo using custom commands</li>
</ul>
<p>Cargo can do even more than what we cover in this chapter, so for a full
explanation of all its features, see <a href="https://doc.rust-lang.org/cargo/">its
documentation</a>.</p>
<h2><a class="header" href="#customizing-builds-with-release-profiles" id="customizing-builds-with-release-profiles">Customizing Builds with Release Profiles</a></h2>
<p>In Rust, <em>release profiles</em> are predefined and customizable profiles with
different configurations that allow a programmer to have more control over
various options for compiling code. Each profile is configured independently of
the others.</p>
<p>Cargo has two main profiles: the <code>dev</code> profile Cargo uses when you run <code>cargo build</code> and the <code>release</code> profile Cargo uses when you run <code>cargo build --release</code>. The <code>dev</code> profile is defined with good defaults for development,
and the <code>release</code> profile has good defaults for release builds.</p>
<p>These profile names might be familiar from the output of your builds:</p>
<pre><code class="language-text">$ cargo build
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
$ cargo build --release
    Finished release [optimized] target(s) in 0.0 secs
</code></pre>
<p>The <code>dev</code> and <code>release</code> shown in this build output indicate that the compiler
is using different profiles.</p>
<p>Cargo has default settings for each of the profiles that apply when there
aren’t any <code>[profile.*]</code> sections in the project’s <em>Cargo.toml</em> file. By adding
<code>[profile.*]</code> sections for any profile you want to customize, you can override
any subset of the default settings. For example, here are the default values
for the <code>opt-level</code> setting for the <code>dev</code> and <code>release</code> profiles:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3
</code></pre>
<p>The <code>opt-level</code> setting controls the number of optimizations Rust will apply to
your code, with a range of 0 to 3. Applying more optimizations extends
compiling time, so if you’re in development and compiling your code often,
you’ll want faster compiling even if the resulting code runs slower. That is
the reason the default <code>opt-level</code> for <code>dev</code> is <code>0</code>. When you’re ready to
release your code, it’s best to spend more time compiling. You’ll only compile
in release mode once, but you’ll run the compiled program many times, so
release mode trades longer compile time for code that runs faster. That is why
the default <code>opt-level</code> for the <code>release</code> profile is <code>3</code>.</p>
<p>You can override any default setting by adding a different value for it in
<em>Cargo.toml</em>. For example, if we want to use optimization level 1 in the
development profile, we can add these two lines to our project’s <em>Cargo.toml</em>
file:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1
</code></pre>
<p>This code overrides the default setting of <code>0</code>. Now when we run <code>cargo build</code>,
Cargo will use the defaults for the <code>dev</code> profile plus our customization to
<code>opt-level</code>. Because we set <code>opt-level</code> to <code>1</code>, Cargo will apply more
optimizations than the default, but not as many as in a release build.</p>
<p>For the full list of configuration options and defaults for each profile, see
<a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a>.</p>
<h2><a class="header" href="#publishing-a-crate-to-cratesio" id="publishing-a-crate-to-cratesio">Publishing a Crate to Crates.io</a></h2>
<p>We’ve used packages from <a href="https://crates.io/">crates.io</a><!-- ignore --> as
dependencies of our project, but you can also share your code with other people
by publishing your own packages. The crate registry at
<a href="https://crates.io/">crates.io</a><!-- ignore --> distributes the source code of
your packages, so it primarily hosts code that is open source.</p>
<p>Rust and Cargo have features that help make your published package easier for
people to use and to find in the first place. We’ll talk about some of these
features next and then explain how to publish a package.</p>
<h3><a class="header" href="#making-useful-documentation-comments" id="making-useful-documentation-comments">Making Useful Documentation Comments</a></h3>
<p>Accurately documenting your packages will help other users know how and when to
use them, so it’s worth investing the time to write documentation. In Chapter
3, we discussed how to comment Rust code using two slashes, <code>//</code>. Rust also has
a particular kind of comment for documentation, known conveniently as a
<em>documentation comment</em>, that will generate HTML documentation. The HTML
displays the contents of documentation comments for public API items intended
for programmers interested in knowing how to <em>use</em> your crate as opposed to how
your crate is <em>implemented</em>.</p>
<p>Documentation comments use three slashes, <code>///</code>, instead of two and support
Markdown notation for formatting the text. Place documentation comments just
before the item they’re documenting. Listing 14-1 shows documentation comments
for an <code>add_one</code> function in a crate named <code>my_crate</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre>
<p><span class="caption">Listing 14-1: A documentation comment for a
function</span></p>
<p>Here, we give a description of what the <code>add_one</code> function does, start a
section with the heading <code>Examples</code>, and then provide code that demonstrates
how to use the <code>add_one</code> function. We can generate the HTML documentation from
this documentation comment by running <code>cargo doc</code>. This command runs the
<code>rustdoc</code> tool distributed with Rust and puts the generated HTML documentation
in the <em>target/doc</em> directory.</p>
<p>For convenience, running <code>cargo doc --open</code> will build the HTML for your
current crate’s documentation (as well as the documentation for all of your
crate’s dependencies) and open the result in a web browser. Navigate to the
<code>add_one</code> function and you’ll see how the text in the documentation comments is
rendered, as shown in Figure 14-1:</p>
<img alt="Rendered HTML documentation for the `add_one` function of `my_crate`" src="rustbook/img/trpl14-01.png" class="center" />
<p><span class="caption">Figure 14-1: HTML documentation for the <code>add_one</code>
function</span></p>
<h4><a class="header" href="#commonly-used-sections" id="commonly-used-sections">Commonly Used Sections</a></h4>
<p>We used the <code># Examples</code> Markdown heading in Listing 14-1 to create a section
in the HTML with the title “Examples.” Here are some other sections that crate
authors commonly use in their documentation:</p>
<ul>
<li><strong>Panics</strong>: The scenarios in which the function being documented could
panic. Callers of the function who don’t want their programs to panic should
make sure they don’t call the function in these situations.</li>
<li><strong>Errors</strong>: If the function returns a <code>Result</code>, describing the kinds of
errors that might occur and what conditions might cause those errors to be
returned can be helpful to callers so they can write code to handle the
different kinds of errors in different ways.</li>
<li><strong>Safety</strong>: If the function is <code>unsafe</code> to call (we discuss unsafety in
Chapter 19), there should be a section explaining why the function is unsafe
and covering the invariants that the function expects callers to uphold.</li>
</ul>
<p>Most documentation comments don’t need all of these sections, but this is a
good checklist to remind you of the aspects of your code that people calling
your code will be interested in knowing about.</p>
<h4><a class="header" href="#documentation-comments-as-tests" id="documentation-comments-as-tests">Documentation Comments as Tests</a></h4>
<p>Adding example code blocks in your documentation comments can help demonstrate
how to use your library, and doing so has an additional bonus: running <code>cargo test</code> will run the code examples in your documentation as tests! Nothing is
better than documentation with examples. But nothing is worse than examples
that don’t work because the code has changed since the documentation was
written. If we run <code>cargo test</code> with the documentation for the <code>add_one</code>
function from Listing 14-1, we will see a section in the test results like this:</p>
<pre><code class="language-text">   Doc-tests my_crate

running 1 test
test src/lib.rs - add_one (line 5) ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Now if we change either the function or the example so the <code>assert_eq!</code> in the
example panics and run <code>cargo test</code> again, we’ll see that the doc tests catch
that the example and the code are out of sync with each other!</p>
<h4><a class="header" href="#commenting-contained-items" id="commenting-contained-items">Commenting Contained Items</a></h4>
<p>Another style of doc comment, <code>//!</code>, adds documentation to the item that
contains the comments rather than adding documentation to the items following
the comments. We typically use these doc comments inside the crate root file
(<em>src/lib.rs</em> by convention) or inside a module to document the crate or the
module as a whole.</p>
<p>For example, if we want to add documentation that describes the purpose of the
<code>my_crate</code> crate that contains the <code>add_one</code> function, we can add documentation
comments that start with <code>//!</code> to the beginning of the <em>src/lib.rs</em> file, as
shown in Listing 14-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.

/// Adds one to the number given.
// --snip--
</code></pre>
<p><span class="caption">Listing 14-2: Documentation for the <code>my_crate</code> crate as a
whole</span></p>
<p>Notice there isn’t any code after the last line that begins with <code>//!</code>. Because
we started the comments with <code>//!</code> instead of <code>///</code>, we’re documenting the item
that contains this comment rather than an item that follows this comment. In
this case, the item that contains this comment is the <em>src/lib.rs</em> file, which
is the crate root. These comments describe the entire crate.</p>
<p>When we run <code>cargo doc --open</code>, these comments will display on the front
page of the documentation for <code>my_crate</code> above the list of public items in the
crate, as shown in Figure 14-2:</p>
<img alt="Rendered HTML documentation with a comment for the crate as a whole" src="rustbook/img/trpl14-02.png" class="center" />
<p><span class="caption">Figure 14-2: Rendered documentation for <code>my_crate</code>,
including the comment describing the crate as a whole</span></p>
<p>Documentation comments within items are useful for describing crates and
modules especially. Use them to explain the overall purpose of the container to
help your users understand the crate’s organization.</p>
<h3><a class="header" href="#exporting-a-convenient-public-api-with-pub-use" id="exporting-a-convenient-public-api-with-pub-use">Exporting a Convenient Public API with <code>pub use</code></a></h3>
<p>In Chapter 7, we covered how to organize our code into modules using the <code>mod</code>
keyword, how to make items public using the <code>pub</code> keyword, and how to bring
items into a scope with the <code>use</code> keyword. However, the structure that makes
sense to you while you’re developing a crate might not be very convenient for
your users. You might want to organize your structs in a hierarchy containing
multiple levels, but then people who want to use a type you’ve defined deep in
the hierarchy might have trouble finding out that type exists. They might also
be annoyed at having to enter <code>use</code>
<code>my_crate::some_module::another_module::UsefulType;</code> rather than <code>use</code>
<code>my_crate::UsefulType;</code>.</p>
<p>The structure of your public API is a major consideration when publishing a
crate. People who use your crate are less familiar with the structure than you
are and might have difficulty finding the pieces they want to use if your crate
has a large module hierarchy.</p>
<p>The good news is that if the structure <em>isn’t</em> convenient for others to use
from another library, you don’t have to rearrange your internal organization:
instead, you can re-export items to make a public structure that’s different
from your private structure by using <code>pub use</code>. Re-exporting takes a public
item in one location and makes it public in another location, as if it were
defined in the other location instead.</p>
<p>For example, say we made a library named <code>art</code> for modeling artistic concepts.
Within this library are two modules: a <code>kinds</code> module containing two enums
named <code>PrimaryColor</code> and <code>SecondaryColor</code> and a <code>utils</code> module containing a
function named <code>mix</code>, as shown in Listing 14-3:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">//! # Art
//!
//! A library for modeling artistic concepts.

pub mod kinds {
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}

pub mod utils {
    use crate::kinds::*;

    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
<span class="boring">        SecondaryColor::Orange
</span>    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 14-3: An <code>art</code> library with items organized into
<code>kinds</code> and <code>utils</code> modules</span></p>
<p>Figure 14-3 shows what the front page of the documentation for this crate
generated by <code>cargo doc</code> would look like:</p>
<img alt="Rendered documentation for the `art` crate that lists the `kinds` and `utils` modules" src="rustbook/img/trpl14-03.png" class="center" />
<p><span class="caption">Figure 14-3: Front page of the documentation for <code>art</code>
that lists the <code>kinds</code> and <code>utils</code> modules</span></p>
<p>Note that the <code>PrimaryColor</code> and <code>SecondaryColor</code> types aren’t listed on the
front page, nor is the <code>mix</code> function. We have to click <code>kinds</code> and <code>utils</code> to
see them.</p>
<p>Another crate that depends on this library would need <code>use</code> statements that
bring the items from <code>art</code> into scope, specifying the module structure that’s
currently defined. Listing 14-4 shows an example of a crate that uses the
<code>PrimaryColor</code> and <code>mix</code> items from the <code>art</code> crate:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::kinds::PrimaryColor;
use art::utils::mix;

fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}
</code></pre>
<p><span class="caption">Listing 14-4: A crate using the <code>art</code> crate’s items with
its internal structure exported</span></p>
<p>The author of the code in Listing 14-4, which uses the <code>art</code> crate, had to
figure out that <code>PrimaryColor</code> is in the <code>kinds</code> module and <code>mix</code> is in the
<code>utils</code> module. The module structure of the <code>art</code> crate is more relevant to
developers working on the <code>art</code> crate than to developers using the <code>art</code> crate.
The internal structure that organizes parts of the crate into the <code>kinds</code>
module and the <code>utils</code> module doesn’t contain any useful information for
someone trying to understand how to use the <code>art</code> crate. Instead, the <code>art</code>
crate’s module structure causes confusion because developers have to figure out
where to look, and the structure is inconvenient because developers must
specify the module names in the <code>use</code> statements.</p>
<p>To remove the internal organization from the public API, we can modify the
<code>art</code> crate code in Listing 14-3 to add <code>pub use</code> statements to re-export the
items at the top level, as shown in Listing 14-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}
</code></pre>
<p><span class="caption">Listing 14-5: Adding <code>pub use</code> statements to re-export
items</span></p>
<p>The API documentation that <code>cargo doc</code> generates for this crate will now list
and link re-exports on the front page, as shown in Figure 14-4, making the
<code>PrimaryColor</code> and <code>SecondaryColor</code> types and the <code>mix</code> function easier to find.</p>
<img alt="Rendered documentation for the `art` crate with the re-exports on the front page" src="rustbook/img/trpl14-04.png" class="center" />
<p><span class="caption">Figure 14-4: The front page of the documentation for <code>art</code>
that lists the re-exports</span></p>
<p>The <code>art</code> crate users can still see and use the internal structure from Listing
14-3 as demonstrated in Listing 14-4, or they can use the more convenient
structure in Listing 14-5, as shown in Listing 14-6:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use art::PrimaryColor;
use art::mix;

fn main() {
    // --snip--
}
</code></pre>
<p><span class="caption">Listing 14-6: A program using the re-exported items from
the <code>art</code> crate</span></p>
<p>In cases where there are many nested modules, re-exporting the types at the top
level with <code>pub use</code> can make a significant difference in the experience of
people who use the crate.</p>
<p>Creating a useful public API structure is more of an art than a science, and
you can iterate to find the API that works best for your users. Choosing <code>pub use</code> gives you flexibility in how you structure your crate internally and
decouples that internal structure from what you present to your users. Look at
some of the code of crates you’ve installed to see if their internal structure
differs from their public API.</p>
<h3><a class="header" href="#setting-up-a-cratesio-account" id="setting-up-a-cratesio-account">Setting Up a Crates.io Account</a></h3>
<p>Before you can publish any crates, you need to create an account on
<a href="https://crates.io/">crates.io</a><!-- ignore --> and get an API token. To do so,
visit the home page at <a href="https://crates.io/">crates.io</a><!-- ignore --> and log in
via a GitHub account. (The GitHub account is currently a requirement, but the
site might support other ways of creating an account in the future.) Once
you’re logged in, visit your account settings at
<a href="https://crates.io/me/">https://crates.io/me/</a><!-- ignore --> and retrieve your
API key. Then run the <code>cargo login</code> command with your API key, like this:</p>
<pre><code class="language-text">$ cargo login abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>This command will inform Cargo of your API token and store it locally in
<em>~/.cargo/credentials</em>. Note that this token is a <em>secret</em>: do not share it
with anyone else. If you do share it with anyone for any reason, you should
revoke it and generate a new token on <a href="https://crates.io/">crates.io</a><!-- ignore
-->.</p>
<h3><a class="header" href="#adding-metadata-to-a-new-crate" id="adding-metadata-to-a-new-crate">Adding Metadata to a New Crate</a></h3>
<p>Now that you have an account, let’s say you have a crate you want to publish.
Before publishing, you’ll need to add some metadata to your crate by adding it
to the <code>[package]</code> section of the crate’s <em>Cargo.toml</em> file.</p>
<p>Your crate will need a unique name. While you’re working on a crate locally,
you can name a crate whatever you’d like. However, crate names on
<a href="https://crates.io/">crates.io</a><!-- ignore --> are allocated on a first-come,
first-served basis. Once a crate name is taken, no one else can publish a crate
with that name. Before attempting to publish a crate, search for the name you
want to use on the site. If the name has been used by another crate, you will
need to find another name and edit the <code>name</code> field in the <em>Cargo.toml</em> file
under the <code>[package]</code> section to use the new name for publishing, like so:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
</code></pre>
<p>Even if you’ve chosen a unique name, when you run <code>cargo publish</code> to publish
the crate at this point, you’ll get a warning and then an error:</p>
<pre><code class="language-text">$ cargo publish
    Updating registry `https://github.com/rust-lang/crates.io-index`
warning: manifest has no description, license, license-file, documentation,
homepage or repository.
--snip--
error: api errors: missing or empty metadata fields: description, license.
</code></pre>
<p>The reason is that you’re missing some crucial information: a description and
license are required so people will know what your crate does and under what
terms they can use it. To rectify this error, you need to include this
information in the <em>Cargo.toml</em> file.</p>
<p>Add a description that is just a sentence or two, because it will appear with
your crate in search results. For the <code>license</code> field, you need to give a
<em>license identifier value</em>. The <a href="http://spdx.org/licenses/">Linux Foundation’s Software Package Data
Exchange (SPDX)</a> lists the identifiers you can use for this value. For
example, to specify that you’ve licensed your crate using the MIT License, add
the <code>MIT</code> identifier:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
license = &quot;MIT&quot;
</code></pre>
<p>If you want to use a license that doesn’t appear in the SPDX, you need to place
the text of that license in a file, include the file in your project, and then
use <code>license-file</code> to specify the name of that file instead of using the
<code>license</code> key.</p>
<p>Guidance on which license is appropriate for your project is beyond the scope
of this book. Many people in the Rust community license their projects in the
same way as Rust by using a dual license of <code>MIT OR Apache-2.0</code>. This practice
demonstrates that you can also specify multiple license identifiers separated
by <code>OR</code> to have multiple licenses for your project.</p>
<p>With a unique name, the version, the author details that <code>cargo new</code> added
when you created the crate, your description, and a license added, the
<em>Cargo.toml</em> file for a project that is ready to publish might look like this:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[package]
name = &quot;guessing_game&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]
edition = &quot;2018&quot;
description = &quot;A fun game where you guess what number the computer has chosen.&quot;
license = &quot;MIT OR Apache-2.0&quot;

[dependencies]
</code></pre>
<p><a href="https://doc.rust-lang.org/cargo/">Cargo’s documentation</a> describes other
metadata you can specify to ensure others can discover and use your crate more
easily.</p>
<h3><a class="header" href="#publishing-to-cratesio" id="publishing-to-cratesio">Publishing to Crates.io</a></h3>
<p>Now that you’ve created an account, saved your API token, chosen a name for
your crate, and specified the required metadata, you’re ready to publish!
Publishing a crate uploads a specific version to
<a href="https://crates.io/">crates.io</a><!-- ignore --> for others to use.</p>
<p>Be careful when publishing a crate because a publish is <em>permanent</em>. The
version can never be overwritten, and the code cannot be deleted. One major
goal of <a href="https://crates.io/">crates.io</a><!-- ignore --> is to act as a permanent
archive of code so that builds of all projects that depend on crates from
<a href="https://crates.io/">crates.io</a><!-- ignore --> will continue to work. Allowing
version deletions would make fulfilling that goal impossible. However, there is
no limit to the number of crate versions you can publish.</p>
<p>Run the <code>cargo publish</code> command again. It should succeed now:</p>
<pre><code class="language-text">$ cargo publish
 Updating registry `https://github.com/rust-lang/crates.io-index`
Packaging guessing_game v0.1.0 (file:///projects/guessing_game)
Verifying guessing_game v0.1.0 (file:///projects/guessing_game)
Compiling guessing_game v0.1.0
(file:///projects/guessing_game/target/package/guessing_game-0.1.0)
 Finished dev [unoptimized + debuginfo] target(s) in 0.19 secs
Uploading guessing_game v0.1.0 (file:///projects/guessing_game)
</code></pre>
<p>Congratulations! You’ve now shared your code with the Rust community, and
anyone can easily add your crate as a dependency of their project.</p>
<h3><a class="header" href="#publishing-a-new-version-of-an-existing-crate" id="publishing-a-new-version-of-an-existing-crate">Publishing a New Version of an Existing Crate</a></h3>
<p>When you’ve made changes to your crate and are ready to release a new version,
you change the <code>version</code> value specified in your <em>Cargo.toml</em> file and
republish. Use the <a href="http://semver.org/">Semantic Versioning rules</a> to decide what an
appropriate next version number is based on the kinds of changes you’ve made.
Then run <code>cargo publish</code> to upload the new version.</p>
<h3><a class="header" href="#removing-versions-from-cratesio-with-cargo-yank" id="removing-versions-from-cratesio-with-cargo-yank">Removing Versions from Crates.io with <code>cargo yank</code></a></h3>
<p>Although you can’t remove previous versions of a crate, you can prevent any
future projects from adding them as a new dependency. This is useful when a
crate version is broken for one reason or another. In such situations, Cargo
supports <em>yanking</em> a crate version.</p>
<p>Yanking a version prevents new projects from starting to depend on that version
while allowing all existing projects that depend on it to continue to download
and depend on that version. Essentially, a yank means that all projects with a
<em>Cargo.lock</em> will not break, and any future <em>Cargo.lock</em> files generated will
not use the yanked version.</p>
<p>To yank a version of a crate, run <code>cargo yank</code> and specify which version you
want to yank:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1
</code></pre>
<p>By adding <code>--undo</code> to the command, you can also undo a yank and allow projects
to start depending on a version again:</p>
<pre><code class="language-text">$ cargo yank --vers 1.0.1 --undo
</code></pre>
<p>A yank <em>does not</em> delete any code. For example, the yank feature is not
intended for deleting accidentally uploaded secrets. If that happens, you must
reset those secrets immediately.</p>
<h2><a class="header" href="#cargo-workspaces" id="cargo-workspaces">Cargo Workspaces</a></h2>
<p>In Chapter 12, we built a package that included a binary crate and a library
crate. As your project develops, you might find that the library crate
continues to get bigger and you want to split up your package further into
multiple library crates. In this situation, Cargo offers a feature called
<em>workspaces</em> that can help manage multiple related packages that are developed
in tandem.</p>
<h3><a class="header" href="#creating-a-workspace" id="creating-a-workspace">Creating a Workspace</a></h3>
<p>A <em>workspace</em> is a set of packages that share the same <em>Cargo.lock</em> and output
directory. Let’s make a project using a workspace—we’ll use trivial code so we
can concentrate on the structure of the workspace. There are multiple ways to
structure a workspace; we’re going to show one common way. We’ll have a
workspace containing a binary and two libraries. The binary, which will provide
the main functionality, will depend on the two libraries. One library will
provide an <code>add_one</code> function, and a second library an <code>add_two</code> function.
These three crates will be part of the same workspace. We’ll start by creating
a new directory for the workspace:</p>
<pre><code class="language-text">$ mkdir add
$ cd add
</code></pre>
<p>Next, in the <em>add</em> directory, we create the <em>Cargo.toml</em> file that will
configure the entire workspace. This file won’t have a <code>[package]</code> section or
the metadata we’ve seen in other <em>Cargo.toml</em> files. Instead, it will start
with a <code>[workspace]</code> section that will allow us to add members to the workspace
by specifying the path to our binary crate; in this case, that path is <em>adder</em>:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
]
</code></pre>
<p>Next, we’ll create the <code>adder</code> binary crate by running <code>cargo new</code> within the
<em>add</em> directory:</p>
<pre><code class="language-text">$ cargo new adder
     Created binary (application) `adder` project
</code></pre>
<p>At this point, we can build the workspace by running <code>cargo build</code>. The files
in your <em>add</em> directory should look like this:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>The workspace has one <em>target</em> directory at the top level for the compiled
artifacts to be placed into; the <code>adder</code> crate doesn’t have its own <em>target</em>
directory. Even if we were to run <code>cargo build</code> from inside the <em>adder</em>
directory, the compiled artifacts would still end up in <em>add/target</em> rather
than <em>add/adder/target</em>. Cargo structures the <em>target</em> directory in a workspace
like this because the crates in a workspace are meant to depend on each other.
If each crate had its own <em>target</em> directory, each crate would have to
recompile each of the other crates in the workspace to have the artifacts in
its own <em>target</em> directory. By sharing one <em>target</em> directory, the crates can
avoid unnecessary rebuilding.</p>
<h3><a class="header" href="#creating-the-second-crate-in-the-workspace" id="creating-the-second-crate-in-the-workspace">Creating the Second Crate in the Workspace</a></h3>
<p>Next, let’s create another member crate in the workspace and call it <code>add-one</code>.
Change the top-level <em>Cargo.toml</em> to specify the <em>add-one</em> path in the
<code>members</code> list:</p>
<p><span class="filename">Filename: Cargo.toml</span></p>
<pre><code class="language-toml">[workspace]

members = [
    &quot;adder&quot;,
    &quot;add-one&quot;,
]
</code></pre>
<p>Then generate a new library crate named <code>add-one</code>:</p>
<pre><code class="language-text">$ cargo new add-one --lib
     Created library `add-one` project
</code></pre>
<p>Your <em>add</em> directory should now have these directories and files:</p>
<pre><code class="language-text">├── Cargo.lock
├── Cargo.toml
├── add-one
│   ├── Cargo.toml
│   └── src
│       └── lib.rs
├── adder
│   ├── Cargo.toml
│   └── src
│       └── main.rs
└── target
</code></pre>
<p>In the <em>add-one/src/lib.rs</em> file, let’s add an <code>add_one</code> function:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>Now that we have a library crate in the workspace, we can have the binary crate
<code>adder</code> depend on the library crate <code>add-one</code>. First, we’ll need to add a path
dependency on <code>add-one</code> to <em>adder/Cargo.toml</em>.</p>
<p><span class="filename">Filename: adder/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

add-one = { path = &quot;../add-one&quot; }
</code></pre>
<p>Cargo doesn’t assume that crates in a workspace will depend on each other, so
we need to be explicit about the dependency relationships between the crates.</p>
<p>Next, let’s use the <code>add_one</code> function from the <code>add-one</code> crate in the <code>adder</code>
crate. Open the <em>adder/src/main.rs</em> file and add a <code>use</code> line at the top to
bring the new <code>add-one</code> library crate into scope. Then change the <code>main</code>
function to call the <code>add_one</code> function, as in Listing 14-7.</p>
<p><span class="filename">Filename: adder/src/main.rs</span></p>
<pre><code class="language-rust ignore">use add_one;

fn main() {
    let num = 10;
    println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));
}
</code></pre>
<p><span class="caption">Listing 14-7: Using the <code>add-one</code> library crate from the
<code>adder</code> crate</span></p>
<p>Let’s build the workspace by running <code>cargo build</code> in the top-level <em>add</em>
directory!</p>
<pre><code class="language-text">$ cargo build
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.68 secs
</code></pre>
<p>To run the binary crate from the <em>add</em> directory, we need to specify which
package in the workspace we want to use by using the <code>-p</code> argument and the
package name with <code>cargo run</code>:</p>
<pre><code class="language-text">$ cargo run -p adder
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running `target/debug/adder`
Hello, world! 10 plus one is 11!
</code></pre>
<p>This runs the code in <em>adder/src/main.rs</em>, which depends on the <code>add-one</code> crate.</p>
<h4><a class="header" href="#depending-on-an-external-crate-in-a-workspace" id="depending-on-an-external-crate-in-a-workspace">Depending on an External Crate in a Workspace</a></h4>
<p>Notice that the workspace has only one <em>Cargo.lock</em> file at the top level of
the workspace rather than having a <em>Cargo.lock</em> in each crate’s directory. This
ensures that all crates are using the same version of all dependencies. If we
add the <code>rand</code> crate to the <em>adder/Cargo.toml</em> and <em>add-one/Cargo.toml</em>
files, Cargo will resolve both of those to one version of <code>rand</code> and record
that in the one <em>Cargo.lock</em>. Making all crates in the workspace use the same
dependencies means the crates in the workspace will always be compatible with
each other. Let’s add the <code>rand</code> crate to the <code>[dependencies]</code> section in the
<em>add-one/Cargo.toml</em> file to be able to use the <code>rand</code> crate in the <code>add-one</code>
crate:</p>
<p><span class="filename">Filename: add-one/Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]

rand = &quot;0.3.14&quot;
</code></pre>
<p>We can now add <code>use rand;</code> to the <em>add-one/src/lib.rs</em> file, and building the
whole workspace by running <code>cargo build</code> in the <em>add</em> directory will bring in
and compile the <code>rand</code> crate:</p>
<pre><code class="language-text">$ cargo build
    Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading rand v0.3.14
   --snip--
   Compiling rand v0.3.14
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 10.18 secs
</code></pre>
<p>The top-level <em>Cargo.lock</em> now contains information about the dependency of
<code>add-one</code> on <code>rand</code>. However, even though <code>rand</code> is used somewhere in the
workspace, we can’t use it in other crates in the workspace unless we add
<code>rand</code> to their <em>Cargo.toml</em> files as well. For example, if we add <code>use rand;</code>
to the <em>adder/src/main.rs</em> file for the <code>adder</code> crate, we’ll get an error:</p>
<pre><code class="language-text">$ cargo build
   Compiling adder v0.1.0 (file:///projects/add/adder)
error: use of unstable library feature 'rand': use `rand` from crates.io (see
issue #27703)
 --&gt; adder/src/main.rs:1:1
  |
1 | use rand;
</code></pre>
<p>To fix this, edit the <em>Cargo.toml</em> file for the <code>adder</code> crate and indicate that
<code>rand</code> is a dependency for that crate as well. Building the <code>adder</code> crate will
add <code>rand</code> to the list of dependencies for <code>adder</code> in <em>Cargo.lock</em>, but no
additional copies of <code>rand</code> will be downloaded. Cargo has ensured that every
crate in the workspace using the <code>rand</code> crate will be using the same version.
Using the same version of <code>rand</code> across the workspace saves space because we
won’t have multiple copies and ensures that the crates in the workspace will be
compatible with each other.</p>
<h4><a class="header" href="#adding-a-test-to-a-workspace" id="adding-a-test-to-a-workspace">Adding a Test to a Workspace</a></h4>
<p>For another enhancement, let’s add a test of the <code>add_one::add_one</code> function
within the <code>add_one</code> crate:</p>
<p><span class="filename">Filename: add-one/src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Now run <code>cargo test</code> in the top-level <em>add</em> directory:</p>
<pre><code class="language-text">$ cargo test
   Compiling add-one v0.1.0 (file:///projects/add/add-one)
   Compiling adder v0.1.0 (file:///projects/add/adder)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27 secs
     Running target/debug/deps/add_one-f0253159197f7841

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/adder-f88af9d2cc175a5e

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>The first section of the output shows that the <code>it_works</code> test in the <code>add-one</code>
crate passed. The next section shows that zero tests were found in the <code>adder</code>
crate, and then the last section shows zero documentation tests were found in
the <code>add-one</code> crate. Running <code>cargo test</code> in a workspace structured like this
one will run the tests for all the crates in the workspace.</p>
<p>We can also run tests for one particular crate in a workspace from the
top-level directory by using the <code>-p</code> flag and specifying the name of the crate
we want to test:</p>
<pre><code class="language-text">$ cargo test -p add-one
    Finished dev [unoptimized + debuginfo] target(s) in 0.0 secs
     Running target/debug/deps/add_one-b3235fea9a156f74

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests add-one

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>This output shows <code>cargo test</code> only ran the tests for the <code>add-one</code> crate and
didn’t run the <code>adder</code> crate tests.</p>
<p>If you publish the crates in the workspace to <a href="https://crates.io/">crates.io</a>,
each crate in the workspace will need to be published separately. The <code>cargo publish</code> command does not have an <code>--all</code> flag or a <code>-p</code> flag, so you must
change to each crate’s directory and run <code>cargo publish</code> on each crate in the
workspace to publish the crates.</p>
<p>For additional practice, add an <code>add-two</code> crate to this workspace in a similar
way as the <code>add-one</code> crate!</p>
<p>As your project grows, consider using a workspace: it’s easier to understand
smaller, individual components than one big blob of code. Furthermore, keeping
the crates in a workspace can make coordination between them easier if they are
often changed at the same time.</p>
<h2><a class="header" href="#installing-binaries-from-cratesio-with-cargo-install" id="installing-binaries-from-cratesio-with-cargo-install">Installing Binaries from Crates.io with <code>cargo install</code></a></h2>
<p>The <code>cargo install</code> command allows you to install and use binary crates
locally. This isn’t intended to replace system packages; it’s meant to be a
convenient way for Rust developers to install tools that others have shared on
<a href="https://crates.io/">crates.io</a><!-- ignore -->. Note that you can only install
packages that have binary targets. A <em>binary target</em> is the runnable program
that is created if the crate has a <em>src/main.rs</em> file or another file specified
as a binary, as opposed to a library target that isn’t runnable on its own but
is suitable for including within other programs. Usually, crates have
information in the <em>README</em> file about whether a crate is a library, has a
binary target, or both.</p>
<p>All binaries installed with <code>cargo install</code> are stored in the installation
root’s <em>bin</em> folder. If you installed Rust using <em>rustup.rs</em> and don’t have any
custom configurations, this directory will be <em>$HOME/.cargo/bin</em>. Ensure that
directory is in your <code>$PATH</code> to be able to run programs you’ve installed with
<code>cargo install</code>.</p>
<p>For example, in Chapter 12 we mentioned that there’s a Rust implementation of
the <code>grep</code> tool called <code>ripgrep</code> for searching files. If we want to install
<code>ripgrep</code>, we can run the following:</p>
<pre><code class="language-text">$ cargo install ripgrep
Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
  Installing ~/.cargo/bin/rg
</code></pre>
<p>The last line of the output shows the location and the name of the installed
binary, which in the case of <code>ripgrep</code> is <code>rg</code>. As long as the installation
directory is in your <code>$PATH</code>, as mentioned previously, you can then run <code>rg --help</code> and start using a faster, rustier tool for searching files!</p>
<h2><a class="header" href="#extending-cargo-with-custom-commands" id="extending-cargo-with-custom-commands">Extending Cargo with Custom Commands</a></h2>
<p>Cargo is designed so you can extend it with new subcommands without having to
modify Cargo. If a binary in your <code>$PATH</code> is named <code>cargo-something</code>, you can
run it as if it was a Cargo subcommand by running <code>cargo something</code>. Custom
commands like this are also listed when you run <code>cargo --list</code>. Being able to
use <code>cargo install</code> to install extensions and then run them just like the
built-in Cargo tools is a super convenient benefit of Cargo’s design!</p>
<h2><a class="header" href="#summary-13" id="summary-13">Summary</a></h2>
<p>Sharing code with Cargo and <a href="https://crates.io/">crates.io</a><!-- ignore --> is
part of what makes the Rust ecosystem useful for many different tasks. Rust’s
standard library is small and stable, but crates are easy to share, use, and
improve on a timeline different from that of the language. Don’t be shy about
sharing code that’s useful to you on <a href="https://crates.io/">crates.io</a><!-- ignore
-->; it’s likely that it will be useful to someone else as well!</p>
<h1><a class="header" href="#smart-pointers" id="smart-pointers">Smart Pointers</a></h1>
<p>A <em>pointer</em> is a general concept for a variable that contains an address in
memory. This address refers to, or “points at,” some other data. The most
common kind of pointer in Rust is a reference, which you learned about in
Chapter 4. References are indicated by the <code>&amp;</code> symbol and borrow the value they
point to. They don’t have any special capabilities other than referring to
data. Also, they don’t have any overhead and are the kind of pointer we use
most often.</p>
<p><em>Smart pointers</em>, on the other hand, are data structures that not only act like
a pointer but also have additional metadata and capabilities. The concept of
smart pointers isn’t unique to Rust: smart pointers originated in C++ and exist
in other languages as well. In Rust, the different smart pointers defined in
the standard library provide functionality beyond that provided by references.
One example that we’ll explore in this chapter is the <em>reference counting</em>
smart pointer type. This pointer enables you to have multiple owners of data by
keeping track of the number of owners and, when no owners remain, cleaning up
the data.</p>
<p>In Rust, which uses the concept of ownership and borrowing, an additional
difference between references and smart pointers is that references are
pointers that only borrow data; in contrast, in many cases, smart pointers
<em>own</em> the data they point to.</p>
<p>We’ve already encountered a few smart pointers in this book, such as <code>String</code>
and <code>Vec&lt;T&gt;</code> in Chapter 8, although we didn’t call them smart pointers at the
time. Both these types count as smart pointers because they own some memory and
allow you to manipulate it. They also have metadata (such as their capacity)
and extra capabilities or guarantees (such as with <code>String</code> ensuring its data
will always be valid UTF-8).</p>
<p>Smart pointers are usually implemented using structs. The characteristic that
distinguishes a smart pointer from an ordinary struct is that smart pointers
implement the <code>Deref</code> and <code>Drop</code> traits. The <code>Deref</code> trait allows an instance
of the smart pointer struct to behave like a reference so you can write code
that works with either references or smart pointers. The <code>Drop</code> trait allows
you to customize the code that is run when an instance of the smart pointer
goes out of scope. In this chapter, we’ll discuss both traits and demonstrate
why they’re important to smart pointers.</p>
<p>Given that the smart pointer pattern is a general design pattern used
frequently in Rust, this chapter won’t cover every existing smart pointer. Many
libraries have their own smart pointers, and you can even write your own. We’ll
cover the most common smart pointers in the standard library:</p>
<ul>
<li><code>Box&lt;T&gt;</code> for allocating values on the heap</li>
<li><code>Rc&lt;T&gt;</code>, a reference counting type that enables multiple ownership</li>
<li><code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code>, accessed through <code>RefCell&lt;T&gt;</code>, a type that enforces
the borrowing rules at runtime instead of compile time</li>
</ul>
<p>In addition, we’ll cover the <em>interior mutability</em> pattern where an immutable
type exposes an API for mutating an interior value. We’ll also discuss
<em>reference cycles</em>: how they can leak memory and how to prevent them.</p>
<p>Let’s dive in!</p>
<h2><a class="header" href="#using-boxt-to-point-to-data-on-the-heap" id="using-boxt-to-point-to-data-on-the-heap">Using <code>Box&lt;T&gt;</code> to Point to Data on the Heap</a></h2>
<p>The most straightforward smart pointer is a <em>box</em>, whose type is written
<code>Box&lt;T&gt;</code>. Boxes allow you to store data on the heap rather than the stack. What
remains on the stack is the pointer to the heap data. Refer to Chapter 4 to
review the difference between the stack and the heap.</p>
<p>Boxes don’t have performance overhead, other than storing their data on the
heap instead of on the stack. But they don’t have many extra capabilities
either. You’ll use them most often in these situations:</p>
<ul>
<li>When you have a type whose size can’t be known at compile time and you want
to use a value of that type in a context that requires an exact size</li>
<li>When you have a large amount of data and you want to transfer ownership but
ensure the data won’t be copied when you do so</li>
<li>When you want to own a value and you care only that it’s a type that
implements a particular trait rather than being of a specific type</li>
</ul>
<p>We’ll demonstrate the first situation in the <a href="rustbook/ch15-01-box.html#enabling-recursive-types-with-boxes">“Enabling Recursive Types with
Boxes”</a><!-- ignore --> section. In the
second case, transferring ownership of a large amount of data can take a long
time because the data is copied around on the stack. To improve performance in
this situation, we can store the large amount of data on the heap in a box.
Then, only the small amount of pointer data is copied around on the stack,
while the data it references stays in one place on the heap. The third case is
known as a <em>trait object</em>, and Chapter 17 devotes an entire section, <a href="rustbook/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using
Trait Objects That Allow for Values of Different Types,”</a><!--
ignore --> just to that topic. So what you learn here you’ll apply again in
Chapter 17!</p>
<h3><a class="header" href="#using-a-boxt-to-store-data-on-the-heap" id="using-a-boxt-to-store-data-on-the-heap">Using a <code>Box&lt;T&gt;</code> to Store Data on the Heap</a></h3>
<p>Before we discuss this use case for <code>Box&lt;T&gt;</code>, we’ll cover the syntax and how to
interact with values stored within a <code>Box&lt;T&gt;</code>.</p>
<p>Listing 15-1 shows how to use a box to store an <code>i32</code> value on the heap:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let b = Box::new(5);
    println!(&quot;b = {}&quot;, b);
}
</code></pre></pre>
<p><span class="caption">Listing 15-1: Storing an <code>i32</code> value on the heap using a
box</span></p>
<p>We define the variable <code>b</code> to have the value of a <code>Box</code> that points to the
value <code>5</code>, which is allocated on the heap. This program will print <code>b = 5</code>; in
this case, we can access the data in the box similar to how we would if this
data were on the stack. Just like any owned value, when a box goes out of
scope, as <code>b</code> does at the end of <code>main</code>, it will be deallocated. The
deallocation happens for the box (stored on the stack) and the data it points
to (stored on the heap).</p>
<p>Putting a single value on the heap isn’t very useful, so you won’t use boxes by
themselves in this way very often. Having values like a single <code>i32</code> on the
stack, where they’re stored by default, is more appropriate in the majority of
situations. Let’s look at a case where boxes allow us to define types that we
wouldn’t be allowed to if we didn’t have boxes.</p>
<h3><a class="header" href="#enabling-recursive-types-with-boxes" id="enabling-recursive-types-with-boxes">Enabling Recursive Types with Boxes</a></h3>
<p>At compile time, Rust needs to know how much space a type takes up. One type
whose size can’t be known at compile time is a <em>recursive type</em>, where a value
can have as part of itself another value of the same type. Because this nesting
of values could theoretically continue infinitely, Rust doesn’t know how much
space a value of a recursive type needs. However, boxes have a known size, so
by inserting a box in a recursive type definition, you can have recursive types.</p>
<p>Let’s explore the <em>cons list</em>, which is a data type common in functional
programming languages, as an example of a recursive type. The cons list type
we’ll define is straightforward except for the recursion; therefore, the
concepts in the example we’ll work with will be useful any time you get into
more complex situations involving recursive types.</p>
<h4><a class="header" href="#more-information-about-the-cons-list" id="more-information-about-the-cons-list">More Information About the Cons List</a></h4>
<p>A <em>cons list</em> is a data structure that comes from the Lisp programming language
and its dialects. In Lisp, the <code>cons</code> function (short for “construct function”)
constructs a new pair from its two arguments, which usually are a single value
and another pair. These pairs containing pairs form a list.</p>
<p>The cons function concept has made its way into more general functional
programming jargon: “to cons <em>x</em> onto <em>y</em>” informally means to construct a new
container instance by putting the element <em>x</em> at the start of this new
container, followed by the container <em>y</em>.</p>
<p>Each item in a cons list contains two elements: the value of the current item
and the next item. The last item in the list contains only a value called <code>Nil</code>
without a next item. A cons list is produced by recursively calling the <code>cons</code>
function. The canonical name to denote the base case of the recursion is <code>Nil</code>.
Note that this is not the same as the “null” or “nil” concept in Chapter 6,
which is an invalid or absent value.</p>
<p>Although functional programming languages use cons lists frequently, the cons
list isn’t a commonly used data structure in Rust. Most of the time when you
have a list of items in Rust, <code>Vec&lt;T&gt;</code> is a better choice to use. Other, more
complex recursive data types <em>are</em> useful in various situations, but by
starting with the cons list, we can explore how boxes let us define a recursive
data type without much distraction.</p>
<p>Listing 15-2 contains an enum definition for a cons list. Note that this code
won’t compile yet because the <code>List</code> type doesn’t have a known size, which
we’ll demonstrate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, List),
    Nil,
}
</code></pre>
<p><span class="caption">Listing 15-2: The first attempt at defining an enum to
represent a cons list data structure of <code>i32</code> values</span></p>
<blockquote>
<p>Note: We’re implementing a cons list that holds only <code>i32</code> values for the
purposes of this example. We could have implemented it using generics, as we
discussed in Chapter 10, to define a cons list type that could store values of
any type.</p>
</blockquote>
<p>Using the <code>List</code> type to store the list <code>1, 2, 3</code> would look like the code in
Listing 15-3:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
</code></pre>
<p><span class="caption">Listing 15-3: Using the <code>List</code> enum to store the list <code>1, 2, 3</code></span></p>
<p>The first <code>Cons</code> value holds <code>1</code> and another <code>List</code> value. This <code>List</code> value is
another <code>Cons</code> value that holds <code>2</code> and another <code>List</code> value. This <code>List</code> value
is one more <code>Cons</code> value that holds <code>3</code> and a <code>List</code> value, which is finally
<code>Nil</code>, the non-recursive variant that signals the end of the list.</p>
<p>If we try to compile the code in Listing 15-3, we get the error shown in
Listing 15-4:</p>
<pre><code class="language-text">error[E0072]: recursive type `List` has infinite size
 --&gt; src/main.rs:1:1
  |
1 | enum List {
  | ^^^^^^^^^ recursive type has infinite size
2 |     Cons(i32, List),
  |               ----- recursive without indirection
  |
  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p><span class="caption">Listing 15-4: The error we get when attempting to define
a recursive enum</span></p>
<p>The error shows this type “has infinite size.” The reason is that we’ve defined
<code>List</code> with a variant that is recursive: it holds another value of itself
directly. As a result, Rust can’t figure out how much space it needs to store a
<code>List</code> value. Let’s break down why we get this error a bit. First, let’s look
at how Rust decides how much space it needs to store a value of a non-recursive
type.</p>
<h4><a class="header" href="#computing-the-size-of-a-non-recursive-type" id="computing-the-size-of-a-non-recursive-type">Computing the Size of a Non-Recursive Type</a></h4>
<p>Recall the <code>Message</code> enum we defined in Listing 6-2 when we discussed enum
definitions in Chapter 6:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">}
</span></code></pre></pre>
<p>To determine how much space to allocate for a <code>Message</code> value, Rust goes
through each of the variants to see which variant needs the most space. Rust
sees that <code>Message::Quit</code> doesn’t need any space, <code>Message::Move</code> needs enough
space to store two <code>i32</code> values, and so forth. Because only one variant will be
used, the most space a <code>Message</code> value will need is the space it would take to
store the largest of its variants.</p>
<p>Contrast this with what happens when Rust tries to determine how much space a
recursive type like the <code>List</code> enum in Listing 15-2 needs. The compiler starts
by looking at the <code>Cons</code> variant, which holds a value of type <code>i32</code> and a value
of type <code>List</code>. Therefore, <code>Cons</code> needs an amount of space equal to the size of
an <code>i32</code> plus the size of a <code>List</code>. To figure out how much memory the <code>List</code>
type needs, the compiler looks at the variants, starting with the <code>Cons</code>
variant. The <code>Cons</code> variant holds a value of type <code>i32</code> and a value of type
<code>List</code>, and this process continues infinitely, as shown in Figure 15-1.</p>
<img alt="An infinite Cons list" src="rustbook/img/trpl15-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Figure 15-1: An infinite <code>List</code> consisting of infinite
<code>Cons</code> variants</span></p>
<h4><a class="header" href="#using-boxt-to-get-a-recursive-type-with-a-known-size" id="using-boxt-to-get-a-recursive-type-with-a-known-size">Using <code>Box&lt;T&gt;</code> to Get a Recursive Type with a Known Size</a></h4>
<p>Rust can’t figure out how much space to allocate for recursively defined types,
so the compiler gives the error in Listing 15-4. But the error does include
this helpful suggestion:</p>
<pre><code class="language-text">  = help: insert indirection (e.g., a `Box`, `Rc`, or `&amp;`) at some point to
  make `List` representable
</code></pre>
<p>In this suggestion, “indirection” means that instead of storing a value
directly, we’ll change the data structure to store the value indirectly by
storing a pointer to the value instead.</p>
<p>Because a <code>Box&lt;T&gt;</code> is a pointer, Rust always knows how much space a <code>Box&lt;T&gt;</code>
needs: a pointer’s size doesn’t change based on the amount of data it’s
pointing to. This means we can put a <code>Box&lt;T&gt;</code> inside the <code>Cons</code> variant instead
of another <code>List</code> value directly. The <code>Box&lt;T&gt;</code> will point to the next <code>List</code>
value that will be on the heap rather than inside the <code>Cons</code> variant.
Conceptually, we still have a list, created with lists “holding” other lists,
but this implementation is now more like placing the items next to one another
rather than inside one another.</p>
<p>We can change the definition of the <code>List</code> enum in Listing 15-2 and the usage
of the <code>List</code> in Listing 15-3 to the code in Listing 15-5, which will compile:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
</code></pre></pre>
<p><span class="caption">Listing 15-5: Definition of <code>List</code> that uses <code>Box&lt;T&gt;</code> in
order to have a known size</span></p>
<p>The <code>Cons</code> variant will need the size of an <code>i32</code> plus the space to store the
box’s pointer data. The <code>Nil</code> variant stores no values, so it needs less space
than the <code>Cons</code> variant. We now know that any <code>List</code> value will take up the
size of an <code>i32</code> plus the size of a box’s pointer data. By using a box, we’ve
broken the infinite, recursive chain, so the compiler can figure out the size
it needs to store a <code>List</code> value. Figure 15-2 shows what the <code>Cons</code> variant
looks like now.</p>
<img alt="A finite Cons list" src="rustbook/img/trpl15-02.svg" class="center" />
<p><span class="caption">Figure 15-2: A <code>List</code> that is not infinitely sized
because <code>Cons</code> holds a <code>Box</code></span></p>
<p>Boxes provide only the indirection and heap allocation; they don’t have any
other special capabilities, like those we’ll see with the other smart pointer
types. They also don’t have any performance overhead that these special
capabilities incur, so they can be useful in cases like the cons list where the
indirection is the only feature we need. We’ll look at more use cases for boxes
in Chapter 17, too.</p>
<p>The <code>Box&lt;T&gt;</code> type is a smart pointer because it implements the <code>Deref</code> trait,
which allows <code>Box&lt;T&gt;</code> values to be treated like references. When a <code>Box&lt;T&gt;</code>
value goes out of scope, the heap data that the box is pointing to is cleaned
up as well because of the <code>Drop</code> trait implementation. Let’s explore these two
traits in more detail. These two traits will be even more important to the
functionality provided by the other smart pointer types we’ll discuss in the
rest of this chapter.</p>
<h2><a class="header" href="#treating-smart-pointers-like-regular-references-with-the-deref-trait" id="treating-smart-pointers-like-regular-references-with-the-deref-trait">Treating Smart Pointers Like Regular References with the <code>Deref</code> Trait</a></h2>
<p>Implementing the <code>Deref</code> trait allows you to customize the behavior of the
<em>dereference operator</em>, <code>*</code> (as opposed to the multiplication or glob
operator). By implementing <code>Deref</code> in such a way that a smart pointer can be
treated like a regular reference, you can write code that operates on
references and use that code with smart pointers too.</p>
<p>Let’s first look at how the dereference operator works with regular references.
Then we’ll try to define a custom type that behaves like <code>Box&lt;T&gt;</code>, and see why
the dereference operator doesn’t work like a reference on our newly defined
type. We’ll explore how implementing the <code>Deref</code> trait makes it possible for
smart pointers to work in a similar way as references. Then we’ll look at
Rust’s <em>deref coercion</em> feature and how it lets us work with either references
or smart pointers.</p>
<blockquote>
<p>Note: there’s one big difference between the <code>MyBox&lt;T&gt;</code> type we’re about to
build and the real <code>Box&lt;T&gt;</code>: our version will not store its data on the heap.
We are focusing this example on <code>Deref</code>, so where the data is actually stored
is less important than the pointer-like behavior.</p>
</blockquote>
<h3><a class="header" href="#following-the-pointer-to-the-value-with-the-dereference-operator" id="following-the-pointer-to-the-value-with-the-dereference-operator">Following the Pointer to the Value with the Dereference Operator</a></h3>
<p>A regular reference is a type of pointer, and one way to think of a pointer is
as an arrow to a value stored somewhere else. In Listing 15-6, we create a
reference to an <code>i32</code> value and then use the dereference operator to follow the
reference to the data:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = &amp;x;

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listing 15-6: Using the dereference operator to follow a
reference to an <code>i32</code> value</span></p>
<p>The variable <code>x</code> holds an <code>i32</code> value, <code>5</code>. We set <code>y</code> equal to a reference to
<code>x</code>. We can assert that <code>x</code> is equal to <code>5</code>. However, if we want to make an
assertion about the value in <code>y</code>, we have to use <code>*y</code> to follow the reference
to the value it’s pointing to (hence <em>dereference</em>). Once we dereference <code>y</code>,
we have access to the integer value <code>y</code> is pointing to that we can compare with
<code>5</code>.</p>
<p>If we tried to write <code>assert_eq!(5, y);</code> instead, we would get this compilation
error:</p>
<pre><code class="language-text">error[E0277]: can't compare `{integer}` with `&amp;{integer}`
 --&gt; src/main.rs:6:5
  |
6 |     assert_eq!(5, y);
  |     ^^^^^^^^^^^^^^^^^ no implementation for `{integer} == &amp;{integer}`
  |
  = help: the trait `std::cmp::PartialEq&lt;&amp;{integer}&gt;` is not implemented for
  `{integer}`
</code></pre>
<p>Comparing a number and a reference to a number isn’t allowed because they’re
different types. We must use the dereference operator to follow the reference
to the value it’s pointing to.</p>
<h3><a class="header" href="#using-boxt-like-a-reference" id="using-boxt-like-a-reference">Using <code>Box&lt;T&gt;</code> Like a Reference</a></h3>
<p>We can rewrite the code in Listing 15-6 to use a <code>Box&lt;T&gt;</code> instead of a
reference; the dereference operator will work as shown in Listing 15-7:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre></pre>
<p><span class="caption">Listing 15-7: Using the dereference operator on a
<code>Box&lt;i32&gt;</code></span></p>
<p>The only difference between Listing 15-7 and Listing 15-6 is that here we set
<code>y</code> to be an instance of a box pointing to the value in <code>x</code> rather than a
reference pointing to the value of <code>x</code>. In the last assertion, we can use the
dereference operator to follow the box’s pointer in the same way that we did
when <code>y</code> was a reference. Next, we’ll explore what is special about <code>Box&lt;T&gt;</code>
that enables us to use the dereference operator by defining our own box type.</p>
<h3><a class="header" href="#defining-our-own-smart-pointer" id="defining-our-own-smart-pointer">Defining Our Own Smart Pointer</a></h3>
<p>Let’s build a smart pointer similar to the <code>Box&lt;T&gt;</code> type provided by the
standard library to experience how smart pointers behave differently from
references by default. Then we’ll look at how to add the ability to use the
dereference operator.</p>
<p>The <code>Box&lt;T&gt;</code> type is ultimately defined as a tuple struct with one element, so
Listing 15-8 defines a <code>MyBox&lt;T&gt;</code> type in the same way. We’ll also define a
<code>new</code> function to match the <code>new</code> function defined on <code>Box&lt;T&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
    fn new(x: T) -&gt; MyBox&lt;T&gt; {
        MyBox(x)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 15-8: Defining a <code>MyBox&lt;T&gt;</code> type</span></p>
<p>We define a struct named <code>MyBox</code> and declare a generic parameter <code>T</code>, because
we want our type to hold values of any type. The <code>MyBox</code> type is a tuple struct
with one element of type <code>T</code>. The <code>MyBox::new</code> function takes one parameter of
type <code>T</code> and returns a <code>MyBox</code> instance that holds the value passed in.</p>
<p>Let’s try adding the <code>main</code> function in Listing 15-7 to Listing 15-8 and
changing it to use the <code>MyBox&lt;T&gt;</code> type we’ve defined instead of <code>Box&lt;T&gt;</code>. The
code in Listing 15-9 won’t compile because Rust doesn’t know how to dereference
<code>MyBox</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}
</code></pre>
<p><span class="caption">Listing 15-9: Attempting to use <code>MyBox&lt;T&gt;</code> in the same
way we used references and <code>Box&lt;T&gt;</code></span></p>
<p>Here’s the resulting compilation error:</p>
<pre><code class="language-text">error[E0614]: type `MyBox&lt;{integer}&gt;` cannot be dereferenced
  --&gt; src/main.rs:14:19
   |
14 |     assert_eq!(5, *y);
   |                   ^^
</code></pre>
<p>Our <code>MyBox&lt;T&gt;</code> type can’t be dereferenced because we haven’t implemented that
ability on our type. To enable dereferencing with the <code>*</code> operator, we
implement the <code>Deref</code> trait.</p>
<h3><a class="header" href="#treating-a-type-like-a-reference-by-implementing-the-deref-trait" id="treating-a-type-like-a-reference-by-implementing-the-deref-trait">Treating a Type Like a Reference by Implementing the <code>Deref</code> Trait</a></h3>
<p>As discussed in Chapter 10, to implement a trait, we need to provide
implementations for the trait’s required methods. The <code>Deref</code> trait, provided
by the standard library, requires us to implement one method named <code>deref</code> that
borrows <code>self</code> and returns a reference to the inner data. Listing 15-10
contains an implementation of <code>Deref</code> to add to the definition of <code>MyBox</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::ops::Deref;

<span class="boring">struct MyBox&lt;T&gt;(T);
</span>impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
    type Target = T;

    fn deref(&amp;self) -&gt; &amp;T {
        &amp;self.0
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 15-10: Implementing <code>Deref</code> on <code>MyBox&lt;T&gt;</code></span></p>
<p>The <code>type Target = T;</code> syntax defines an associated type for the <code>Deref</code> trait
to use. Associated types are a slightly different way of declaring a generic
parameter, but you don’t need to worry about them for now; we’ll cover them in
more detail in Chapter 19.</p>
<p>We fill in the body of the <code>deref</code> method with <code>&amp;self.0</code> so <code>deref</code> returns a
reference to the value we want to access with the <code>*</code> operator. The <code>main</code>
function in Listing 15-9 that calls <code>*</code> on the <code>MyBox&lt;T&gt;</code> value now compiles,
and the assertions pass!</p>
<p>Without the <code>Deref</code> trait, the compiler can only dereference <code>&amp;</code> references.
The <code>deref</code> method gives the compiler the ability to take a value of any type
that implements <code>Deref</code> and call the <code>deref</code> method to get a <code>&amp;</code> reference that
it knows how to dereference.</p>
<p>When we entered <code>*y</code> in Listing 15-9, behind the scenes Rust actually ran this
code:</p>
<pre><code class="language-rust ignore">*(y.deref())
</code></pre>
<p>Rust substitutes the <code>*</code> operator with a call to the <code>deref</code> method and then a
plain dereference so we don’t have to think about whether or not we need to
call the <code>deref</code> method. This Rust feature lets us write code that functions
identically whether we have a regular reference or a type that implements
<code>Deref</code>.</p>
<p>The reason the <code>deref</code> method returns a reference to a value, and that the plain
dereference outside the parentheses in <code>*(y.deref())</code> is still necessary, is the
ownership system. If the <code>deref</code> method returned the value directly instead of
a reference to the value, the value would be moved out of <code>self</code>. We don’t want
to take ownership of the inner value inside <code>MyBox&lt;T&gt;</code> in this case or in most
cases where we use the dereference operator.</p>
<p>Note that the <code>*</code> operator is replaced with a call to the <code>deref</code> method and
then a call to the <code>*</code> operator just once, each time we use a <code>*</code> in our code.
Because the substitution of the <code>*</code> operator does not recurse infinitely, we
end up with data of type <code>i32</code>, which matches the <code>5</code> in <code>assert_eq!</code> in
Listing 15-9.</p>
<h3><a class="header" href="#implicit-deref-coercions-with-functions-and-methods" id="implicit-deref-coercions-with-functions-and-methods">Implicit Deref Coercions with Functions and Methods</a></h3>
<p><em>Deref coercion</em> is a convenience that Rust performs on arguments to functions
and methods. Deref coercion converts a reference to a type that implements
<code>Deref</code> into a reference to a type that <code>Deref</code> can convert the original type
into. Deref coercion happens automatically when we pass a reference to a
particular type’s value as an argument to a function or method that doesn’t
match the parameter type in the function or method definition. A sequence of
calls to the <code>deref</code> method converts the type we provided into the type the
parameter needs.</p>
<p>Deref coercion was added to Rust so that programmers writing function and
method calls don’t need to add as many explicit references and dereferences
with <code>&amp;</code> and <code>*</code>. The deref coercion feature also lets us write more code that
can work for either references or smart pointers.</p>
<p>To see deref coercion in action, let’s use the <code>MyBox&lt;T&gt;</code> type we defined in
Listing 15-8 as well as the implementation of <code>Deref</code> that we added in Listing
15-10. Listing 15-11 shows the definition of a function that has a string slice
parameter:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn hello(name: &amp;str) {
    println!(&quot;Hello, {}!&quot;, name);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 15-11: A <code>hello</code> function that has the parameter
<code>name</code> of type <code>&amp;str</code></span></p>
<p>We can call the <code>hello</code> function with a string slice as an argument, such as
<code>hello(&quot;Rust&quot;);</code> for example. Deref coercion makes it possible to call <code>hello</code>
with a reference to a value of type <code>MyBox&lt;String&gt;</code>, as shown in Listing 15-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;m);
}
</code></pre></pre>
<p><span class="caption">Listing 15-12: Calling <code>hello</code> with a reference to a
<code>MyBox&lt;String&gt;</code> value, which works because of deref coercion</span></p>
<p>Here we’re calling the <code>hello</code> function with the argument <code>&amp;m</code>, which is a
reference to a <code>MyBox&lt;String&gt;</code> value. Because we implemented the <code>Deref</code> trait
on <code>MyBox&lt;T&gt;</code> in Listing 15-10, Rust can turn <code>&amp;MyBox&lt;String&gt;</code> into <code>&amp;String</code>
by calling <code>deref</code>. The standard library provides an implementation of <code>Deref</code>
on <code>String</code> that returns a string slice, and this is in the API documentation
for <code>Deref</code>. Rust calls <code>deref</code> again to turn the <code>&amp;String</code> into <code>&amp;str</code>, which
matches the <code>hello</code> function’s definition.</p>
<p>If Rust didn’t implement deref coercion, we would have to write the code in
Listing 15-13 instead of the code in Listing 15-12 to call <code>hello</code> with a value
of type <code>&amp;MyBox&lt;String&gt;</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use std::ops::Deref;
</span><span class="boring">
</span><span class="boring">struct MyBox&lt;T&gt;(T);
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; MyBox&lt;T&gt; {
</span><span class="boring">    fn new(x: T) -&gt; MyBox&lt;T&gt; {
</span><span class="boring">        MyBox(x)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
</span><span class="boring">    type Target = T;
</span><span class="boring">
</span><span class="boring">    fn deref(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.0
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn hello(name: &amp;str) {
</span><span class="boring">    println!(&quot;Hello, {}!&quot;, name);
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let m = MyBox::new(String::from(&quot;Rust&quot;));
    hello(&amp;(*m)[..]);
}
</code></pre></pre>
<p><span class="caption">Listing 15-13: The code we would have to write if Rust
didn’t have deref coercion</span></p>
<p>The <code>(*m)</code> dereferences the <code>MyBox&lt;String&gt;</code> into a <code>String</code>. Then the <code>&amp;</code> and
<code>[..]</code> take a string slice of the <code>String</code> that is equal to the whole string to
match the signature of <code>hello</code>. The code without deref coercions is harder to
read, write, and understand with all of these symbols involved. Deref coercion
allows Rust to handle these conversions for us automatically.</p>
<p>When the <code>Deref</code> trait is defined for the types involved, Rust will analyze the
types and use <code>Deref::deref</code> as many times as necessary to get a reference to
match the parameter’s type. The number of times that <code>Deref::deref</code> needs to be
inserted is resolved at compile time, so there is no runtime penalty for taking
advantage of deref coercion!</p>
<h3><a class="header" href="#how-deref-coercion-interacts-with-mutability" id="how-deref-coercion-interacts-with-mutability">How Deref Coercion Interacts with Mutability</a></h3>
<p>Similar to how you use the <code>Deref</code> trait to override the <code>*</code> operator on
immutable references, you can use the <code>DerefMut</code> trait to override the <code>*</code>
operator on mutable references.</p>
<p>Rust does deref coercion when it finds types and trait implementations in three
cases:</p>
<ul>
<li>From <code>&amp;T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;mut U</code> when <code>T: DerefMut&lt;Target=U&gt;</code></li>
<li>From <code>&amp;mut T</code> to <code>&amp;U</code> when <code>T: Deref&lt;Target=U&gt;</code></li>
</ul>
<p>The first two cases are the same except for mutability. The first case states
that if you have a <code>&amp;T</code>, and <code>T</code> implements <code>Deref</code> to some type <code>U</code>, you can
get a <code>&amp;U</code> transparently. The second case states that the same deref coercion
happens for mutable references.</p>
<p>The third case is trickier: Rust will also coerce a mutable reference to an
immutable one. But the reverse is <em>not</em> possible: immutable references will
never coerce to mutable references. Because of the borrowing rules, if you have
a mutable reference, that mutable reference must be the only reference to that
data (otherwise, the program wouldn’t compile). Converting one mutable
reference to one immutable reference will never break the borrowing rules.
Converting an immutable reference to a mutable reference would require that
there is only one immutable reference to that data, and the borrowing rules
don’t guarantee that. Therefore, Rust can’t make the assumption that converting
an immutable reference to a mutable reference is possible.</p>
<h2><a class="header" href="#running-code-on-cleanup-with-the-drop-trait" id="running-code-on-cleanup-with-the-drop-trait">Running Code on Cleanup with the <code>Drop</code> Trait</a></h2>
<p>The second trait important to the smart pointer pattern is <code>Drop</code>, which lets
you customize what happens when a value is about to go out of scope. You can
provide an implementation for the <code>Drop</code> trait on any type, and the code you
specify can be used to release resources like files or network connections.
We’re introducing <code>Drop</code> in the context of smart pointers because the
functionality of the <code>Drop</code> trait is almost always used when implementing a
smart pointer. For example, <code>Box&lt;T&gt;</code> customizes <code>Drop</code> to deallocate the space
on the heap that the box points to.</p>
<p>In some languages, the programmer must call code to free memory or resources
every time they finish using an instance of a smart pointer. If they forget,
the system might become overloaded and crash. In Rust, you can specify that a
particular bit of code be run whenever a value goes out of scope, and the
compiler will insert this code automatically. As a result, you don’t need to be
careful about placing cleanup code everywhere in a program that an instance of
a particular type is finished with—you still won’t leak resources!</p>
<p>Specify the code to run when a value goes out of scope by implementing the
<code>Drop</code> trait. The <code>Drop</code> trait requires you to implement one method named
<code>drop</code> that takes a mutable reference to <code>self</code>. To see when Rust calls <code>drop</code>,
let’s implement <code>drop</code> with <code>println!</code> statements for now.</p>
<p>Listing 15-14 shows a <code>CustomSmartPointer</code> struct whose only custom
functionality is that it will print <code>Dropping CustomSmartPointer!</code> when the
instance goes out of scope. This example demonstrates when Rust runs the <code>drop</code>
function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
    }
}

fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;my stuff&quot;) };
    let d = CustomSmartPointer { data: String::from(&quot;other stuff&quot;) };
    println!(&quot;CustomSmartPointers created.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 15-14: A <code>CustomSmartPointer</code> struct that
implements the <code>Drop</code> trait where we would put our cleanup code</span></p>
<p>The <code>Drop</code> trait is included in the prelude, so we don’t need to bring it into
scope. We implement the <code>Drop</code> trait on <code>CustomSmartPointer</code> and provide an
implementation for the <code>drop</code> method that calls <code>println!</code>. The body of the
<code>drop</code> function is where you would place any logic that you wanted to run when
an instance of your type goes out of scope. We’re printing some text here to
demonstrate when Rust will call <code>drop</code>.</p>
<p>In <code>main</code>, we create two instances of <code>CustomSmartPointer</code> and then print
<code>CustomSmartPointers created.</code>. At the end of <code>main</code>, our instances of
<code>CustomSmartPointer</code> will go out of scope, and Rust will call the code we put
in the <code>drop</code> method, printing our final message. Note that we didn’t need to
call the <code>drop</code> method explicitly.</p>
<p>When we run this program, we’ll see the following output:</p>
<pre><code class="language-text">CustomSmartPointers created.
Dropping CustomSmartPointer with data `other stuff`!
Dropping CustomSmartPointer with data `my stuff`!
</code></pre>
<p>Rust automatically called <code>drop</code> for us when our instances went out of scope,
calling the code we specified. Variables are dropped in the reverse order of
their creation, so <code>d</code> was dropped before <code>c</code>. This example gives you a visual
guide to how the <code>drop</code> method works; usually you would specify the cleanup
code that your type needs to run rather than a print message.</p>
<h3><a class="header" href="#dropping-a-value-early-with-stdmemdrop" id="dropping-a-value-early-with-stdmemdrop">Dropping a Value Early with <code>std::mem::drop</code></a></h3>
<p>Unfortunately, it’s not straightforward to disable the automatic <code>drop</code>
functionality. Disabling <code>drop</code> isn’t usually necessary; the whole point of the
<code>Drop</code> trait is that it’s taken care of automatically. Occasionally, however,
you might want to clean up a value early. One example is when using smart
pointers that manage locks: you might want to force the <code>drop</code> method that
releases the lock to run so other code in the same scope can acquire the lock.
Rust doesn’t let you call the <code>Drop</code> trait’s <code>drop</code> method manually; instead
you have to call the <code>std::mem::drop</code> function provided by the standard library
if you want to force a value to be dropped before the end of its scope.</p>
<p>If we try to call the <code>Drop</code> trait’s <code>drop</code> method manually by modifying the
<code>main</code> function from Listing 15-14, as shown in Listing 15-15, we’ll get a
compiler error:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    c.drop();
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre>
<p><span class="caption">Listing 15-15: Attempting to call the <code>drop</code> method from
the <code>Drop</code> trait manually to clean up early</span></p>
<p>When we try to compile this code, we’ll get this error:</p>
<pre><code class="language-text">error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed
</code></pre>
<p>This error message states that we’re not allowed to explicitly call <code>drop</code>. The
error message uses the term <em>destructor</em>, which is the general programming term
for a function that cleans up an instance. A <em>destructor</em> is analogous to a
<em>constructor</em>, which creates an instance. The <code>drop</code> function in Rust is one
particular destructor.</p>
<p>Rust doesn’t let us call <code>drop</code> explicitly because Rust would still
automatically call <code>drop</code> on the value at the end of <code>main</code>. This would be a
<em>double free</em> error because Rust would be trying to clean up the same value
twice.</p>
<p>We can’t disable the automatic insertion of <code>drop</code> when a value goes out of
scope, and we can’t call the <code>drop</code> method explicitly. So, if we need to force
a value to be cleaned up early, we can use the <code>std::mem::drop</code> function.</p>
<p>The <code>std::mem::drop</code> function is different from the <code>drop</code> method in the <code>Drop</code>
trait. We call it by passing the value we want to force to be dropped early as
an argument. The function is in the prelude, so we can modify <code>main</code> in Listing
15-15 to call the <code>drop</code> function, as shown in Listing 15-16:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct CustomSmartPointer {
</span><span class="boring">    data: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Drop for CustomSmartPointer {
</span><span class="boring">    fn drop(&amp;mut self) {
</span><span class="boring">        println!(&quot;Dropping CustomSmartPointer!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let c = CustomSmartPointer { data: String::from(&quot;some data&quot;) };
    println!(&quot;CustomSmartPointer created.&quot;);
    drop(c);
    println!(&quot;CustomSmartPointer dropped before the end of main.&quot;);
}
</code></pre></pre>
<p><span class="caption">Listing 15-16: Calling <code>std::mem::drop</code> to explicitly
drop a value before it goes out of scope</span></p>
<p>Running this code will print the following:</p>
<pre><code class="language-text">CustomSmartPointer created.
Dropping CustomSmartPointer with data `some data`!
CustomSmartPointer dropped before the end of main.
</code></pre>
<p>The text <code>Dropping CustomSmartPointer with data `some data`!</code> is printed
between the <code>CustomSmartPointer created.</code> and <code>CustomSmartPointer dropped before the end of main.</code> text, showing that the <code>drop</code> method code is called to
drop <code>c</code> at that point.</p>
<p>You can use code specified in a <code>Drop</code> trait implementation in many ways to
make cleanup convenient and safe: for instance, you could use it to create your
own memory allocator! With the <code>Drop</code> trait and Rust’s ownership system, you
don’t have to remember to clean up because Rust does it automatically.</p>
<p>You also don’t have to worry about problems resulting from accidentally
cleaning up values still in use: the ownership system that makes sure
references are always valid also ensures that <code>drop</code> gets called only once when
the value is no longer being used.</p>
<p>Now that we’ve examined <code>Box&lt;T&gt;</code> and some of the characteristics of smart
pointers, let’s look at a few other smart pointers defined in the standard
library.</p>
<h2><a class="header" href="#rct-the-reference-counted-smart-pointer" id="rct-the-reference-counted-smart-pointer"><code>Rc&lt;T&gt;</code>, the Reference Counted Smart Pointer</a></h2>
<p>In the majority of cases, ownership is clear: you know exactly which variable
owns a given value. However, there are cases when a single value might have
multiple owners. For example, in graph data structures, multiple edges might
point to the same node, and that node is conceptually owned by all of the edges
that point to it. A node shouldn’t be cleaned up unless it doesn’t have any
edges pointing to it.</p>
<p>To enable multiple ownership, Rust has a type called <code>Rc&lt;T&gt;</code>, which is an
abbreviation for <em>reference counting</em>. The <code>Rc&lt;T&gt;</code> type keeps track of the
number of references to a value which determines whether or not a value is
still in use. If there are zero references to a value, the value can be cleaned
up without any references becoming invalid.</p>
<p>Imagine <code>Rc&lt;T&gt;</code> as a TV in a family room. When one person enters to watch TV,
they turn it on. Others can come into the room and watch the TV. When the last
person leaves the room, they turn off the TV because it’s no longer being used.
If someone turns off the TV while others are still watching it, there would be
uproar from the remaining TV watchers!</p>
<p>We use the <code>Rc&lt;T&gt;</code> type when we want to allocate some data on the heap for
multiple parts of our program to read and we can’t determine at compile time
which part will finish using the data last. If we knew which part would finish
last, we could just make that part the data’s owner, and the normal ownership
rules enforced at compile time would take effect.</p>
<p>Note that <code>Rc&lt;T&gt;</code> is only for use in single-threaded scenarios. When we discuss
concurrency in Chapter 16, we’ll cover how to do reference counting in
multithreaded programs.</p>
<h3><a class="header" href="#using-rct-to-share-data" id="using-rct-to-share-data">Using <code>Rc&lt;T&gt;</code> to Share Data</a></h3>
<p>Let’s return to our cons list example in Listing 15-5. Recall that we defined
it using <code>Box&lt;T&gt;</code>. This time, we’ll create two lists that both share ownership
of a third list. Conceptually, this looks similar to Figure 15-3:</p>
<img alt="Two lists that share ownership of a third list" src="rustbook/img/trpl15-03.svg" class="center" />
<p><span class="caption">Figure 15-3: Two lists, <code>b</code> and <code>c</code>, sharing ownership of
a third list, <code>a</code></span></p>
<p>We’ll create list <code>a</code> that contains 5 and then 10. Then we’ll make two more
lists: <code>b</code> that starts with 3 and <code>c</code> that starts with 4. Both <code>b</code> and <code>c</code>
lists will then continue on to the first <code>a</code> list containing 5 and 10. In other
words, both lists will share the first list containing 5 and 10.</p>
<p>Trying to implement this scenario using our definition of <code>List</code> with <code>Box&lt;T&gt;</code>
won’t work, as shown in Listing 15-17:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
    let b = Cons(3, Box::new(a));
    let c = Cons(4, Box::new(a));
}
</code></pre>
<p><span class="caption">Listing 15-17: Demonstrating we’re not allowed to have
two lists using <code>Box&lt;T&gt;</code> that try to share ownership of a third list</span></p>
<p>When we compile this code, we get this error:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait
</code></pre>
<p>The <code>Cons</code> variants own the data they hold, so when we create the <code>b</code> list, <code>a</code>
is moved into <code>b</code> and <code>b</code> owns <code>a</code>. Then, when we try to use <code>a</code> again when
creating <code>c</code>, we’re not allowed to because <code>a</code> has been moved.</p>
<p>We could change the definition of <code>Cons</code> to hold references instead, but then
we would have to specify lifetime parameters. By specifying lifetime
parameters, we would be specifying that every element in the list will live at
least as long as the entire list. The borrow checker wouldn’t let us compile
<code>let a = Cons(10, &amp;Nil);</code> for example, because the temporary <code>Nil</code> value would
be dropped before <code>a</code> could take a reference to it.</p>
<p>Instead, we’ll change our definition of <code>List</code> to use <code>Rc&lt;T&gt;</code> in place of
<code>Box&lt;T&gt;</code>, as shown in Listing 15-18. Each <code>Cons</code> variant will now hold a value
and an <code>Rc&lt;T&gt;</code> pointing to a <code>List</code>. When we create <code>b</code>, instead of taking
ownership of <code>a</code>, we’ll clone the <code>Rc&lt;List&gt;</code> that <code>a</code> is holding, thereby
increasing the number of references from one to two and letting <code>a</code> and <code>b</code>
share ownership of the data in that <code>Rc&lt;List&gt;</code>. We’ll also clone <code>a</code> when
creating <code>c</code>, increasing the number of references from two to three. Every time
we call <code>Rc::clone</code>, the reference count to the data within the <code>Rc&lt;List&gt;</code> will
increase, and the data won’t be cleaned up unless there are zero references to
it.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum List {
    Cons(i32, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;

fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    let b = Cons(3, Rc::clone(&amp;a));
    let c = Cons(4, Rc::clone(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listing 15-18: A definition of <code>List</code> that uses
<code>Rc&lt;T&gt;</code></span></p>
<p>We need to add a <code>use</code> statement to bring <code>Rc&lt;T&gt;</code> into scope because it’s not
in the prelude. In <code>main</code>, we create the list holding 5 and 10 and store it in
a new <code>Rc&lt;List&gt;</code> in <code>a</code>. Then when we create <code>b</code> and <code>c</code>, we call the
<code>Rc::clone</code> function and pass a reference to the <code>Rc&lt;List&gt;</code> in <code>a</code> as an
argument.</p>
<p>We could have called <code>a.clone()</code> rather than <code>Rc::clone(&amp;a)</code>, but Rust’s
convention is to use <code>Rc::clone</code> in this case. The implementation of
<code>Rc::clone</code> doesn’t make a deep copy of all the data like most types’
implementations of <code>clone</code> do. The call to <code>Rc::clone</code> only increments the
reference count, which doesn’t take much time. Deep copies of data can take a
lot of time. By using <code>Rc::clone</code> for reference counting, we can visually
distinguish between the deep-copy kinds of clones and the kinds of clones that
increase the reference count. When looking for performance problems in the
code, we only need to consider the deep-copy clones and can disregard calls to
<code>Rc::clone</code>.</p>
<h3><a class="header" href="#cloning-an-rct-increases-the-reference-count" id="cloning-an-rct-increases-the-reference-count">Cloning an <code>Rc&lt;T&gt;</code> Increases the Reference Count</a></h3>
<p>Let’s change our working example in Listing 15-18 so we can see the reference
counts changing as we create and drop references to the <code>Rc&lt;List&gt;</code> in <code>a</code>.</p>
<p>In Listing 15-19, we’ll change <code>main</code> so it has an inner scope around list <code>c</code>;
then we can see how the reference count changes when <code>c</code> goes out of scope.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum List {
</span><span class="boring">    Cons(i32, Rc&lt;List&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    println!(&quot;count after creating a = {}&quot;, Rc::strong_count(&amp;a));
    let b = Cons(3, Rc::clone(&amp;a));
    println!(&quot;count after creating b = {}&quot;, Rc::strong_count(&amp;a));
    {
        let c = Cons(4, Rc::clone(&amp;a));
        println!(&quot;count after creating c = {}&quot;, Rc::strong_count(&amp;a));
    }
    println!(&quot;count after c goes out of scope = {}&quot;, Rc::strong_count(&amp;a));
}
</code></pre></pre>
<p><span class="caption">Listing 15-19: Printing the reference count</span></p>
<p>At each point in the program where the reference count changes, we print the
reference count, which we can get by calling the <code>Rc::strong_count</code> function.
This function is named <code>strong_count</code> rather than <code>count</code> because the <code>Rc&lt;T&gt;</code>
type also has a <code>weak_count</code>; we’ll see what <code>weak_count</code> is used for in the
<a href="rustbook/ch15-06-reference-cycles.html#preventing-reference-cycles-turning-an-rct-into-a-weakt">“Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a
<code>Weak&lt;T&gt;</code>”</a><!-- ignore --> section.</p>
<p>This code prints the following:</p>
<pre><code class="language-text">count after creating a = 1
count after creating b = 2
count after creating c = 3
count after c goes out of scope = 2
</code></pre>
<p>We can see that the <code>Rc&lt;List&gt;</code> in <code>a</code> has an initial reference count of 1; then
each time we call <code>clone</code>, the count goes up by 1. When <code>c</code> goes out of scope,
the count goes down by 1. We don’t have to call a function to decrease the
reference count like we have to call <code>Rc::clone</code> to increase the reference
count: the implementation of the <code>Drop</code> trait decreases the reference count
automatically when an <code>Rc&lt;T&gt;</code> value goes out of scope.</p>
<p>What we can’t see in this example is that when <code>b</code> and then <code>a</code> go out of scope
at the end of <code>main</code>, the count is then 0, and the <code>Rc&lt;List&gt;</code> is cleaned up
completely at that point. Using <code>Rc&lt;T&gt;</code> allows a single value to have
multiple owners, and the count ensures that the value remains valid as long as
any of the owners still exist.</p>
<p>Via immutable references, <code>Rc&lt;T&gt;</code> allows you to share data between multiple
parts of your program for reading only. If <code>Rc&lt;T&gt;</code> allowed you to have multiple
mutable references too, you might violate one of the borrowing rules discussed
in Chapter 4: multiple mutable borrows to the same place can cause data races
and inconsistencies. But being able to mutate data is very useful! In the next
section, we’ll discuss the interior mutability pattern and the <code>RefCell&lt;T&gt;</code>
type that you can use in conjunction with an <code>Rc&lt;T&gt;</code> to work with this
immutability restriction.</p>
<h2><a class="header" href="#refcellt-and-the-interior-mutability-pattern" id="refcellt-and-the-interior-mutability-pattern"><code>RefCell&lt;T&gt;</code> and the Interior Mutability Pattern</a></h2>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate
data even when there are immutable references to that data; normally, this
action is disallowed by the borrowing rules. To mutate data, the pattern uses
<code>unsafe</code> code inside a data structure to bend Rust’s usual rules that govern
mutation and borrowing. We haven’t yet covered unsafe code; we will in
Chapter 19. We can use types that use the interior mutability pattern when we
can ensure that the borrowing rules will be followed at runtime, even though
the compiler can’t guarantee that. The <code>unsafe</code> code involved is then wrapped
in a safe API, and the outer type is still immutable.</p>
<p>Let’s explore this concept by looking at the <code>RefCell&lt;T&gt;</code> type that follows the
interior mutability pattern.</p>
<h3><a class="header" href="#enforcing-borrowing-rules-at-runtime-with-refcellt" id="enforcing-borrowing-rules-at-runtime-with-refcellt">Enforcing Borrowing Rules at Runtime with <code>RefCell&lt;T&gt;</code></a></h3>
<p>Unlike <code>Rc&lt;T&gt;</code>, the <code>RefCell&lt;T&gt;</code> type represents single ownership over the data
it holds. So, what makes <code>RefCell&lt;T&gt;</code> different from a type like <code>Box&lt;T&gt;</code>?
Recall the borrowing rules you learned in Chapter 4:</p>
<ul>
<li>At any given time, you can have <em>either</em> (but not both of) one mutable
reference or any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p>With references and <code>Box&lt;T&gt;</code>, the borrowing rules’ invariants are enforced at
compile time. With <code>RefCell&lt;T&gt;</code>, these invariants are enforced <em>at runtime</em>.
With references, if you break these rules, you’ll get a compiler error. With
<code>RefCell&lt;T&gt;</code>, if you break these rules, your program will panic and exit.</p>
<p>The advantages of checking the borrowing rules at compile time are that errors
will be caught sooner in the development process, and there is no impact on
runtime performance because all the analysis is completed beforehand. For those
reasons, checking the borrowing rules at compile time is the best choice in the
majority of cases, which is why this is Rust’s default.</p>
<p>The advantage of checking the borrowing rules at runtime instead is that
certain memory-safe scenarios are then allowed, whereas they are disallowed by
the compile-time checks. Static analysis, like the Rust compiler, is inherently
conservative. Some properties of code are impossible to detect by analyzing the
code: the most famous example is the Halting Problem, which is beyond the scope
of this book but is an interesting topic to research.</p>
<p>Because some analysis is impossible, if the Rust compiler can’t be sure the
code complies with the ownership rules, it might reject a correct program; in
this way, it’s conservative. If Rust accepted an incorrect program, users
wouldn’t be able to trust in the guarantees Rust makes. However, if Rust
rejects a correct program, the programmer will be inconvenienced, but nothing
catastrophic can occur. The <code>RefCell&lt;T&gt;</code> type is useful when you’re sure your
code follows the borrowing rules but the compiler is unable to understand and
guarantee that.</p>
<p>Similar to <code>Rc&lt;T&gt;</code>, <code>RefCell&lt;T&gt;</code> is only for use in single-threaded scenarios
and will give you a compile-time error if you try using it in a multithreaded
context. We’ll talk about how to get the functionality of <code>RefCell&lt;T&gt;</code> in a
multithreaded program in Chapter 16.</p>
<p>Here is a recap of the reasons to choose <code>Box&lt;T&gt;</code>, <code>Rc&lt;T&gt;</code>, or <code>RefCell&lt;T&gt;</code>:</p>
<ul>
<li><code>Rc&lt;T&gt;</code> enables multiple owners of the same data; <code>Box&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code>
have single owners.</li>
<li><code>Box&lt;T&gt;</code> allows immutable or mutable borrows checked at compile time; <code>Rc&lt;T&gt;</code>
allows only immutable borrows checked at compile time; <code>RefCell&lt;T&gt;</code> allows
immutable or mutable borrows checked at runtime.</li>
<li>Because <code>RefCell&lt;T&gt;</code> allows mutable borrows checked at runtime, you can
mutate the value inside the <code>RefCell&lt;T&gt;</code> even when the <code>RefCell&lt;T&gt;</code> is
immutable.</li>
</ul>
<p>Mutating the value inside an immutable value is the <em>interior mutability</em>
pattern. Let’s look at a situation in which interior mutability is useful and
examine how it’s possible.</p>
<h3><a class="header" href="#interior-mutability-a-mutable-borrow-to-an-immutable-value" id="interior-mutability-a-mutable-borrow-to-an-immutable-value">Interior Mutability: A Mutable Borrow to an Immutable Value</a></h3>
<p>A consequence of the borrowing rules is that when you have an immutable value,
you can’t borrow it mutably. For example, this code won’t compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let x = 5;
    let y = &amp;mut x;
}
</code></pre>
<p>If you tried to compile this code, you’d get the following error:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable local variable `x` as mutable
 --&gt; src/main.rs:3:18
  |
2 |     let x = 5;
  |         - consider changing this to `mut x`
3 |     let y = &amp;mut x;
  |                  ^ cannot borrow mutably
</code></pre>
<p>However, there are situations in which it would be useful for a value to mutate
itself in its methods but appear immutable to other code. Code outside the
value’s methods would not be able to mutate the value. Using <code>RefCell&lt;T&gt;</code> is
one way to get the ability to have interior mutability. But <code>RefCell&lt;T&gt;</code>
doesn’t get around the borrowing rules completely: the borrow checker in the
compiler allows this interior mutability, and the borrowing rules are checked
at runtime instead. If you violate the rules, you’ll get a <code>panic!</code> instead of
a compiler error.</p>
<p>Let’s work through a practical example where we can use <code>RefCell&lt;T&gt;</code> to mutate
an immutable value and see why that is useful.</p>
<h4><a class="header" href="#a-use-case-for-interior-mutability-mock-objects" id="a-use-case-for-interior-mutability-mock-objects">A Use Case for Interior Mutability: Mock Objects</a></h4>
<p>A <em>test double</em> is the general programming concept for a type used in place of
another type during testing. <em>Mock objects</em> are specific types of test doubles
that record what happens during a test so you can assert that the correct
actions took place.</p>
<p>Rust doesn’t have objects in the same sense as other languages have objects,
and Rust doesn’t have mock object functionality built into the standard library
as some other languages do. However, you can definitely create a struct that
will serve the same purposes as a mock object.</p>
<p>Here’s the scenario we’ll test: we’ll create a library that tracks a value
against a maximum value and sends messages based on how close to the maximum
value the current value is. This library could be used to keep track of a
user’s quota for the number of API calls they’re allowed to make, for example.</p>
<p>Our library will only provide the functionality of tracking how close to the
maximum a value is and what the messages should be at what times. Applications
that use our library will be expected to provide the mechanism for sending the
messages: the application could put a message in the application, send an
email, send a text message, or something else. The library doesn’t need to know
that detail. All it needs is something that implements a trait we’ll provide
called <code>Messenger</code>. Listing 15-20 shows the library code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Messenger {
    fn send(&amp;self, msg: &amp;str);
}

pub struct LimitTracker&lt;'a, T: Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}

impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where T: Messenger {
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
    }

    pub fn set_value(&amp;mut self, value: usize) {
        self.value = value;

        let percentage_of_max = self.value as f64 / self.max as f64;

        if percentage_of_max &gt;= 1.0 {
            self.messenger.send(&quot;Error: You are over your quota!&quot;);
        } else if percentage_of_max &gt;= 0.9 {
             self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 15-20: A library to keep track of how close a
value is to a maximum value and warn when the value is at certain levels</span></p>
<p>One important part of this code is that the <code>Messenger</code> trait has one method
called <code>send</code> that takes an immutable reference to <code>self</code> and the text of the
message. This is the interface our mock object needs to have. The other
important part is that we want to test the behavior of the <code>set_value</code> method
on the <code>LimitTracker</code>. We can change what we pass in for the <code>value</code> parameter,
but <code>set_value</code> doesn’t return anything for us to make assertions on. We want
to be able to say that if we create a <code>LimitTracker</code> with something that
implements the <code>Messenger</code> trait and a particular value for <code>max</code>, when we pass
different numbers for <code>value</code>, the messenger is told to send the appropriate
messages.</p>
<p>We need a mock object that, instead of sending an email or text message when we
call <code>send</code>, will only keep track of the messages it’s told to send. We can
create a new instance of the mock object, create a <code>LimitTracker</code> that uses the
mock object, call the <code>set_value</code> method on <code>LimitTracker</code>, and then check that
the mock object has the messages we expect. Listing 15-21 shows an attempt to
implement a mock object to do just that, but the borrow checker won’t allow it:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">#[cfg(test)]
mod tests {
    use super::*;

    struct MockMessenger {
        sent_messages: Vec&lt;String&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        let mock_messenger = MockMessenger::new();
        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);

        limit_tracker.set_value(80);

        assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}
</code></pre>
<p><span class="caption">Listing 15-21: An attempt to implement a <code>MockMessenger</code>
that isn’t allowed by the borrow checker</span></p>
<p>This test code defines a <code>MockMessenger</code> struct that has a <code>sent_messages</code>
field with a <code>Vec</code> of <code>String</code> values to keep track of the messages it’s told
to send. We also define an associated function <code>new</code> to make it convenient to
create new <code>MockMessenger</code> values that start with an empty list of messages. We
then implement the <code>Messenger</code> trait for <code>MockMessenger</code> so we can give a
<code>MockMessenger</code> to a <code>LimitTracker</code>. In the definition of the <code>send</code> method, we
take the message passed in as a parameter and store it in the <code>MockMessenger</code>
list of <code>sent_messages</code>.</p>
<p>In the test, we’re testing what happens when the <code>LimitTracker</code> is told to set
<code>value</code> to something that is more than 75 percent of the <code>max</code> value. First, we
create a new <code>MockMessenger</code>, which will start with an empty list of messages.
Then we create a new <code>LimitTracker</code> and give it a reference to the new
<code>MockMessenger</code> and a <code>max</code> value of 100. We call the <code>set_value</code> method on the
<code>LimitTracker</code> with a value of 80, which is more than 75 percent of 100. Then
we assert that the list of messages that the <code>MockMessenger</code> is keeping track
of should now have one message in it.</p>
<p>However, there’s one problem with this test, as shown here:</p>
<pre><code class="language-text">error[E0596]: cannot borrow immutable field `self.sent_messages` as mutable
  --&gt; src/lib.rs:52:13
   |
51 |         fn send(&amp;self, message: &amp;str) {
   |                 ----- use `&amp;mut self` here to make mutable
52 |             self.sent_messages.push(String::from(message));
   |             ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field
</code></pre>
<p>We can’t modify the <code>MockMessenger</code> to keep track of the messages, because the
<code>send</code> method takes an immutable reference to <code>self</code>. We also can’t take the
suggestion from the error text to use <code>&amp;mut self</code> instead, because then the
signature of <code>send</code> wouldn’t match the signature in the <code>Messenger</code> trait
definition (feel free to try and see what error message you get).</p>
<p>This is a situation in which interior mutability can help! We’ll store the
<code>sent_messages</code> within a <code>RefCell&lt;T&gt;</code>, and then the <code>send</code> message will be
able to modify <code>sent_messages</code> to store the messages we’ve seen. Listing 15-22
shows what that looks like:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">pub trait Messenger {
</span><span class="boring">    fn send(&amp;self, msg: &amp;str);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct LimitTracker&lt;'a, T: Messenger&gt; {
</span><span class="boring">    messenger: &amp;'a T,
</span><span class="boring">    value: usize,
</span><span class="boring">    max: usize,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
</span><span class="boring">    where T: Messenger {
</span><span class="boring">    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
</span><span class="boring">        LimitTracker {
</span><span class="boring">            messenger,
</span><span class="boring">            value: 0,
</span><span class="boring">            max,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn set_value(&amp;mut self, value: usize) {
</span><span class="boring">        self.value = value;
</span><span class="boring">
</span><span class="boring">        let percentage_of_max = self.value as f64 / self.max as f64;
</span><span class="boring">
</span><span class="boring">        if percentage_of_max &gt;= 1.0 {
</span><span class="boring">            self.messenger.send(&quot;Error: You are over your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.9 {
</span><span class="boring">             self.messenger.send(&quot;Urgent warning: You've used up over 90% of your quota!&quot;);
</span><span class="boring">        } else if percentage_of_max &gt;= 0.75 {
</span><span class="boring">            self.messenger.send(&quot;Warning: You've used up over 75% of your quota!&quot;);
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    use std::cell::RefCell;

    struct MockMessenger {
        sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,
    }

    impl MockMessenger {
        fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: RefCell::new(vec![]) }
        }
    }

    impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    #[test]
    fn it_sends_an_over_75_percent_warning_message() {
        // --snip--
<span class="boring">        let mock_messenger = MockMessenger::new();
</span><span class="boring">        let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
</span><span class="boring">        limit_tracker.set_value(75);
</span>
        assert_eq!(mock_messenger.sent_messages.borrow().len(), 1);
    }
}
<span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Listing 15-22: Using <code>RefCell&lt;T&gt;</code> to mutate an inner
value while the outer value is considered immutable</span></p>
<p>The <code>sent_messages</code> field is now of type <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> instead of
<code>Vec&lt;String&gt;</code>. In the <code>new</code> function, we create a new <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>
instance around the empty vector.</p>
<p>For the implementation of the <code>send</code> method, the first parameter is still an
immutable borrow of <code>self</code>, which matches the trait definition. We call
<code>borrow_mut</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> in <code>self.sent_messages</code> to get a
mutable reference to the value inside the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>, which is
the vector. Then we can call <code>push</code> on the mutable reference to the vector to
keep track of the messages sent during the test.</p>
<p>The last change we have to make is in the assertion: to see how many items are
in the inner vector, we call <code>borrow</code> on the <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> to get an
immutable reference to the vector.</p>
<p>Now that you’ve seen how to use <code>RefCell&lt;T&gt;</code>, let’s dig into how it works!</p>
<h4><a class="header" href="#keeping-track-of-borrows-at-runtime-with-refcellt" id="keeping-track-of-borrows-at-runtime-with-refcellt">Keeping Track of Borrows at Runtime with <code>RefCell&lt;T&gt;</code></a></h4>
<p>When creating immutable and mutable references, we use the <code>&amp;</code> and <code>&amp;mut</code>
syntax, respectively. With <code>RefCell&lt;T&gt;</code>, we use the <code>borrow</code> and <code>borrow_mut</code>
methods, which are part of the safe API that belongs to <code>RefCell&lt;T&gt;</code>. The
<code>borrow</code> method returns the smart pointer type <code>Ref&lt;T&gt;</code>, and <code>borrow_mut</code>
returns the smart pointer type <code>RefMut&lt;T&gt;</code>. Both types implement <code>Deref</code>, so we
can treat them like regular references.</p>
<p>The <code>RefCell&lt;T&gt;</code> keeps track of how many <code>Ref&lt;T&gt;</code> and <code>RefMut&lt;T&gt;</code> smart
pointers are currently active. Every time we call <code>borrow</code>, the <code>RefCell&lt;T&gt;</code>
increases its count of how many immutable borrows are active. When a <code>Ref&lt;T&gt;</code>
value goes out of scope, the count of immutable borrows goes down by one. Just
like the compile-time borrowing rules, <code>RefCell&lt;T&gt;</code> lets us have many immutable
borrows or one mutable borrow at any point in time.</p>
<p>If we try to violate these rules, rather than getting a compiler error as we
would with references, the implementation of <code>RefCell&lt;T&gt;</code> will panic at
runtime. Listing 15-23 shows a modification of the implementation of <code>send</code> in
Listing 15-22. We’re deliberately trying to create two mutable borrows active
for the same scope to illustrate that <code>RefCell&lt;T&gt;</code> prevents us from doing this
at runtime.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore panics">impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
</code></pre>
<p><span class="caption">Listing 15-23: Creating two mutable references in the
same scope to see that <code>RefCell&lt;T&gt;</code> will panic</span></p>
<p>We create a variable <code>one_borrow</code> for the <code>RefMut&lt;T&gt;</code> smart pointer returned
from <code>borrow_mut</code>. Then we create another mutable borrow in the same way in the
variable <code>two_borrow</code>. This makes two mutable references in the same scope,
which isn’t allowed. When we run the tests for our library, the code in Listing
15-23 will compile without any errors, but the test will fail:</p>
<pre><code class="language-text">---- tests::it_sends_an_over_75_percent_warning_message stdout ----
	thread 'tests::it_sends_an_over_75_percent_warning_message' panicked at
'already borrowed: BorrowMutError', src/libcore/result.rs:906:4
note: Run with `RUST_BACKTRACE=1` for a backtrace.
</code></pre>
<p>Notice that the code panicked with the message <code>already borrowed: BorrowMutError</code>. This is how <code>RefCell&lt;T&gt;</code> handles violations of the borrowing
rules at runtime.</p>
<p>Catching borrowing errors at runtime rather than compile time means that you
would find a mistake in your code later in the development process and possibly
not until your code was deployed to production. Also, your code would incur a
small runtime performance penalty as a result of keeping track of the borrows
at runtime rather than compile time. However, using <code>RefCell&lt;T&gt;</code> makes it
possible to write a mock object that can modify itself to keep track of the
messages it has seen while you’re using it in a context where only immutable
values are allowed. You can use <code>RefCell&lt;T&gt;</code> despite its trade-offs to get more
functionality than regular references provide.</p>
<h3><a class="header" href="#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt" id="having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt">Having Multiple Owners of Mutable Data by Combining <code>Rc&lt;T&gt;</code> and <code>RefCell&lt;T&gt;</code></a></h3>
<p>A common way to use <code>RefCell&lt;T&gt;</code> is in combination with <code>Rc&lt;T&gt;</code>. Recall that
<code>Rc&lt;T&gt;</code> lets you have multiple owners of some data, but it only gives immutable
access to that data. If you have an <code>Rc&lt;T&gt;</code> that holds a <code>RefCell&lt;T&gt;</code>, you can
get a value that can have multiple owners <em>and</em> that you can mutate!</p>
<p>For example, recall the cons list example in Listing 15-18 where we used
<code>Rc&lt;T&gt;</code> to allow multiple lists to share ownership of another list. Because
<code>Rc&lt;T&gt;</code> holds only immutable values, we can’t change any of the values in the
list once we’ve created them. Let’s add in <code>RefCell&lt;T&gt;</code> to gain the ability to
change the values in the lists. Listing 15-24 shows that by using a
<code>RefCell&lt;T&gt;</code> in the <code>Cons</code> definition, we can modify the value stored in all
the lists:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}

use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
    let value = Rc::new(RefCell::new(5));

    let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));

    let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
    let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));

    *value.borrow_mut() += 10;

    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}
</code></pre></pre>
<p><span class="caption">Listing 15-24: Using <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> to create a
<code>List</code> that we can mutate</span></p>
<p>We create a value that is an instance of <code>Rc&lt;RefCell&lt;i32&gt;&gt;</code> and store it in a
variable named <code>value</code> so we can access it directly later. Then we create a
<code>List</code> in <code>a</code> with a <code>Cons</code> variant that holds <code>value</code>. We need to clone
<code>value</code> so both <code>a</code> and <code>value</code> have ownership of the inner <code>5</code> value rather
than transferring ownership from <code>value</code> to <code>a</code> or having <code>a</code> borrow from
<code>value</code>.</p>
<p>We wrap the list <code>a</code> in an <code>Rc&lt;T&gt;</code> so when we create lists <code>b</code> and <code>c</code>, they
can both refer to <code>a</code>, which is what we did in Listing 15-18.</p>
<p>After we’ve created the lists in <code>a</code>, <code>b</code>, and <code>c</code>, we add 10 to the value in
<code>value</code>. We do this by calling <code>borrow_mut</code> on <code>value</code>, which uses the
automatic dereferencing feature we discussed in Chapter 5 (see the section
<a href="rustbook/ch05-03-method-syntax.html#wheres-the---operator">“Where’s the <code>-&gt;</code> Operator?”</a><!-- ignore -->) to
dereference the <code>Rc&lt;T&gt;</code> to the inner <code>RefCell&lt;T&gt;</code> value. The <code>borrow_mut</code>
method returns a <code>RefMut&lt;T&gt;</code> smart pointer, and we use the dereference operator
on it and change the inner value.</p>
<p>When we print <code>a</code>, <code>b</code>, and <code>c</code>, we can see that they all have the modified
value of 15 rather than 5:</p>
<pre><code class="language-text">a after = Cons(RefCell { value: 15 }, Nil)
b after = Cons(RefCell { value: 6 }, Cons(RefCell { value: 15 }, Nil))
c after = Cons(RefCell { value: 10 }, Cons(RefCell { value: 15 }, Nil))
</code></pre>
<p>This technique is pretty neat! By using <code>RefCell&lt;T&gt;</code>, we have an outwardly
immutable <code>List</code> value. But we can use the methods on <code>RefCell&lt;T&gt;</code> that provide
access to its interior mutability so we can modify our data when we need to.
The runtime checks of the borrowing rules protect us from data races, and it’s
sometimes worth trading a bit of speed for this flexibility in our data
structures.</p>
<p>The standard library has other types that provide interior mutability, such as
<code>Cell&lt;T&gt;</code>, which is similar except that instead of giving references to the
inner value, the value is copied in and out of the <code>Cell&lt;T&gt;</code>. There’s also
<code>Mutex&lt;T&gt;</code>, which offers interior mutability that’s safe to use across threads;
we’ll discuss its use in Chapter 16. Check out the standard library docs for
more details on the differences between these types.</p>
<h2><a class="header" href="#reference-cycles-can-leak-memory" id="reference-cycles-can-leak-memory">Reference Cycles Can Leak Memory</a></h2>
<p>Rust’s memory safety guarantees make it difficult, but not impossible, to
accidentally create memory that is never cleaned up (known as a <em>memory leak</em>).
Preventing memory leaks entirely is not one of Rust’s guarantees in the same
way that disallowing data races at compile time is, meaning memory leaks are
memory safe in Rust. We can see that Rust allows memory leaks by using <code>Rc&lt;T&gt;</code>
and <code>RefCell&lt;T&gt;</code>: it’s possible to create references where items refer to each
other in a cycle. This creates memory leaks because the reference count of each
item in the cycle will never reach 0, and the values will never be dropped.</p>
<h3><a class="header" href="#creating-a-reference-cycle" id="creating-a-reference-cycle">Creating a Reference Cycle</a></h3>
<p>Let’s look at how a reference cycle might happen and how to prevent it,
starting with the definition of the <code>List</code> enum and a <code>tail</code> method in Listing
15-25:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<!-- Hidden fn main is here to disable the automatic wrapping in fn main that
doc tests do; the `use List` fails if this listing is put within a main -->
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {}
</span>use std::rc::Rc;
use std::cell::RefCell;
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 15-25: A cons list definition that holds a
<code>RefCell&lt;T&gt;</code> so we can modify what a <code>Cons</code> variant is referring to</span></p>
<p>We’re using another variation of the <code>List</code> definition from Listing 15-5. The
second element in the <code>Cons</code> variant is now <code>RefCell&lt;Rc&lt;List&gt;&gt;</code>, meaning that
instead of having the ability to modify the <code>i32</code> value as we did in Listing
15-24, we want to modify which <code>List</code> value a <code>Cons</code> variant is pointing to.
We’re also adding a <code>tail</code> method to make it convenient for us to access the
second item if we have a <code>Cons</code> variant.</p>
<p>In Listing 15-26, we’re adding a <code>main</code> function that uses the definitions in
Listing 15-25. This code creates a list in <code>a</code> and a list in <code>b</code> that points to
the list in <code>a</code>. Then it modifies the list in <code>a</code> to point to <code>b</code>, creating a
reference cycle. There are <code>println!</code> statements along the way to show what the
reference counts are at various points in this process.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use crate::List::{Cons, Nil};
</span><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">enum List {
</span><span class="boring">    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
</span><span class="boring">    Nil,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl List {
</span><span class="boring">    fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            Cons(_, item) =&gt; Some(item),
</span><span class="boring">            Nil =&gt; None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));

    println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;a next item = {:?}&quot;, a.tail());

    let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));

    println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
    println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;b next item = {:?}&quot;, b.tail());

    if let Some(link) = a.tail() {
        *link.borrow_mut() = Rc::clone(&amp;b);
    }

    println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
    println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));

    // Uncomment the next line to see that we have a cycle;
    // it will overflow the stack
    // println!(&quot;a next item = {:?}&quot;, a.tail());
}
</code></pre></pre>
<p><span class="caption">Listing 15-26: Creating a reference cycle of two <code>List</code>
values pointing to each other</span></p>
<p>We create an <code>Rc&lt;List&gt;</code> instance holding a <code>List</code> value in the variable <code>a</code>
with an initial list of <code>5, Nil</code>. We then create an <code>Rc&lt;List&gt;</code> instance
holding another <code>List</code> value in the variable <code>b</code> that contains the value 10 and
points to the list in <code>a</code>.</p>
<p>We modify <code>a</code> so it points to <code>b</code> instead of <code>Nil</code>, creating a cycle. We
do that by using the <code>tail</code> method to get a reference to the
<code>RefCell&lt;Rc&lt;List&gt;&gt;</code> in <code>a</code>, which we put in the variable <code>link</code>. Then we use
the <code>borrow_mut</code> method on the <code>RefCell&lt;Rc&lt;List&gt;&gt;</code> to change the value inside
from an <code>Rc&lt;List&gt;</code> that holds a <code>Nil</code> value to the <code>Rc&lt;List&gt;</code> in <code>b</code>.</p>
<p>When we run this code, keeping the last <code>println!</code> commented out for the
moment, we’ll get this output:</p>
<pre><code class="language-text">a initial rc count = 1
a next item = Some(RefCell { value: Nil })
a rc count after b creation = 2
b initial rc count = 1
b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })
b rc count after changing a = 2
a rc count after changing a = 2
</code></pre>
<p>The reference count of the <code>Rc&lt;List&gt;</code> instances in both <code>a</code> and <code>b</code> are 2
after we change the list in <code>a</code> to point to <code>b</code>. At the end of <code>main</code>, Rust
will try to drop <code>b</code> first, which will decrease the count of the <code>Rc&lt;List&gt;</code>
instance in <code>b</code> by 1.</p>
<p>However, because <code>a</code> is still referencing the <code>Rc&lt;List&gt;</code> that was in <code>b</code>, that
<code>Rc&lt;List&gt;</code> has a count of 1 rather than 0, so the memory the <code>Rc&lt;List&gt;</code> has on
the heap won’t be dropped. The memory will just sit there with a count of 1,
forever. To visualize this reference cycle, we’ve created a diagram in Figure
15-4.</p>
<img alt="Reference cycle of lists" src="rustbook/img/trpl15-04.svg" class="center" />
<p><span class="caption">Figure 15-4: A reference cycle of lists <code>a</code> and <code>b</code>
pointing to each other</span></p>
<p>If you uncomment the last <code>println!</code> and run the program, Rust will try to
print this cycle with <code>a</code> pointing to <code>b</code> pointing to <code>a</code> and so forth until it
overflows the stack.</p>
<p>In this case, right after we create the reference cycle, the program ends. The
consequences of this cycle aren’t very dire. However, if a more complex program
allocated lots of memory in a cycle and held onto it for a long time, the
program would use more memory than it needed and might overwhelm the system,
causing it to run out of available memory.</p>
<p>Creating reference cycles is not easily done, but it’s not impossible either.
If you have <code>RefCell&lt;T&gt;</code> values that contain <code>Rc&lt;T&gt;</code> values or similar nested
combinations of types with interior mutability and reference counting, you must
ensure that you don’t create cycles; you can’t rely on Rust to catch them.
Creating a reference cycle would be a logic bug in your program that you should
use automated tests, code reviews, and other software development practices to
minimize.</p>
<p>Another solution for avoiding reference cycles is reorganizing your data
structures so that some references express ownership and some references don’t.
As a result, you can have cycles made up of some ownership relationships and
some non-ownership relationships, and only the ownership relationships affect
whether or not a value can be dropped. In Listing 15-25, we always want <code>Cons</code>
variants to own their list, so reorganizing the data structure isn’t possible.
Let’s look at an example using graphs made up of parent nodes and child nodes
to see when non-ownership relationships are an appropriate way to prevent
reference cycles.</p>
<h3><a class="header" href="#preventing-reference-cycles-turning-an-rct-into-a-weakt" id="preventing-reference-cycles-turning-an-rct-into-a-weakt">Preventing Reference Cycles: Turning an <code>Rc&lt;T&gt;</code> into a <code>Weak&lt;T&gt;</code></a></h3>
<p>So far, we’ve demonstrated that calling <code>Rc::clone</code> increases the
<code>strong_count</code> of an <code>Rc&lt;T&gt;</code> instance, and an <code>Rc&lt;T&gt;</code> instance is only cleaned
up if its <code>strong_count</code> is 0. You can also create a <em>weak reference</em> to the
value within an <code>Rc&lt;T&gt;</code> instance by calling <code>Rc::downgrade</code> and passing a
reference to the <code>Rc&lt;T&gt;</code>. When you call <code>Rc::downgrade</code>, you get a smart
pointer of type <code>Weak&lt;T&gt;</code>. Instead of increasing the <code>strong_count</code> in the
<code>Rc&lt;T&gt;</code> instance by 1, calling <code>Rc::downgrade</code> increases the <code>weak_count</code> by 1.
The <code>Rc&lt;T&gt;</code> type uses <code>weak_count</code> to keep track of how many <code>Weak&lt;T&gt;</code>
references exist, similar to <code>strong_count</code>. The difference is the <code>weak_count</code>
doesn’t need to be 0 for the <code>Rc&lt;T&gt;</code> instance to be cleaned up.</p>
<p>Strong references are how you can share ownership of an <code>Rc&lt;T&gt;</code> instance. Weak
references don’t express an ownership relationship. They won’t cause a
reference cycle because any cycle involving some weak references will be broken
once the strong reference count of values involved is 0.</p>
<p>Because the value that <code>Weak&lt;T&gt;</code> references might have been dropped, to do
anything with the value that a <code>Weak&lt;T&gt;</code> is pointing to, you must make sure the
value still exists. Do this by calling the <code>upgrade</code> method on a <code>Weak&lt;T&gt;</code>
instance, which will return an <code>Option&lt;Rc&lt;T&gt;&gt;</code>. You’ll get a result of <code>Some</code>
if the <code>Rc&lt;T&gt;</code> value has not been dropped yet and a result of <code>None</code> if the
<code>Rc&lt;T&gt;</code> value has been dropped. Because <code>upgrade</code> returns an <code>Option&lt;T&gt;</code>, Rust
will ensure that the <code>Some</code> case and the <code>None</code> case are handled, and there
won’t be an invalid pointer.</p>
<p>As an example, rather than using a list whose items know only about the next
item, we’ll create a tree whose items know about their children items <em>and</em>
their parent items.</p>
<h4><a class="header" href="#creating-a-tree-data-structure-a-node-with-child-nodes" id="creating-a-tree-data-structure-a-node-with-child-nodes">Creating a Tree Data Structure: a <code>Node</code> with Child Nodes</a></h4>
<p>To start, we’ll build a tree with nodes that know about their child nodes.
We’ll create a struct named <code>Node</code> that holds its own <code>i32</code> value as well as
references to its children <code>Node</code> values:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>We want a <code>Node</code> to own its children, and we want to share that ownership with
variables so we can access each <code>Node</code> in the tree directly. To do this, we
define the <code>Vec&lt;T&gt;</code> items to be values of type <code>Rc&lt;Node&gt;</code>. We also want to
modify which nodes are children of another node, so we have a <code>RefCell&lt;T&gt;</code> in
<code>children</code> around the <code>Vec&lt;Rc&lt;Node&gt;&gt;</code>.</p>
<p>Next, we’ll use our struct definition and create one <code>Node</code> instance named
<code>leaf</code> with the value 3 and no children, and another instance named <code>branch</code>
with the value 5 and <code>leaf</code> as one of its children, as shown in Listing 15-27:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use std::rc::Rc;
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">   children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        children: RefCell::new(vec![]),
    });

    let branch = Rc::new(Node {
        value: 5,
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });
}
</code></pre></pre>
<p><span class="caption">Listing 15-27: Creating a <code>leaf</code> node with no children
and a <code>branch</code> node with <code>leaf</code> as one of its children</span></p>
<p>We clone the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> and store that in <code>branch</code>, meaning the
<code>Node</code> in <code>leaf</code> now has two owners: <code>leaf</code> and <code>branch</code>. We can get from
<code>branch</code> to <code>leaf</code> through <code>branch.children</code>, but there’s no way to get from
<code>leaf</code> to <code>branch</code>. The reason is that <code>leaf</code> has no reference to <code>branch</code> and
doesn’t know they’re related. We want <code>leaf</code> to know that <code>branch</code> is its
parent. We’ll do that next.</p>
<h4><a class="header" href="#adding-a-reference-from-a-child-to-its-parent" id="adding-a-reference-from-a-child-to-its-parent">Adding a Reference from a Child to Its Parent</a></h4>
<p>To make the child node aware of its parent, we need to add a <code>parent</code> field to
our <code>Node</code> struct definition. The trouble is in deciding what the type of
<code>parent</code> should be. We know it can’t contain an <code>Rc&lt;T&gt;</code>, because that would
create a reference cycle with <code>leaf.parent</code> pointing to <code>branch</code> and
<code>branch.children</code> pointing to <code>leaf</code>, which would cause their <code>strong_count</code>
values to never be 0.</p>
<p>Thinking about the relationships another way, a parent node should own its
children: if a parent node is dropped, its child nodes should be dropped as
well. However, a child should not own its parent: if we drop a child node, the
parent should still exist. This is a case for weak references!</p>
<p>So instead of <code>Rc&lt;T&gt;</code>, we’ll make the type of <code>parent</code> use <code>Weak&lt;T&gt;</code>,
specifically a <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code>. Now our <code>Node</code> struct definition looks
like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>A node will be able to refer to its parent node but doesn’t own its parent.
In Listing 15-28, we update <code>main</code> to use this new definition so the <code>leaf</code>
node will have a way to refer to its parent, <code>branch</code>:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());

    let branch = Rc::new(Node {
        value: 5,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
    });

    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}
</code></pre></pre>
<p><span class="caption">Listing 15-28: A <code>leaf</code> node with a weak reference to its
parent node <code>branch</code></span></p>
<p>Creating the <code>leaf</code> node looks similar to how creating the <code>leaf</code> node looked
in Listing 15-27 with the exception of the <code>parent</code> field: <code>leaf</code> starts out
without a parent, so we create a new, empty <code>Weak&lt;Node&gt;</code> reference instance.</p>
<p>At this point, when we try to get a reference to the parent of <code>leaf</code> by using
the <code>upgrade</code> method, we get a <code>None</code> value. We see this in the output from the
first <code>println!</code> statement:</p>
<pre><code class="language-text">leaf parent = None
</code></pre>
<p>When we create the <code>branch</code> node, it will also have a new <code>Weak&lt;Node&gt;</code>
reference in the <code>parent</code> field, because <code>branch</code> doesn’t have a parent node.
We still have <code>leaf</code> as one of the children of <code>branch</code>. Once we have the
<code>Node</code> instance in <code>branch</code>, we can modify <code>leaf</code> to give it a <code>Weak&lt;Node&gt;</code>
reference to its parent. We use the <code>borrow_mut</code> method on the
<code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> in the <code>parent</code> field of <code>leaf</code>, and then we use the
<code>Rc::downgrade</code> function to create a <code>Weak&lt;Node&gt;</code> reference to <code>branch</code> from
the <code>Rc&lt;Node&gt;</code> in <code>branch.</code></p>
<p>When we print the parent of <code>leaf</code> again, this time we’ll get a <code>Some</code> variant
holding <code>branch</code>: now <code>leaf</code> can access its parent! When we print <code>leaf</code>, we
also avoid the cycle that eventually ended in a stack overflow like we had in
Listing 15-26; the <code>Weak&lt;Node&gt;</code> references are printed as <code>(Weak)</code>:</p>
<pre><code class="language-text">leaf parent = Some(Node { value: 5, parent: RefCell { value: (Weak) },
children: RefCell { value: [Node { value: 3, parent: RefCell { value: (Weak) },
children: RefCell { value: [] } }] } })
</code></pre>
<p>The lack of infinite output indicates that this code didn’t create a reference
cycle. We can also tell this by looking at the values we get from calling
<code>Rc::strong_count</code> and <code>Rc::weak_count</code>.</p>
<h4><a class="header" href="#visualizing-changes-to-strong_count-and-weak_count" id="visualizing-changes-to-strong_count-and-weak_count">Visualizing Changes to <code>strong_count</code> and <code>weak_count</code></a></h4>
<p>Let’s look at how the <code>strong_count</code> and <code>weak_count</code> values of the <code>Rc&lt;Node&gt;</code>
instances change by creating a new inner scope and moving the creation of
<code>branch</code> into that scope. By doing so, we can see what happens when <code>branch</code> is
created and then dropped when it goes out of scope. The modifications are shown
in Listing 15-29:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use std::rc::{Rc, Weak};
</span><span class="boring">use std::cell::RefCell;
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Node {
</span><span class="boring">    value: i32,
</span><span class="boring">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
</span><span class="boring">    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });

    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );

    {
        let branch = Rc::new(Node {
            value: 5,
            parent: RefCell::new(Weak::new()),
            children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
        });

        *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);

        println!(
            &quot;branch strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;branch),
            Rc::weak_count(&amp;branch),
        );

        println!(
            &quot;leaf strong = {}, weak = {}&quot;,
            Rc::strong_count(&amp;leaf),
            Rc::weak_count(&amp;leaf),
        );
    }

    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
    println!(
        &quot;leaf strong = {}, weak = {}&quot;,
        Rc::strong_count(&amp;leaf),
        Rc::weak_count(&amp;leaf),
    );
}
</code></pre></pre>
<p><span class="caption">Listing 15-29: Creating <code>branch</code> in an inner scope and
examining strong and weak reference counts</span></p>
<p>After <code>leaf</code> is created, its <code>Rc&lt;Node&gt;</code> has a strong count of 1 and a weak
count of 0. In the inner scope, we create <code>branch</code> and associate it with
<code>leaf</code>, at which point when we print the counts, the <code>Rc&lt;Node&gt;</code> in <code>branch</code>
will have a strong count of 1 and a weak count of 1 (for <code>leaf.parent</code> pointing
to <code>branch</code> with a <code>Weak&lt;Node&gt;</code>). When we print the counts in <code>leaf</code>, we’ll see
it will have a strong count of 2, because <code>branch</code> now has a clone of the
<code>Rc&lt;Node&gt;</code> of <code>leaf</code> stored in <code>branch.children</code>, but will still have a weak
count of 0.</p>
<p>When the inner scope ends, <code>branch</code> goes out of scope and the strong count of
the <code>Rc&lt;Node&gt;</code> decreases to 0, so its <code>Node</code> is dropped. The weak count of 1
from <code>leaf.parent</code> has no bearing on whether or not <code>Node</code> is dropped, so we
don’t get any memory leaks!</p>
<p>If we try to access the parent of <code>leaf</code> after the end of the scope, we’ll get
<code>None</code> again. At the end of the program, the <code>Rc&lt;Node&gt;</code> in <code>leaf</code> has a strong
count of 1 and a weak count of 0, because the variable <code>leaf</code> is now the only
reference to the <code>Rc&lt;Node&gt;</code> again.</p>
<p>All of the logic that manages the counts and value dropping is built into
<code>Rc&lt;T&gt;</code> and <code>Weak&lt;T&gt;</code> and their implementations of the <code>Drop</code> trait. By
specifying that the relationship from a child to its parent should be a
<code>Weak&lt;T&gt;</code> reference in the definition of <code>Node</code>, you’re able to have parent
nodes point to child nodes and vice versa without creating a reference cycle
and memory leaks.</p>
<h2><a class="header" href="#summary-14" id="summary-14">Summary</a></h2>
<p>This chapter covered how to use smart pointers to make different guarantees and
trade-offs from those Rust makes by default with regular references. The
<code>Box&lt;T&gt;</code> type has a known size and points to data allocated on the heap. The
<code>Rc&lt;T&gt;</code> type keeps track of the number of references to data on the heap so
that data can have multiple owners. The <code>RefCell&lt;T&gt;</code> type with its interior
mutability gives us a type that we can use when we need an immutable type but
need to change an inner value of that type; it also enforces the borrowing
rules at runtime instead of at compile time.</p>
<p>Also discussed were the <code>Deref</code> and <code>Drop</code> traits, which enable a lot of the
functionality of smart pointers. We explored reference cycles that can cause
memory leaks and how to prevent them using <code>Weak&lt;T&gt;</code>.</p>
<p>If this chapter has piqued your interest and you want to implement your own
smart pointers, check out <a href="https://doc.rust-lang.org/stable/nomicon/">“The Rustonomicon”</a> for more useful
information.</p>
<p>Next, we’ll talk about concurrency in Rust. You’ll even learn about a few new
smart pointers.</p>
<h1><a class="header" href="#fearless-concurrency" id="fearless-concurrency">Fearless Concurrency</a></h1>
<p>Handling concurrent programming safely and efficiently is another of Rust’s
major goals. <em>Concurrent programming</em>, where different parts of a program
execute independently, and <em>parallel programming</em>, where different parts of a
program execute at the same time, are becoming increasingly important as more
computers take advantage of their multiple processors. Historically,
programming in these contexts has been difficult and error prone: Rust hopes to
change that.</p>
<p>Initially, the Rust team thought that ensuring memory safety and preventing
concurrency problems were two separate challenges to be solved with different
methods. Over time, the team discovered that the ownership and type systems are
a powerful set of tools to help manage memory safety <em>and</em> concurrency
problems! By leveraging ownership and type checking, many concurrency errors
are compile-time errors in Rust rather than runtime errors. Therefore, rather
than making you spend lots of time trying to reproduce the exact circumstances
under which a runtime concurrency bug occurs, incorrect code will refuse to
compile and present an error explaining the problem. As a result, you can fix
your code while you’re working on it rather than potentially after it has been
shipped to production. We’ve nicknamed this aspect of Rust <em>fearless</em>
<em>concurrency</em>. Fearless concurrency allows you to write code that is free of
subtle bugs and is easy to refactor without introducing new bugs.</p>
<blockquote>
<p>Note: For simplicity’s sake, we’ll refer to many of the problems as
<em>concurrent</em> rather than being more precise by saying <em>concurrent and/or
parallel</em>. If this book were about concurrency and/or parallelism, we’d be
more specific. For this chapter, please mentally substitute <em>concurrent
and/or parallel</em> whenever we use <em>concurrent</em>.</p>
</blockquote>
<p>Many languages are dogmatic about the solutions they offer for handling
concurrent problems. For example, Erlang has elegant functionality for
message-passing concurrency but has only obscure ways to share state between
threads. Supporting only a subset of possible solutions is a reasonable
strategy for higher-level languages, because a higher-level language promises
benefits from giving up some control to gain abstractions. However, lower-level
languages are expected to provide the solution with the best performance in any
given situation and have fewer abstractions over the hardware. Therefore, Rust
offers a variety of tools for modeling problems in whatever way is appropriate
for your situation and requirements.</p>
<p>Here are the topics we’ll cover in this chapter:</p>
<ul>
<li>How to create threads to run multiple pieces of code at the same time</li>
<li><em>Message-passing</em> concurrency, where channels send messages between threads</li>
<li><em>Shared-state</em> concurrency, where multiple threads have access to some piece
of data</li>
<li>The <code>Sync</code> and <code>Send</code> traits, which extend Rust’s concurrency guarantees to
user-defined types as well as types provided by the standard library</li>
</ul>
<h2><a class="header" href="#using-threads-to-run-code-simultaneously" id="using-threads-to-run-code-simultaneously">Using Threads to Run Code Simultaneously</a></h2>
<p>In most current operating systems, an executed program’s code is run in a
<em>process</em>, and the operating system manages multiple processes at once. Within
your program, you can also have independent parts that run simultaneously. The
features that run these independent parts are called <em>threads</em>.</p>
<p>Splitting the computation in your program into multiple threads can improve
performance because the program does multiple tasks at the same time, but it
also adds complexity. Because threads can run simultaneously, there’s no
inherent guarantee about the order in which parts of your code on different
threads will run. This can lead to problems, such as:</p>
<ul>
<li>Race conditions, where threads are accessing data or resources in an
inconsistent order</li>
<li>Deadlocks, where two threads are waiting for each other to finish using a
resource the other thread has, preventing both threads from continuing</li>
<li>Bugs that happen only in certain situations and are hard to reproduce and fix
reliably</li>
</ul>
<p>Rust attempts to mitigate the negative effects of using threads, but
programming in a multithreaded context still takes careful thought and requires
a code structure that is different from that in programs running in a single
thread.</p>
<p>Programming languages implement threads in a few different ways. Many operating
systems provide an API for creating new threads. This model where a language
calls the operating system APIs to create threads is sometimes called <em>1:1</em>,
meaning one operating system thread per one language thread.</p>
<p>Many programming languages provide their own special implementation of threads.
Programming language-provided threads are known as <em>green</em> threads, and
languages that use these green threads will execute them in the context of a
different number of operating system threads. For this reason, the
green-threaded model is called the <em>M:N</em> model: there are <code>M</code> green threads per
<code>N</code> operating system threads, where <code>M</code> and <code>N</code> are not necessarily the same
number.</p>
<p>Each model has its own advantages and trade-offs, and the trade-off most
important to Rust is runtime support. <em>Runtime</em> is a confusing term and can
have different meanings in different contexts.</p>
<p>In this context, by <em>runtime</em> we mean code that is included by the language in
every binary. This code can be large or small depending on the language, but
every non-assembly language will have some amount of runtime code. For that
reason, colloquially when people say a language has “no runtime,” they often
mean “small runtime.” Smaller runtimes have fewer features but have the
advantage of resulting in smaller binaries, which make it easier to combine the
language with other languages in more contexts. Although many languages are
okay with increasing the runtime size in exchange for more features, Rust needs
to have nearly no runtime and cannot compromise on being able to call into C to
maintain performance.</p>
<p>The green-threading M:N model requires a larger language runtime to manage
threads. As such, the Rust standard library only provides an implementation of
1:1 threading. Because Rust is such a low-level language, there are crates that
implement M:N threading if you would rather trade overhead for aspects such as
more control over which threads run when and lower costs of context switching,
for example.</p>
<p>Now that we’ve defined threads in Rust, let’s explore how to use the
thread-related API provided by the standard library.</p>
<h3><a class="header" href="#creating-a-new-thread-with-spawn" id="creating-a-new-thread-with-spawn">Creating a New Thread with <code>spawn</code></a></h3>
<p>To create a new thread, we call the <code>thread::spawn</code> function and pass it a
closure (we talked about closures in Chapter 13) containing the code we want to
run in the new thread. The example in Listing 16-1 prints some text from a main
thread and other text from a new thread:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 16-1: Creating a new thread to print one thing
while the main thread prints something else</span></p>
<p>Note that with this function, the new thread will be stopped when the main
thread ends, whether or not it has finished running. The output from this
program might be a little different every time, but it will look similar to the
following:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 1 from the spawned thread!
hi number 2 from the main thread!
hi number 2 from the spawned thread!
hi number 3 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the main thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
</code></pre>
<p>The calls to <code>thread::sleep</code> force a thread to stop its execution for a short
duration, allowing a different thread to run. The threads will probably take
turns, but that isn’t guaranteed: it depends on how your operating system
schedules the threads. In this run, the main thread printed first, even though
the print statement from the spawned thread appears first in the code. And even
though we told the spawned thread to print until <code>i</code> is 9, it only got to 5
before the main thread shut down.</p>
<p>If you run this code and only see output from the main thread, or don’t see any
overlap, try increasing the numbers in the ranges to create more opportunities
for the operating system to switch between the threads.</p>
<h3><a class="header" href="#waiting-for-all-threads-to-finish-using-join-handles" id="waiting-for-all-threads-to-finish-using-join-handles">Waiting for All Threads to Finish Using <code>join</code> Handles</a></h3>
<p>The code in Listing 16-1 not only stops the spawned thread prematurely most of
the time due to the main thread ending, but also can’t guarantee that the
spawned thread will get to run at all. The reason is that there is no guarantee
on the order in which threads run!</p>
<p>We can fix the problem of the spawned thread not getting to run, or not getting
to run completely, by saving the return value of <code>thread::spawn</code> in a variable.
The return type of <code>thread::spawn</code> is <code>JoinHandle</code>. A <code>JoinHandle</code> is an owned
value that, when we call the <code>join</code> method on it, will wait for its thread to
finish. Listing 16-2 shows how to use the <code>JoinHandle</code> of the thread we created
in Listing 16-1 and call <code>join</code> to make sure the spawned thread finishes before
<code>main</code> exits:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-2: Saving a <code>JoinHandle</code> from <code>thread::spawn</code>
to guarantee the thread is run to completion</span></p>
<p>Calling <code>join</code> on the handle blocks the thread currently running until the
thread represented by the handle terminates. <em>Blocking</em> a thread means that
thread is prevented from performing work or exiting. Because we’ve put the call
to <code>join</code> after the main thread’s <code>for</code> loop, running Listing 16-2 should
produce output similar to this:</p>
<pre><code class="language-text">hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 1 from the spawned thread!
hi number 3 from the main thread!
hi number 2 from the spawned thread!
hi number 4 from the main thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
</code></pre>
<p>The two threads continue alternating, but the main thread waits because of the
call to <code>handle.join()</code> and does not end until the spawned thread is finished.</p>
<p>But let’s see what happens when we instead move <code>handle.join()</code> before the
<code>for</code> loop in <code>main</code>, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    handle.join().unwrap();

    for i in 1..5 {
        println!(&quot;hi number {} from the main thread!&quot;, i);
        thread::sleep(Duration::from_millis(1));
    }
}
</code></pre></pre>
<p>The main thread will wait for the spawned thread to finish and then run its
<code>for</code> loop, so the output won’t be interleaved anymore, as shown here:</p>
<pre><code class="language-text">hi number 1 from the spawned thread!
hi number 2 from the spawned thread!
hi number 3 from the spawned thread!
hi number 4 from the spawned thread!
hi number 5 from the spawned thread!
hi number 6 from the spawned thread!
hi number 7 from the spawned thread!
hi number 8 from the spawned thread!
hi number 9 from the spawned thread!
hi number 1 from the main thread!
hi number 2 from the main thread!
hi number 3 from the main thread!
hi number 4 from the main thread!
</code></pre>
<p>Small details, such as where <code>join</code> is called, can affect whether or not your
threads run at the same time.</p>
<h3><a class="header" href="#using-move-closures-with-threads" id="using-move-closures-with-threads">Using <code>move</code> Closures with Threads</a></h3>
<p>The <code>move</code> closure is often used alongside <code>thread::spawn</code> because it allows
you to use data from one thread in another thread.</p>
<p>In Chapter 13, we mentioned we can use the <code>move</code> keyword before the parameter
list of a closure to force the closure to take ownership of the values it uses
in the environment. This technique is especially useful when creating new
threads in order to transfer ownership of values from one thread to another.</p>
<p>Notice in Listing 16-1 that the closure we pass to <code>thread::spawn</code> takes no
arguments: we’re not using any data from the main thread in the spawned
thread’s code. To use data from the main thread in the spawned thread, the
spawned thread’s closure must capture the values it needs. Listing 16-3 shows
an attempt to create a vector in the main thread and use it in the spawned
thread. However, this won’t yet work, as you’ll see in a moment.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listing 16-3: Attempting to use a vector created by the
main thread in another thread</span></p>
<p>The closure uses <code>v</code>, so it will capture <code>v</code> and make it part of the closure’s
environment. Because <code>thread::spawn</code> runs this closure in a new thread, we
should be able to access <code>v</code> inside that new thread. But when we compile this
example, we get the following error:</p>
<pre><code class="language-text">error[E0373]: closure may outlive the current function, but it borrows `v`,
which is owned by the current function
 --&gt; src/main.rs:6:32
  |
6 |     let handle = thread::spawn(|| {
  |                                ^^ may outlive borrowed value `v`
7 |         println!(&quot;Here's a vector: {:?}&quot;, v);
  |                                           - `v` is borrowed here
  |
help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>Rust <em>infers</em> how to capture <code>v</code>, and because <code>println!</code> only needs a reference
to <code>v</code>, the closure tries to borrow <code>v</code>. However, there’s a problem: Rust can’t
tell how long the spawned thread will run, so it doesn’t know if the reference
to <code>v</code> will always be valid.</p>
<p>Listing 16-4 provides a scenario that’s more likely to have a reference to <code>v</code>
that won’t be valid:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(|| {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    drop(v); // oh no!

    handle.join().unwrap();
}
</code></pre>
<p><span class="caption">Listing 16-4: A thread with a closure that attempts to
capture a reference to <code>v</code> from a main thread that drops <code>v</code></span></p>
<p>If we were allowed to run this code, there’s a possibility the spawned thread
would be immediately put in the background without running at all. The spawned
thread has a reference to <code>v</code> inside, but the main thread immediately drops
<code>v</code>, using the <code>drop</code> function we discussed in Chapter 15. Then, when the
spawned thread starts to execute, <code>v</code> is no longer valid, so a reference to it
is also invalid. Oh no!</p>
<p>To fix the compiler error in Listing 16-3, we can use the error message’s
advice:</p>
<pre><code class="language-text">help: to force the closure to take ownership of `v` (and any other referenced
variables), use the `move` keyword
  |
6 |     let handle = thread::spawn(move || {
  |                                ^^^^^^^
</code></pre>
<p>By adding the <code>move</code> keyword before the closure, we force the closure to take
ownership of the values it’s using rather than allowing Rust to infer that it
should borrow the values. The modification to Listing 16-3 shown in Listing
16-5 will compile and run as we intend:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;

fn main() {
    let v = vec![1, 2, 3];

    let handle = thread::spawn(move || {
        println!(&quot;Here's a vector: {:?}&quot;, v);
    });

    handle.join().unwrap();
}
</code></pre></pre>
<p><span class="caption">Listing 16-5: Using the <code>move</code> keyword to force a closure
to take ownership of the values it uses</span></p>
<p>What would happen to the code in Listing 16-4 where the main thread called
<code>drop</code> if we use a <code>move</code> closure? Would <code>move</code> fix that case? Unfortunately,
no; we would get a different error because what Listing 16-4 is trying to do
isn’t allowed for a different reason. If we added <code>move</code> to the closure, we
would move <code>v</code> into the closure’s environment, and we could no longer call
<code>drop</code> on it in the main thread. We would get this compiler error instead:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `v`
  --&gt; src/main.rs:10:10
   |
6  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
10 |     drop(v); // oh no!
   |          ^ value used here after move
   |
   = note: move occurs because `v` has type `std::vec::Vec&lt;i32&gt;`, which does
   not implement the `Copy` trait
</code></pre>
<p>Rust’s ownership rules have saved us again! We got an error from the code in
Listing 16-3 because Rust was being conservative and only borrowing <code>v</code> for the
thread, which meant the main thread could theoretically invalidate the spawned
thread’s reference. By telling Rust to move ownership of <code>v</code> to the spawned
thread, we’re guaranteeing Rust that the main thread won’t use <code>v</code> anymore. If
we change Listing 16-4 in the same way, we’re then violating the ownership
rules when we try to use <code>v</code> in the main thread. The <code>move</code> keyword overrides
Rust’s conservative default of borrowing; it doesn’t let us violate the
ownership rules.</p>
<p>With a basic understanding of threads and the thread API, let’s look at what we
can <em>do</em> with threads.</p>
<h2><a class="header" href="#using-message-passing-to-transfer-data-between-threads" id="using-message-passing-to-transfer-data-between-threads">Using Message Passing to Transfer Data Between Threads</a></h2>
<p>One increasingly popular approach to ensuring safe concurrency is <em>message
passing</em>, where threads or actors communicate by sending each other messages
containing data. Here’s the idea in a slogan from <a href="http://golang.org/doc/effective_go.html">the Go language
documentation</a>: “Do not communicate by
sharing memory; instead, share memory by communicating.”</p>
<p>One major tool Rust has for accomplishing message-sending concurrency is the
<em>channel</em>, a programming concept that Rust’s standard library provides an
implementation of. You can imagine a channel in programming as being like a
channel of water, such as a stream or a river. If you put something like a
rubber duck or boat into a stream, it will travel downstream to the end of the
waterway.</p>
<p>A channel in programming has two halves: a transmitter and a receiver. The
transmitter half is the upstream location where you put rubber ducks into the
river, and the receiver half is where the rubber duck ends up downstream. One
part of your code calls methods on the transmitter with the data you want to
send, and another part checks the receiving end for arriving messages. A
channel is said to be <em>closed</em> if either the transmitter or receiver half is
dropped.</p>
<p>Here, we’ll work up to a program that has one thread to generate values and
send them down a channel, and another thread that will receive the values and
print them out. We’ll be sending simple values between threads using a channel
to illustrate the feature. Once you’re familiar with the technique, you could
use channels to implement a chat system or a system where many threads perform
parts of a calculation and send the parts to one thread that aggregates the
results.</p>
<p>First, in Listing 16-6, we’ll create a channel but not do anything with it.
Note that this won’t compile yet because Rust can’t tell what type of values we
want to send over the channel.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();
<span class="boring">    tx.send(()).unwrap();
</span>}
</code></pre></pre>
<p><span class="caption">Listing 16-6: Creating a channel and assigning the two
halves to <code>tx</code> and <code>rx</code></span></p>
<p>We create a new channel using the <code>mpsc::channel</code> function; <code>mpsc</code> stands for
<em>multiple producer, single consumer</em>. In short, the way Rust’s standard library
implements channels means a channel can have multiple <em>sending</em> ends that
produce values but only one <em>receiving</em> end that consumes those values. Imagine
multiple streams flowing together into one big river: everything sent down any
of the streams will end up in one river at the end. We’ll start with a single
producer for now, but we’ll add multiple producers when we get this example
working.</p>
<!-- NEXT PARAGRAPH WRAPPED WEIRD INTENTIONALLY SEE #199 -->
<p>The <code>mpsc::channel</code> function returns a tuple, the first element of which is the
sending end and the second element is the receiving end. The abbreviations <code>tx</code>
and <code>rx</code> are traditionally used in many fields for <em>transmitter</em> and <em>receiver</em>
respectively, so we name our variables as such to indicate each end. We’re
using a <code>let</code> statement with a pattern that destructures the tuples; we’ll
discuss the use of patterns in <code>let</code> statements and destructuring in
Chapter 18. Using a <code>let</code> statement this way is a convenient approach to
extract the pieces of the tuple returned by <code>mpsc::channel</code>.</p>
<p>Let’s move the transmitting end into a spawned thread and have it send one
string so the spawned thread is communicating with the main thread, as shown in
Listing 16-7. This is like putting a rubber duck in the river upstream or
sending a chat message from one thread to another.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });
}
</code></pre></pre>
<p><span class="caption">Listing 16-7: Moving <code>tx</code> to a spawned thread and sending
“hi”</span></p>
<p>Again, we’re using <code>thread::spawn</code> to create a new thread and then using <code>move</code>
to move <code>tx</code> into the closure so the spawned thread owns <code>tx</code>. The spawned
thread needs to own the transmitting end of the channel to be able to send
messages through the channel.</p>
<p>The transmitting end has a <code>send</code> method that takes the value we want to send.
The <code>send</code> method returns a <code>Result&lt;T, E&gt;</code> type, so if the receiving end has
already been dropped and there’s nowhere to send a value, the send operation
will return an error. In this example, we’re calling <code>unwrap</code> to panic in case
of an error. But in a real application, we would handle it properly: return to
Chapter 9 to review strategies for proper error handling.</p>
<p>In Listing 16-8, we’ll get the value from the receiving end of the channel in
the main thread. This is like retrieving the rubber duck from the water at the
end of the river or like getting a chat message.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre></pre>
<p><span class="caption">Listing 16-8: Receiving the value “hi” in the main thread
and printing it</span></p>
<p>The receiving end of a channel has two useful methods: <code>recv</code> and <code>try_recv</code>.
We’re using <code>recv</code>, short for <em>receive</em>, which will block the main thread’s
execution and wait until a value is sent down the channel. Once a value is
sent, <code>recv</code> will return it in a <code>Result&lt;T, E&gt;</code>. When the sending end of the
channel closes, <code>recv</code> will return an error to signal that no more values will
be coming.</p>
<p>The <code>try_recv</code> method doesn’t block, but will instead return a <code>Result&lt;T, E&gt;</code>
immediately: an <code>Ok</code> value holding a message if one is available and an <code>Err</code>
value if there aren’t any messages this time. Using <code>try_recv</code> is useful if
this thread has other work to do while waiting for messages: we could write a
loop that calls <code>try_recv</code> every so often, handles a message if one is
available, and otherwise does other work for a little while until checking
again.</p>
<p>We’ve used <code>recv</code> in this example for simplicity; we don’t have any other work
for the main thread to do other than wait for messages, so blocking the main
thread is appropriate.</p>
<p>When we run the code in Listing 16-8, we’ll see the value printed from the main
thread:</p>
<pre><code class="language-text">Got: hi
</code></pre>
<p>Perfect!</p>
<h3><a class="header" href="#channels-and-ownership-transference" id="channels-and-ownership-transference">Channels and Ownership Transference</a></h3>
<p>The ownership rules play a vital role in message sending because they help you
write safe, concurrent code. Preventing errors in concurrent programming is the
advantage of thinking about ownership throughout your Rust programs. Let’s do
an experiment to show how channels and ownership work together to prevent
problems: we’ll try to use a <code>val</code> value in the spawned thread <em>after</em> we’ve
sent it down the channel. Try compiling the code in Listing 16-9 to see why
this code isn’t allowed:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::thread;
use std::sync::mpsc;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let val = String::from(&quot;hi&quot;);
        tx.send(val).unwrap();
        println!(&quot;val is {}&quot;, val);
    });

    let received = rx.recv().unwrap();
    println!(&quot;Got: {}&quot;, received);
}
</code></pre>
<p><span class="caption">Listing 16-9: Attempting to use <code>val</code> after we’ve sent it
down the channel</span></p>
<p>Here, we try to print <code>val</code> after we’ve sent it down the channel via <code>tx.send</code>.
Allowing this would be a bad idea: once the value has been sent to another
thread, that thread could modify or drop it before we try to use the value
again. Potentially, the other thread’s modifications could cause errors or
unexpected results due to inconsistent or nonexistent data. However, Rust gives
us an error if we try to compile the code in Listing 16-9:</p>
<pre><code class="language-text">error[E0382]: use of moved value: `val`
  --&gt; src/main.rs:10:31
   |
9  |         tx.send(val).unwrap();
   |                 --- value moved here
10 |         println!(&quot;val is {}&quot;, val);
   |                               ^^^ value used here after move
   |
   = note: move occurs because `val` has type `std::string::String`, which does
not implement the `Copy` trait
</code></pre>
<p>Our concurrency mistake has caused a compile time error. The <code>send</code> function
takes ownership of its parameter, and when the value is moved, the receiver
takes ownership of it. This stops us from accidentally using the value again
after sending it; the ownership system checks that everything is okay.</p>
<h3><a class="header" href="#sending-multiple-values-and-seeing-the-receiver-waiting" id="sending-multiple-values-and-seeing-the-receiver-waiting">Sending Multiple Values and Seeing the Receiver Waiting</a></h3>
<p>The code in Listing 16-8 compiled and ran, but it didn’t clearly show us that
two separate threads were talking to each other over the channel. In Listing
16-10 we’ve made some modifications that will prove the code in Listing 16-8 is
running concurrently: the spawned thread will now send multiple messages and
pause for a second between each message.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::thread;
use std::sync::mpsc;
use std::time::Duration;

fn main() {
    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let vals = vec![
            String::from(&quot;hi&quot;),
            String::from(&quot;from&quot;),
            String::from(&quot;the&quot;),
            String::from(&quot;thread&quot;),
        ];

        for val in vals {
            tx.send(val).unwrap();
            thread::sleep(Duration::from_secs(1));
        }
    });

    for received in rx {
        println!(&quot;Got: {}&quot;, received);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 16-10: Sending multiple messages and pausing
between each</span></p>
<p>This time, the spawned thread has a vector of strings that we want to send to
the main thread. We iterate over them, sending each individually, and pause
between each by calling the <code>thread::sleep</code> function with a <code>Duration</code> value of
1 second.</p>
<p>In the main thread, we’re not calling the <code>recv</code> function explicitly anymore:
instead, we’re treating <code>rx</code> as an iterator. For each value received, we’re
printing it. When the channel is closed, iteration will end.</p>
<p>When running the code in Listing 16-10, you should see the following output
with a 1-second pause in between each line:</p>
<pre><code class="language-text">Got: hi
Got: from
Got: the
Got: thread
</code></pre>
<p>Because we don’t have any code that pauses or delays in the <code>for</code> loop in the
main thread, we can tell that the main thread is waiting to receive values from
the spawned thread.</p>
<h3><a class="header" href="#creating-multiple-producers-by-cloning-the-transmitter" id="creating-multiple-producers-by-cloning-the-transmitter">Creating Multiple Producers by Cloning the Transmitter</a></h3>
<p>Earlier we mentioned that <code>mpsc</code> was an acronym for <em>multiple producer,
single consumer</em>. Let’s put <code>mpsc</code> to use and expand the code in Listing 16-10
to create multiple threads that all send values to the same receiver. We can do
so by cloning the transmitting half of the channel, as shown in Listing 16-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use std::thread;
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">use std::time::Duration;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>// --snip--

let (tx, rx) = mpsc::channel();

let tx1 = mpsc::Sender::clone(&amp;tx);
thread::spawn(move || {
    let vals = vec![
        String::from(&quot;hi&quot;),
        String::from(&quot;from&quot;),
        String::from(&quot;the&quot;),
        String::from(&quot;thread&quot;),
    ];

    for val in vals {
        tx1.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

thread::spawn(move || {
    let vals = vec![
        String::from(&quot;more&quot;),
        String::from(&quot;messages&quot;),
        String::from(&quot;for&quot;),
        String::from(&quot;you&quot;),
    ];

    for val in vals {
        tx.send(val).unwrap();
        thread::sleep(Duration::from_secs(1));
    }
});

for received in rx {
    println!(&quot;Got: {}&quot;, received);
}

// --snip--
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 16-11: Sending multiple messages from multiple
producers</span></p>
<p>This time, before we create the first spawned thread, we call <code>clone</code> on the
sending end of the channel. This will give us a new sending handle we can pass
to the first spawned thread. We pass the original sending end of the channel to
a second spawned thread. This gives us two threads, each sending different
messages to the receiving end of the channel.</p>
<p>When you run the code, your output should look something like this:</p>
<pre><code class="language-text">Got: hi
Got: more
Got: from
Got: messages
Got: for
Got: the
Got: thread
Got: you
</code></pre>
<p>You might see the values in another order; it depends on your system. This is
what makes concurrency interesting as well as difficult. If you experiment with
<code>thread::sleep</code>, giving it various values in the different threads, each run
will be more nondeterministic and create different output each time.</p>
<p>Now that we’ve looked at how channels work, let’s look at a different method of
concurrency.</p>
<h2><a class="header" href="#shared-state-concurrency" id="shared-state-concurrency">Shared-State Concurrency</a></h2>
<p>Message passing is a fine way of handling concurrency, but it’s not the only
one. Consider this part of the slogan from the Go language documentation again:
“communicate by sharing memory.”</p>
<p>What would communicating by sharing memory look like? In addition, why would
message-passing enthusiasts not use it and do the opposite instead?</p>
<p>In a way, channels in any programming language are similar to single ownership,
because once you transfer a value down a channel, you should no longer use that
value. Shared memory concurrency is like multiple ownership: multiple threads
can access the same memory location at the same time. As you saw in Chapter 15,
where smart pointers made multiple ownership possible, multiple ownership can
add complexity because these different owners need managing. Rust’s type system
and ownership rules greatly assist in getting this management correct. For an
example, let’s look at mutexes, one of the more common concurrency primitives
for shared memory.</p>
<h3><a class="header" href="#using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time" id="using-mutexes-to-allow-access-to-data-from-one-thread-at-a-time">Using Mutexes to Allow Access to Data from One Thread at a Time</a></h3>
<p><em>Mutex</em> is an abbreviation for <em>mutual exclusion</em>, as in, a mutex allows only
one thread to access some data at any given time. To access the data in a
mutex, a thread must first signal that it wants access by asking to acquire the
mutex’s <em>lock</em>. The lock is a data structure that is part of the mutex that
keeps track of who currently has exclusive access to the data. Therefore, the
mutex is described as <em>guarding</em> the data it holds via the locking system.</p>
<p>Mutexes have a reputation for being difficult to use because you have to
remember two rules:</p>
<ul>
<li>You must attempt to acquire the lock before using the data.</li>
<li>When you’re done with the data that the mutex guards, you must unlock the
data so other threads can acquire the lock.</li>
</ul>
<p>For a real-world metaphor for a mutex, imagine a panel discussion at a
conference with only one microphone. Before a panelist can speak, they have to
ask or signal that they want to use the microphone. When they get the
microphone, they can talk for as long as they want to and then hand the
microphone to the next panelist who requests to speak. If a panelist forgets to
hand the microphone off when they’re finished with it, no one else is able to
speak. If management of the shared microphone goes wrong, the panel won’t work
as planned!</p>
<p>Management of mutexes can be incredibly tricky to get right, which is why so
many people are enthusiastic about channels. However, thanks to Rust’s type
system and ownership rules, you can’t get locking and unlocking wrong.</p>
<h4><a class="header" href="#the-api-of-mutext" id="the-api-of-mutext">The API of <code>Mutex&lt;T&gt;</code></a></h4>
<p>As an example of how to use a mutex, let’s start by using a mutex in a
single-threaded context, as shown in Listing 16-12:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::Mutex;

fn main() {
    let m = Mutex::new(5);

    {
        let mut num = m.lock().unwrap();
        *num = 6;
    }

    println!(&quot;m = {:?}&quot;, m);
}
</code></pre></pre>
<p><span class="caption">Listing 16-12: Exploring the API of <code>Mutex&lt;T&gt;</code> in a
single-threaded context for simplicity</span></p>
<p>As with many types, we create a <code>Mutex&lt;T&gt;</code> using the associated function <code>new</code>.
To access the data inside the mutex, we use the <code>lock</code> method to acquire the
lock. This call will block the current thread so it can’t do any work until
it’s our turn to have the lock.</p>
<p>The call to <code>lock</code> would fail if another thread holding the lock panicked. In
that case, no one would ever be able to get the lock, so we’ve chosen to
<code>unwrap</code> and have this thread panic if we’re in that situation.</p>
<p>After we’ve acquired the lock, we can treat the return value, named <code>num</code> in
this case, as a mutable reference to the data inside. The type system ensures
that we acquire a lock before using the value in <code>m</code>: <code>Mutex&lt;i32&gt;</code> is not an
<code>i32</code>, so we <em>must</em> acquire the lock to be able to use the <code>i32</code> value. We
can’t forget; the type system won’t let us access the inner <code>i32</code> otherwise.</p>
<p>As you might suspect, <code>Mutex&lt;T&gt;</code> is a smart pointer. More accurately, the call
to <code>lock</code> <em>returns</em> a smart pointer called <code>MutexGuard</code>, wrapped in a
<code>LockResult</code> that we handled with the call to <code>unwrap</code>. The <code>MutexGuard</code> smart
pointer implements <code>Deref</code> to point at our inner data; the smart pointer also
has a <code>Drop</code> implementation that releases the lock automatically when a
<code>MutexGuard</code> goes out of scope, which happens at the end of the inner scope in
Listing 16-12. As a result, we don’t risk forgetting to release the lock and
blocking the mutex from being used by other threads because the lock release
happens automatically.</p>
<p>After dropping the lock, we can print the mutex value and see that we were able
to change the inner <code>i32</code> to 6.</p>
<h4><a class="header" href="#sharing-a-mutext-between-multiple-threads" id="sharing-a-mutext-between-multiple-threads">Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple Threads</a></h4>
<p>Now, let’s try to share a value between multiple threads using <code>Mutex&lt;T&gt;</code>.
We’ll spin up 10 threads and have them each increment a counter value by 1, so
the counter goes from 0 to 10. Note that the next few examples will have
compiler errors, and we’ll use those errors to learn more about using
<code>Mutex&lt;T&gt;</code> and how Rust helps us use it correctly. Listing 16-13 has our
starting example:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    for _ in 0..10 {
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listing 16-13: Ten threads each increment a counter
guarded by a <code>Mutex&lt;T&gt;</code></span></p>
<p>We create a <code>counter</code> variable to hold an <code>i32</code> inside a <code>Mutex&lt;T&gt;</code>, as we
did in Listing 16-12. Next, we create 10 threads by iterating over a range
of numbers. We use <code>thread::spawn</code> and give all the threads the same closure,
one that moves the counter into the thread, acquires a lock on the <code>Mutex&lt;T&gt;</code>
by calling the <code>lock</code> method, and then adds 1 to the value in the mutex. When a
thread finishes running its closure, <code>num</code> will go out of scope and release the
lock so another thread can acquire it.</p>
<p>In the main thread, we collect all the join handles. Then, as we did in Listing
16-2, we call <code>join</code> on each handle to make sure all the threads finish. At
that point, the main thread will acquire the lock and print the result of this
program.</p>
<p>We hinted that this example wouldn’t compile. Now let’s find out why!</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:10:27
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
10 |             let mut num = counter.lock().unwrap();
   |                           ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:21:29
   |
9  |         let handle = thread::spawn(move || {
   |                                    ------- value moved (into closure) here
...
21 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>The error message states that the <code>counter</code> value is moved into the closure and
then captured when we call <code>lock</code>. That description sounds like what we wanted,
but it’s not allowed!</p>
<p>Let’s figure this out by simplifying the program. Instead of making 10 threads
in a <code>for</code> loop, let’s just make two threads without a loop and see what
happens. Replace the first <code>for</code> loop in Listing 16-13 with this code instead:</p>
<pre><code class="language-rust ignore does_not_compile">use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Mutex::new(0);
    let mut handles = vec![];

    let handle = thread::spawn(move || {
        let mut num = counter.lock().unwrap();

        *num += 1;
    });
    handles.push(handle);

    let handle2 = thread::spawn(move || {
        let mut num2 = counter.lock().unwrap();

        *num2 += 1;
    });
    handles.push(handle2);

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p>We make two threads and change the variable names used with the second thread
to <code>handle2</code> and <code>num2</code>. When we run the code this time, compiling gives us the
following:</p>
<pre><code class="language-text">error[E0382]: capture of moved value: `counter`
  --&gt; src/main.rs:16:24
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
16 |         let mut num2 = counter.lock().unwrap();
   |                        ^^^^^^^ value captured here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error[E0382]: use of moved value: `counter`
  --&gt; src/main.rs:26:29
   |
8  |     let handle = thread::spawn(move || {
   |                                ------- value moved (into closure) here
...
26 |     println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
   |                             ^^^^^^^ value used here after move
   |
   = note: move occurs because `counter` has type `std::sync::Mutex&lt;i32&gt;`,
   which does not implement the `Copy` trait

error: aborting due to 2 previous errors
</code></pre>
<p>Aha! The first error message indicates that <code>counter</code> is moved into the closure
for the thread associated with <code>handle</code>. That move is preventing us from
capturing <code>counter</code> when we try to call <code>lock</code> on it and store the result in
<code>num2</code> in the second thread! So Rust is telling us that we can’t move ownership
of <code>counter</code> into multiple threads. This was hard to see earlier because our
threads were in a loop, and Rust can’t point to different threads in different
iterations of the loop. Let’s fix the compiler error with a multiple-ownership
method we discussed in Chapter 15.</p>
<h4><a class="header" href="#multiple-ownership-with-multiple-threads" id="multiple-ownership-with-multiple-threads">Multiple Ownership with Multiple Threads</a></h4>
<p>In Chapter 15, we gave a value multiple owners by using the smart pointer
<code>Rc&lt;T&gt;</code> to create a reference counted value. Let’s do the same here and see
what happens. We’ll wrap the <code>Mutex&lt;T&gt;</code> in <code>Rc&lt;T&gt;</code> in Listing 16-14 and clone
the <code>Rc&lt;T&gt;</code> before moving ownership to the thread. Now that we’ve seen the
errors, we’ll also switch back to using the <code>for</code> loop, and we’ll keep the
<code>move</code> keyword with the closure.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use std::rc::Rc;
use std::sync::Mutex;
use std::thread;

fn main() {
    let counter = Rc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Rc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre>
<p><span class="caption">Listing 16-14: Attempting to use <code>Rc&lt;T&gt;</code> to allow
multiple threads to own the <code>Mutex&lt;T&gt;</code></span></p>
<p>Once again, we compile and get... different errors! The compiler is teaching us
a lot.</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;:
std::marker::Send` is not satisfied in `[closure@src/main.rs:11:36:
15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
  --&gt; src/main.rs:11:22
   |
11 |         let handle = thread::spawn(move || {
   |                      ^^^^^^^^^^^^^ `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
cannot be sent between threads safely
   |
   = help: within `[closure@src/main.rs:11:36: 15:10
counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`, the trait `std::marker::Send` is
not implemented for `std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;`
   = note: required because it appears within the type
`[closure@src/main.rs:11:36: 15:10 counter:std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;]`
   = note: required by `std::thread::spawn`
</code></pre>
<p>Wow, that error message is very wordy! Here are some important parts to focus
on: the first inline error says <code>`std::rc::Rc&lt;std::sync::Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>. The reason for this is in the next important
part to focus on, the error message. The distilled error message says <code>the trait bound `Send` is not satisfied</code>. We’ll talk about <code>Send</code> in the next
section: it’s one of the traits that ensures the types we use with threads are
meant for use in concurrent situations.</p>
<p>Unfortunately, <code>Rc&lt;T&gt;</code> is not safe to share across threads. When <code>Rc&lt;T&gt;</code>
manages the reference count, it adds to the count for each call to <code>clone</code> and
subtracts from the count when each clone is dropped. But it doesn’t use any
concurrency primitives to make sure that changes to the count can’t be
interrupted by another thread. This could lead to wrong counts—subtle bugs that
could in turn lead to memory leaks or a value being dropped before we’re done
with it. What we need is a type exactly like <code>Rc&lt;T&gt;</code> but one that makes changes
to the reference count in a thread-safe way.</p>
<h4><a class="header" href="#atomic-reference-counting-with-arct" id="atomic-reference-counting-with-arct">Atomic Reference Counting with <code>Arc&lt;T&gt;</code></a></h4>
<p>Fortunately, <code>Arc&lt;T&gt;</code> <em>is</em> a type like <code>Rc&lt;T&gt;</code> that is safe to use in
concurrent situations. The <em>a</em> stands for <em>atomic</em>, meaning it’s an <em>atomically
reference counted</em> type. Atomics are an additional kind of concurrency
primitive that we won’t cover in detail here: see the standard library
documentation for <code>std::sync::atomic</code> for more details. At this point, you just
need to know that atomics work like primitive types but are safe to share
across threads.</p>
<p>You might then wonder why all primitive types aren’t atomic and why standard
library types aren’t implemented to use <code>Arc&lt;T&gt;</code> by default. The reason is that
thread safety comes with a performance penalty that you only want to pay when
you really need to. If you’re just performing operations on values within a
single thread, your code can run faster if it doesn’t have to enforce the
guarantees atomics provide.</p>
<p>Let’s return to our example: <code>Arc&lt;T&gt;</code> and <code>Rc&lt;T&gt;</code> have the same API, so we fix
our program by changing the <code>use</code> line, the call to <code>new</code>, and the call to
<code>clone</code>. The code in Listing 16-15 will finally compile and run:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::sync::{Mutex, Arc};
use std::thread;

fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&amp;counter);
        let handle = thread::spawn(move || {
            let mut num = counter.lock().unwrap();

            *num += 1;
        });
        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!(&quot;Result: {}&quot;, *counter.lock().unwrap());
}
</code></pre></pre>
<p><span class="caption">Listing 16-15: Using an <code>Arc&lt;T&gt;</code> to wrap the <code>Mutex&lt;T&gt;</code>
to be able to share ownership across multiple threads</span></p>
<p>This code will print the following:</p>
<pre><code class="language-text">Result: 10
</code></pre>
<p>We did it! We counted from 0 to 10, which may not seem very impressive, but it
did teach us a lot about <code>Mutex&lt;T&gt;</code> and thread safety. You could also use this
program’s structure to do more complicated operations than just incrementing a
counter. Using this strategy, you can divide a calculation into independent
parts, split those parts across threads, and then use a <code>Mutex&lt;T&gt;</code> to have each
thread update the final result with its part.</p>
<h3><a class="header" href="#similarities-between-refcelltrct-and-mutextarct" id="similarities-between-refcelltrct-and-mutextarct">Similarities Between <code>RefCell&lt;T&gt;</code>/<code>Rc&lt;T&gt;</code> and <code>Mutex&lt;T&gt;</code>/<code>Arc&lt;T&gt;</code></a></h3>
<p>You might have noticed that <code>counter</code> is immutable but we could get a mutable
reference to the value inside it; this means <code>Mutex&lt;T&gt;</code> provides interior
mutability, as the <code>Cell</code> family does. In the same way we used <code>RefCell&lt;T&gt;</code> in
Chapter 15 to allow us to mutate contents inside an <code>Rc&lt;T&gt;</code>, we use <code>Mutex&lt;T&gt;</code>
to mutate contents inside an <code>Arc&lt;T&gt;</code>.</p>
<p>Another detail to note is that Rust can’t protect you from all kinds of logic
errors when you use <code>Mutex&lt;T&gt;</code>. Recall in Chapter 15 that using <code>Rc&lt;T&gt;</code> came
with the risk of creating reference cycles, where two <code>Rc&lt;T&gt;</code> values refer to
each other, causing memory leaks. Similarly, <code>Mutex&lt;T&gt;</code> comes with the risk of
creating <em>deadlocks</em>. These occur when an operation needs to lock two resources
and two threads have each acquired one of the locks, causing them to wait for
each other forever. If you’re interested in deadlocks, try creating a Rust
program that has a deadlock; then research deadlock mitigation strategies for
mutexes in any language and have a go at implementing them in Rust. The
standard library API documentation for <code>Mutex&lt;T&gt;</code> and <code>MutexGuard</code> offers
useful information.</p>
<p>We’ll round out this chapter by talking about the <code>Send</code> and <code>Sync</code> traits and
how we can use them with custom types.</p>
<h2><a class="header" href="#extensible-concurrency-with-the-sync-and-send-traits" id="extensible-concurrency-with-the-sync-and-send-traits">Extensible Concurrency with the <code>Sync</code> and <code>Send</code> Traits</a></h2>
<p>Interestingly, the Rust language has <em>very</em> few concurrency features. Almost
every concurrency feature we’ve talked about so far in this chapter has been
part of the standard library, not the language. Your options for handling
concurrency are not limited to the language or the standard library; you can
write your own concurrency features or use those written by others.</p>
<p>However, two concurrency concepts are embedded in the language: the
<code>std::marker</code> traits <code>Sync</code> and <code>Send</code>.</p>
<h3><a class="header" href="#allowing-transference-of-ownership-between-threads-with-send" id="allowing-transference-of-ownership-between-threads-with-send">Allowing Transference of Ownership Between Threads with <code>Send</code></a></h3>
<p>The <code>Send</code> marker trait indicates that ownership of the type implementing
<code>Send</code> can be transferred between threads. Almost every Rust type is <code>Send</code>,
but there are some exceptions, including <code>Rc&lt;T&gt;</code>: this cannot be <code>Send</code> because
if you cloned an <code>Rc&lt;T&gt;</code> value and tried to transfer ownership of the clone to
another thread, both threads might update the reference count at the same time.
For this reason, <code>Rc&lt;T&gt;</code> is implemented for use in single-threaded situations
where you don’t want to pay the thread-safe performance penalty.</p>
<p>Therefore, Rust’s type system and trait bounds ensure that you can never
accidentally send an <code>Rc&lt;T&gt;</code> value across threads unsafely. When we tried to do
this in Listing 16-14, we got the error <code>the trait Send is not implemented for Rc&lt;Mutex&lt;i32&gt;&gt;</code>. When we switched to <code>Arc&lt;T&gt;</code>, which is <code>Send</code>, the code
compiled.</p>
<p>Any type composed entirely of <code>Send</code> types is automatically marked as <code>Send</code> as
well. Almost all primitive types are <code>Send</code>, aside from raw pointers, which
we’ll discuss in Chapter 19.</p>
<h3><a class="header" href="#allowing-access-from-multiple-threads-with-sync" id="allowing-access-from-multiple-threads-with-sync">Allowing Access from Multiple Threads with <code>Sync</code></a></h3>
<p>The <code>Sync</code> marker trait indicates that it is safe for the type implementing
<code>Sync</code> to be referenced from multiple threads. In other words, any type <code>T</code> is
<code>Sync</code> if <code>&amp;T</code> (a reference to <code>T</code>) is <code>Send</code>, meaning the reference can be
sent safely to another thread. Similar to <code>Send</code>, primitive types are <code>Sync</code>,
and types composed entirely of types that are <code>Sync</code> are also <code>Sync</code>.</p>
<p>The smart pointer <code>Rc&lt;T&gt;</code> is also not <code>Sync</code> for the same reasons that it’s not
<code>Send</code>. The <code>RefCell&lt;T&gt;</code> type (which we talked about in Chapter 15) and the
family of related <code>Cell&lt;T&gt;</code> types are not <code>Sync</code>. The implementation of borrow
checking that <code>RefCell&lt;T&gt;</code> does at runtime is not thread-safe. The smart
pointer <code>Mutex&lt;T&gt;</code> is <code>Sync</code> and can be used to share access with multiple
threads as you saw in the <a href="rustbook/ch16-03-shared-state.html#sharing-a-mutext-between-multiple-threads">“Sharing a <code>Mutex&lt;T&gt;</code> Between Multiple
Threads”</a><!-- ignore --> section.</p>
<h3><a class="header" href="#implementing-send-and-sync-manually-is-unsafe" id="implementing-send-and-sync-manually-is-unsafe">Implementing <code>Send</code> and <code>Sync</code> Manually Is Unsafe</a></h3>
<p>Because types that are made up of <code>Send</code> and <code>Sync</code> traits are automatically
also <code>Send</code> and <code>Sync</code>, we don’t have to implement those traits manually. As
marker traits, they don’t even have any methods to implement. They’re just
useful for enforcing invariants related to concurrency.</p>
<p>Manually implementing these traits involves implementing unsafe Rust code.
We’ll talk about using unsafe Rust code in Chapter 19; for now, the important
information is that building new concurrent types not made up of <code>Send</code> and
<code>Sync</code> parts requires careful thought to uphold the safety guarantees.
<a href="https://doc.rust-lang.org/stable/nomicon/">The Rustonomicon</a> has more information about these guarantees and how to
uphold them.</p>
<h2><a class="header" href="#summary-15" id="summary-15">Summary</a></h2>
<p>This isn’t the last you’ll see of concurrency in this book: the project in
Chapter 20 will use the concepts in this chapter in a more realistic situation
than the smaller examples discussed here.</p>
<p>As mentioned earlier, because very little of how Rust handles concurrency is
part of the language, many concurrency solutions are implemented as crates.
These evolve more quickly than the standard library, so be sure to search
online for the current, state-of-the-art crates to use in multithreaded
situations.</p>
<p>The Rust standard library provides channels for message passing and smart
pointer types, such as <code>Mutex&lt;T&gt;</code> and <code>Arc&lt;T&gt;</code>, that are safe to use in
concurrent contexts. The type system and the borrow checker ensure that the
code using these solutions won’t end up with data races or invalid references.
Once you get your code to compile, you can rest assured that it will happily
run on multiple threads without the kinds of hard-to-track-down bugs common in
other languages. Concurrent programming is no longer a concept to be afraid of:
go forth and make your programs concurrent, fearlessly!</p>
<p>Next, we’ll talk about idiomatic ways to model problems and structure solutions
as your Rust programs get bigger. In addition, we’ll discuss how Rust’s idioms
relate to those you might be familiar with from object-oriented programming.</p>
<h1><a class="header" href="#object-oriented-programming-features-of-rust" id="object-oriented-programming-features-of-rust">Object Oriented Programming Features of Rust</a></h1>
<p>Object-oriented programming (OOP) is a way of modeling programs. Objects came
from Simula in the 1960s. Those objects influenced Alan Kay’s programming
architecture in which objects pass messages to each other. He coined the term
<em>object-oriented programming</em> in 1967 to describe this architecture. Many
competing definitions describe what OOP is; some definitions would classify
Rust as object oriented, but other definitions would not. In this chapter,
we’ll explore certain characteristics that are commonly considered object
oriented and how those characteristics translate to idiomatic Rust. We’ll then
show you how to implement an object-oriented design pattern in Rust and discuss
the trade-offs of doing so versus implementing a solution using some of Rust’s
strengths instead.</p>
<h2><a class="header" href="#characteristics-of-object-oriented-languages" id="characteristics-of-object-oriented-languages">Characteristics of Object-Oriented Languages</a></h2>
<p>There is no consensus in the programming community about what features a
language must have to be considered object oriented. Rust is influenced by many
programming paradigms, including OOP; for example, we explored the features
that came from functional programming in Chapter 13. Arguably, OOP languages
share certain common characteristics, namely objects, encapsulation, and
inheritance. Let’s look at what each of those characteristics means and whether
Rust supports it.</p>
<h3><a class="header" href="#objects-contain-data-and-behavior" id="objects-contain-data-and-behavior">Objects Contain Data and Behavior</a></h3>
<p>The book <em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by
Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (Addison-Wesley
Professional, 1994) colloquially referred to as <em>The Gang of Four</em> book, is a
catalog of object-oriented design patterns. It defines OOP this way:</p>
<blockquote>
<p>Object-oriented programs are made up of objects. An <em>object</em> packages both
data and the procedures that operate on that data. The procedures are
typically called <em>methods</em> or <em>operations</em>.</p>
</blockquote>
<p>Using this definition, Rust is object oriented: structs and enums have data,
and <code>impl</code> blocks provide methods on structs and enums. Even though structs and
enums with methods aren’t <em>called</em> objects, they provide the same
functionality, according to the Gang of Four’s definition of objects.</p>
<h3><a class="header" href="#encapsulation-that-hides-implementation-details" id="encapsulation-that-hides-implementation-details">Encapsulation that Hides Implementation Details</a></h3>
<p>Another aspect commonly associated with OOP is the idea of <em>encapsulation</em>,
which means that the implementation details of an object aren’t accessible to
code using that object. Therefore, the only way to interact with an object is
through its public API; code using the object shouldn’t be able to reach into
the object’s internals and change data or behavior directly. This enables the
programmer to change and refactor an object’s internals without needing to
change the code that uses the object.</p>
<p>We discussed how to control encapsulation in Chapter 7: we can use the <code>pub</code>
keyword to decide which modules, types, functions, and methods in our code
should be public, and by default everything else is private. For example, we
can define a struct <code>AveragedCollection</code> that has a field containing a vector
of <code>i32</code> values. The struct can also have a field that contains the average of
the values in the vector, meaning the average doesn’t have to be computed
on demand whenever anyone needs it. In other words, <code>AveragedCollection</code> will
cache the calculated average for us. Listing 17-1 has the definition of the
<code>AveragedCollection</code> struct:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct AveragedCollection {
    list: Vec&lt;i32&gt;,
    average: f64,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-1: An <code>AveragedCollection</code> struct that
maintains a list of integers and the average of the items in the
collection</span></p>
<p>The struct is marked <code>pub</code> so that other code can use it, but the fields within
the struct remain private. This is important in this case because we want to
ensure that whenever a value is added or removed from the list, the average is
also updated. We do this by implementing <code>add</code>, <code>remove</code>, and <code>average</code> methods
on the struct, as shown in Listing 17-2:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct AveragedCollection {
</span><span class="boring">    list: Vec&lt;i32&gt;,
</span><span class="boring">    average: f64,
</span><span class="boring">}
</span>impl AveragedCollection {
    pub fn add(&amp;mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&amp;mut self) -&gt; Option&lt;i32&gt; {
        let result = self.list.pop();
        match result {
            Some(value) =&gt; {
                self.update_average();
                Some(value)
            },
            None =&gt; None,
        }
    }

    pub fn average(&amp;self) -&gt; f64 {
        self.average
    }

    fn update_average(&amp;mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-2: Implementations of the public methods
<code>add</code>, <code>remove</code>, and <code>average</code> on <code>AveragedCollection</code></span></p>
<p>The public methods <code>add</code>, <code>remove</code>, and <code>average</code> are the only ways to access
or modify data in an instance of <code>AveragedCollection</code>. When an item is added
to <code>list</code> using the <code>add</code> method or removed using the <code>remove</code> method, the
implementations of each call the private <code>update_average</code> method that handles
updating the <code>average</code> field as well.</p>
<p>We leave the <code>list</code> and <code>average</code> fields private so there is no way for
external code to add or remove items to the <code>list</code> field directly; otherwise,
the <code>average</code> field might become out of sync when the <code>list</code> changes. The
<code>average</code> method returns the value in the <code>average</code> field, allowing external
code to read the <code>average</code> but not modify it.</p>
<p>Because we’ve encapsulated the implementation details of the struct
<code>AveragedCollection</code>, we can easily change aspects, such as the data structure,
in the future. For instance, we could use a <code>HashSet&lt;i32&gt;</code> instead of a
<code>Vec&lt;i32&gt;</code> for the <code>list</code> field. As long as the signatures of the <code>add</code>,
<code>remove</code>, and <code>average</code> public methods stay the same, code using
<code>AveragedCollection</code> wouldn’t need to change. If we made <code>list</code> public instead,
this wouldn’t necessarily be the case: <code>HashSet&lt;i32&gt;</code> and <code>Vec&lt;i32&gt;</code> have
different methods for adding and removing items, so the external code would
likely have to change if it were modifying <code>list</code> directly.</p>
<p>If encapsulation is a required aspect for a language to be considered object
oriented, then Rust meets that requirement. The option to use <code>pub</code> or not for
different parts of code enables encapsulation of implementation details.</p>
<h3><a class="header" href="#inheritance-as-a-type-system-and-as-code-sharing" id="inheritance-as-a-type-system-and-as-code-sharing">Inheritance as a Type System and as Code Sharing</a></h3>
<p><em>Inheritance</em> is a mechanism whereby an object can inherit from another
object’s definition, thus gaining the parent object’s data and behavior without
you having to define them again.</p>
<p>If a language must have inheritance to be an object-oriented language, then
Rust is not one. There is no way to define a struct that inherits the parent
struct’s fields and method implementations. However, if you’re used to having
inheritance in your programming toolbox, you can use other solutions in Rust,
depending on your reason for reaching for inheritance in the first place.</p>
<p>You choose inheritance for two main reasons. One is for reuse of code: you can
implement particular behavior for one type, and inheritance enables you to
reuse that implementation for a different type. You can share Rust code using
default trait method implementations instead, which you saw in Listing 10-14
when we added a default implementation of the <code>summarize</code> method on the
<code>Summary</code> trait. Any type implementing the <code>Summary</code> trait would have the
<code>summarize</code> method available on it without any further code. This is similar to
a parent class having an implementation of a method and an inheriting child
class also having the implementation of the method. We can also override the
default implementation of the <code>summarize</code> method when we implement the
<code>Summary</code> trait, which is similar to a child class overriding the
implementation of a method inherited from a parent class.</p>
<p>The other reason to use inheritance relates to the type system: to enable a
child type to be used in the same places as the parent type. This is also
called <em>polymorphism</em>, which means that you can substitute multiple objects for
each other at runtime if they share certain characteristics.</p>
<blockquote>
<h3><a class="header" href="#polymorphism" id="polymorphism">Polymorphism</a></h3>
<p>To many people, polymorphism is synonymous with inheritance. But it’s
actually a more general concept that refers to code that can work with data
of multiple types. For inheritance, those types are generally subclasses.</p>
<p>Rust instead uses generics to abstract over different possible types and
trait bounds to impose constraints on what those types must provide. This is
sometimes called <em>bounded parametric polymorphism</em>.</p>
</blockquote>
<p>Inheritance has recently fallen out of favor as a programming design solution
in many programming languages because it’s often at risk of sharing more code
than necessary. Subclasses shouldn’t always share all characteristics of their
parent class but will do so with inheritance. This can make a program’s design
less flexible. It also introduces the possibility of calling methods on
subclasses that don’t make sense or that cause errors because the methods don’t
apply to the subclass. In addition, some languages will only allow a subclass
to inherit from one class, further restricting the flexibility of a program’s
design.</p>
<p>For these reasons, Rust takes a different approach, using trait objects instead
of inheritance. Let’s look at how trait objects enable polymorphism in Rust.</p>
<h2><a class="header" href="#using-trait-objects-that-allow-for-values-of-different-types" id="using-trait-objects-that-allow-for-values-of-different-types">Using Trait Objects That Allow for Values of Different Types</a></h2>
<p>In Chapter 8, we mentioned that one limitation of vectors is that they can
store elements of only one type. We created a workaround in Listing 8-10 where
we defined a <code>SpreadsheetCell</code> enum that had variants to hold integers, floats,
and text. This meant we could store different types of data in each cell and
still have a vector that represented a row of cells. This is a perfectly good
solution when our interchangeable items are a fixed set of types that we know
when our code is compiled.</p>
<p>However, sometimes we want our library user to be able to extend the set of
types that are valid in a particular situation. To show how we might achieve
this, we’ll create an example graphical user interface (GUI) tool that iterates
through a list of items, calling a <code>draw</code> method on each one to draw it to the
screen—a common technique for GUI tools. We’ll create a library crate called
<code>gui</code> that contains the structure of a GUI library. This crate might include
some types for people to use, such as <code>Button</code> or <code>TextField</code>. In addition,
<code>gui</code> users will want to create their own types that can be drawn: for
instance, one programmer might add an <code>Image</code> and another might add a
<code>SelectBox</code>.</p>
<p>We won’t implement a fully fledged GUI library for this example but will show
how the pieces would fit together. At the time of writing the library, we can’t
know and define all the types other programmers might want to create. But we do
know that <code>gui</code> needs to keep track of many values of different types, and it
needs to call a <code>draw</code> method on each of these differently typed values. It
doesn’t need to know exactly what will happen when we call the <code>draw</code> method,
just that the value will have that method available for us to call.</p>
<p>To do this in a language with inheritance, we might define a class named
<code>Component</code> that has a method named <code>draw</code> on it. The other classes, such as
<code>Button</code>, <code>Image</code>, and <code>SelectBox</code>, would inherit from <code>Component</code> and thus
inherit the <code>draw</code> method. They could each override the <code>draw</code> method to define
their custom behavior, but the framework could treat all of the types as if
they were <code>Component</code> instances and call <code>draw</code> on them. But because Rust
doesn’t have inheritance, we need another way to structure the <code>gui</code> library to
allow users to extend it with new types.</p>
<h3><a class="header" href="#defining-a-trait-for-common-behavior" id="defining-a-trait-for-common-behavior">Defining a Trait for Common Behavior</a></h3>
<p>To implement the behavior we want <code>gui</code> to have, we’ll define a trait named
<code>Draw</code> that will have one method named <code>draw</code>. Then we can define a vector that
takes a <em>trait object</em>. A trait object points to both an instance of a type
implementing our specified trait as well as a table used to look up trait
methods on that type at runtime. We create a trait object by specifying some
sort of pointer, such as a <code>&amp;</code> reference or a <code>Box&lt;T&gt;</code> smart pointer, then the
<code>dyn</code> keyword, and then specifying the relevant trait. (We’ll talk about the
reason trait objects must use a pointer in Chapter 19 in the section
<a href="rustbook/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait">“Dynamically Sized Types and the <code>Sized</code> Trait.”</a><!--
ignore -->) We can use trait objects in place of a generic or concrete type.
Wherever we use a trait object, Rust’s type system will ensure at compile time
that any value used in that context will implement the trait object’s trait.
Consequently, we don’t need to know all the possible types at compile time.</p>
<p>We’ve mentioned that in Rust, we refrain from calling structs and enums
“objects” to distinguish them from other languages’ objects. In a struct or
enum, the data in the struct fields and the behavior in <code>impl</code> blocks are
separated, whereas in other languages, the data and behavior combined into one
concept is often labeled an object. However, trait objects <em>are</em> more like
objects in other languages in the sense that they combine data and behavior.
But trait objects differ from traditional objects in that we can’t add data to
a trait object. Trait objects aren’t as generally useful as objects in other
languages: their specific purpose is to allow abstraction across common
behavior.</p>
<p>Listing 17-3 shows how to define a trait named <code>Draw</code> with one method named
<code>draw</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Draw {
    fn draw(&amp;self);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-3: Definition of the <code>Draw</code> trait</span></p>
<p>This syntax should look familiar from our discussions on how to define traits
in Chapter 10. Next comes some new syntax: Listing 17-4 defines a struct named
<code>Screen</code> that holds a vector named <code>components</code>. This vector is of type
<code>Box&lt;dyn Draw&gt;</code>, which is a trait object; it’s a stand-in for any type inside
a <code>Box</code> that implements the <code>Draw</code> trait.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-4: Definition of the <code>Screen</code> struct with a
<code>components</code> field holding a vector of trait objects that implement the <code>Draw</code>
trait</span></p>
<p>On the <code>Screen</code> struct, we’ll define a method named <code>run</code> that will call the
<code>draw</code> method on each of its <code>components</code>, as shown in Listing 17-5:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Screen {
</span><span class="boring">    pub components: Vec&lt;Box&lt;dyn Draw&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Screen {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-5: A <code>run</code> method on <code>Screen</code> that calls the
<code>draw</code> method on each component</span></p>
<p>This works differently from defining a struct that uses a generic type
parameter with trait bounds. A generic type parameter can only be substituted
with one concrete type at a time, whereas trait objects allow for multiple
concrete types to fill in for the trait object at runtime. For example, we
could have defined the <code>Screen</code> struct using a generic type and a trait bound
as in Listing 17-6:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Screen&lt;T: Draw&gt; {
    pub components: Vec&lt;T&gt;,
}

impl&lt;T&gt; Screen&lt;T&gt;
    where T: Draw {
    pub fn run(&amp;self) {
        for component in self.components.iter() {
            component.draw();
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-6: An alternate implementation of the <code>Screen</code>
struct and its <code>run</code> method using generics and trait bounds</span></p>
<p>This restricts us to a <code>Screen</code> instance that has a list of components all of
type <code>Button</code> or all of type <code>TextField</code>. If you’ll only ever have homogeneous
collections, using generics and trait bounds is preferable because the
definitions will be monomorphized at compile time to use the concrete types.</p>
<p>On the other hand, with the method using trait objects, one <code>Screen</code> instance
can hold a <code>Vec&lt;T&gt;</code> that contains a <code>Box&lt;Button&gt;</code> as well as a
<code>Box&lt;TextField&gt;</code>. Let’s look at how this works, and then we’ll talk about the
runtime performance implications.</p>
<h3><a class="header" href="#implementing-the-trait" id="implementing-the-trait">Implementing the Trait</a></h3>
<p>Now we’ll add some types that implement the <code>Draw</code> trait. We’ll provide the
<code>Button</code> type. Again, actually implementing a GUI library is beyond the scope
of this book, so the <code>draw</code> method won’t have any useful implementation in its
body. To imagine what the implementation might look like, a <code>Button</code> struct
might have fields for <code>width</code>, <code>height</code>, and <code>label</code>, as shown in Listing 17-7:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Draw {
</span><span class="boring">    fn draw(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span>pub struct Button {
    pub width: u32,
    pub height: u32,
    pub label: String,
}

impl Draw for Button {
    fn draw(&amp;self) {
        // code to actually draw a button
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-7: A <code>Button</code> struct that implements the
<code>Draw</code> trait</span></p>
<p>The <code>width</code>, <code>height</code>, and <code>label</code> fields on <code>Button</code> will differ from the
fields on other components, such as a <code>TextField</code> type, that might have those
fields plus a <code>placeholder</code> field instead. Each of the types we want to draw on
the screen will implement the <code>Draw</code> trait but will use different code in the
<code>draw</code> method to define how to draw that particular type, as <code>Button</code> has here
(without the actual GUI code, which is beyond the scope of this chapter). The
<code>Button</code> type, for instance, might have an additional <code>impl</code> block containing
methods related to what happens when a user clicks the button. These kinds of
methods won’t apply to types like <code>TextField</code>.</p>
<p>If someone using our library decides to implement a <code>SelectBox</code> struct that has
<code>width</code>, <code>height</code>, and <code>options</code> fields, they implement the <code>Draw</code> trait on the
<code>SelectBox</code> type as well, as shown in Listing 17-8:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::Draw;

struct SelectBox {
    width: u32,
    height: u32,
    options: Vec&lt;String&gt;,
}

impl Draw for SelectBox {
    fn draw(&amp;self) {
        // code to actually draw a select box
    }
}
</code></pre>
<p><span class="caption">Listing 17-8: Another crate using <code>gui</code> and implementing
the <code>Draw</code> trait on a <code>SelectBox</code> struct</span></p>
<p>Our library’s user can now write their <code>main</code> function to create a <code>Screen</code>
instance. To the <code>Screen</code> instance, they can add a <code>SelectBox</code> and a <code>Button</code>
by putting each in a <code>Box&lt;T&gt;</code> to become a trait object. They can then call the
<code>run</code> method on the <code>Screen</code> instance, which will call <code>draw</code> on each of the
components. Listing 17-9 shows this implementation:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use gui::{Screen, Button};

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(SelectBox {
                width: 75,
                height: 10,
                options: vec![
                    String::from(&quot;Yes&quot;),
                    String::from(&quot;Maybe&quot;),
                    String::from(&quot;No&quot;)
                ],
            }),
            Box::new(Button {
                width: 50,
                height: 10,
                label: String::from(&quot;OK&quot;),
            }),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-9: Using trait objects to store values of
different types that implement the same trait</span></p>
<p>When we wrote the library, we didn’t know that someone might add the
<code>SelectBox</code> type, but our <code>Screen</code> implementation was able to operate on the
new type and draw it because <code>SelectBox</code> implements the <code>Draw</code> trait, which
means it implements the <code>draw</code> method.</p>
<p>This concept—of being concerned only with the messages a value responds to
rather than the value’s concrete type—is similar to the concept <em>duck typing</em>
in dynamically typed languages: if it walks like a duck and quacks like a duck,
then it must be a duck! In the implementation of <code>run</code> on <code>Screen</code> in Listing
17-5, <code>run</code> doesn’t need to know what the concrete type of each component is.
It doesn’t check whether a component is an instance of a <code>Button</code> or a
<code>SelectBox</code>, it just calls the <code>draw</code> method on the component. By specifying
<code>Box&lt;dyn Draw&gt;</code> as the type of the values in the <code>components</code> vector, we’ve
defined <code>Screen</code> to need values that we can call the <code>draw</code> method on.</p>
<p>The advantage of using trait objects and Rust’s type system to write code
similar to code using duck typing is that we never have to check whether a
value implements a particular method at runtime or worry about getting errors
if a value doesn’t implement a method but we call it anyway. Rust won’t compile
our code if the values don’t implement the traits that the trait objects need.</p>
<p>For example, Listing 17-10 shows what happens if we try to create a <code>Screen</code>
with a <code>String</code> as a component:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">use gui::Screen;

fn main() {
    let screen = Screen {
        components: vec![
            Box::new(String::from(&quot;Hi&quot;)),
        ],
    };

    screen.run();
}
</code></pre>
<p><span class="caption">Listing 17-10: Attempting to use a type that doesn’t
implement the trait object’s trait</span></p>
<p>We’ll get this error because <code>String</code> doesn’t implement the <code>Draw</code> trait:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::string::String: gui::Draw` is not satisfied
  --&gt; src/main.rs:7:13
   |
 7 |             Box::new(String::from(&quot;Hi&quot;)),
   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait gui::Draw is not
   implemented for `std::string::String`
   |
   = note: required for the cast to the object type `gui::Draw`
</code></pre>
<p>This error lets us know that either we’re passing something to <code>Screen</code> we
didn’t mean to pass and we should pass a different type or we should implement
<code>Draw</code> on <code>String</code> so that <code>Screen</code> is able to call <code>draw</code> on it.</p>
<h3><a class="header" href="#trait-objects-perform-dynamic-dispatch" id="trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</a></h3>
<p>Recall in the <a href="rustbook/ch10-01-syntax.html#performance-of-code-using-generics">“Performance of Code Using
Generics”</a><!-- ignore --> section in
Chapter 10 our discussion on the monomorphization process performed by the
compiler when we use trait bounds on generics: the compiler generates
nongeneric implementations of functions and methods for each concrete type
that we use in place of a generic type parameter. The code that results from
monomorphization is doing <em>static dispatch</em>, which is when the compiler knows
what method you’re calling at compile time. This is opposed to <em>dynamic
dispatch</em>, which is when the compiler can’t tell at compile time which method
you’re calling. In dynamic dispatch cases, the compiler emits code that at
runtime will figure out which method to call.</p>
<p>When we use trait objects, Rust must use dynamic dispatch. The compiler doesn’t
know all the types that might be used with the code that is using trait
objects, so it doesn’t know which method implemented on which type to call.
Instead, at runtime, Rust uses the pointers inside the trait object to know
which method to call. There is a runtime cost when this lookup happens that
doesn’t occur with static dispatch. Dynamic dispatch also prevents the compiler
from choosing to inline a method’s code, which in turn prevents some
optimizations. However, we did get extra flexibility in the code that we wrote
in Listing 17-5 and were able to support in Listing 17-9, so it’s a trade-off
to consider.</p>
<h3><a class="header" href="#object-safety-is-required-for-trait-objects" id="object-safety-is-required-for-trait-objects">Object Safety Is Required for Trait Objects</a></h3>
<p>You can only make <em>object-safe</em> traits into trait objects. Some complex rules
govern all the properties that make a trait object safe, but in practice, only
two rules are relevant. A trait is object safe if all the methods defined in
the trait have the following properties:</p>
<ul>
<li>The return type isn’t <code>Self</code>.</li>
<li>There are no generic type parameters.</li>
</ul>
<p>The <code>Self</code> keyword is an alias for the type we’re implementing the traits or
methods on. Trait objects must be object safe because once you’ve used a trait
object, Rust no longer knows the concrete type that’s implementing that trait.
If a trait method returns the concrete <code>Self</code> type, but a trait object forgets
the exact type that <code>Self</code> is, there is no way the method can use the original
concrete type. The same is true of generic type parameters that are filled in
with concrete type parameters when the trait is used: the concrete types become
part of the type that implements the trait. When the type is forgotten through
the use of a trait object, there is no way to know what types to fill in the
generic type parameters with.</p>
<p>An example of a trait whose methods are not object safe is the standard
library’s <code>Clone</code> trait. The signature for the <code>clone</code> method in the <code>Clone</code>
trait looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Clone {
    fn clone(&amp;self) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>String</code> type implements the <code>Clone</code> trait, and when we call the <code>clone</code>
method on an instance of <code>String</code> we get back an instance of <code>String</code>.
Similarly, if we call <code>clone</code> on an instance of <code>Vec&lt;T&gt;</code>, we get back an
instance of <code>Vec&lt;T&gt;</code>. The signature of <code>clone</code> needs to know what type will
stand in for <code>Self</code>, because that’s the return type.</p>
<p>The compiler will indicate when you’re trying to do something that violates the
rules of object safety in regard to trait objects. For example, let’s say we
tried to implement the <code>Screen</code> struct in Listing 17-4 to hold types that
implement the <code>Clone</code> trait instead of the <code>Draw</code> trait, like this:</p>
<pre><code class="language-rust ignore does_not_compile">pub struct Screen {
    pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
}
</code></pre>
<p>We would get this error:</p>
<pre><code class="language-text">error[E0038]: the trait `std::clone::Clone` cannot be made into an object
 --&gt; src/lib.rs:2:5
  |
2 |     pub components: Vec&lt;Box&lt;dyn Clone&gt;&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::clone::Clone`
  cannot be made into an object
  |
  = note: the trait cannot require that `Self : Sized`
</code></pre>
<p>This error means you can’t use this trait as a trait object in this way. If
you’re interested in more details on object safety, see <a href="https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md">Rust RFC 255</a>.</p>
<h2><a class="header" href="#implementing-an-object-oriented-design-pattern" id="implementing-an-object-oriented-design-pattern">Implementing an Object-Oriented Design Pattern</a></h2>
<p>The <em>state pattern</em> is an object-oriented design pattern. The crux of the
pattern is that a value has some internal state, which is represented by a set
of <em>state objects</em>, and the value’s behavior changes based on the internal
state. The state objects share functionality: in Rust, of course, we use
structs and traits rather than objects and inheritance. Each state object is
responsible for its own behavior and for governing when it should change into
another state. The value that holds a state object knows nothing about the
different behavior of the states or when to transition between states.</p>
<p>Using the state pattern means when the business requirements of the program
change, we won’t need to change the code of the value holding the state or the
code that uses the value. We’ll only need to update the code inside one of the
state objects to change its rules or perhaps add more state objects. Let’s look
at an example of the state design pattern and how to use it in Rust.</p>
<p>We’ll implement a blog post workflow in an incremental way. The blog’s final
functionality will look like this:</p>
<ol>
<li>A blog post starts as an empty draft.</li>
<li>When the draft is done, a review of the post is requested.</li>
<li>When the post is approved, it gets published.</li>
<li>Only published blog posts return content to print, so unapproved posts can’t
accidentally be published.</li>
</ol>
<p>Any other changes attempted on a post should have no effect. For example, if we
try to approve a draft blog post before we’ve requested a review, the post
should remain an unpublished draft.</p>
<p>Listing 17-11 shows this workflow in code form: this is an example usage of the
API we’ll implement in a library crate named <code>blog</code>. This won’t compile yet
because we haven’t implemented the <code>blog</code> crate yet.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());

    post.request_review();
    assert_eq!(&quot;&quot;, post.content());

    post.approve();
    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listing 17-11: Code that demonstrates the desired
behavior we want our <code>blog</code> crate to have</span></p>
<p>We want to allow the user to create a new draft blog post with <code>Post::new</code>.
Then we want to allow text to be added to the blog post while it’s in the draft
state. If we try to get the post’s content immediately, before approval,
nothing should happen because the post is still a draft. We’ve added
<code>assert_eq!</code> in the code for demonstration purposes. An excellent unit test for
this would be to assert that a draft blog post returns an empty string from the
<code>content</code> method, but we’re not going to write tests for this example.</p>
<p>Next, we want to enable a request for a review of the post, and we want
<code>content</code> to return an empty string while waiting for the review. When the post
receives approval, it should get published, meaning the text of the post will
be returned when <code>content</code> is called.</p>
<p>Notice that the only type we’re interacting with from the crate is the <code>Post</code>
type. This type will use the state pattern and will hold a value that will be
one of three state objects representing the various states a post can be
in—draft, waiting for review, or published. Changing from one state to another
will be managed internally within the <code>Post</code> type. The states change in
response to the methods called by our library’s users on the <code>Post</code> instance,
but they don’t have to manage the state changes directly. Also, users can’t
make a mistake with the states, like publishing a post before it’s reviewed.</p>
<h3><a class="header" href="#defining-post-and-creating-a-new-instance-in-the-draft-state" id="defining-post-and-creating-a-new-instance-in-the-draft-state">Defining <code>Post</code> and Creating a New Instance in the Draft State</a></h3>
<p>Let’s get started on the implementation of the library! We know we need a
public <code>Post</code> struct that holds some content, so we’ll start with the
definition of the struct and an associated public <code>new</code> function to create an
instance of <code>Post</code>, as shown in Listing 17-12. We’ll also make a private
<code>State</code> trait. Then <code>Post</code> will hold a trait object of <code>Box&lt;dyn State&gt;</code>
inside an <code>Option&lt;T&gt;</code> in a private field named <code>state</code>. You’ll see why the
<code>Option&lt;T&gt;</code> is necessary in a bit.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

impl Post {
    pub fn new() -&gt; Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
}

trait State {}

struct Draft {}

impl State for Draft {}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-12: Definition of a <code>Post</code> struct and a <code>new</code>
function that creates a new <code>Post</code> instance, a <code>State</code> trait, and a <code>Draft</code>
struct</span></p>
<p>The <code>State</code> trait defines the behavior shared by different post states, and the
<code>Draft</code>, <code>PendingReview</code>, and <code>Published</code> states will all implement the <code>State</code>
trait. For now, the trait doesn’t have any methods, and we’ll start by defining
just the <code>Draft</code> state because that is the state we want a post to start in.</p>
<p>When we create a new <code>Post</code>, we set its <code>state</code> field to a <code>Some</code> value that
holds a <code>Box</code>. This <code>Box</code> points to a new instance of the <code>Draft</code> struct. This
ensures whenever we create a new instance of <code>Post</code>, it will start out as a
draft. Because the <code>state</code> field of <code>Post</code> is private, there is no way to
create a <code>Post</code> in any other state! In the <code>Post::new</code> function, we set the
<code>content</code> field to a new, empty <code>String</code>.</p>
<h3><a class="header" href="#storing-the-text-of-the-post-content" id="storing-the-text-of-the-post-content">Storing the Text of the Post Content</a></h3>
<p>Listing 17-11 showed that we want to be able to call a method named
<code>add_text</code> and pass it a <code>&amp;str</code> that is then added to the text content of the
blog post. We implement this as a method rather than exposing the <code>content</code>
field as <code>pub</code>. This means we can implement a method later that will control
how the <code>content</code> field’s data is read. The <code>add_text</code> method is pretty
straightforward, so let’s add the implementation in Listing 17-13 to the <code>impl Post</code> block:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-13: Implementing the <code>add_text</code> method to add
text to a post’s <code>content</code></span></p>
<p>The <code>add_text</code> method takes a mutable reference to <code>self</code>, because we’re
changing the <code>Post</code> instance that we’re calling <code>add_text</code> on. We then call
<code>push_str</code> on the <code>String</code> in <code>content</code> and pass the <code>text</code> argument to add to
the saved <code>content</code>. This behavior doesn’t depend on the state the post is in,
so it’s not part of the state pattern. The <code>add_text</code> method doesn’t interact
with the <code>state</code> field at all, but it is part of the behavior we want to
support.</p>
<h3><a class="header" href="#ensuring-the-content-of-a-draft-post-is-empty" id="ensuring-the-content-of-a-draft-post-is-empty">Ensuring the Content of a Draft Post Is Empty</a></h3>
<p>Even after we’ve called <code>add_text</code> and added some content to our post, we still
want the <code>content</code> method to return an empty string slice because the post is
still in the draft state, as shown on line 7 of Listing 17-11. For now, let’s
implement the <code>content</code> method with the simplest thing that will fulfill this
requirement: always returning an empty string slice. We’ll change this later
once we implement the ability to change a post’s state so it can be published.
So far, posts can only be in the draft state, so the post content should always
be empty. Listing 17-14 shows this placeholder implementation:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        &quot;&quot;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-14: Adding a placeholder implementation for
the <code>content</code> method on <code>Post</code> that always returns an empty string slice</span></p>
<p>With this added <code>content</code> method, everything in Listing 17-11 up to line 7
works as intended.</p>
<h3><a class="header" href="#requesting-a-review-of-the-post-changes-its-state" id="requesting-a-review-of-the-post-changes-its-state">Requesting a Review of the Post Changes Its State</a></h3>
<p>Next, we need to add functionality to request a review of a post, which should
change its state from <code>Draft</code> to <code>PendingReview</code>. Listing 17-15 shows this code:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn request_review(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(PendingReview {})
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-15: Implementing <code>request_review</code> methods on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>We give <code>Post</code> a public method named <code>request_review</code> that will take a mutable
reference to <code>self</code>. Then we call an internal <code>request_review</code> method on the
current state of <code>Post</code>, and this second <code>request_review</code> method consumes the
current state and returns a new state.</p>
<p>We’ve added the <code>request_review</code> method to the <code>State</code> trait; all types that
implement the trait will now need to implement the <code>request_review</code> method.
Note that rather than having <code>self</code>, <code>&amp;self</code>, or <code>&amp;mut self</code> as the first
parameter of the method, we have <code>self: Box&lt;Self&gt;</code>. This syntax means the
method is only valid when called on a <code>Box</code> holding the type. This syntax takes
ownership of <code>Box&lt;Self&gt;</code>, invalidating the old state so the state value of the
<code>Post</code> can transform into a new state.</p>
<p>To consume the old state, the <code>request_review</code> method needs to take ownership
of the state value. This is where the <code>Option</code> in the <code>state</code> field of <code>Post</code>
comes in: we call the <code>take</code> method to take the <code>Some</code> value out of the <code>state</code>
field and leave a <code>None</code> in its place, because Rust doesn’t let us have
unpopulated fields in structs. This lets us move the <code>state</code> value out of
<code>Post</code> rather than borrowing it. Then we’ll set the post’s <code>state</code> value to the
result of this operation.</p>
<p>We need to set <code>state</code> to <code>None</code> temporarily rather than setting it directly
with code like <code>self.state = self.state.request_review();</code> to get ownership of
the <code>state</code> value. This ensures <code>Post</code> can’t use the old <code>state</code> value after
we’ve transformed it into a new state.</p>
<p>The <code>request_review</code> method on <code>Draft</code> needs to return a new, boxed instance of
a new <code>PendingReview</code> struct, which represents the state when a post is waiting
for a review. The <code>PendingReview</code> struct also implements the <code>request_review</code>
method but doesn’t do any transformations. Rather, it returns itself, because
when we request a review on a post already in the <code>PendingReview</code> state, it
should stay in the <code>PendingReview</code> state.</p>
<p>Now we can start seeing the advantages of the state pattern: the
<code>request_review</code> method on <code>Post</code> is the same no matter its <code>state</code> value. Each
state is responsible for its own rules.</p>
<p>We’ll leave the <code>content</code> method on <code>Post</code> as is, returning an empty string
slice. We can now have a <code>Post</code> in the <code>PendingReview</code> state as well as in the
<code>Draft</code> state, but we want the same behavior in the <code>PendingReview</code> state.
Listing 17-11 now works up to line 10!</p>
<h3><a class="header" href="#adding-the-approve-method-that-changes-the-behavior-of-content" id="adding-the-approve-method-that-changes-the-behavior-of-content">Adding the <code>approve</code> Method that Changes the Behavior of <code>content</code></a></h3>
<p>The <code>approve</code> method will be similar to the <code>request_review</code> method: it will
set <code>state</code> to the value that the current state says it should have when that
state is approved, as shown in Listing 17-16:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
}

struct Draft {}

impl State for Draft {
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        Box::new(PendingReview {})
</span><span class="boring">    }
</span><span class="boring">
</span>    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
<span class="boring">    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
</span><span class="boring">        self
</span><span class="boring">    }
</span><span class="boring">
</span>    // --snip--
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }

    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
        self
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-16: Implementing the <code>approve</code> method on
<code>Post</code> and the <code>State</code> trait</span></p>
<p>We add the <code>approve</code> method to the <code>State</code> trait and add a new struct that
implements <code>State</code>, the <code>Published</code> state.</p>
<p>Similar to <code>request_review</code>, if we call the <code>approve</code> method on a <code>Draft</code>, it
will have no effect because it will return <code>self</code>. When we call <code>approve</code> on
<code>PendingReview</code>, it returns a new, boxed instance of the <code>Published</code> struct.
The <code>Published</code> struct implements the <code>State</code> trait, and for both the
<code>request_review</code> method and the <code>approve</code> method, it returns itself, because
the post should stay in the <code>Published</code> state in those cases.</p>
<p>Now we need to update the <code>content</code> method on <code>Post</code>: if the state is
<code>Published</code>, we want to return the value in the post’s <code>content</code> field;
otherwise, we want to return an empty string slice, as shown in Listing 17-17:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait State {
</span><span class="boring">    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str;
</span><span class="boring">}
</span><span class="boring">pub struct Post {
</span><span class="boring">    state: Option&lt;Box&lt;dyn State&gt;&gt;,
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Post {
    // --snip--
    pub fn content(&amp;self) -&gt; &amp;str {
        self.state.as_ref().unwrap().content(&amp;self)
    }
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-17: Updating the <code>content</code> method on <code>Post</code> to
delegate to a <code>content</code> method on <code>State</code></span></p>
<p>Because the goal is to keep all these rules inside the structs that implement
<code>State</code>, we call a <code>content</code> method on the value in <code>state</code> and pass the post
instance (that is, <code>self</code>) as an argument. Then we return the value that is
returned from using the <code>content</code> method on the <code>state</code> value.</p>
<p>We call the <code>as_ref</code> method on the <code>Option</code> because we want a reference to the
value inside the <code>Option</code> rather than ownership of the value. Because <code>state</code>
is an <code>Option&lt;Box&lt;dyn State&gt;&gt;</code>, when we call <code>as_ref</code>, an <code>Option&lt;&amp;Box&lt;dyn State&gt;&gt;</code> is
returned. If we didn’t call <code>as_ref</code>, we would get an error because we can’t
move <code>state</code> out of the borrowed <code>&amp;self</code> of the function parameter.</p>
<p>We then call the <code>unwrap</code> method, which we know will never panic, because we
know the methods on <code>Post</code> ensure that <code>state</code> will always contain a <code>Some</code>
value when those methods are done. This is one of the cases we talked about in
the <a href="rustbook/ch09-03-to-panic-or-not-to-panic.html#cases-in-which-you-have-more-information-than-the-compiler">“Cases In Which You Have More Information Than the
Compiler”</a><!-- ignore --> section of Chapter 9 when we
know that a <code>None</code> value is never possible, even though the compiler isn’t able
to understand that.</p>
<p>At this point, when we call <code>content</code> on the <code>&amp;Box&lt;dyn State&gt;</code>, deref coercion will
take effect on the <code>&amp;</code> and the <code>Box</code> so the <code>content</code> method will ultimately be
called on the type that implements the <code>State</code> trait. That means we need to add
<code>content</code> to the <code>State</code> trait definition, and that is where we’ll put the
logic for what content to return depending on which state we have, as shown in
Listing 17-18:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String
</span><span class="boring">}
</span>trait State {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &quot;&quot;
    }
}

// --snip--
struct Published {}

impl State for Published {
    // --snip--
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; &amp;'a str {
        &amp;post.content
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-18: Adding the <code>content</code> method to the <code>State</code>
trait</span></p>
<p>We add a default implementation for the <code>content</code> method that returns an empty
string slice. That means we don’t need to implement <code>content</code> on the <code>Draft</code>
and <code>PendingReview</code> structs. The <code>Published</code> struct will override the <code>content</code>
method and return the value in <code>post.content</code>.</p>
<p>Note that we need lifetime annotations on this method, as we discussed in
Chapter 10. We’re taking a reference to a <code>post</code> as an argument and returning a
reference to part of that <code>post</code>, so the lifetime of the returned reference is
related to the lifetime of the <code>post</code> argument.</p>
<p>And we’re done—all of Listing 17-11 now works! We’ve implemented the state
pattern with the rules of the blog post workflow. The logic related to the
rules lives in the state objects rather than being scattered throughout <code>Post</code>.</p>
<h3><a class="header" href="#trade-offs-of-the-state-pattern" id="trade-offs-of-the-state-pattern">Trade-offs of the State Pattern</a></h3>
<p>We’ve shown that Rust is capable of implementing the object-oriented state
pattern to encapsulate the different kinds of behavior a post should have in
each state. The methods on <code>Post</code> know nothing about the various behaviors. The
way we organized the code, we have to look in only one place to know the
different ways a published post can behave: the implementation of the <code>State</code>
trait on the <code>Published</code> struct.</p>
<p>If we were to create an alternative implementation that didn’t use the state
pattern, we might instead use <code>match</code> expressions in the methods on <code>Post</code> or
even in the <code>main</code> code that checks the state of the post and changes behavior
in those places. That would mean we would have to look in several places to
understand all the implications of a post being in the published state! This
would only increase the more states we added: each of those <code>match</code> expressions
would need another arm.</p>
<p>With the state pattern, the <code>Post</code> methods and the places we use <code>Post</code> don’t
need <code>match</code> expressions, and to add a new state, we would only need to add a
new struct and implement the trait methods on that one struct.</p>
<p>The implementation using the state pattern is easy to extend to add more
functionality. To see the simplicity of maintaining code that uses the state
pattern, try a few of these suggestions:</p>
<ul>
<li>Add a <code>reject</code> method that changes the post’s state from <code>PendingReview</code> back
to <code>Draft</code>.</li>
<li>Require two calls to <code>approve</code> before the state can be changed to <code>Published</code>.</li>
<li>Allow users to add text content only when a post is in the <code>Draft</code> state.
Hint: have the state object responsible for what might change about the
content but not responsible for modifying the <code>Post</code>.</li>
</ul>
<p>One downside of the state pattern is that, because the states implement the
transitions between states, some of the states are coupled to each other. If we
add another state between <code>PendingReview</code> and <code>Published</code>, such as <code>Scheduled</code>,
we would have to change the code in <code>PendingReview</code> to transition to
<code>Scheduled</code> instead. It would be less work if <code>PendingReview</code> didn’t need to
change with the addition of a new state, but that would mean switching to
another design pattern.</p>
<p>Another downside is that we’ve duplicated some logic. To eliminate some of the
duplication, we might try to make default implementations for the
<code>request_review</code> and <code>approve</code> methods on the <code>State</code> trait that return <code>self</code>;
however, this would violate object safety, because the trait doesn’t know what
the concrete <code>self</code> will be exactly. We want to be able to use <code>State</code> as a
trait object, so we need its methods to be object safe.</p>
<p>Other duplication includes the similar implementations of the <code>request_review</code>
and <code>approve</code> methods on <code>Post</code>. Both methods delegate to the implementation of
the same method on the value in the <code>state</code> field of <code>Option</code> and set the new
value of the <code>state</code> field to the result. If we had a lot of methods on <code>Post</code>
that followed this pattern, we might consider defining a macro to eliminate the
repetition (see the <a href="rustbook/ch19-06-macros.html#macros">“Macros”</a><!-- ignore --> section in Chapter 19).</p>
<p>By implementing the state pattern exactly as it’s defined for object-oriented
languages, we’re not taking as full advantage of Rust’s strengths as we could.
Let’s look at some changes we can make to the <code>blog</code> crate that can make
invalid states and transitions into compile time errors.</p>
<h4><a class="header" href="#encoding-states-and-behavior-as-types" id="encoding-states-and-behavior-as-types">Encoding States and Behavior as Types</a></h4>
<p>We’ll show you how to rethink the state pattern to get a different set of
trade-offs. Rather than encapsulating the states and transitions completely so
outside code has no knowledge of them, we’ll encode the states into different
types. Consequently, Rust’s type checking system will prevent attempts to use
draft posts where only published posts are allowed by issuing a compiler error.</p>
<p>Let’s consider the first part of <code>main</code> in Listing 17-11:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore"><span class="boring">use blog::Post;
</span>
fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);
    assert_eq!(&quot;&quot;, post.content());
}
</code></pre>
<p>We still enable the creation of new posts in the draft state using <code>Post::new</code>
and the ability to add text to the post’s content. But instead of having a
<code>content</code> method on a draft post that returns an empty string, we’ll make it so
draft posts don’t have the <code>content</code> method at all. That way, if we try to get
a draft post’s content, we’ll get a compiler error telling us the method
doesn’t exist. As a result, it will be impossible for us to accidentally
display draft post content in production, because that code won’t even compile.
Listing 17-19 shows the definition of a <code>Post</code> struct and a <code>DraftPost</code> struct,
as well as methods on each:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Post {
    content: String,
}

pub struct DraftPost {
    content: String,
}

impl Post {
    pub fn new() -&gt; DraftPost {
        DraftPost {
            content: String::new(),
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        &amp;self.content
    }
}

impl DraftPost {
    pub fn add_text(&amp;mut self, text: &amp;str) {
        self.content.push_str(text);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-19: A <code>Post</code> with a <code>content</code> method and a
<code>DraftPost</code> without a <code>content</code> method</span></p>
<p>Both the <code>Post</code> and <code>DraftPost</code> structs have a private <code>content</code> field that
stores the blog post text. The structs no longer have the <code>state</code> field because
we’re moving the encoding of the state to the types of the structs. The <code>Post</code>
struct will represent a published post, and it has a <code>content</code> method that
returns the <code>content</code>.</p>
<p>We still have a <code>Post::new</code> function, but instead of returning an instance of
<code>Post</code>, it returns an instance of <code>DraftPost</code>. Because <code>content</code> is private
and there aren’t any functions that return <code>Post</code>, it’s not possible to create
an instance of <code>Post</code> right now.</p>
<p>The <code>DraftPost</code> struct has an <code>add_text</code> method, so we can add text to
<code>content</code> as before, but note that <code>DraftPost</code> does not have a <code>content</code> method
defined! So now the program ensures all posts start as draft posts, and draft
posts don’t have their content available for display. Any attempt to get around
these constraints will result in a compiler error.</p>
<h4><a class="header" href="#implementing-transitions-as-transformations-into-different-types" id="implementing-transitions-as-transformations-into-different-types">Implementing Transitions as Transformations into Different Types</a></h4>
<p>So how do we get a published post? We want to enforce the rule that a draft
post has to be reviewed and approved before it can be published. A post in the
pending review state should still not display any content. Let’s implement
these constraints by adding another struct, <code>PendingReviewPost</code>, defining the
<code>request_review</code> method on <code>DraftPost</code> to return a <code>PendingReviewPost</code>, and
defining an <code>approve</code> method on <code>PendingReviewPost</code> to return a <code>Post</code>, as
shown in Listing 17-20:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Post {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct DraftPost {
</span><span class="boring">    content: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl DraftPost {
    // --snip--

    pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}

pub struct PendingReviewPost {
    content: String,
}

impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 17-20: A <code>PendingReviewPost</code> that gets created by
calling <code>request_review</code> on <code>DraftPost</code> and an <code>approve</code> method that turns a
<code>PendingReviewPost</code> into a published <code>Post</code></span></p>
<p>The <code>request_review</code> and <code>approve</code> methods take ownership of <code>self</code>, thus
consuming the <code>DraftPost</code> and <code>PendingReviewPost</code> instances and transforming
them into a <code>PendingReviewPost</code> and a published <code>Post</code>, respectively. This way,
we won’t have any lingering <code>DraftPost</code> instances after we’ve called
<code>request_review</code> on them, and so forth. The <code>PendingReviewPost</code> struct doesn’t
have a <code>content</code> method defined on it, so attempting to read its content
results in a compiler error, as with <code>DraftPost</code>. Because the only way to get a
published <code>Post</code> instance that does have a <code>content</code> method defined is to call
the <code>approve</code> method on a <code>PendingReviewPost</code>, and the only way to get a
<code>PendingReviewPost</code> is to call the <code>request_review</code> method on a <code>DraftPost</code>,
we’ve now encoded the blog post workflow into the type system.</p>
<p>But we also have to make some small changes to <code>main</code>. The <code>request_review</code> and
<code>approve</code> methods return new instances rather than modifying the struct they’re
called on, so we need to add more <code>let post =</code> shadowing assignments to save
the returned instances. We also can’t have the assertions about the draft and
pending review post’s contents be empty strings, nor do we need them: we can’t
compile code that tries to use the content of posts in those states any longer.
The updated code in <code>main</code> is shown in Listing 17-21:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use blog::Post;

fn main() {
    let mut post = Post::new();

    post.add_text(&quot;I ate a salad for lunch today&quot;);

    let post = post.request_review();

    let post = post.approve();

    assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());
}
</code></pre>
<p><span class="caption">Listing 17-21: Modifications to <code>main</code> to use the new
implementation of the blog post workflow</span></p>
<p>The changes we needed to make to <code>main</code> to reassign <code>post</code> mean that this
implementation doesn’t quite follow the object-oriented state pattern anymore:
the transformations between the states are no longer encapsulated entirely
within the <code>Post</code> implementation. However, our gain is that invalid states are
now impossible because of the type system and the type checking that happens at
compile time! This ensures that certain bugs, such as display of the content of
an unpublished post, will be discovered before they make it to production.</p>
<p>Try the tasks suggested for additional requirements that we mentioned at the
start of this section on the <code>blog</code> crate as it is after Listing 17-20 to see
what you think about the design of this version of the code. Note that some of
the tasks might be completed already in this design.</p>
<p>We’ve seen that even though Rust is capable of implementing object-oriented
design patterns, other patterns, such as encoding state into the type system,
are also available in Rust. These patterns have different trade-offs. Although
you might be very familiar with object-oriented patterns, rethinking the
problem to take advantage of Rust’s features can provide benefits, such as
preventing some bugs at compile time. Object-oriented patterns won’t always be
the best solution in Rust due to certain features, like ownership, that
object-oriented languages don’t have.</p>
<h2><a class="header" href="#summary-16" id="summary-16">Summary</a></h2>
<p>No matter whether or not you think Rust is an object-oriented language after
reading this chapter, you now know that you can use trait objects to get some
object-oriented features in Rust. Dynamic dispatch can give your code some
flexibility in exchange for a bit of runtime performance. You can use this
flexibility to implement object-oriented patterns that can help your code’s
maintainability. Rust also has other features, like ownership, that
object-oriented languages don’t have. An object-oriented pattern won’t always
be the best way to take advantage of Rust’s strengths, but is an available
option.</p>
<p>Next, we’ll look at patterns, which are another of Rust’s features that enable
lots of flexibility. We’ve looked at them briefly throughout the book but
haven’t seen their full capability yet. Let’s go!</p>
<h1><a class="header" href="#patterns-and-matching" id="patterns-and-matching">Patterns and Matching</a></h1>
<p>Patterns are a special syntax in Rust for matching against the structure of
types, both complex and simple. Using patterns in conjunction with <code>match</code>
expressions and other constructs gives you more control over a program’s
control flow. A pattern consists of some combination of the following:</p>
<ul>
<li>Literals</li>
<li>Destructured arrays, enums, structs, or tuples</li>
<li>Variables</li>
<li>Wildcards</li>
<li>Placeholders</li>
</ul>
<p>These components describe the shape of the data we’re working with, which we
then match against values to determine whether our program has the correct data
to continue running a particular piece of code.</p>
<p>To use a pattern, we compare it to some value. If the pattern matches the
value, we use the value parts in our code. Recall the <code>match</code> expressions in
Chapter 6 that used patterns, such as the coin-sorting machine example. If the
value fits the shape of the pattern, we can use the named pieces. If it
doesn’t, the code associated with the pattern won’t run.</p>
<p>This chapter is a reference on all things related to patterns. We’ll cover the
valid places to use patterns, the difference between refutable and irrefutable
patterns, and the different kinds of pattern syntax that you might see. By the
end of the chapter, you’ll know how to use patterns to express many concepts in
a clear way.</p>
<h2><a class="header" href="#all-the-places-patterns-can-be-used" id="all-the-places-patterns-can-be-used">All the Places Patterns Can Be Used</a></h2>
<p>Patterns pop up in a number of places in Rust, and you’ve been using them a lot
without realizing it! This section discusses all the places where patterns are
valid.</p>
<h3><a class="header" href="#match-arms" id="match-arms"><code>match</code> Arms</a></h3>
<p>As discussed in Chapter 6, we use patterns in the arms of <code>match</code> expressions.
Formally, <code>match</code> expressions are defined as the keyword <code>match</code>, a value to
match on, and one or more match arms that consist of a pattern and an
expression to run if the value matches that arm’s pattern, like this:</p>
<pre><code class="language-text">match VALUE {
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
    PATTERN =&gt; EXPRESSION,
}
</code></pre>
<p>One requirement for <code>match</code> expressions is that they need to be <em>exhaustive</em> in
the sense that all possibilities for the value in the <code>match</code> expression must
be accounted for. One way to ensure you’ve covered every possibility is to have
a catchall pattern for the last arm: for example, a variable name matching any
value can never fail and thus covers every remaining case.</p>
<p>A particular pattern <code>_</code> will match anything, but it never binds to a variable,
so it’s often used in the last match arm. The <code>_</code> pattern can be useful when
you want to ignore any value not specified, for example. We’ll cover the <code>_</code>
pattern in more detail in the <a href="rustbook/ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Ignoring Values in a
Pattern”</a><!-- ignore --> section later in this
chapter.</p>
<h3><a class="header" href="#conditional-if-let-expressions" id="conditional-if-let-expressions">Conditional <code>if let</code> Expressions</a></h3>
<p>In Chapter 6 we discussed how to use <code>if let</code> expressions mainly as a shorter
way to write the equivalent of a <code>match</code> that only matches one case.
Optionally, <code>if let</code> can have a corresponding <code>else</code> containing code to run if
the pattern in the <code>if let</code> doesn’t match.</p>
<p>Listing 18-1 shows that it’s also possible to mix and match <code>if let</code>, <code>else if</code>, and <code>else if let</code> expressions. Doing so gives us more flexibility than a
<code>match</code> expression in which we can express only one value to compare with the
patterns. Also, the conditions in a series of <code>if let</code>, <code>else if</code>, <code>else if let</code> arms aren’t required to relate to each other.</p>
<p>The code in Listing 18-1 shows a series of checks for several conditions that
decide what the background color should be. For this example, we’ve created
variables with hardcoded values that a real program might receive from user
input.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let favorite_color: Option&lt;&amp;str&gt; = None;
    let is_tuesday = false;
    let age: Result&lt;u8, _&gt; = &quot;34&quot;.parse();

    if let Some(color) = favorite_color {
        println!(&quot;Using your favorite color, {}, as the background&quot;, color);
    } else if is_tuesday {
        println!(&quot;Tuesday is green day!&quot;);
    } else if let Ok(age) = age {
        if age &gt; 30 {
            println!(&quot;Using purple as the background color&quot;);
        } else {
            println!(&quot;Using orange as the background color&quot;);
        }
    } else {
        println!(&quot;Using blue as the background color&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-1: Mixing <code>if let</code>, <code>else if</code>, <code>else if let</code>,
and <code>else</code></span></p>
<p>If the user specifies a favorite color, that color is the background color. If
today is Tuesday, the background color is green. If the user specifies
their age as a string and we can parse it as a number successfully, the color
is either purple or orange depending on the value of the number. If none of
these conditions apply, the background color is blue.</p>
<p>This conditional structure lets us support complex requirements. With the
hardcoded values we have here, this example will print <code>Using purple as the background color</code>.</p>
<p>You can see that <code>if let</code> can also introduce shadowed variables in the same way
that <code>match</code> arms can: the line <code>if let Ok(age) = age</code> introduces a new
shadowed <code>age</code> variable that contains the value inside the <code>Ok</code> variant. This
means we need to place the <code>if age &gt; 30</code> condition within that block: we can’t
combine these two conditions into <code>if let Ok(age) = age &amp;&amp; age &gt; 30</code>. The
shadowed <code>age</code> we want to compare to 30 isn’t valid until the new scope starts
with the curly bracket.</p>
<p>The downside of using <code>if let</code> expressions is that the compiler doesn’t check
exhaustiveness, whereas with <code>match</code> expressions it does. If we omitted the
last <code>else</code> block and therefore missed handling some cases, the compiler would
not alert us to the possible logic bug.</p>
<h3><a class="header" href="#while-let-conditional-loops" id="while-let-conditional-loops"><code>while let</code> Conditional Loops</a></h3>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows a
<code>while</code> loop to run for as long as a pattern continues to match. The example in
Listing 18-2 shows a <code>while let</code> loop that uses a vector as a stack and prints
the values in the vector in the opposite order in which they were pushed.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut stack = Vec::new();

stack.push(1);
stack.push(2);
stack.push(3);

while let Some(top) = stack.pop() {
    println!(&quot;{}&quot;, top);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-2: Using a <code>while let</code> loop to print values
for as long as <code>stack.pop()</code> returns <code>Some</code></span></p>
<p>This example prints 3, 2, and then 1. The <code>pop</code> method takes the last element
out of the vector and returns <code>Some(value)</code>. If the vector is empty, <code>pop</code>
returns <code>None</code>. The <code>while</code> loop continues running the code in its block as
long as <code>pop</code> returns <code>Some</code>. When <code>pop</code> returns <code>None</code>, the loop stops. We can
use <code>while let</code> to pop every element off our stack.</p>
<h3><a class="header" href="#for-loops-1" id="for-loops-1"><code>for</code> Loops</a></h3>
<p>In Chapter 3, we mentioned that the <code>for</code> loop is the most common loop
construction in Rust code, but we haven’t yet discussed the pattern that <code>for</code>
takes. In a <code>for</code> loop, the pattern is the value that directly follows the
keyword <code>for</code>, so in <code>for x in y</code> the <code>x</code> is the pattern.</p>
<p>Listing 18-3 demonstrates how to use a pattern in a <code>for</code> loop to destructure,
or break apart, a tuple as part of the <code>for</code> loop.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = vec!['a', 'b', 'c'];

for (index, value) in v.iter().enumerate() {
    println!(&quot;{} is at index {}&quot;, value, index);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-3: Using a pattern in a <code>for</code> loop to
destructure a tuple</span></p>
<p>The code in Listing 18-3 will print the following:</p>
<pre><code class="language-text">a is at index 0
b is at index 1
c is at index 2
</code></pre>
<p>We use the <code>enumerate</code> method to adapt an iterator to produce a value and that
value’s index in the iterator, placed into a tuple. The first call to
<code>enumerate</code> produces the tuple <code>(0, 'a')</code>. When this value is matched to the
pattern <code>(index, value)</code>, <code>index</code> will be <code>0</code> and <code>value</code> will be <code>'a'</code>,
printing the first line of the output.</p>
<h3><a class="header" href="#let-statements" id="let-statements"><code>let</code> Statements</a></h3>
<p>Prior to this chapter, we had only explicitly discussed using patterns with
<code>match</code> and <code>if let</code>, but in fact, we’ve used patterns in other places as well,
including in <code>let</code> statements. For example, consider this straightforward
variable assignment with <code>let</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>Throughout this book, we’ve used <code>let</code> like this hundreds of times, and
although you might not have realized it, you were using patterns! More
formally, a <code>let</code> statement looks like this:</p>
<pre><code class="language-text">let PATTERN = EXPRESSION;
</code></pre>
<p>In statements like <code>let x = 5;</code> with a variable name in the <code>PATTERN</code> slot, the
variable name is just a particularly simple form of a pattern. Rust compares
the expression against the pattern and assigns any names it finds. So in the
<code>let x = 5;</code> example, <code>x</code> is a pattern that means “bind what matches here to
the variable <code>x</code>.” Because the name <code>x</code> is the whole pattern, this pattern
effectively means “bind everything to the variable <code>x</code>, whatever the value is.”</p>
<p>To see the pattern matching aspect of <code>let</code> more clearly, consider Listing
18-4, which uses a pattern with <code>let</code> to destructure a tuple.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let (x, y, z) = (1, 2, 3);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-4: Using a pattern to destructure a tuple and
create three variables at once</span></p>
<p>Here, we match a tuple against a pattern. Rust compares the value <code>(1, 2, 3)</code>
to the pattern <code>(x, y, z)</code> and sees that the value matches the pattern, so Rust
binds <code>1</code> to <code>x</code>, <code>2</code> to <code>y</code>, and <code>3</code> to <code>z</code>. You can think of this tuple
pattern as nesting three individual variable patterns inside it.</p>
<p>If the number of elements in the pattern doesn’t match the number of elements
in the tuple, the overall type won’t match and we’ll get a compiler error. For
example, Listing 18-5 shows an attempt to destructure a tuple with three
elements into two variables, which won’t work.</p>
<pre><code class="language-rust ignore does_not_compile">let (x, y) = (1, 2, 3);
</code></pre>
<p><span class="caption">Listing 18-5: Incorrectly constructing a pattern whose
variables don’t match the number of elements in the tuple</span></p>
<p>Attempting to compile this code results in this type error:</p>
<pre><code class="language-text">error[E0308]: mismatched types
 --&gt; src/main.rs:2:9
  |
2 |     let (x, y) = (1, 2, 3);
  |         ^^^^^^ expected a tuple with 3 elements, found one with 2 elements
  |
  = note: expected type `({integer}, {integer}, {integer})`
             found type `(_, _)`
</code></pre>
<p>If we wanted to ignore one or more of the values in the tuple, we could use <code>_</code>
or <code>..</code>, as you’ll see in the <a href="rustbook/ch18-03-pattern-syntax.html#ignoring-values-in-a-pattern">“Ignoring Values in a
Pattern”</a><!-- ignore --> section. If the problem
is that we have too many variables in the pattern, the solution is to make the
types match by removing variables so the number of variables equals the number
of elements in the tuple.</p>
<h3><a class="header" href="#function-parameters-1" id="function-parameters-1">Function Parameters</a></h3>
<p>Function parameters can also be patterns. The code in Listing 18-6, which
declares a function named <code>foo</code> that takes one parameter named <code>x</code> of type
<code>i32</code>, should by now look familiar.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo(x: i32) {
    // code goes here
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-6: A function signature uses patterns in the
parameters</span></p>
<p>The <code>x</code> part is a pattern! As we did with <code>let</code>, we could match a tuple in a
function’s arguments to the pattern. Listing 18-7 splits the values in a tuple
as we pass it to a function.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<p><span class="caption">Listing 18-7: A function with parameters that destructure
a tuple</span></p>
<p>This code prints <code>Current location: (3, 5)</code>. The values <code>&amp;(3, 5)</code> match the
pattern <code>&amp;(x, y)</code>, so <code>x</code> is the value <code>3</code> and <code>y</code> is the value <code>5</code>.</p>
<p>We can also use patterns in closure parameter lists in the same way as in
function parameter lists, because closures are similar to functions, as
discussed in Chapter 13.</p>
<p>At this point, you’ve seen several ways of using patterns, but patterns don’t
work the same in every place we can use them. In some places, the patterns must
be irrefutable; in other circumstances, they can be refutable. We’ll discuss
these two concepts next.</p>
<h2><a class="header" href="#refutability-whether-a-pattern-might-fail-to-match" id="refutability-whether-a-pattern-might-fail-to-match">Refutability: Whether a Pattern Might Fail to Match</a></h2>
<p>Patterns come in two forms: refutable and irrefutable. Patterns that will match
for any possible value passed are <em>irrefutable</em>. An example would be <code>x</code> in the
statement <code>let x = 5;</code> because <code>x</code> matches anything and therefore cannot fail
to match. Patterns that can fail to match for some possible value are
<em>refutable</em>. An example would be <code>Some(x)</code> in the expression <code>if let Some(x) = a_value</code> because if the value in the <code>a_value</code> variable is <code>None</code> rather than
<code>Some</code>, the <code>Some(x)</code> pattern will not match.</p>
<p>Function parameters, <code>let</code> statements, and <code>for</code> loops can only accept
irrefutable patterns, because the program cannot do anything meaningful when
values don’t match. The <code>if let</code> and <code>while let</code> expressions only accept
refutable patterns, because by definition they’re intended to handle possible
failure: the functionality of a conditional is in its ability to perform
differently depending on success or failure.</p>
<p>In general, you shouldn’t have to worry about the distinction between refutable
and irrefutable patterns; however, you do need to be familiar with the concept
of refutability so you can respond when you see it in an error message. In
those cases, you’ll need to change either the pattern or the construct you’re
using the pattern with, depending on the intended behavior of the code.</p>
<p>Let’s look at an example of what happens when we try to use a refutable pattern
where Rust requires an irrefutable pattern and vice versa. Listing 18-8 shows a
<code>let</code> statement, but for the pattern we’ve specified <code>Some(x)</code>, a refutable
pattern. As you might expect, this code will not compile.</p>
<pre><code class="language-rust ignore does_not_compile">let Some(x) = some_option_value;
</code></pre>
<p><span class="caption">Listing 18-8: Attempting to use a refutable pattern with
<code>let</code></span></p>
<p>If <code>some_option_value</code> was a <code>None</code> value, it would fail to match the pattern
<code>Some(x)</code>, meaning the pattern is refutable. However, the <code>let</code> statement can
only accept an irrefutable pattern because there is nothing valid the code can
do with a <code>None</code> value. At compile time, Rust will complain that we’ve tried to
use a refutable pattern where an irrefutable pattern is required:</p>
<pre><code class="language-text">error[E0005]: refutable pattern in local binding: `None` not covered
 --&gt;
  |
3 | let Some(x) = some_option_value;
  |     ^^^^^^^ pattern `None` not covered
</code></pre>
<p>Because we didn’t cover (and couldn’t cover!) every valid value with the
pattern <code>Some(x)</code>, Rust rightfully produces a compiler error.</p>
<p>To fix the problem where we have a refutable pattern where an irrefutable
pattern is needed, we can change the code that uses the pattern: instead of
using <code>let</code>, we can use <code>if let</code>. Then if the pattern doesn’t match, the code
will just skip the code in the curly brackets, giving it a way to continue
validly. Listing 18-9 shows how to fix the code in Listing 18-8.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_option_value: Option&lt;i32&gt; = None;
</span>if let Some(x) = some_option_value {
    println!(&quot;{}&quot;, x);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-9: Using <code>if let</code> and a block with refutable
patterns instead of <code>let</code></span></p>
<p>We’ve given the code an out! This code is perfectly valid, although it means we
cannot use an irrefutable pattern without receiving an error. If we give <code>if let</code> a pattern that will always match, such as <code>x</code>, as shown in Listing 18-10,
it will not compile.</p>
<pre><code class="language-rust ignore does_not_compile">if let x = 5 {
    println!(&quot;{}&quot;, x);
};
</code></pre>
<p><span class="caption">Listing 18-10: Attempting to use an irrefutable pattern
with <code>if let</code></span></p>
<p>Rust complains that it doesn’t make sense to use <code>if let</code> with an irrefutable
pattern:</p>
<pre><code class="language-text">error[E0162]: irrefutable if-let pattern
 --&gt; &lt;anon&gt;:2:8
  |
2 | if let x = 5 {
  |        ^ irrefutable pattern
</code></pre>
<p>For this reason, match arms must use refutable patterns, except for the last
arm, which should match any remaining values with an irrefutable pattern. Rust
allows us to use an irrefutable pattern in a <code>match</code> with only one arm, but
this syntax isn’t particularly useful and could be replaced with a simpler
<code>let</code> statement.</p>
<p>Now that you know where to use patterns and the difference between refutable
and irrefutable patterns, let’s cover all the syntax we can use to create
patterns.</p>
<h2><a class="header" href="#pattern-syntax" id="pattern-syntax">Pattern Syntax</a></h2>
<p>Throughout the book, you’ve seen examples of many kinds of patterns. In this
section, we gather all the syntax valid in patterns and discuss why you might
want to use each one.</p>
<h3><a class="header" href="#matching-literals" id="matching-literals">Matching Literals</a></h3>
<p>As you saw in Chapter 6, you can match patterns against literals directly. The
following code gives some examples:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 =&gt; println!(&quot;one&quot;),
    2 =&gt; println!(&quot;two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>This code prints <code>one</code> because the value in <code>x</code> is 1. This syntax is useful
when you want your code to take an action if it gets a particular concrete
value.</p>
<h3><a class="header" href="#matching-named-variables" id="matching-named-variables">Matching Named Variables</a></h3>
<p>Named variables are irrefutable patterns that match any value, and we’ve used
them many times in the book. However, there is a complication when you use
named variables in <code>match</code> expressions. Because <code>match</code> starts a new scope,
variables declared as part of a pattern inside the <code>match</code> expression will
shadow those with the same name outside the <code>match</code> construct, as is the case
with all variables. In Listing 18-11, we declare a variable named <code>x</code> with the
value <code>Some(5)</code> and a variable <code>y</code> with the value <code>10</code>. We then create a
<code>match</code> expression on the value <code>x</code>. Look at the patterns in the match arms and
<code>println!</code> at the end, and try to figure out what the code will print before
running this code or reading further.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(y) =&gt; println!(&quot;Matched, y = {:?}&quot;, y),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-11: A <code>match</code> expression with an arm that
introduces a shadowed variable <code>y</code></span></p>
<p>Let’s walk through what happens when the <code>match</code> expression runs. The pattern
in the first match arm doesn’t match the defined value of <code>x</code>, so the code
continues.</p>
<p>The pattern in the second match arm introduces a new variable named <code>y</code> that
will match any value inside a <code>Some</code> value. Because we’re in a new scope inside
the <code>match</code> expression, this is a new <code>y</code> variable, not the <code>y</code> we declared at
the beginning with the value 10. This new <code>y</code> binding will match any value
inside a <code>Some</code>, which is what we have in <code>x</code>. Therefore, this new <code>y</code> binds to
the inner value of the <code>Some</code> in <code>x</code>. That value is <code>5</code>, so the expression for
that arm executes and prints <code>Matched, y = 5</code>.</p>
<p>If <code>x</code> had been a <code>None</code> value instead of <code>Some(5)</code>, the patterns in the first
two arms wouldn’t have matched, so the value would have matched to the
underscore. We didn’t introduce the <code>x</code> variable in the pattern of the
underscore arm, so the <code>x</code> in the expression is still the outer <code>x</code> that hasn’t
been shadowed. In this hypothetical case, the <code>match</code> would print <code>Default case, x = None</code>.</p>
<p>When the <code>match</code> expression is done, its scope ends, and so does the scope of
the inner <code>y</code>. The last <code>println!</code> produces <code>at the end: x = Some(5), y = 10</code>.</p>
<p>To create a <code>match</code> expression that compares the values of the outer <code>x</code> and
<code>y</code>, rather than introducing a shadowed variable, we would need to use a match
guard conditional instead. We’ll talk about match guards later in the <a href="rustbook/ch18-03-pattern-syntax.html#extra-conditionals-with-match-guards">“Extra
Conditionals with Match Guards”</a><!--
ignore --> section.</p>
<h3><a class="header" href="#multiple-patterns" id="multiple-patterns">Multiple Patterns</a></h3>
<p>In <code>match</code> expressions, you can match multiple patterns using the <code>|</code> syntax,
which means <em>or</em>. For example, the following code matches the value of <code>x</code>
against the match arms, the first of which has an <em>or</em> option, meaning if the
value of <code>x</code> matches either of the values in that arm, that arm’s code will
run:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 1;

match x {
    1 | 2 =&gt; println!(&quot;one or two&quot;),
    3 =&gt; println!(&quot;three&quot;),
    _ =&gt; println!(&quot;anything&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>This code prints <code>one or two</code>.</p>
<h3><a class="header" href="#matching-ranges-of-values-with-" id="matching-ranges-of-values-with-">Matching Ranges of Values with <code>...</code></a></h3>
<p>The <code>...</code> syntax allows us to match to an inclusive range of values. In the
following code, when a pattern matches any of the values within the range, that
arm will execute:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;

match x {
    1...5 =&gt; println!(&quot;one through five&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>If <code>x</code> is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more
convenient than using the <code>|</code> operator to express the same idea; instead of
<code>1...5</code>, we would have to specify <code>1 | 2 | 3 | 4 | 5</code> if we used <code>|</code>.
Specifying a range is much shorter, especially if we want to match, say, any
number between 1 and 1,000!</p>
<p>Ranges are only allowed with numeric values or <code>char</code> values, because the
compiler checks that the range isn’t empty at compile time. The only types for
which Rust can tell if a range is empty or not are <code>char</code> and numeric values.</p>
<p>Here is an example using ranges of <code>char</code> values:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 'c';

match x {
    'a'...'j' =&gt; println!(&quot;early ASCII letter&quot;),
    'k'...'z' =&gt; println!(&quot;late ASCII letter&quot;),
    _ =&gt; println!(&quot;something else&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p>Rust can tell that <code>c</code> is within the first pattern’s range and prints <code>early ASCII letter</code>.</p>
<h3><a class="header" href="#destructuring-to-break-apart-values" id="destructuring-to-break-apart-values">Destructuring to Break Apart Values</a></h3>
<p>We can also use patterns to destructure structs, enums, tuples, and references
to use different parts of these values. Let’s walk through each value.</p>
<h4><a class="header" href="#destructuring-structs" id="destructuring-structs">Destructuring Structs</a></h4>
<p>Listing 18-12 shows a <code>Point</code> struct with two fields, <code>x</code> and <code>y</code>, that we can
break apart using a pattern with a <code>let</code> statement.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x: a, y: b } = p;
    assert_eq!(0, a);
    assert_eq!(7, b);
}
</code></pre></pre>
<p><span class="caption">Listing 18-12: Destructuring a struct’s fields into
separate variables</span></p>
<p>This code creates the variables <code>a</code> and <code>b</code> that match the values of the <code>x</code>
and <code>y</code> fields of the <code>p</code> struct. This example shows that the names of the
variables in the pattern don’t have to match the field names of the struct. But
it’s common to want the variable names to match the field names to make it
easier to remember which variables came from which fields.</p>
<p>Because having variable names match the fields is common and because writing
<code>let Point { x: x, y: y } = p;</code> contains a lot of duplication, there is a
shorthand for patterns that match struct fields: you only need to list the name
of the struct field, and the variables created from the pattern will have the
same names. Listing 18-13 shows code that behaves in the same way as the code
in Listing 18-12, but the variables created in the <code>let</code> pattern are <code>x</code> and
<code>y</code> instead of <code>a</code> and <code>b</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let p = Point { x: 0, y: 7 };

    let Point { x, y } = p;
    assert_eq!(0, x);
    assert_eq!(7, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-13: Destructuring struct fields using struct
field shorthand</span></p>
<p>This code creates the variables <code>x</code> and <code>y</code> that match the <code>x</code> and <code>y</code> fields
of the <code>p</code> variable. The outcome is that the variables <code>x</code> and <code>y</code> contain the
values from the <code>p</code> struct.</p>
<p>We can also destructure with literal values as part of the struct pattern
rather than creating variables for all the fields. Doing so allows us to test
some of the fields for particular values while creating variables to
destructure the other fields.</p>
<p>Listing 18-14 shows a <code>match</code> expression that separates <code>Point</code> values into
three cases: points that lie directly on the <code>x</code> axis (which is true when <code>y = 0</code>), on the <code>y</code> axis (<code>x = 0</code>), or neither.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let p = Point { x: 0, y: 7 };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        Point { x: 0, y } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-14: Destructuring and matching literal values
in one pattern</span></p>
<p>The first arm will match any point that lies on the <code>x</code> axis by specifying that
the <code>y</code> field matches if its value matches the literal <code>0</code>. The pattern still
creates an <code>x</code> variable that we can use in the code for this arm.</p>
<p>Similarly, the second arm matches any point on the <code>y</code> axis by specifying that
the <code>x</code> field matches if its value is <code>0</code> and creates a variable <code>y</code> for the
value of the <code>y</code> field. The third arm doesn’t specify any literals, so it
matches any other <code>Point</code> and creates variables for both the <code>x</code> and <code>y</code> fields.</p>
<p>In this example, the value <code>p</code> matches the second arm by virtue of <code>x</code>
containing a 0, so this code will print <code>On the y axis at 7</code>.</p>
<h4><a class="header" href="#destructuring-enums" id="destructuring-enums">Destructuring Enums</a></h4>
<p>We’ve destructured enums earlier in this book, for example, when we
destructured <code>Option&lt;i32&gt;</code> in Listing 6-5 in Chapter 6. One detail we haven’t
mentioned explicitly is that the pattern to destructure an enum should
correspond to the way the data stored within the enum is defined. As an
example, in Listing 18-15 we use the <code>Message</code> enum from Listing 6-2 and write
a <code>match</code> with patterns that will destructure each inner value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::ChangeColor(0, 160, 255);

    match msg {
        Message::Quit =&gt; {
            println!(&quot;The Quit variant has no data to destructure.&quot;)
        },
        Message::Move { x, y } =&gt; {
            println!(
                &quot;Move in the x direction {} and in the y direction {}&quot;,
                x,
                y
            );
        }
        Message::Write(text) =&gt; println!(&quot;Text message: {}&quot;, text),
        Message::ChangeColor(r, g, b) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        }
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-15: Destructuring enum variants that hold
different kinds of values</span></p>
<p>This code will print <code>Change the color to red 0, green 160, and blue 255</code>. Try
changing the value of <code>msg</code> to see the code from the other arms run.</p>
<p>For enum variants without any data, like <code>Message::Quit</code>, we can’t destructure
the value any further. We can only match on the literal <code>Message::Quit</code> value,
and no variables are in that pattern.</p>
<p>For struct-like enum variants, such as <code>Message::Move</code>, we can use a pattern
similar to the pattern we specify to match structs. After the variant name, we
place curly brackets and then list the fields with variables so we break apart
the pieces to use in the code for this arm. Here we use the shorthand form as
we did in Listing 18-13.</p>
<p>For tuple-like enum variants, like <code>Message::Write</code> that holds a tuple with one
element and <code>Message::ChangeColor</code> that holds a tuple with three elements, the
pattern is similar to the pattern we specify to match tuples. The number of
variables in the pattern must match the number of elements in the variant we’re
matching.</p>
<h4><a class="header" href="#destructuring-nested-structs-and-enums" id="destructuring-nested-structs-and-enums">Destructuring Nested Structs and Enums</a></h4>
<p>Until now, all our examples have been matching structs or enums that were one
level deep. Matching can work on nested items too!</p>
<p>For example, we can refactor the code in Listing 18-15 to support RGB and HSV
colors in the <code>ChangeColor</code> message, as shown in Listing 18-16.</p>
<pre><pre class="playpen"><code class="language-rust">enum Color {
   Rgb(i32, i32, i32),
   Hsv(i32, i32, i32),
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(Color),
}

fn main() {
    let msg = Message::ChangeColor(Color::Hsv(0, 160, 255));

    match msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) =&gt; {
            println!(
                &quot;Change the color to red {}, green {}, and blue {}&quot;,
                r,
                g,
                b
            )
        },
        Message::ChangeColor(Color::Hsv(h, s, v)) =&gt; {
            println!(
                &quot;Change the color to hue {}, saturation {}, and value {}&quot;,
                h,
                s,
                v
            )
        }
        _ =&gt; ()
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-16: Matching on nested enums</span></p>
<p>The pattern of the first arm in the <code>match</code> expression matches a
<code>Message::ChangeColor</code> enum variant that contains a <code>Color::Rgb</code> variant; then
the pattern binds to the three inner <code>i32</code> values. The pattern of the second
arm also matches a <code>Message::ChangeColor</code> enum variant, but the inner enum
matches the <code>Color::Hsv</code> variant instead. We can specify these complex
conditions in one <code>match</code> expression, even though two enums are involved.</p>
<h4><a class="header" href="#destructuring-structs-and-tuples" id="destructuring-structs-and-tuples">Destructuring Structs and Tuples</a></h4>
<p>We can mix, match, and nest destructuring patterns in even more complex ways.
The following example shows a complicated destructure where we nest structs and
tuples inside a tuple and destructure all the primitive values out:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });
<span class="boring">}
</span></code></pre></pre>
<p>This code lets us break complex types into their component parts so we can use
the values we’re interested in separately.</p>
<p>Destructuring with patterns is a convenient way to use pieces of values, such
as the value from each field in a struct, separately from each other.</p>
<h3><a class="header" href="#ignoring-values-in-a-pattern" id="ignoring-values-in-a-pattern">Ignoring Values in a Pattern</a></h3>
<p>You’ve seen that it’s sometimes useful to ignore values in a pattern, such as
in the last arm of a <code>match</code>, to get a catchall that doesn’t actually do
anything but does account for all remaining possible values. There are a few
ways to ignore entire values or parts of values in a pattern: using the <code>_</code>
pattern (which you’ve seen), using the <code>_</code> pattern within another pattern,
using a name that starts with an underscore, or using <code>..</code> to ignore remaining
parts of a value. Let’s explore how and why to use each of these patterns.</p>
<h4><a class="header" href="#ignoring-an-entire-value-with-_" id="ignoring-an-entire-value-with-_">Ignoring an Entire Value with <code>_</code></a></h4>
<p>We’ve used the underscore (<code>_</code>) as a wildcard pattern that will match any value
but not bind to the value. Although the underscore <code>_</code> pattern is especially
useful as the last arm in a <code>match</code> expression, we can use it in any pattern,
including function parameters, as shown in Listing 18-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn foo(_: i32, y: i32) {
    println!(&quot;This code only uses the y parameter: {}&quot;, y);
}

fn main() {
    foo(3, 4);
}
</code></pre></pre>
<p><span class="caption">Listing 18-17: Using <code>_</code> in a function signature</span></p>
<p>This code will completely ignore the value passed as the first argument, <code>3</code>,
and will print <code>This code only uses the y parameter: 4</code>.</p>
<p>In most cases when you no longer need a particular function parameter, you
would change the signature so it doesn’t include the unused parameter. Ignoring
a function parameter can be especially useful in some cases, for example, when
implementing a trait when you need a certain type signature but the function
body in your implementation doesn’t need one of the parameters. The compiler
will then not warn about unused function parameters, as it would if you used a
name instead.</p>
<h4><a class="header" href="#ignoring-parts-of-a-value-with-a-nested-_" id="ignoring-parts-of-a-value-with-a-nested-_">Ignoring Parts of a Value with a Nested <code>_</code></a></h4>
<p>We can also use <code>_</code> inside another pattern to ignore just part of a value, for
example, when we want to test for only part of a value but have no use for the
other parts in the corresponding code we want to run. Listing 18-18 shows code
responsible for managing a setting’s value. The business requirements are that
the user should not be allowed to overwrite an existing customization of a
setting but can unset the setting and give it a value if it is currently unset.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut setting_value = Some(5);
let new_setting_value = Some(10);

match (setting_value, new_setting_value) {
    (Some(_), Some(_)) =&gt; {
        println!(&quot;Can't overwrite an existing customized value&quot;);
    }
    _ =&gt; {
        setting_value = new_setting_value;
    }
}

println!(&quot;setting is {:?}&quot;, setting_value);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-18: Using an underscore within patterns that
match <code>Some</code> variants when we don’t need to use the value inside the
<code>Some</code></span></p>
<p>This code will print <code>Can't overwrite an existing customized value</code> and then
<code>setting is Some(5)</code>. In the first match arm, we don’t need to match on or use
the values inside either <code>Some</code> variant, but we do need to test for the case
when <code>setting_value</code> and <code>new_setting_value</code> are the <code>Some</code> variant. In that
case, we print why we’re not changing <code>setting_value</code>, and it doesn’t get
changed.</p>
<p>In all other cases (if either <code>setting_value</code> or <code>new_setting_value</code> are
<code>None</code>) expressed by the <code>_</code> pattern in the second arm, we want to allow
<code>new_setting_value</code> to become <code>setting_value</code>.</p>
<p>We can also use underscores in multiple places within one pattern to ignore
particular values. Listing 18-19 shows an example of ignoring the second and
fourth values in a tuple of five items.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let numbers = (2, 4, 8, 16, 32);

match numbers {
    (first, _, third, _, fifth) =&gt; {
        println!(&quot;Some numbers: {}, {}, {}&quot;, first, third, fifth)
    },
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-19: Ignoring multiple parts of a tuple</span></p>
<p>This code will print <code>Some numbers: 2, 8, 32</code>, and the values 4 and 16 will be
ignored.</p>
<h4><a class="header" href="#ignoring-an-unused-variable-by-starting-its-name-with-_" id="ignoring-an-unused-variable-by-starting-its-name-with-_">Ignoring an Unused Variable by Starting Its Name with <code>_</code></a></h4>
<p>If you create a variable but don’t use it anywhere, Rust will usually issue a
warning because that could be a bug. But sometimes it’s useful to create a
variable you won’t use yet, such as when you’re prototyping or just starting a
project. In this situation, you can tell Rust not to warn you about the unused
variable by starting the name of the variable with an underscore. In Listing
18-20, we create two unused variables, but when we run this code, we should
only get a warning about one of them.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let _x = 5;
    let y = 10;
}
</code></pre></pre>
<p><span class="caption">Listing 18-20: Starting a variable name with an
underscore to avoid getting unused variable warnings</span></p>
<p>Here we get a warning about not using the variable <code>y</code>, but we don’t get a
warning about not using the variable preceded by the underscore.</p>
<p>Note that there is a subtle difference between using only <code>_</code> and using a name
that starts with an underscore. The syntax <code>_x</code> still binds the value to the
variable, whereas <code>_</code> doesn’t bind at all. To show a case where this
distinction matters, Listing 18-21 will provide us with an error.</p>
<pre><code class="language-rust ignore does_not_compile">let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_s) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
</code></pre>
<p><span class="caption">Listing 18-21: An unused variable starting with an
underscore still binds the value, which might take ownership of the value</span></p>
<p>We’ll receive an error because the <code>s</code> value will still be moved into <code>_s</code>,
which prevents us from using <code>s</code> again. However, using the underscore by itself
doesn’t ever bind to the value. Listing 18-22 will compile without any errors
because <code>s</code> doesn’t get moved into <code>_</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = Some(String::from(&quot;Hello!&quot;));

if let Some(_) = s {
    println!(&quot;found a string&quot;);
}

println!(&quot;{:?}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-22: Using an underscore does not bind the
value</span></p>
<p>This code works just fine because we never bind <code>s</code> to anything; it isn’t moved.</p>
<h4><a class="header" href="#ignoring-remaining-parts-of-a-value-with-" id="ignoring-remaining-parts-of-a-value-with-">Ignoring Remaining Parts of a Value with <code>..</code></a></h4>
<p>With values that have many parts, we can use the <code>..</code> syntax to use only a few
parts and ignore the rest, avoiding the need to list underscores for each
ignored value. The <code>..</code> pattern ignores any parts of a value that we haven’t
explicitly matched in the rest of the pattern. In Listing 18-23, we have a
<code>Point</code> struct that holds a coordinate in three-dimensional space. In the
<code>match</code> expression, we want to operate only on the <code>x</code> coordinate and ignore
the values in the <code>y</code> and <code>z</code> fields.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
    z: i32,
}

let origin = Point { x: 0, y: 0, z: 0 };

match origin {
    Point { x, .. } =&gt; println!(&quot;x is {}&quot;, x),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-23: Ignoring all fields of a <code>Point</code> except
for <code>x</code> by using <code>..</code></span></p>
<p>We list the <code>x</code> value and then just include the <code>..</code> pattern. This is quicker
than having to list <code>y: _</code> and <code>z: _</code>, particularly when we’re working with
structs that have lots of fields in situations where only one or two fields are
relevant.</p>
<p>The syntax <code>..</code> will expand to as many values as it needs to be. Listing 18-24
shows how to use <code>..</code> with a tuple.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (first, .., last) =&gt; {
            println!(&quot;Some numbers: {}, {}&quot;, first, last);
        },
    }
}
</code></pre></pre>
<p><span class="caption">Listing 18-24: Matching only the first and last values in
a tuple and ignoring all other values</span></p>
<p>In this code, the first and last value are matched with <code>first</code> and <code>last</code>. The
<code>..</code> will match and ignore everything in the middle.</p>
<p>However, using <code>..</code> must be unambiguous. If it is unclear which values are
intended for matching and which should be ignored, Rust will give us an error.
Listing 18-25 shows an example of using <code>..</code> ambiguously, so it will not
compile.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    let numbers = (2, 4, 8, 16, 32);

    match numbers {
        (.., second, ..) =&gt; {
            println!(&quot;Some numbers: {}&quot;, second)
        },
    }
}
</code></pre>
<p><span class="caption">Listing 18-25: An attempt to use <code>..</code> in an ambiguous
way</span></p>
<p>When we compile this example, we get this error:</p>
<pre><code class="language-text">error: `..` can only be used once per tuple or tuple struct pattern
 --&gt; src/main.rs:5:22
  |
5 |         (.., second, ..) =&gt; {
  |                      ^^
</code></pre>
<p>It’s impossible for Rust to determine how many values in the tuple to ignore
before matching a value with <code>second</code> and then how many further values to
ignore thereafter. This code could mean that we want to ignore <code>2</code>, bind
<code>second</code> to <code>4</code>, and then ignore <code>8</code>, <code>16</code>, and <code>32</code>; or that we want to ignore
<code>2</code> and <code>4</code>, bind <code>second</code> to <code>8</code>, and then ignore <code>16</code> and <code>32</code>; and so forth.
The variable name <code>second</code> doesn’t mean anything special to Rust, so we get a
compiler error because using <code>..</code> in two places like this is ambiguous.</p>
<h3><a class="header" href="#extra-conditionals-with-match-guards" id="extra-conditionals-with-match-guards">Extra Conditionals with Match Guards</a></h3>
<p>A <em>match guard</em> is an additional <code>if</code> condition specified after the pattern in
a <code>match</code> arm that must also match, along with the pattern matching, for that
arm to be chosen. Match guards are useful for expressing more complex ideas
than a pattern alone allows.</p>
<p>The condition can use variables created in the pattern. Listing 18-26 shows a
<code>match</code> where the first arm has the pattern <code>Some(x)</code> and also has a match
guard of <code>if x &lt; 5</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let num = Some(4);

match num {
    Some(x) if x &lt; 5 =&gt; println!(&quot;less than five: {}&quot;, x),
    Some(x) =&gt; println!(&quot;{}&quot;, x),
    None =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-26: Adding a match guard to a pattern</span></p>
<p>This example will print <code>less than five: 4</code>. When <code>num</code> is compared to the
pattern in the first arm, it matches, because <code>Some(4)</code> matches <code>Some(x)</code>. Then
the match guard checks whether the value in <code>x</code> is less than <code>5</code>, and because
it is, the first arm is selected.</p>
<p>If <code>num</code> had been <code>Some(10)</code> instead, the match guard in the first arm would
have been false because 10 is not less than 5. Rust would then go to the second
arm, which would match because the second arm doesn’t have a match guard and
therefore matches any <code>Some</code> variant.</p>
<p>There is no way to express the <code>if x &lt; 5</code> condition within a pattern, so the
match guard gives us the ability to express this logic.</p>
<p>In Listing 18-11, we mentioned that we could use match guards to solve our
pattern-shadowing problem. Recall that a new variable was created inside the
pattern in the <code>match</code> expression instead of using the variable outside the
<code>match</code>. That new variable meant we couldn’t test against the value of the
outer variable. Listing 18-27 shows how we can use a match guard to fix this
problem.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = Some(5);
    let y = 10;

    match x {
        Some(50) =&gt; println!(&quot;Got 50&quot;),
        Some(n) if n == y =&gt; println!(&quot;Matched, n = {:?}&quot;, n),
        _ =&gt; println!(&quot;Default case, x = {:?}&quot;, x),
    }

    println!(&quot;at the end: x = {:?}, y = {:?}&quot;, x, y);
}
</code></pre></pre>
<p><span class="caption">Listing 18-27: Using a match guard to test for equality
with an outer variable</span></p>
<p>This code will now print <code>Default case, x = Some(5)</code>. The pattern in the second
match arm doesn’t introduce a new variable <code>y</code> that would shadow the outer <code>y</code>,
meaning we can use the outer <code>y</code> in the match guard. Instead of specifying the
pattern as <code>Some(y)</code>, which would have shadowed the outer <code>y</code>, we specify
<code>Some(n)</code>. This creates a new variable <code>n</code> that doesn’t shadow anything because
there is no <code>n</code> variable outside the <code>match</code>.</p>
<p>The match guard <code>if n == y</code> is not a pattern and therefore doesn’t introduce
new variables. This <code>y</code> <em>is</em> the outer <code>y</code> rather than a new shadowed <code>y</code>, and
we can look for a value that has the same value as the outer <code>y</code> by comparing
<code>n</code> to <code>y</code>.</p>
<p>You can also use the <em>or</em> operator <code>|</code> in a match guard to specify multiple
patterns; the match guard condition will apply to all the patterns. Listing
18-28 shows the precedence of combining a match guard with a pattern that uses
<code>|</code>. The important part of this example is that the <code>if y</code> match guard applies
to <code>4</code>, <code>5</code>, <em>and</em> <code>6</code>, even though it might look like <code>if y</code> only applies to
<code>6</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 4;
let y = false;

match x {
    4 | 5 | 6 if y =&gt; println!(&quot;yes&quot;),
    _ =&gt; println!(&quot;no&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-28: Combining multiple patterns with a match
guard</span></p>
<p>The match condition states that the arm only matches if the value of <code>x</code> is
equal to <code>4</code>, <code>5</code>, or <code>6</code> <em>and</em> if <code>y</code> is <code>true</code>. When this code runs, the
pattern of the first arm matches because <code>x</code> is <code>4</code>, but the match guard <code>if y</code>
is false, so the first arm is not chosen. The code moves on to the second arm,
which does match, and this program prints <code>no</code>. The reason is that the <code>if</code>
condition applies to the whole pattern <code>4 | 5 | 6</code>, not only to the last value
<code>6</code>. In other words, the precedence of a match guard in relation to a pattern
behaves like this:</p>
<pre><code class="language-text">(4 | 5 | 6) if y =&gt; ...
</code></pre>
<p>rather than this:</p>
<pre><code class="language-text">4 | 5 | (6 if y) =&gt; ...
</code></pre>
<p>After running the code, the precedence behavior is evident: if the match guard
were applied only to the final value in the list of values specified using the
<code>|</code> operator, the arm would have matched and the program would have printed
<code>yes</code>.</p>
<h3><a class="header" href="#-bindings" id="-bindings"><code>@</code> Bindings</a></h3>
<p>The <em>at</em> operator (<code>@</code>) lets us create a variable that holds a value at the
same time we’re testing that value to see whether it matches a pattern. Listing
18-29 shows an example where we want to test that a <code>Message::Hello</code> <code>id</code> field
is within the range <code>3...7</code>. But we also want to bind the value to the variable
<code>id_variable</code> so we can use it in the code associated with the arm. We could
name this variable <code>id</code>, the same as the field, but for this example we’ll use
a different name.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Message {
    Hello { id: i32 },
}

let msg = Message::Hello { id: 5 };

match msg {
    Message::Hello { id: id_variable @ 3...7 } =&gt; {
        println!(&quot;Found an id in range: {}&quot;, id_variable)
    },
    Message::Hello { id: 10...12 } =&gt; {
        println!(&quot;Found an id in another range&quot;)
    },
    Message::Hello { id } =&gt; {
        println!(&quot;Found some other id: {}&quot;, id)
    },
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 18-29: Using <code>@</code> to bind to a value in a pattern
while also testing it</span></p>
<p>This example will print <code>Found an id in range: 5</code>. By specifying <code>id_variable @</code> before the range <code>3...7</code>, we’re capturing whatever value matched the range
while also testing that the value matched the range pattern.</p>
<p>In the second arm, where we only have a range specified in the pattern, the code
associated with the arm doesn’t have a variable that contains the actual value
of the <code>id</code> field. The <code>id</code> field’s value could have been 10, 11, or 12, but
the code that goes with that pattern doesn’t know which it is. The pattern code
isn’t able to use the value from the <code>id</code> field, because we haven’t saved the
<code>id</code> value in a variable.</p>
<p>In the last arm, where we’ve specified a variable without a range, we do have
the value available to use in the arm’s code in a variable named <code>id</code>. The
reason is that we’ve used the struct field shorthand syntax. But we haven’t
applied any test to the value in the <code>id</code> field in this arm, as we did with the
first two arms: any value would match this pattern.</p>
<p>Using <code>@</code> lets us test a value and save it in a variable within one pattern.</p>
<h2><a class="header" href="#summary-17" id="summary-17">Summary</a></h2>
<p>Rust’s patterns are very useful in that they help distinguish between different
kinds of data. When used in <code>match</code> expressions, Rust ensures your patterns
cover every possible value, or your program won’t compile. Patterns in <code>let</code>
statements and function parameters make those constructs more useful, enabling
the destructuring of values into smaller parts at the same time as assigning to
variables. We can create simple or complex patterns to suit our needs.</p>
<p>Next, for the penultimate chapter of the book, we’ll look at some advanced
aspects of a variety of Rust’s features.</p>
<h1><a class="header" href="#advanced-features" id="advanced-features">Advanced Features</a></h1>
<p>By now, you’ve learned the most commonly used parts of the Rust programming
language. Before we do one more project in Chapter 20, we’ll look at a few
aspects of the language you might run into every once in a while. You can use
this chapter as a reference for when you encounter any unknowns when using
Rust. The features you’ll learn to use in this chapter are useful in very
specific situations. Although you might not reach for them often, we want to
make sure you have a grasp of all the features Rust has to offer.</p>
<p>In this chapter, we’ll cover:</p>
<ul>
<li>Unsafe Rust: how to opt out of some of Rust’s guarantees and take
responsibility for manually upholding those guarantees</li>
<li>Advanced traits: associated types, default type parameters, fully qualified
syntax, supertraits, and the newtype pattern in relation to traits</li>
<li>Advanced types: more about the newtype pattern, type aliases, the never type,
and dynamically sized types</li>
<li>Advanced functions and closures: function pointers and returning closures</li>
<li>Macros: ways to define code that defines more code at compile time</li>
</ul>
<p>It’s a panoply of Rust features with something for everyone! Let’s dive in!</p>
<h2><a class="header" href="#unsafe-rust" id="unsafe-rust">Unsafe Rust</a></h2>
<p>All the code we’ve discussed so far has had Rust’s memory safety guarantees
enforced at compile time. However, Rust has a second language hidden inside it
that doesn’t enforce these memory safety guarantees: it’s called <em>unsafe Rust</em>
and works just like regular Rust, but gives us extra superpowers.</p>
<p>Unsafe Rust exists because, by nature, static analysis is conservative. When
the compiler tries to determine whether or not code upholds the guarantees,
it’s better for it to reject some valid programs rather than accept some
invalid programs. Although the code might be okay, as far as Rust is able to
tell, it’s not! In these cases, you can use unsafe code to tell the compiler,
“Trust me, I know what I’m doing.” The downside is that you use it at your own
risk: if you use unsafe code incorrectly, problems due to memory unsafety, such
as null pointer dereferencing, can occur.</p>
<p>Another reason Rust has an unsafe alter ego is that the underlying computer
hardware is inherently unsafe. If Rust didn’t let you do unsafe operations, you
couldn’t do certain tasks. Rust needs to allow you to do low-level systems
programming, such as directly interacting with the operating system or even
writing your own operating system. Working with low-level systems programming
is one of the goals of the language. Let’s explore what we can do with unsafe
Rust and how to do it.</p>
<h3><a class="header" href="#unsafe-superpowers" id="unsafe-superpowers">Unsafe Superpowers</a></h3>
<p>To switch to unsafe Rust, use the <code>unsafe</code> keyword and then start a new block
that holds the unsafe code. You can take four actions in unsafe Rust, called
<em>unsafe superpowers</em>, that you can’t in safe Rust. Those superpowers include
the ability to:</p>
<ul>
<li>Dereference a raw pointer</li>
<li>Call an unsafe function or method</li>
<li>Access or modify a mutable static variable</li>
<li>Implement an unsafe trait</li>
</ul>
<p>It’s important to understand that <code>unsafe</code> doesn’t turn off the borrow checker
or disable any other of Rust’s safety checks: if you use a reference in unsafe
code, it will still be checked. The <code>unsafe</code> keyword only gives you access to
these four features that are then not checked by the compiler for memory
safety. You’ll still get some degree of safety inside of an unsafe block.</p>
<p>In addition, <code>unsafe</code> does not mean the code inside the block is necessarily
dangerous or that it will definitely have memory safety problems: the intent is
that as the programmer, you’ll ensure the code inside an <code>unsafe</code> block will
access memory in a valid way.</p>
<p>People are fallible, and mistakes will happen, but by requiring these four
unsafe operations to be inside blocks annotated with <code>unsafe</code> you’ll know that
any errors related to memory safety must be within an <code>unsafe</code> block. Keep
<code>unsafe</code> blocks small; you’ll be thankful later when you investigate memory
bugs.</p>
<p>To isolate unsafe code as much as possible, it’s best to enclose unsafe code
within a safe abstraction and provide a safe API, which we’ll discuss later in
the chapter when we examine unsafe functions and methods. Parts of the standard
library are implemented as safe abstractions over unsafe code that has been
audited. Wrapping unsafe code in a safe abstraction prevents uses of <code>unsafe</code>
from leaking out into all the places that you or your users might want to use
the functionality implemented with <code>unsafe</code> code, because using a safe
abstraction is safe.</p>
<p>Let’s look at each of the four unsafe superpowers in turn. We’ll also look at
some abstractions that provide a safe interface to unsafe code.</p>
<h3><a class="header" href="#dereferencing-a-raw-pointer" id="dereferencing-a-raw-pointer">Dereferencing a Raw Pointer</a></h3>
<p>In Chapter 4, in the <a href="rustbook/ch04-02-references-and-borrowing.html#dangling-references">“Dangling References”</a><!-- ignore
--> section, we mentioned that the compiler ensures references are always
valid. Unsafe Rust has two new types called <em>raw pointers</em> that are similar to
references. As with references, raw pointers can be immutable or mutable and
are written as <code>*const T</code> and <code>*mut T</code>, respectively. The asterisk isn’t the
dereference operator; it’s part of the type name. In the context of raw
pointers, <em>immutable</em> means that the pointer can’t be directly assigned to
after being dereferenced.</p>
<p>Different from references and smart pointers, raw pointers:</p>
<ul>
<li>Are allowed to ignore the borrowing rules by having both immutable and
mutable pointers or multiple mutable pointers to the same location</li>
<li>Aren’t guaranteed to point to valid memory</li>
<li>Are allowed to be null</li>
<li>Don’t implement any automatic cleanup</li>
</ul>
<p>By opting out of having Rust enforce these guarantees, you can give up
guaranteed safety in exchange for greater performance or the ability to
interface with another language or hardware where Rust’s guarantees don’t apply.</p>
<p>Listing 19-1 shows how to create an immutable and a mutable raw pointer from
references.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-1: Creating raw pointers from references</span></p>
<p>Notice that we don’t include the <code>unsafe</code> keyword in this code. We can create
raw pointers in safe code; we just can’t dereference raw pointers outside an
unsafe block, as you’ll see in a bit.</p>
<p>We’ve created raw pointers by using <code>as</code> to cast an immutable and a mutable
reference into their corresponding raw pointer types. Because we created them
directly from references guaranteed to be valid, we know these particular raw
pointers are valid, but we can’t make that assumption about just any raw
pointer.</p>
<p>Next, we’ll create a raw pointer whose validity we can’t be so certain of.
Listing 19-2 shows how to create a raw pointer to an arbitrary location in
memory. Trying to use arbitrary memory is undefined: there might be data at
that address or there might not, the compiler might optimize the code so there
is no memory access, or the program might error with a segmentation fault.
Usually, there is no good reason to write code like this, but it is possible.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let address = 0x012345usize;
let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-2: Creating a raw pointer to an arbitrary
memory address</span></p>
<p>Recall that we can create raw pointers in safe code, but we can’t <em>dereference</em>
raw pointers and read the data being pointed to. In Listing 19-3, we use the
dereference operator <code>*</code> on a raw pointer that requires an <code>unsafe</code> block.</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-3: Dereferencing raw pointers within an
<code>unsafe</code> block</span></p>
<p>Creating a pointer does no harm; it’s only when we try to access the value that
it points at that we might end up dealing with an invalid value.</p>
<p>Note also that in Listing 19-1 and 19-3, we created <code>*const i32</code> and <code>*mut i32</code>
raw pointers that both pointed to the same memory location, where <code>num</code> is
stored. If we instead tried to create an immutable and a mutable reference to
<code>num</code>, the code would not have compiled because Rust’s ownership rules don’t
allow a mutable reference at the same time as any immutable references. With
raw pointers, we can create a mutable pointer and an immutable pointer to the
same location and change data through the mutable pointer, potentially creating
a data race. Be careful!</p>
<p>With all of these dangers, why would you ever use raw pointers? One major use
case is when interfacing with C code, as you’ll see in the next section,
<a href="rustbook/ch19-01-unsafe-rust.html#calling-an-unsafe-function-or-method">“Calling an Unsafe Function or
Method.”</a><!-- ignore --> Another case is
when building up safe abstractions that the borrow checker doesn’t understand.
We’ll introduce unsafe functions and then look at an example of a safe
abstraction that uses unsafe code.</p>
<h3><a class="header" href="#calling-an-unsafe-function-or-method" id="calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></h3>
<p>The second type of operation that requires an unsafe block is calls to unsafe
functions. Unsafe functions and methods look exactly like regular functions and
methods, but they have an extra <code>unsafe</code> before the rest of the definition. The
<code>unsafe</code> keyword in this context indicates the function has requirements we
need to uphold when we call this function, because Rust can’t guarantee we’ve
met these requirements. By calling an unsafe function within an <code>unsafe</code> block,
we’re saying that we’ve read this function’s documentation and take
responsibility for upholding the function’s contracts.</p>
<p>Here is an unsafe function named <code>dangerous</code> that doesn’t do anything in its
body:</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>unsafe fn dangerous() {}

unsafe {
    dangerous();
}
<span class="boring">}
</span></code></pre></pre>
<p>We must call the <code>dangerous</code> function within a separate <code>unsafe</code> block. If we
try to call <code>dangerous</code> without the <code>unsafe</code> block, we’ll get an error:</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<p>By inserting the <code>unsafe</code> block around our call to <code>dangerous</code>, we’re asserting
to Rust that we’ve read the function’s documentation, we understand how to use
it properly, and we’ve verified that we’re fulfilling the contract of the
function.</p>
<p>Bodies of unsafe functions are effectively <code>unsafe</code> blocks, so to perform other
unsafe operations within an unsafe function, we don’t need to add another
<code>unsafe</code> block.</p>
<h4><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code" id="creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></h4>
<p>Just because a function contains unsafe code doesn’t mean we need to mark the
entire function as unsafe. In fact, wrapping unsafe code in a safe function is
a common abstraction. As an example, let’s study a function from the standard
library, <code>split_at_mut</code>, that requires some unsafe code and explore how we
might implement it. This safe method is defined on mutable slices: it takes one
slice and makes it two by splitting the slice at the index given as an
argument. Listing 19-4 shows how to use <code>split_at_mut</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-4: Using the safe <code>split_at_mut</code>
function</span></p>
<p>We can’t implement this function using only safe Rust. An attempt might look
something like Listing 19-5, which won’t compile. For simplicity, we’ll
implement <code>split_at_mut</code> as a function rather than a method and only for slices
of <code>i32</code> values rather than for a generic type <code>T</code>.</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<p><span class="caption">Listing 19-5: An attempted implementation of
<code>split_at_mut</code> using only safe Rust</span></p>
<p>This function first gets the total length of the slice. Then it asserts that
the index given as a parameter is within the slice by checking whether it’s
less than or equal to the length. The assertion means that if we pass an index
that is greater than the index to split the slice at, the function will panic
before it attempts to use that index.</p>
<p>Then we return two mutable slices in a tuple: one from the start of the
original slice to the <code>mid</code> index and another from <code>mid</code> to the end of the
slice.</p>
<p>When we try to compile the code in Listing 19-5, we’ll get an error.</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<p>Rust’s borrow checker can’t understand that we’re borrowing different parts of
the slice; it only knows that we’re borrowing from the same slice twice.
Borrowing different parts of a slice is fundamentally okay because the two
slices aren’t overlapping, but Rust isn’t smart enough to know this. When we
know code is okay, but Rust doesn’t, it’s time to reach for unsafe code.</p>
<p>Listing 19-6 shows how to use an <code>unsafe</code> block, a raw pointer, and some calls
to unsafe functions to make the implementation of <code>split_at_mut</code> work.</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-6: Using unsafe code in the implementation of
the <code>split_at_mut</code> function</span></p>
<p>Recall from <a href="rustbook/ch04-03-slices.html#the-slice-type">“The Slice Type”</a><!-- ignore --> section in
Chapter 4 that slices are a pointer to some data and the length of the slice.
We use the <code>len</code> method to get the length of a slice and the <code>as_mut_ptr</code>
method to access the raw pointer of a slice. In this case, because we have a
mutable slice to <code>i32</code> values, <code>as_mut_ptr</code> returns a raw pointer with the type
<code>*mut i32</code>, which we’ve stored in the variable <code>ptr</code>.</p>
<p>We keep the assertion that the <code>mid</code> index is within the slice. Then we get to
the unsafe code: the <code>slice::from_raw_parts_mut</code> function takes a raw pointer
and a length, and it creates a slice. We use this function to create a slice
that starts from <code>ptr</code> and is <code>mid</code> items long. Then we call the <code>offset</code>
method on <code>ptr</code> with <code>mid</code> as an argument to get a raw pointer that starts at
<code>mid</code>, and we create a slice using that pointer and the remaining number of
items after <code>mid</code> as the length.</p>
<p>The function <code>slice::from_raw_parts_mut</code> is unsafe because it takes a raw
pointer and must trust that this pointer is valid. The <code>offset</code> method on raw
pointers is also unsafe, because it must trust that the offset location is also
a valid pointer. Therefore, we had to put an <code>unsafe</code> block around our calls to
<code>slice::from_raw_parts_mut</code> and <code>offset</code> so we could call them. By looking at
the code and by adding the assertion that <code>mid</code> must be less than or equal to
<code>len</code>, we can tell that all the raw pointers used within the <code>unsafe</code> block
will be valid pointers to data within the slice. This is an acceptable and
appropriate use of <code>unsafe</code>.</p>
<p>Note that we don’t need to mark the resulting <code>split_at_mut</code> function as
<code>unsafe</code>, and we can call this function from safe Rust. We’ve created a safe
abstraction to the unsafe code with an implementation of the function that uses
<code>unsafe</code> code in a safe way, because it creates only valid pointers from the
data this function has access to.</p>
<p>In contrast, the use of <code>slice::from_raw_parts_mut</code> in Listing 19-7 would
likely crash when the slice is used. This code takes an arbitrary memory
location and creates a slice 10,000 items long.</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let slice: &amp;[i32] = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-7: Creating a slice from an arbitrary memory
location</span></p>
<p>We don’t own the memory at this arbitrary location, and there is no guarantee
that the slice this code creates contains valid <code>i32</code> values. Attempting to use
<code>slice</code> as though it’s a valid slice results in undefined behavior.</p>
<h4><a class="header" href="#using-extern-functions-to-call-external-code" id="using-extern-functions-to-call-external-code">Using <code>extern</code> Functions to Call External Code</a></h4>
<p>Sometimes, your Rust code might need to interact with code written in another
language. For this, Rust has a keyword, <code>extern</code>, that facilitates the creation
and use of a <em>Foreign Function Interface (FFI)</em>. An FFI is a way for a
programming language to define functions and enable a different (foreign)
programming language to call those functions.</p>
<p>Listing 19-8 demonstrates how to set up an integration with the <code>abs</code> function
from the C standard library. Functions declared within <code>extern</code> blocks are
always unsafe to call from Rust code. The reason is that other languages don’t
enforce Rust’s rules and guarantees, and Rust can’t check them, so
responsibility falls on the programmer to ensure safety.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">Listing 19-8: Declaring and calling an <code>extern</code> function
defined in another language</span></p>
<p>Within the <code>extern &quot;C&quot;</code> block, we list the names and signatures of external
functions from another language we want to call. The <code>&quot;C&quot;</code> part defines which
<em>application binary interface (ABI)</em> the external function uses: the ABI
defines how to call the function at the assembly level. The <code>&quot;C&quot;</code> ABI is the
most common and follows the C programming language’s ABI.</p>
<blockquote>
<h4><a class="header" href="#calling-rust-functions-from-other-languages" id="calling-rust-functions-from-other-languages">Calling Rust Functions from Other Languages</a></h4>
<p>We can also use <code>extern</code> to create an interface that allows other languages
to call Rust functions. Instead of an <code>extern</code> block, we add the <code>extern</code>
keyword and specify the ABI to use just before the <code>fn</code> keyword. We also need
to add a <code>#[no_mangle]</code> annotation to tell the Rust compiler not to mangle
the name of this function. <em>Mangling</em> is when a compiler changes the name
we’ve given a function to a different name that contains more information for
other parts of the compilation process to consume but is less human readable.
Every programming language compiler mangles names slightly differently, so
for a Rust function to be nameable by other languages, we must disable the
Rust compiler’s name mangling.</p>
<p>In the following example, we make the <code>call_from_c</code> function accessible from
C code, after it’s compiled to a shared library and linked from C:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>This usage of <code>extern</code> does not require <code>unsafe</code>.</p>
</blockquote>
<h3><a class="header" href="#accessing-or-modifying-a-mutable-static-variable" id="accessing-or-modifying-a-mutable-static-variable">Accessing or Modifying a Mutable Static Variable</a></h3>
<p>Until now, we’ve not talked about <em>global variables</em>, which Rust does support
but can be problematic with Rust’s ownership rules. If two threads are
accessing the same mutable global variable, it can cause a data race.</p>
<p>In Rust, global variables are called <em>static</em> variables. Listing 19-9 shows an
example declaration and use of a static variable with a string slice as a
value.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">Listing 19-9: Defining and using an immutable static
variable</span></p>
<p>Static variables are similar to constants, which we discussed in the
<a href="rustbook/ch03-01-variables-and-mutability.html#differences-between-variables-and-constants">“Differences Between Variables and
Constants”</a><!-- ignore -->
section in Chapter 3. The names of static variables are in
<code>SCREAMING_SNAKE_CASE</code> by convention, and we <em>must</em> annotate the variable’s
type, which is <code>&amp;'static str</code> in this example. Static variables can only store
references with the <code>'static</code> lifetime, which means the Rust compiler can
figure out the lifetime; we don’t need to annotate it explicitly. Accessing an
immutable static variable is safe.</p>
<p>Constants and immutable static variables might seem similar, but a subtle
difference is that values in a static variable have a fixed address in memory.
Using the value will always access the same data. Constants, on the other hand,
are allowed to duplicate their data whenever they’re used.</p>
<p>Another difference between constants and static variables is that static
variables can be mutable. Accessing and modifying mutable static variables is
<em>unsafe</em>. Listing 19-10 shows how to declare, access, and modify a mutable
static variable named <code>COUNTER</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust unsafe">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 19-10: Reading from or writing to a mutable
static variable is unsafe</span></p>
<p>As with regular variables, we specify mutability using the <code>mut</code> keyword. Any
code that reads or writes from <code>COUNTER</code> must be within an <code>unsafe</code> block. This
code compiles and prints <code>COUNTER: 3</code> as we would expect because it’s single
threaded. Having multiple threads access <code>COUNTER</code> would likely result in data
races.</p>
<p>With mutable data that is globally accessible, it’s difficult to ensure there
are no data races, which is why Rust considers mutable static variables to be
unsafe. Where possible, it’s preferable to use the concurrency techniques and
thread-safe smart pointers we discussed in Chapter 16 so the compiler checks
that data accessed from different threads is done safely.</p>
<h3><a class="header" href="#implementing-an-unsafe-trait" id="implementing-an-unsafe-trait">Implementing an Unsafe Trait</a></h3>
<p>The final action that works only with <code>unsafe</code> is implementing an unsafe trait.
A trait is unsafe when at least one of its methods has some invariant that the
compiler can’t verify. We can declare that a trait is <code>unsafe</code> by adding the
<code>unsafe</code> keyword before <code>trait</code> and marking the implementation of the trait as
<code>unsafe</code> too, as shown in Listing 19-11.</p>
<pre><pre class="playpen"><code class="language-rust unsafe">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-11: Defining and implementing an unsafe
trait</span></p>
<p>By using <code>unsafe impl</code>, we’re promising that we’ll uphold the invariants that
the compiler can’t verify.</p>
<p>As an example, recall the <code>Sync</code> and <code>Send</code> marker traits we discussed in the
<a href="rustbook/ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">“Extensible Concurrency with the <code>Sync</code> and <code>Send</code>
Traits”</a><!-- ignore -->
section in Chapter 16: the compiler implements these traits automatically if
our types are composed entirely of <code>Send</code> and <code>Sync</code> types. If we implement a
type that contains a type that is not <code>Send</code> or <code>Sync</code>, such as raw pointers,
and we want to mark that type as <code>Send</code> or <code>Sync</code>, we must use <code>unsafe</code>. Rust
can’t verify that our type upholds the guarantees that it can be safely sent
across threads or accessed from multiple threads; therefore, we need to do
those checks manually and indicate as such with <code>unsafe</code>.</p>
<h3><a class="header" href="#when-to-use-unsafe-code" id="when-to-use-unsafe-code">When to Use Unsafe Code</a></h3>
<p>Using <code>unsafe</code> to take one of the four actions (superpowers) just discussed
isn’t wrong or even frowned upon. But it is trickier to get <code>unsafe</code> code
correct because the compiler can’t help uphold memory safety. When you have a
reason to use <code>unsafe</code> code, you can do so, and having the explicit <code>unsafe</code>
annotation makes it easier to track down the source of problems if they occur.</p>
<h2><a class="header" href="#advanced-traits" id="advanced-traits">Advanced Traits</a></h2>
<p>We first covered traits in the <a href="rustbook/ch10-02-traits.html#traits-defining-shared-behavior">“Traits: Defining Shared
Behavior”</a><!-- ignore --> section of Chapter
10, but as with lifetimes, we didn’t discuss the more advanced details. Now
that you know more about Rust, we can get into the nitty-gritty.</p>
<h3><a class="header" href="#specifying-placeholder-types-in-trait-definitions-with-associated-types" id="specifying-placeholder-types-in-trait-definitions-with-associated-types">Specifying Placeholder Types in Trait Definitions with Associated Types</a></h3>
<p><em>Associated types</em> connect a type placeholder with a trait such that the trait
method definitions can use these placeholder types in their signatures. The
implementor of a trait will specify the concrete type to be used in this type’s
place for the particular implementation. That way, we can define a trait that
uses some types without needing to know exactly what those types are until the
trait is implemented.</p>
<p>We’ve described most of the advanced features in this chapter as being rarely
needed. Associated types are somewhere in the middle: they’re used more rarely
than features explained in the rest of the book but more commonly than many of
the other features discussed in this chapter.</p>
<p>One example of a trait with an associated type is the <code>Iterator</code> trait that the
standard library provides. The associated type is named <code>Item</code> and stands in
for the type of the values the type implementing the <code>Iterator</code> trait is
iterating over. In <a href="rustbook/ch13-02-iterators.html#the-iterator-trait-and-the-next-method">“The <code>Iterator</code> Trait and the <code>next</code>
Method”</a><!-- ignore --> section of
Chapter 13, we mentioned that the definition of the <code>Iterator</code> trait is as
shown in Listing 19-12.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    type Item;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-12: The definition of the <code>Iterator</code> trait
that has an associated type <code>Item</code></span></p>
<p>The type <code>Item</code> is a placeholder type, and the <code>next</code> method’s definition shows
that it will return values of type <code>Option&lt;Self::Item&gt;</code>. Implementors of the
<code>Iterator</code> trait will specify the concrete type for <code>Item</code>, and the <code>next</code>
method will return an <code>Option</code> containing a value of that concrete type.</p>
<p>Associated types might seem like a similar concept to generics, in that the
latter allow us to define a function without specifying what types it can
handle. So why use associated types?</p>
<p>Let’s examine the difference between the two concepts with an example from
Chapter 13 that implements the <code>Iterator</code> trait on the <code>Counter</code> struct. In
Listing 13-21, we specified that the <code>Item</code> type was <code>u32</code>:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Iterator for Counter {
    type Item = u32;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        // --snip--
</code></pre>
<p>This syntax seems comparable to that of generics. So why not just define the
<code>Iterator</code> trait with generics, as shown in Listing 19-13?</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Iterator&lt;T&gt; {
    fn next(&amp;mut self) -&gt; Option&lt;T&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-13: A hypothetical definition of the
<code>Iterator</code> trait using generics</span></p>
<p>The difference is that when using generics, as in Listing 19-13, we must
annotate the types in each implementation; because we can also implement
<code>Iterator&lt;String&gt; for Counter</code> or any other type, we could have multiple
implementations of <code>Iterator</code> for <code>Counter</code>. In other words, when a trait has a
generic parameter, it can be implemented for a type multiple times, changing
the concrete types of the generic type parameters each time. When we use the
<code>next</code> method on <code>Counter</code>, we would have to provide type annotations to
indicate which implementation of <code>Iterator</code> we want to use.</p>
<p>With associated types, we don’t need to annotate types because we can’t
implement a trait on a type multiple times. In Listing 19-12 with the
definition that uses associated types, we can only choose what the type of
<code>Item</code> will be once, because there can only be one <code>impl Iterator for Counter</code>.
We don’t have to specify that we want an iterator of <code>u32</code> values everywhere
that we call <code>next</code> on <code>Counter</code>.</p>
<h3><a class="header" href="#default-generic-type-parameters-and-operator-overloading" id="default-generic-type-parameters-and-operator-overloading">Default Generic Type Parameters and Operator Overloading</a></h3>
<p>When we use generic type parameters, we can specify a default concrete type for
the generic type. This eliminates the need for implementors of the trait to
specify a concrete type if the default type works. The syntax for specifying a
default type for a generic type is <code>&lt;PlaceholderType=ConcreteType&gt;</code> when
declaring the generic type.</p>
<p>A great example of a situation where this technique is useful is with operator
overloading. <em>Operator overloading</em> is customizing the behavior of an operator
(such as <code>+</code>) in particular situations.</p>
<p>Rust doesn’t allow you to create your own operators or overload arbitrary
operators. But you can overload the operations and corresponding traits listed
in <code>std::ops</code> by implementing the traits associated with the operator. For
example, in Listing 19-14 we overload the <code>+</code> operator to add two <code>Point</code>
instances together. We do this by implementing the <code>Add</code> trait on a <code>Point</code>
struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::Add;

#[derive(Debug, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}

impl Add for Point {
    type Output = Point;

    fn add(self, other: Point) -&gt; Point {
        Point {
            x: self.x + other.x,
            y: self.y + other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 1, y: 0 } + Point { x: 2, y: 3 },
               Point { x: 3, y: 3 });
}
</code></pre></pre>
<p><span class="caption">Listing 19-14: Implementing the <code>Add</code> trait to overload
the <code>+</code> operator for <code>Point</code> instances</span></p>
<p>The <code>add</code> method adds the <code>x</code> values of two <code>Point</code> instances and the <code>y</code>
values of two <code>Point</code> instances to create a new <code>Point</code>. The <code>Add</code> trait has an
associated type named <code>Output</code> that determines the type returned from the <code>add</code>
method.</p>
<p>The default generic type in this code is within the <code>Add</code> trait. Here is its
definition:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Add&lt;RHS=Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}
<span class="boring">}
</span></code></pre></pre>
<p>This code should look generally familiar: a trait with one method and an
associated type. The new part is <code>RHS=Self</code>: this syntax is called <em>default
type parameters</em>. The <code>RHS</code> generic type parameter (short for “right hand
side”) defines the type of the <code>rhs</code> parameter in the <code>add</code> method. If we don’t
specify a concrete type for <code>RHS</code> when we implement the <code>Add</code> trait, the type
of <code>RHS</code> will default to <code>Self</code>, which will be the type we’re implementing
<code>Add</code> on.</p>
<p>When we implemented <code>Add</code> for <code>Point</code>, we used the default for <code>RHS</code> because we
wanted to add two <code>Point</code> instances. Let’s look at an example of implementing
the <code>Add</code> trait where we want to customize the <code>RHS</code> type rather than using the
default.</p>
<p>We have two structs, <code>Millimeters</code> and <code>Meters</code>, holding values in different
units. We want to add values in millimeters to values in meters and have the
implementation of <code>Add</code> do the conversion correctly. We can implement <code>Add</code> for
<code>Millimeters</code> with <code>Meters</code> as the <code>RHS</code>, as shown in Listing 19-15.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::ops::Add;

struct Millimeters(u32);
struct Meters(u32);

impl Add&lt;Meters&gt; for Millimeters {
    type Output = Millimeters;

    fn add(self, other: Meters) -&gt; Millimeters {
        Millimeters(self.0 + (other.0 * 1000))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-15: Implementing the <code>Add</code> trait on
<code>Millimeters</code> to add <code>Millimeters</code> to <code>Meters</code></span></p>
<p>To add <code>Millimeters</code> and <code>Meters</code>, we specify <code>impl Add&lt;Meters&gt;</code> to set the
value of the <code>RHS</code> type parameter instead of using the default of <code>Self</code>.</p>
<p>You’ll use default type parameters in two main ways:</p>
<ul>
<li>To extend a type without breaking existing code</li>
<li>To allow customization in specific cases most users won’t need</li>
</ul>
<p>The standard library’s <code>Add</code> trait is an example of the second purpose:
usually, you’ll add two like types, but the <code>Add</code> trait provides the ability to
customize beyond that. Using a default type parameter in the <code>Add</code> trait
definition means you don’t have to specify the extra parameter most of the
time. In other words, a bit of implementation boilerplate isn’t needed, making
it easier to use the trait.</p>
<p>The first purpose is similar to the second but in reverse: if you want to add a
type parameter to an existing trait, you can give it a default to allow
extension of the functionality of the trait without breaking the existing
implementation code.</p>
<h3><a class="header" href="#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name" id="fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name">Fully Qualified Syntax for Disambiguation: Calling Methods with the Same Name</a></h3>
<p>Nothing in Rust prevents a trait from having a method with the same name as
another trait’s method, nor does Rust prevent you from implementing both traits
on one type. It’s also possible to implement a method directly on the type with
the same name as methods from traits.</p>
<p>When calling methods with the same name, you’ll need to tell Rust which one you
want to use. Consider the code in Listing 19-16 where we’ve defined two traits,
<code>Pilot</code> and <code>Wizard</code>, that both have a method called <code>fly</code>. We then implement
both traits on a type <code>Human</code> that already has a method named <code>fly</code> implemented
on it. Each <code>fly</code> method does something different.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Pilot {
    fn fly(&amp;self);
}

trait Wizard {
    fn fly(&amp;self);
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) {
        println!(&quot;This is your captain speaking.&quot;);
    }
}

impl Wizard for Human {
    fn fly(&amp;self) {
        println!(&quot;Up!&quot;);
    }
}

impl Human {
    fn fly(&amp;self) {
        println!(&quot;*waving arms furiously*&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-16: Two traits are defined to have a <code>fly</code>
method and are implemented on the <code>Human</code> type, and a <code>fly</code> method is
implemented on <code>Human</code> directly</span></p>
<p>When we call <code>fly</code> on an instance of <code>Human</code>, the compiler defaults to calling
the method that is directly implemented on the type, as shown in Listing 19-17.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listing 19-17: Calling <code>fly</code> on an instance of
<code>Human</code></span></p>
<p>Running this code will print <code>*waving arms furiously*</code>, showing that Rust
called the <code>fly</code> method implemented on <code>Human</code> directly.</p>
<p>To call the <code>fly</code> methods from either the <code>Pilot</code> trait or the <code>Wizard</code> trait,
we need to use more explicit syntax to specify which <code>fly</code> method we mean.
Listing 19-18 demonstrates this syntax.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">trait Pilot {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait Wizard {
</span><span class="boring">    fn fly(&amp;self);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Human;
</span><span class="boring">
</span><span class="boring">impl Pilot for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;This is your captain speaking.&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wizard for Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;Up!&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Human {
</span><span class="boring">    fn fly(&amp;self) {
</span><span class="boring">        println!(&quot;*waving arms furiously*&quot;);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let person = Human;
    Pilot::fly(&amp;person);
    Wizard::fly(&amp;person);
    person.fly();
}
</code></pre></pre>
<p><span class="caption">Listing 19-18: Specifying which trait’s <code>fly</code> method we
want to call</span></p>
<p>Specifying the trait name before the method name clarifies to Rust which
implementation of <code>fly</code> we want to call. We could also write
<code>Human::fly(&amp;person)</code>, which is equivalent to the <code>person.fly()</code> that we used
in Listing 19-18, but this is a bit longer to write if we don’t need to
disambiguate.</p>
<p>Running this code prints the following:</p>
<pre><code class="language-text">This is your captain speaking.
Up!
*waving arms furiously*
</code></pre>
<p>Because the <code>fly</code> method takes a <code>self</code> parameter, if we had two <em>types</em> that
both implement one <em>trait</em>, Rust could figure out which implementation of a
trait to use based on the type of <code>self</code>.</p>
<p>However, associated functions that are part of traits don’t have a <code>self</code>
parameter. When two types in the same scope implement that trait, Rust can’t
figure out which type you mean unless you use <em>fully qualified syntax</em>. For
example, the <code>Animal</code> trait in Listing 19-19 has the associated function
<code>baby_name</code>, the implementation of <code>Animal</code> for the struct <code>Dog</code>, and the
associated function <code>baby_name</code> defined on <code>Dog</code> directly.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">trait Animal {
    fn baby_name() -&gt; String;
}

struct Dog;

impl Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;Spot&quot;)
    }
}

impl Animal for Dog {
    fn baby_name() -&gt; String {
        String::from(&quot;puppy&quot;)
    }
}

fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Dog::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listing 19-19: A trait with an associated function and a
type with an associated function of the same name that also implements the
trait</span></p>
<p>This code is for an animal shelter that wants to name all puppies Spot, which
is implemented in the <code>baby_name</code> associated function that is defined on <code>Dog</code>.
The <code>Dog</code> type also implements the trait <code>Animal</code>, which describes
characteristics that all animals have. Baby dogs are called puppies, and that
is expressed in the implementation of the <code>Animal</code> trait on <code>Dog</code> in the
<code>baby_name</code> function associated with the <code>Animal</code> trait.</p>
<p>In <code>main</code>, we call the <code>Dog::baby_name</code> function, which calls the associated
function defined on <code>Dog</code> directly. This code prints the following:</p>
<pre><code class="language-text">A baby dog is called a Spot
</code></pre>
<p>This output isn’t what we wanted. We want to call the <code>baby_name</code> function that
is part of the <code>Animal</code> trait that we implemented on <code>Dog</code> so the code prints
<code>A baby dog is called a puppy</code>. The technique of specifying the trait name that
we used in Listing 19-18 doesn’t help here; if we change <code>main</code> to the code in
Listing 19-20, we’ll get a compilation error.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn main() {
    println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
}
</code></pre>
<p><span class="caption">Listing 19-20: Attempting to call the <code>baby_name</code>
function from the <code>Animal</code> trait, but Rust doesn’t know which implementation to
use</span></p>
<p>Because <code>Animal::baby_name</code> is an associated function rather than a method, and
thus doesn’t have a <code>self</code> parameter, Rust can’t figure out which
implementation of <code>Animal::baby_name</code> we want. We’ll get this compiler error:</p>
<pre><code class="language-text">error[E0283]: type annotations required: cannot resolve `_: Animal`
  --&gt; src/main.rs:20:43
   |
20 |     println!(&quot;A baby dog is called a {}&quot;, Animal::baby_name());
   |                                           ^^^^^^^^^^^^^^^^^
   |
   = note: required by `Animal::baby_name`
</code></pre>
<p>To disambiguate and tell Rust that we want to use the implementation of
<code>Animal</code> for <code>Dog</code>, we need to use fully qualified syntax. Listing 19-21
demonstrates how to use fully qualified syntax.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">trait Animal {
</span><span class="boring">    fn baby_name() -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Dog;
</span><span class="boring">
</span><span class="boring">impl Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;Spot&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Animal for Dog {
</span><span class="boring">    fn baby_name() -&gt; String {
</span><span class="boring">        String::from(&quot;puppy&quot;)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    println!(&quot;A baby dog is called a {}&quot;, &lt;Dog as Animal&gt;::baby_name());
}
</code></pre></pre>
<p><span class="caption">Listing 19-21: Using fully qualified syntax to specify
that we want to call the <code>baby_name</code> function from the <code>Animal</code> trait as
implemented on <code>Dog</code></span></p>
<p>We’re providing Rust with a type annotation within the angle brackets, which
indicates we want to call the <code>baby_name</code> method from the <code>Animal</code> trait as
implemented on <code>Dog</code> by saying that we want to treat the <code>Dog</code> type as an
<code>Animal</code> for this function call. This code will now print what we want:</p>
<pre><code class="language-text">A baby dog is called a puppy
</code></pre>
<p>In general, fully qualified syntax is defined as follows:</p>
<pre><code class="language-rust ignore">&lt;Type as Trait&gt;::function(receiver_if_method, next_arg, ...);
</code></pre>
<p>For associated functions, there would not be a <code>receiver</code>: there would only be
the list of other arguments. You could use fully qualified syntax everywhere
that you call functions or methods. However, you’re allowed to omit any part of
this syntax that Rust can figure out from other information in the program. You
only need to use this more verbose syntax in cases where there are multiple
implementations that use the same name and Rust needs help to identify which
implementation you want to call.</p>
<h3><a class="header" href="#using-supertraits-to-require-one-traits-functionality-within-another-trait" id="using-supertraits-to-require-one-traits-functionality-within-another-trait">Using Supertraits to Require One Trait’s Functionality Within Another Trait</a></h3>
<p>Sometimes, you might need one trait to use another trait’s functionality. In
this case, you need to rely on the dependent trait also being implemented.
The trait you rely on is a <em>supertrait</em> of the trait you’re implementing.</p>
<p>For example, let’s say we want to make an <code>OutlinePrint</code> trait with an
<code>outline_print</code> method that will print a value framed in asterisks. That is,
given a <code>Point</code> struct that implements <code>Display</code> to result in <code>(x, y)</code>, when we
call <code>outline_print</code> on a <code>Point</code> instance that has <code>1</code> for <code>x</code> and <code>3</code> for
<code>y</code>, it should print the following:</p>
<pre><code class="language-text">**********
*        *
* (1, 3) *
*        *
**********
</code></pre>
<p>In the implementation of <code>outline_print</code>, we want to use the <code>Display</code> trait’s
functionality. Therefore, we need to specify that the <code>OutlinePrint</code> trait will
work only for types that also implement <code>Display</code> and provide the functionality
that <code>OutlinePrint</code> needs. We can do that in the trait definition by specifying
<code>OutlinePrint: Display</code>. This technique is similar to adding a trait bound to
the trait. Listing 19-22 shows an implementation of the <code>OutlinePrint</code> trait.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt;

trait OutlinePrint: fmt::Display {
    fn outline_print(&amp;self) {
        let output = self.to_string();
        let len = output.len();
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;* {} *&quot;, output);
        println!(&quot;*{}*&quot;, &quot; &quot;.repeat(len + 2));
        println!(&quot;{}&quot;, &quot;*&quot;.repeat(len + 4));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-22: Implementing the <code>OutlinePrint</code> trait that
requires the functionality from <code>Display</code></span></p>
<p>Because we’ve specified that <code>OutlinePrint</code> requires the <code>Display</code> trait, we
can use the <code>to_string</code> function that is automatically implemented for any type
that implements <code>Display</code>. If we tried to use <code>to_string</code> without adding a
colon and specifying the <code>Display</code> trait after the trait name, we’d get an
error saying that no method named <code>to_string</code> was found for the type <code>&amp;Self</code> in
the current scope.</p>
<p>Let’s see what happens when we try to implement <code>OutlinePrint</code> on a type that
doesn’t implement <code>Display</code>, such as the <code>Point</code> struct:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">trait OutlinePrint {}
</span>struct Point {
    x: i32,
    y: i32,
}

impl OutlinePrint for Point {}
<span class="boring">}
</span></code></pre></pre>
<p>We get an error saying that <code>Display</code> is required but not implemented:</p>
<pre><code class="language-text">error[E0277]: the trait bound `Point: std::fmt::Display` is not satisfied
  --&gt; src/main.rs:20:6
   |
20 | impl OutlinePrint for Point {}
   |      ^^^^^^^^^^^^ `Point` cannot be formatted with the default formatter;
try using `:?` instead if you are using a format string
   |
   = help: the trait `std::fmt::Display` is not implemented for `Point`
</code></pre>
<p>To fix this, we implement <code>Display</code> on <code>Point</code> and satisfy the constraint that
<code>OutlinePrint</code> requires, like so:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Point {
</span><span class="boring">    x: i32,
</span><span class="boring">    y: i32,
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt;

impl fmt::Display for Point {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;({}, {})&quot;, self.x, self.y)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Then implementing the <code>OutlinePrint</code> trait on <code>Point</code> will compile
successfully, and we can call <code>outline_print</code> on a <code>Point</code> instance to display
it within an outline of asterisks.</p>
<h3><a class="header" href="#using-the-newtype-pattern-to-implement-external-traits-on-external-types" id="using-the-newtype-pattern-to-implement-external-traits-on-external-types">Using the Newtype Pattern to Implement External Traits on External Types</a></h3>
<p>In Chapter 10 in the <a href="rustbook/ch10-02-traits.html#implementing-a-trait-on-a-type">“Implementing a Trait on a
Type”</a><!-- ignore --> section, we mentioned
the orphan rule that states we’re allowed to implement a trait on a type as
long as either the trait or the type are local to our crate. It’s possible to
get around this restriction using the <em>newtype pattern</em>, which involves
creating a new type in a tuple struct. (We covered tuple structs in the
<a href="rustbook/ch05-01-defining-structs.html#using-tuple-structs-without-named-fields-to-create-different-types">“Using Tuple Structs without Named Fields to Create Different
Types”</a><!-- ignore --> section of Chapter 5.) The tuple struct
will have one field and be a thin wrapper around the type we want to implement
a trait for. Then the wrapper type is local to our crate, and we can implement
the trait on the wrapper. <em>Newtype</em> is a term that originates from the Haskell
programming language. There is no runtime performance penalty for using this
pattern, and the wrapper type is elided at compile time.</p>
<p>As an example, let’s say we want to implement <code>Display</code> on <code>Vec&lt;T&gt;</code>, which the
orphan rule prevents us from doing directly because the <code>Display</code> trait and the
<code>Vec&lt;T&gt;</code> type are defined outside our crate. We can make a <code>Wrapper</code> struct
that holds an instance of <code>Vec&lt;T&gt;</code>; then we can implement <code>Display</code> on
<code>Wrapper</code> and use the <code>Vec&lt;T&gt;</code> value, as shown in Listing 19-23.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct Wrapper(Vec&lt;String&gt;);

impl fmt::Display for Wrapper {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;[{}]&quot;, self.0.join(&quot;, &quot;))
    }
}

fn main() {
    let w = Wrapper(vec![String::from(&quot;hello&quot;), String::from(&quot;world&quot;)]);
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<p><span class="caption">Listing 19-23: Creating a <code>Wrapper</code> type around
<code>Vec&lt;String&gt;</code> to implement <code>Display</code></span></p>
<p>The implementation of <code>Display</code> uses <code>self.0</code> to access the inner <code>Vec&lt;T&gt;</code>,
because <code>Wrapper</code> is a tuple struct and <code>Vec&lt;T&gt;</code> is the item at index 0 in the
tuple. Then we can use the functionality of the <code>Display</code> type on <code>Wrapper</code>.</p>
<p>The downside of using this technique is that <code>Wrapper</code> is a new type, so it
doesn’t have the methods of the value it’s holding. We would have to implement
all the methods of <code>Vec&lt;T&gt;</code> directly on <code>Wrapper</code> such that the methods
delegate to <code>self.0</code>, which would allow us to treat <code>Wrapper</code> exactly like a
<code>Vec&lt;T&gt;</code>. If we wanted the new type to have every method the inner type has,
implementing the <code>Deref</code> trait (discussed in Chapter 15 in the <a href="rustbook/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait">“Treating Smart
Pointers Like Regular References with the <code>Deref</code>
Trait”</a><!-- ignore --> section) on the <code>Wrapper</code> to return
the inner type would be a solution. If we don’t want the <code>Wrapper</code> type to have
all the methods of the inner type—for example, to restrict the <code>Wrapper</code> type’s
behavior—we would have to implement just the methods we do want manually.</p>
<p>Now you know how the newtype pattern is used in relation to traits; it’s also a
useful pattern even when traits are not involved. Let’s switch focus and look
at some advanced ways to interact with Rust’s type system.</p>
<h2><a class="header" href="#advanced-types" id="advanced-types">Advanced Types</a></h2>
<p>The Rust type system has some features that we’ve mentioned in this book but
haven’t yet discussed. We’ll start by discussing newtypes in general as we
examine why newtypes are useful as types. Then we’ll move on to type aliases, a
feature similar to newtypes but with slightly different semantics. We’ll also
discuss the <code>!</code> type and dynamically sized types.</p>
<blockquote>
<p>Note: The next section assumes you’ve read the earlier section <a href="rustbook/ch19-03-advanced-traits.html#using-the-newtype-pattern-to-implement-external-traits-on-external-types">“Using the
Newtype Pattern to Implement External Traits on External
Types.”</a><!-- ignore --></p>
</blockquote>
<h3><a class="header" href="#using-the-newtype-pattern-for-type-safety-and-abstraction" id="using-the-newtype-pattern-for-type-safety-and-abstraction">Using the Newtype Pattern for Type Safety and Abstraction</a></h3>
<p>The newtype pattern is useful for tasks beyond those we’ve discussed so far,
including statically enforcing that values are never confused and indicating
the units of a value. You saw an example of using newtypes to indicate units in
Listing 19-15: recall that the <code>Millimeters</code> and <code>Meters</code> structs wrapped <code>u32</code>
values in a newtype. If we wrote a function with a parameter of type
<code>Millimeters</code>, we couldn’t compile a program that accidentally tried to call
that function with a value of type <code>Meters</code> or a plain <code>u32</code>.</p>
<p>Another use of the newtype pattern is in abstracting away some implementation
details of a type: the new type can expose a public API that is different from
the API of the private inner type if we used the new type directly to restrict
the available functionality, for example.</p>
<p>Newtypes can also hide internal implementation. For example, we could provide a
<code>People</code> type to wrap a <code>HashMap&lt;i32, String&gt;</code> that stores a person’s ID
associated with their name. Code using <code>People</code> would only interact with the
public API we provide, such as a method to add a name string to the <code>People</code>
collection; that code wouldn’t need to know that we assign an <code>i32</code> ID to names
internally. The newtype pattern is a lightweight way to achieve encapsulation
to hide implementation details, which we discussed in the <a href="rustbook/ch17-01-what-is-oo.html#encapsulation-that-hides-implementation-details">“Encapsulation that
Hides Implementation
Details”</a><!-- ignore -->
section of Chapter 17.</p>
<h3><a class="header" href="#creating-type-synonyms-with-type-aliases" id="creating-type-synonyms-with-type-aliases">Creating Type Synonyms with Type Aliases</a></h3>
<p>Along with the newtype pattern, Rust provides the ability to declare a <em>type
alias</em> to give an existing type another name. For this we use the <code>type</code>
keyword. For example, we can create the alias <code>Kilometers</code> to <code>i32</code> like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;
<span class="boring">}
</span></code></pre></pre>
<p>Now, the alias <code>Kilometers</code> is a <em>synonym</em> for <code>i32</code>; unlike the <code>Millimeters</code>
and <code>Meters</code> types we created in Listing 19-15, <code>Kilometers</code> is not a separate,
new type. Values that have the type <code>Kilometers</code> will be treated the same as
values of type <code>i32</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type Kilometers = i32;

let x: i32 = 5;
let y: Kilometers = 5;

println!(&quot;x + y = {}&quot;, x + y);
<span class="boring">}
</span></code></pre></pre>
<p>Because <code>Kilometers</code> and <code>i32</code> are the same type, we can add values of both
types and we can pass <code>Kilometers</code> values to functions that take <code>i32</code>
parameters. However, using this method, we don’t get the type checking benefits
that we get from the newtype pattern discussed earlier.</p>
<p>The main use case for type synonyms is to reduce repetition. For example, we
might have a lengthy type like this:</p>
<pre><code class="language-rust ignore">Box&lt;dyn Fn() + Send + 'static&gt;
</code></pre>
<p>Writing this lengthy type in function signatures and as type annotations all
over the code can be tiresome and error prone. Imagine having a project full of
code like that in Listing 19-24.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let f: Box&lt;dyn Fn() + Send + 'static&gt; = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Box&lt;dyn Fn() + Send + 'static&gt;) {
    // --snip--
}

fn returns_long_type() -&gt; Box&lt;dyn Fn() + Send + 'static&gt; {
    // --snip--
<span class="boring">    Box::new(|| ())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-24: Using a long type in many places</span></p>
<p>A type alias makes this code more manageable by reducing the repetition. In
Listing 19-25, we’ve introduced an alias named <code>Thunk</code> for the verbose type and
can replace all uses of the type with the shorter alias <code>Thunk</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type Thunk = Box&lt;dyn Fn() + Send + 'static&gt;;

let f: Thunk = Box::new(|| println!(&quot;hi&quot;));

fn takes_long_type(f: Thunk) {
    // --snip--
}

fn returns_long_type() -&gt; Thunk {
    // --snip--
<span class="boring">    Box::new(|| ())
</span>}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-25: Introducing a type alias <code>Thunk</code> to reduce
repetition</span></p>
<p>This code is much easier to read and write! Choosing a meaningful name for a
type alias can help communicate your intent as well (<em>thunk</em> is a word for code
to be evaluated at a later time, so it’s an appropriate name for a closure that
gets stored).</p>
<p>Type aliases are also commonly used with the <code>Result&lt;T, E&gt;</code> type for reducing
repetition. Consider the <code>std::io</code> module in the standard library. I/O
operations often return a <code>Result&lt;T, E&gt;</code> to handle situations when operations
fail to work. This library has a <code>std::io::Error</code> struct that represents all
possible I/O errors. Many of the functions in <code>std::io</code> will be returning
<code>Result&lt;T, E&gt;</code> where the <code>E</code> is <code>std::io::Error</code>, such as these functions in
the <code>Write</code> trait:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io::Error;
use std::fmt;

pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize, Error&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;(), Error&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;(), Error&gt;;
    fn write_fmt(&amp;mut self, fmt: fmt::Arguments) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Result&lt;..., Error&gt;</code> is repeated a lot. As such, <code>std::io</code> has this type of
alias declaration:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type Result&lt;T&gt; = std::result::Result&lt;T, std::io::Error&gt;;
<span class="boring">}
</span></code></pre></pre>
<p>Because this declaration is in the <code>std::io</code> module, we can use the fully
qualified alias <code>std::io::Result&lt;T&gt;</code>—that is, a <code>Result&lt;T, E&gt;</code> with the <code>E</code>
filled in as <code>std::io::Error</code>. The <code>Write</code> trait function signatures end up
looking like this:</p>
<pre><code class="language-rust ignore">pub trait Write {
    fn write(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;usize&gt;;
    fn flush(&amp;mut self) -&gt; Result&lt;()&gt;;

    fn write_all(&amp;mut self, buf: &amp;[u8]) -&gt; Result&lt;()&gt;;
    fn write_fmt(&amp;mut self, fmt: Arguments) -&gt; Result&lt;()&gt;;
}
</code></pre>
<p>The type alias helps in two ways: it makes code easier to write <em>and</em> it gives
us a consistent interface across all of <code>std::io</code>. Because it’s an alias, it’s
just another <code>Result&lt;T, E&gt;</code>, which means we can use any methods that work on
<code>Result&lt;T, E&gt;</code> with it, as well as special syntax like the <code>?</code> operator.</p>
<h3><a class="header" href="#the-never-type-that-never-returns" id="the-never-type-that-never-returns">The Never Type that Never Returns</a></h3>
<p>Rust has a special type named <code>!</code> that’s known in type theory lingo as the
<em>empty type</em> because it has no values. We prefer to call it the <em>never type</em>
because it stands in the place of the return type when a function will never
return. Here is an example:</p>
<pre><code class="language-rust ignore">fn bar() -&gt; ! {
    // --snip--
}
</code></pre>
<p>This code is read as “the function <code>bar</code> returns never.” Functions that return
never are called <em>diverging functions</em>. We can’t create values of the type <code>!</code>
so <code>bar</code> can never possibly return.</p>
<p>But what use is a type you can never create values for? Recall the code from
Listing 2-5; we’ve reproduced part of it here in Listing 19-26.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let guess = &quot;3&quot;;
</span><span class="boring">loop {
</span>let guess: u32 = match guess.trim().parse() {
    Ok(num) =&gt; num,
    Err(_) =&gt; continue,
};
<span class="boring">break;
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-26: A <code>match</code> with an arm that ends in
<code>continue</code></span></p>
<p>At the time, we skipped over some details in this code. In Chapter 6 in <a href="rustbook/ch06-02-match.html#the-match-control-flow-operator">“The
<code>match</code> Control Flow Operator”</a><!-- ignore
--> section, we discussed that <code>match</code> arms must all return the same type. So,
for example, the following code doesn’t work:</p>
<pre><code class="language-rust ignore does_not_compile">let guess = match guess.trim().parse() {
    Ok(_) =&gt; 5,
    Err(_) =&gt; &quot;hello&quot;,
}
</code></pre>
<p>The type of <code>guess</code> in this code would have to be an integer <em>and</em> a string,
and Rust requires that <code>guess</code> have only one type. So what does <code>continue</code>
return? How were we allowed to return a <code>u32</code> from one arm and have another arm
that ends with <code>continue</code> in Listing 19-26?</p>
<p>As you might have guessed, <code>continue</code> has a <code>!</code> value. That is, when Rust
computes the type of <code>guess</code>, it looks at both match arms, the former with a
value of <code>u32</code> and the latter with a <code>!</code> value. Because <code>!</code> can never have a
value, Rust decides that the type of <code>guess</code> is <code>u32</code>.</p>
<p>The formal way of describing this behavior is that expressions of type <code>!</code> can
be coerced into any other type. We’re allowed to end this <code>match</code> arm with
<code>continue</code> because <code>continue</code> doesn’t return a value; instead, it moves control
back to the top of the loop, so in the <code>Err</code> case, we never assign a value to
<code>guess</code>.</p>
<p>The never type is useful with the <code>panic!</code> macro as well. Remember the <code>unwrap</code>
function that we call on <code>Option&lt;T&gt;</code> values to produce a value or panic? Here
is its definition:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Option&lt;T&gt; {
    pub fn unwrap(self) -&gt; T {
        match self {
            Some(val) =&gt; val,
            None =&gt; panic!(&quot;called `Option::unwrap()` on a `None` value&quot;),
        }
    }
}
</code></pre>
<p>In this code, the same thing happens as in the <code>match</code> in Listing 19-26: Rust
sees that <code>val</code> has the type <code>T</code> and <code>panic!</code> has the type <code>!</code>, so the result
of the overall <code>match</code> expression is <code>T</code>. This code works because <code>panic!</code>
doesn’t produce a value; it ends the program. In the <code>None</code> case, we won’t be
returning a value from <code>unwrap</code>, so this code is valid.</p>
<p>One final expression that has the type <code>!</code> is a <code>loop</code>:</p>
<pre><code class="language-rust ignore">print!(&quot;forever &quot;);

loop {
    print!(&quot;and ever &quot;);
}
</code></pre>
<p>Here, the loop never ends, so <code>!</code> is the value of the expression. However, this
wouldn’t be true if we included a <code>break</code>, because the loop would terminate
when it got to the <code>break</code>.</p>
<h3><a class="header" href="#dynamically-sized-types-and-the-sized-trait" id="dynamically-sized-types-and-the-sized-trait">Dynamically Sized Types and the <code>Sized</code> Trait</a></h3>
<p>Due to Rust’s need to know certain details, such as how much space to allocate
for a value of a particular type, there is a corner of its type system that can
be confusing: the concept of <em>dynamically sized types</em>. Sometimes referred to
as <em>DSTs</em> or <em>unsized types</em>, these types let us write code using values whose
size we can know only at runtime.</p>
<p>Let’s dig into the details of a dynamically sized type called <code>str</code>, which
we’ve been using throughout the book. That’s right, not <code>&amp;str</code>, but <code>str</code> on
its own, is a DST. We can’t know how long the string is until runtime, meaning
we can’t create a variable of type <code>str</code>, nor can we take an argument of type
<code>str</code>. Consider the following code, which does not work:</p>
<pre><code class="language-rust ignore does_not_compile">let s1: str = &quot;Hello there!&quot;;
let s2: str = &quot;How's it going?&quot;;
</code></pre>
<p>Rust needs to know how much memory to allocate for any value of a particular
type, and all values of a type must use the same amount of memory. If Rust
allowed us to write this code, these two <code>str</code> values would need to take up the
same amount of space. But they have different lengths: <code>s1</code> needs 12 bytes of
storage and <code>s2</code> needs 15. This is why it’s not possible to create a variable
holding a dynamically sized type.</p>
<p>So what do we do? In this case, you already know the answer: we make the types
of <code>s1</code> and <code>s2</code> a <code>&amp;str</code> rather than a <code>str</code>. Recall that in the <a href="rustbook/ch04-03-slices.html#string-slices">“String
Slices”</a><!-- ignore --> section of Chapter 4, we said the slice
data structure stores the starting position and the length of the slice.</p>
<p>So although a <code>&amp;T</code> is a single value that stores the memory address of where
the <code>T</code> is located, a <code>&amp;str</code> is <em>two</em> values: the address of the <code>str</code> and its
length. As such, we can know the size of a <code>&amp;str</code> value at compile time: it’s
twice the length of a <code>usize</code>. That is, we always know the size of a <code>&amp;str</code>, no
matter how long the string it refers to is. In general, this is the way in
which dynamically sized types are used in Rust: they have an extra bit of
metadata that stores the size of the dynamic information. The golden rule of
dynamically sized types is that we must always put values of dynamically sized
types behind a pointer of some kind.</p>
<p>We can combine <code>str</code> with all kinds of pointers: for example, <code>Box&lt;str&gt;</code> or
<code>Rc&lt;str&gt;</code>. In fact, you’ve seen this before but with a different dynamically
sized type: traits. Every trait is a dynamically sized type we can refer to by
using the name of the trait. In Chapter 17 in the <a href="rustbook/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects That
Allow for Values of Different
Types”</a><!--
ignore --> section, we mentioned that to use traits as trait objects, we must
put them behind a pointer, such as <code>&amp;dyn Trait</code> or <code>Box&lt;dyn Trait&gt;</code> (<code>Rc&lt;dyn Trait&gt;</code> would work too).</p>
<p>To work with DSTs, Rust has a particular trait called the <code>Sized</code> trait to
determine whether or not a type’s size is known at compile time. This trait is
automatically implemented for everything whose size is known at compile time.
In addition, Rust implicitly adds a bound on <code>Sized</code> to every generic function.
That is, a generic function definition like this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>is actually treated as though we had written this:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: Sized&gt;(t: T) {
    // --snip--
}
</code></pre>
<p>By default, generic functions will work only on types that have a known size at
compile time. However, you can use the following special syntax to relax this
restriction:</p>
<pre><code class="language-rust ignore">fn generic&lt;T: ?Sized&gt;(t: &amp;T) {
    // --snip--
}
</code></pre>
<p>A trait bound on <code>?Sized</code> is the opposite of a trait bound on <code>Sized</code>: we would
read this as “<code>T</code> may or may not be <code>Sized</code>.” This syntax is only available for
<code>Sized</code>, not any other traits.</p>
<p>Also note that we switched the type of the <code>t</code> parameter from <code>T</code> to <code>&amp;T</code>.
Because the type might not be <code>Sized</code>, we need to use it behind some kind of
pointer. In this case, we’ve chosen a reference.</p>
<p>Next, we’ll talk about functions and closures!</p>
<h2><a class="header" href="#advanced-functions-and-closures" id="advanced-functions-and-closures">Advanced Functions and Closures</a></h2>
<p>Finally, we’ll explore some advanced features related to functions and
closures, which include function pointers and returning closures.</p>
<h3><a class="header" href="#function-pointers" id="function-pointers">Function Pointers</a></h3>
<p>We’ve talked about how to pass closures to functions; you can also pass regular
functions to functions! This technique is useful when you want to pass a
function you’ve already defined rather than defining a new closure. Doing this
with function pointers will allow you to use functions as arguments to other
functions. Functions coerce to the type <code>fn</code> (with a lowercase f), not to be
confused with the <code>Fn</code> closure trait. The <code>fn</code> type is called a <em>function
pointer</em>. The syntax for specifying that a parameter is a function pointer is
similar to that of closures, as shown in Listing 19-27.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn add_one(x: i32) -&gt; i32 {
    x + 1
}

fn do_twice(f: fn(i32) -&gt; i32, arg: i32) -&gt; i32 {
    f(arg) + f(arg)
}

fn main() {
    let answer = do_twice(add_one, 5);

    println!(&quot;The answer is: {}&quot;, answer);
}
</code></pre></pre>
<p><span class="caption">Listing 19-27: Using the <code>fn</code> type to accept a function
pointer as an argument</span></p>
<p>This code prints <code>The answer is: 12</code>. We specify that the parameter <code>f</code> in
<code>do_twice</code> is an <code>fn</code> that takes one parameter of type <code>i32</code> and returns an
<code>i32</code>. We can then call <code>f</code> in the body of <code>do_twice</code>. In <code>main</code>, we can pass
the function name <code>add_one</code> as the first argument to <code>do_twice</code>.</p>
<p>Unlike closures, <code>fn</code> is a type rather than a trait, so we specify <code>fn</code> as the
parameter type directly rather than declaring a generic type parameter with one
of the <code>Fn</code> traits as a trait bound.</p>
<p>Function pointers implement all three of the closure traits (<code>Fn</code>, <code>FnMut</code>, and
<code>FnOnce</code>), so you can always pass a function pointer as an argument for a
function that expects a closure. It’s best to write functions using a generic
type and one of the closure traits so your functions can accept either
functions or closures.</p>
<p>An example of where you would want to only accept <code>fn</code> and not closures is when
interfacing with external code that doesn’t have closures: C functions can
accept functions as arguments, but C doesn’t have closures.</p>
<p>As an example of where you could use either a closure defined inline or a named
function, let’s look at a use of <code>map</code>. To use the <code>map</code> function to turn a
vector of numbers into a vector of strings, we could use a closure, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(|i| i.to_string())
    .collect();
<span class="boring">}
</span></code></pre></pre>
<p>Or we could name a function as the argument to <code>map</code> instead of the closure,
like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let list_of_numbers = vec![1, 2, 3];
let list_of_strings: Vec&lt;String&gt; = list_of_numbers
    .iter()
    .map(ToString::to_string)
    .collect();
<span class="boring">}
</span></code></pre></pre>
<p>Note that we must use the fully qualified syntax that we talked about earlier
in the <a href="rustbook/ch19-03-advanced-traits.html#advanced-traits">“Advanced Traits”</a><!-- ignore --> section because
there are multiple functions available named <code>to_string</code>. Here, we’re using the
<code>to_string</code> function defined in the <code>ToString</code> trait, which the standard
library has implemented for any type that implements <code>Display</code>.</p>
<p>We have another useful pattern that exploits an implementation detail of tuple
structs and tuple-struct enum variants. These types use <code>()</code> as initializer
syntax, which looks like a function call. The initializers are actually
implemented as functions returning an instance that’s constructed from their
arguments. We can use these initializer functions as function pointers that
implement the closure traits, which means we can specify the initializer
functions as arguments for methods that take closures, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Status {
    Value(u32),
    Stop,
}

let list_of_statuses: Vec&lt;Status&gt; =
    (0u32..20)
    .map(Status::Value)
    .collect();
<span class="boring">}
</span></code></pre></pre>
<p>Here we create <code>Status::Value</code> instances using each <code>u32</code> value in the range
that <code>map</code> is called on by using the initializer function of <code>Status::Value</code>.
Some people prefer this style, and some people prefer to use closures. They
compile to the same code, so use whichever style is clearer to you.</p>
<h3><a class="header" href="#returning-closures" id="returning-closures">Returning Closures</a></h3>
<p>Closures are represented by traits, which means you can’t return closures
directly. In most cases where you might want to return a trait, you can instead
use the concrete type that implements the trait as the return value of the
function. But you can’t do that with closures because they don’t have a
concrete type that is returnable; you’re not allowed to use the function
pointer <code>fn</code> as a return type, for example.</p>
<p>The following code tries to return a closure directly, but it won’t compile:</p>
<pre><code class="language-rust ignore does_not_compile">fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
    |x| x + 1
}
</code></pre>
<p>The compiler error is as follows:</p>
<pre><code class="language-text">error[E0277]: the trait bound `std::ops::Fn(i32) -&gt; i32 + 'static:
std::marker::Sized` is not satisfied
 --&gt;
  |
1 | fn returns_closure() -&gt; Fn(i32) -&gt; i32 {
  |                         ^^^^^^^^^^^^^^ `std::ops::Fn(i32) -&gt; i32 + 'static`
  does not have a constant size known at compile-time
  |
  = help: the trait `std::marker::Sized` is not implemented for
  `std::ops::Fn(i32) -&gt; i32 + 'static`
  = note: the return type of a function must have a statically known size
</code></pre>
<p>The error references the <code>Sized</code> trait again! Rust doesn’t know how much space
it will need to store the closure. We saw a solution to this problem earlier.
We can use a trait object:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<p>This code will compile just fine. For more about trait objects, refer to the
section <a href="rustbook/ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">“Using Trait Objects That Allow for Values of Different
Types”</a><!--
ignore --> in Chapter 17.</p>
<p>Next, let’s look at macros!</p>
<h2><a class="header" href="#macros" id="macros">Macros</a></h2>
<p>We’ve used macros like <code>println!</code> throughout this book, but we haven’t fully
explored what a macro is and how it works. The term <em>macro</em> refers to a family
of features in Rust: <em>declarative</em> macros with <code>macro_rules!</code> and three kinds
of <em>procedural</em> macros:</p>
<ul>
<li>Custom <code>#[derive]</code> macros that specify code added with the <code>derive</code> attribute
used on structs and enums</li>
<li>Attribute-like macros that define custom attributes usable on any item</li>
<li>Function-like macros that look like function calls but operate on the tokens
specified as their argument</li>
</ul>
<p>We’ll talk about each of these in turn, but first, let’s look at why we even
need macros when we already have functions.</p>
<h3><a class="header" href="#the-difference-between-macros-and-functions" id="the-difference-between-macros-and-functions">The Difference Between Macros and Functions</a></h3>
<p>Fundamentally, macros are a way of writing code that writes other code, which
is known as <em>metaprogramming</em>. In Appendix C, we discuss the <code>derive</code>
attribute, which generates an implementation of various traits for you. We’ve
also used the <code>println!</code> and <code>vec!</code> macros throughout the book. All of these
macros <em>expand</em> to produce more code than the code you’ve written manually.</p>
<p>Metaprogramming is useful for reducing the amount of code you have to write and
maintain, which is also one of the roles of functions. However, macros have
some additional powers that functions don’t.</p>
<p>A function signature must declare the number and type of parameters the
function has. Macros, on the other hand, can take a variable number of
parameters: we can call <code>println!(&quot;hello&quot;)</code> with one argument or
<code>println!(&quot;hello {}&quot;, name)</code> with two arguments. Also, macros are expanded
before the compiler interprets the meaning of the code, so a macro can, for
example, implement a trait on a given type. A function can’t, because it gets
called at runtime and a trait needs to be implemented at compile time.</p>
<p>The downside to implementing a macro instead of a function is that macro
definitions are more complex than function definitions because you’re writing
Rust code that writes Rust code. Due to this indirection, macro definitions are
generally more difficult to read, understand, and maintain than function
definitions.</p>
<p>Another important difference between macros and functions is that you must
define macros or bring them into scope <em>before</em> you call them in a file, as
opposed to functions you can define anywhere and call anywhere.</p>
<h3><a class="header" href="#declarative-macros-with-macro_rules-for-general-metaprogramming" id="declarative-macros-with-macro_rules-for-general-metaprogramming">Declarative Macros with <code>macro_rules!</code> for General Metaprogramming</a></h3>
<p>The most widely used form of macros in Rust is <em>declarative macros</em>. These are
also sometimes referred to as “macros by example,” “<code>macro_rules!</code> macros,” or
just plain “macros.” At their core, declarative macros allow you to write
something similar to a Rust <code>match</code> expression. As discussed in Chapter 6,
<code>match</code> expressions are control structures that take an expression, compare the
resulting value of the expression to patterns, and then run the code associated
with the matching pattern. Macros also compare a value to patterns that are
associated with particular code: in this situation, the value is the literal
Rust source code passed to the macro; the patterns are compared with the
structure of that source code; and the code associated with each pattern, when
matched, replaces the code passed to the macro. This all happens during
compilation.</p>
<p>To define a macro, you use the <code>macro_rules!</code> construct. Let’s explore how to
use <code>macro_rules!</code> by looking at how the <code>vec!</code> macro is defined. Chapter 8
covered how we can use the <code>vec!</code> macro to create a new vector with particular
values. For example, the following macro creates a new vector containing three
integers:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;u32&gt; = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p>We could also use the <code>vec!</code> macro to make a vector of two integers or a vector
of five string slices. We wouldn’t be able to use a function to do the same
because we wouldn’t know the number or type of values up front.</p>
<p>Listing 19-28 shows a slightly simplified definition of the <code>vec!</code> macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! vec {
    ( $( $x:expr ),* ) =&gt; {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )*
            temp_vec
        }
    };
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 19-28: A simplified version of the <code>vec!</code> macro
definition</span></p>
<blockquote>
<p>Note: The actual definition of the <code>vec!</code> macro in the standard library
includes code to preallocate the correct amount of memory up front. That code
is an optimization that we don’t include here to make the example simpler.</p>
</blockquote>
<p>The <code>#[macro_export]</code> annotation indicates that this macro should be made
available whenever the crate in which the macro is defined is brought into
scope. Without this annotation, the macro can’t be brought into scope.</p>
<p>We then start the macro definition with <code>macro_rules!</code> and the name of the
macro we’re defining <em>without</em> the exclamation mark. The name, in this case
<code>vec</code>, is followed by curly brackets denoting the body of the macro definition.</p>
<p>The structure in the <code>vec!</code> body is similar to the structure of a <code>match</code>
expression. Here we have one arm with the pattern <code>( $( $x:expr ),* )</code>,
followed by <code>=&gt;</code> and the block of code associated with this pattern. If the
pattern matches, the associated block of code will be emitted. Given that this
is the only pattern in this macro, there is only one valid way to match; any
other pattern will result in an error. More complex macros will have more than
one arm.</p>
<p>Valid pattern syntax in macro definitions is different than the pattern syntax
covered in Chapter 18 because macro patterns are matched against Rust code
structure rather than values. Let’s walk through what the pattern pieces in
Listing 19-28 mean; for the full macro pattern syntax, see <a href="rustbook/../reference/macros.html">the reference</a>.</p>
<p>First, a set of parentheses encompasses the whole pattern. A dollar sign (<code>$</code>)
is next, followed by a set of parentheses that captures values that match the
pattern within the parentheses for use in the replacement code. Within <code>$()</code> is
<code>$x:expr</code>, which matches any Rust expression and gives the expression the name
<code>$x</code>.</p>
<p>The comma following <code>$()</code> indicates that a literal comma separator character
could optionally appear after the code that matches the code in <code>$()</code>. The <code>*</code>
specifies that the pattern matches zero or more of whatever precedes the <code>*</code>.</p>
<p>When we call this macro with <code>vec![1, 2, 3];</code>, the <code>$x</code> pattern matches three
times with the three expressions <code>1</code>, <code>2</code>, and <code>3</code>.</p>
<p>Now let’s look at the pattern in the body of the code associated with this arm:
<code>temp_vec.push()</code> within <code>$()*</code> is generated for each part that matches <code>$()</code>
in the pattern zero or more times depending on how many times the pattern
matches. The <code>$x</code> is replaced with each expression matched. When we call this
macro with <code>vec![1, 2, 3];</code>, the code generated that replaces this macro call
will be the following:</p>
<pre><code class="language-rust ignore">let mut temp_vec = Vec::new();
temp_vec.push(1);
temp_vec.push(2);
temp_vec.push(3);
temp_vec
</code></pre>
<p>We’ve defined a macro that can take any number of arguments of any type and can
generate code to create a vector containing the specified elements.</p>
<p>There are some strange edge cases with <code>macro_rules!</code>. In the future, Rust will
have a second kind of declarative macro that will work in a similar fashion but
fix some of these edge cases. After that update, <code>macro_rules!</code> will be
effectively deprecated. With this in mind, as well as the fact that most Rust
programmers will <em>use</em> macros more than <em>write</em> macros, we won’t discuss
<code>macro_rules!</code> any further. To learn more about how to write macros, consult
the online documentation or other resources, such as <a href="https://danielkeep.github.io/tlborm/book/index.html">“The Little Book of Rust
Macros”</a>.</p>
<h3><a class="header" href="#procedural-macros-for-generating-code-from-attributes" id="procedural-macros-for-generating-code-from-attributes">Procedural Macros for Generating Code from Attributes</a></h3>
<p>The second form of macros is <em>procedural macros</em>, which act more like functions
(and are a type of procedure). Procedural macros accept some code as an input,
operate on that code, and produce some code as an output rather than matching
against patterns and replacing the code with other code as declarative macros
do.</p>
<p>The three kinds of procedural macros (custom derive, attribute-like, and
function-like) all work in a similar fashion.</p>
<p>When creating procedural macros, the definitions must reside in their own crate
with a special crate type. This is for complex technical reasons that we hope
to eliminate in the future. Using procedural macros looks like the code in
Listing 19-29, where <code>some_attribute</code> is a placeholder for using a specific
macro.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">use proc_macro;

#[some_attribute]
pub fn some_name(input: TokenStream) -&gt; TokenStream {
}
</code></pre>
<p><span class="caption">Listing 19-29: An example of using a procedural
macro</span></p>
<p>The function that defines a procedural macro takes a <code>TokenStream</code> as an input
and produces a <code>TokenStream</code> as an output. The <code>TokenStream</code> type is defined by
the <code>proc_macro</code> crate that is included with Rust and represents a sequence of
tokens. This is the core of the macro: the source code that the macro is
operating on makes up the input <code>TokenStream</code>, and the code the macro produces
is the output <code>TokenStream</code>. The function also has an attribute attached to it
that specifies which kind of procedural macro we’re creating. We can have
multiple kinds of procedural macros in the same crate.</p>
<p>Let’s look at the different kinds of procedural macros. We’ll start with a
custom derive macro and then explain the small dissimilarities that make the
other forms different.</p>
<h3><a class="header" href="#how-to-write-a-custom-derive-macro" id="how-to-write-a-custom-derive-macro">How to Write a Custom <code>derive</code> Macro</a></h3>
<p>Let’s create a crate named <code>hello_macro</code> that defines a trait named
<code>HelloMacro</code> with one associated function named <code>hello_macro</code>. Rather than
making our crate users implement the <code>HelloMacro</code> trait for each of their
types, we’ll provide a procedural macro so users can annotate their type with
<code>#[derive(HelloMacro)]</code> to get a default implementation of the <code>hello_macro</code>
function. The default implementation will print <code>Hello, Macro! My name is TypeName!</code> where <code>TypeName</code> is the name of the type on which this trait has
been defined. In other words, we’ll write a crate that enables another
programmer to write code like Listing 19-30 using our crate.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro;

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p><span class="caption">Listing 19-30: The code a user of our crate will be able
to write when using our procedural macro</span></p>
<p>This code will print <code>Hello, Macro! My name is Pancakes!</code> when we’re done. The
first step is to make a new library crate, like this:</p>
<pre><code class="language-text">$ cargo new hello_macro --lib
</code></pre>
<p>Next, we’ll define the <code>HelloMacro</code> trait and its associated function:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait HelloMacro {
    fn hello_macro();
}
<span class="boring">}
</span></code></pre></pre>
<p>We have a trait and its function. At this point, our crate user could implement
the trait to achieve the desired functionality, like so:</p>
<pre><code class="language-rust ignore">use hello_macro::HelloMacro;

struct Pancakes;

impl HelloMacro for Pancakes {
    fn hello_macro() {
        println!(&quot;Hello, Macro! My name is Pancakes!&quot;);
    }
}

fn main() {
    Pancakes::hello_macro();
}
</code></pre>
<p>However, they would need to write the implementation block for each type they
wanted to use with <code>hello_macro</code>; we want to spare them from having to do this
work.</p>
<p>Additionally, we can’t yet provide the <code>hello_macro</code> function with default
implementation that will print the name of the type the trait is implemented
on: Rust doesn’t have reflection capabilities, so it can’t look up the type’s
name at runtime. We need a macro to generate code at compile time.</p>
<p>The next step is to define the procedural macro. At the time of this writing,
procedural macros need to be in their own crate. Eventually, this restriction
might be lifted. The convention for structuring crates and macro crates is as
follows: for a crate named <code>foo</code>, a custom derive procedural macro crate is
called <code>foo_derive</code>. Let’s start a new crate called <code>hello_macro_derive</code> inside
our <code>hello_macro</code> project:</p>
<pre><code class="language-text">$ cargo new hello_macro_derive --lib
</code></pre>
<p>Our two crates are tightly related, so we create the procedural macro crate
within the directory of our <code>hello_macro</code> crate. If we change the trait
definition in <code>hello_macro</code>, we’ll have to change the implementation of the
procedural macro in <code>hello_macro_derive</code> as well. The two crates will need to
be published separately, and programmers using these crates will need to add
both as dependencies and bring them both into scope. We could instead have the
<code>hello_macro</code> crate use <code>hello_macro_derive</code> as a dependency and re-export the
procedural macro code. However, the way we’ve structured the project makes it
possible for programmers to use <code>hello_macro</code> even if they don’t want the
<code>derive</code> functionality.</p>
<p>We need to declare the <code>hello_macro_derive</code> crate as a procedural macro crate.
We’ll also need functionality from the <code>syn</code> and <code>quote</code> crates, as you’ll see
in a moment, so we need to add them as dependencies. Add the following to the
<em>Cargo.toml</em> file for <code>hello_macro_derive</code>:</p>
<p><span class="filename">Filename: hello_macro_derive/Cargo.toml</span></p>
<pre><code class="language-toml">[lib]
proc-macro = true

[dependencies]
syn = &quot;0.14.4&quot;
quote = &quot;0.6.3&quot;
</code></pre>
<p>To start defining the procedural macro, place the code in Listing 19-31 into
your <em>src/lib.rs</em> file for the <code>hello_macro_derive</code> crate. Note that this code
won’t compile until we add a definition for the <code>impl_hello_macro</code> function.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<!--
This usage of `extern crate` is required for the moment with 1.31.0, see:
https://github.com/rust-lang/rust/issues/54418
https://github.com/rust-lang/rust/pull/54658
https://github.com/rust-lang/rust/issues/55599
-->
<pre><code class="language-rust ignore">extern crate proc_macro;

use crate::proc_macro::TokenStream;
use quote::quote;
use syn;

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -&gt; TokenStream {
    // Construct a representation of Rust code as a syntax tree
    // that we can manipulate
    let ast = syn::parse(input).unwrap();

    // Build the trait implementation
    impl_hello_macro(&amp;ast)
}
</code></pre>
<p><span class="caption">Listing 19-31: Code that most procedural macro crates
will require in order to process Rust code</span></p>
<p>Notice that we’ve split the code into the <code>hello_macro_derive</code> function, which
is responsible for parsing the <code>TokenStream</code>, and the <code>impl_hello_macro</code>
function, which is responsible for transforming the syntax tree: this makes
writing a procedural macro more convenient. The code in the outer function
(<code>hello_macro_derive</code> in this case) will be the same for almost every
procedural macro crate you see or create. The code you specify in the body of
the inner function (<code>impl_hello_macro</code> in this case) will be different
depending on your procedural macro’s purpose.</p>
<p>We’ve introduced three new crates: <code>proc_macro</code>, <a href="https://crates.io/crates/syn"><code>syn</code></a>, and <a href="https://crates.io/crates/quote"><code>quote</code></a>. The
<code>proc_macro</code> crate comes with Rust, so we didn’t need to add that to the
dependencies in <em>Cargo.toml</em>. The <code>proc_macro</code> crate is the compiler’s API that
allows us to read and manipulate Rust code from our code.</p>
<p>The <code>syn</code> crate parses Rust code from a string into a data structure that we
can perform operations on. The <code>quote</code> crate turns <code>syn</code> data structures back
into Rust code. These crates make it much simpler to parse any sort of Rust
code we might want to handle: writing a full parser for Rust code is no simple
task.</p>
<p>The <code>hello_macro_derive</code> function will be called when a user of our library
specifies <code>#[derive(HelloMacro)]</code> on a type. This is possible because we’ve
annotated the <code>hello_macro_derive</code> function here with <code>proc_macro_derive</code> and
specified the name, <code>HelloMacro</code>, which matches our trait name; this is the
convention most procedural macros follow.</p>
<p>The <code>hello_macro_derive</code> function first converts the <code>input</code> from a
<code>TokenStream</code> to a data structure that we can then interpret and perform
operations on. This is where <code>syn</code> comes into play. The <code>parse</code> function in
<code>syn</code> takes a <code>TokenStream</code> and returns a <code>DeriveInput</code> struct representing the
parsed Rust code. Listing 19-32 shows the relevant parts of the <code>DeriveInput</code>
struct we get from parsing the <code>struct Pancakes;</code> string:</p>
<pre><code class="language-rust ignore">DeriveInput {
    // --snip--

    ident: Ident {
        ident: &quot;Pancakes&quot;,
        span: #0 bytes(95..103)
    },
    data: Struct(
        DataStruct {
            struct_token: Struct,
            fields: Unit,
            semi_token: Some(
                Semi
            )
        }
    )
}
</code></pre>
<p><span class="caption">Listing 19-32: The <code>DeriveInput</code> instance we get when
parsing the code that has the macro’s attribute in Listing 19-30</span></p>
<p>The fields of this struct show that the Rust code we’ve parsed is a unit struct
with the <code>ident</code> (identifier, meaning the name) of <code>Pancakes</code>. There are more
fields on this struct for describing all sorts of Rust code; check the <a href="https://docs.rs/syn/0.14.4/syn/struct.DeriveInput.html"><code>syn</code>
documentation for <code>DeriveInput</code></a> for more information.</p>
<p>Soon we’ll define the <code>impl_hello_macro</code> function, which is where we’ll build
the new Rust code we want to include. But before we do, note that the output
for our derive macro is also a <code>TokenStream</code>. The returned <code>TokenStream</code> is
added to the code that our crate users write, so when they compile their crate,
they’ll get the extra functionality that we provide in the modified
<code>TokenStream</code>.</p>
<p>You might have noticed that we’re calling <code>unwrap</code> to cause the
<code>hello_macro_derive</code> function to panic if the call to the <code>syn::parse</code> function
fails here. It’s necessary for our procedural macro to panic on errors because
<code>proc_macro_derive</code> functions must return <code>TokenStream</code> rather than <code>Result</code> to
conform to the procedural macro API. We’ve simplified this example by using
<code>unwrap</code>; in production code, you should provide more specific error messages
about what went wrong by using <code>panic!</code> or <code>expect</code>.</p>
<p>Now that we have the code to turn the annotated Rust code from a <code>TokenStream</code>
into a <code>DeriveInput</code> instance, let’s generate the code that implements the
<code>HelloMacro</code> trait on the annotated type, as shown in Listing 19-33.</p>
<p><span class="filename">Filename: hello_macro_derive/src/lib.rs</span></p>
<pre><code class="language-rust ignore">fn impl_hello_macro(ast: &amp;syn::DeriveInput) -&gt; TokenStream {
    let name = &amp;ast.ident;
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!(&quot;Hello, Macro! My name is {}&quot;, stringify!(#name));
            }
        }
    };
    gen.into()
}
</code></pre>
<p><span class="caption">Listing 19-33: Implementing the <code>HelloMacro</code> trait using
the parsed Rust code</span></p>
<p>We get an <code>Ident</code> struct instance containing the name (identifier) of the
annotated type using <code>ast.ident</code>. The struct in Listing 19-32 shows that when
we run the <code>impl_hello_macro</code> function on the code in Listing 19-30, the
<code>ident</code> we get will have the <code>ident</code> field with a value of <code>&quot;Pancakes&quot;</code>. Thus,
the <code>name</code> variable in Listing 19-33 will contain an <code>Ident</code> struct instance
that, when printed, will be the string <code>&quot;Pancakes&quot;</code>, the name of the struct in
Listing 19-30.</p>
<p>The <code>quote!</code> macro lets us define the Rust code that we want to return. The
compiler expects something different to the direct result of the <code>quote!</code>
macro’s execution, so we need to convert it to a <code>TokenStream</code>. We do this by
calling the <code>into</code> method, which consumes this intermediate representation and
returns a value of the required <code>TokenStream</code> type.</p>
<p>The <code>quote!</code> macro also provides some very cool templating mechanics: we can
enter <code>#name</code>, and <code>quote!</code> will replace it with the value in the variable
<code>name</code>. You can even do some repetition similar to the way regular macros work.
Check out <a href="https://docs.rs/quote">the <code>quote</code> crate’s docs</a> for a thorough introduction.</p>
<p>We want our procedural macro to generate an implementation of our <code>HelloMacro</code>
trait for the type the user annotated, which we can get by using <code>#name</code>. The
trait implementation has one function, <code>hello_macro</code>, whose body contains the
functionality we want to provide: printing <code>Hello, Macro! My name is</code> and then
the name of the annotated type.</p>
<p>The <code>stringify!</code> macro used here is built into Rust. It takes a Rust
expression, such as <code>1 + 2</code>, and at compile time turns the expression into a
string literal, such as <code>&quot;1 + 2&quot;</code>. This is different than <code>format!</code> or
<code>println!</code>, macros which evaluate the expression and then turn the result into
a <code>String</code>. There is a possibility that the <code>#name</code> input might be an
expression to print literally, so we use <code>stringify!</code>. Using <code>stringify!</code> also
saves an allocation by converting <code>#name</code> to a string literal at compile time.</p>
<p>At this point, <code>cargo build</code> should complete successfully in both <code>hello_macro</code>
and <code>hello_macro_derive</code>. Let’s hook up these crates to the code in Listing
19-30 to see the procedural macro in action! Create a new binary project in
your <em>projects</em> directory using <code>cargo new pancakes</code>. We need to add
<code>hello_macro</code> and <code>hello_macro_derive</code> as dependencies in the <code>pancakes</code>
crate’s <em>Cargo.toml</em>. If you’re publishing your versions of <code>hello_macro</code> and
<code>hello_macro_derive</code> to <a href="https://crates.io/">crates.io</a>, they would be regular
dependencies; if not, you can specify them as <code>path</code> dependencies as follows:</p>
<pre><code class="language-toml">[dependencies]
hello_macro = { path = &quot;../hello_macro&quot; }
hello_macro_derive = { path = &quot;../hello_macro/hello_macro_derive&quot; }
</code></pre>
<p>Put the code in Listing 19-30 into <em>src/main.rs</em>, and run <code>cargo run</code>: it
should print <code>Hello, Macro! My name is Pancakes!</code> The implementation of the
<code>HelloMacro</code> trait from the procedural macro was included without the
<code>pancakes</code> crate needing to implement it; the <code>#[derive(HelloMacro)]</code> added the
trait implementation.</p>
<p>Next, let’s explore how the other kinds of procedural macros differ from custom
derive macros.</p>
<h3><a class="header" href="#attribute-like-macros" id="attribute-like-macros">Attribute-like macros</a></h3>
<p>Attribute-like macros are similar to custom derive macros, but instead of
generating code for the <code>derive</code> attribute, they allow you to create new
attributes. They’re also more flexible: <code>derive</code> only works for structs and
enums; attributes can be applied to other items as well, such as functions.
Here’s an example of using an attribute-like macro: say you have an attribute
named <code>route</code> that annotates functions when using a web application framework:</p>
<pre><code class="language-rust ignore">#[route(GET, &quot;/&quot;)]
fn index() {
</code></pre>
<p>This <code>#[route]</code> attribute would be defined by the framework as a procedural
macro. The signature of the macro definition function would look like this:</p>
<pre><code class="language-rust ignore">#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
</code></pre>
<p>Here, we have two parameters of type <code>TokenStream</code>. The first is for the
contents of the attribute: the <code>GET, &quot;/&quot;</code> part. The second is the body of the
item the attribute is attached to: in this case, <code>fn index() {}</code> and the rest
of the function’s body.</p>
<p>Other than that, attribute-like macros work the same way as custom derive
macros: you create a crate with the <code>proc-macro</code> crate type and implement a
function that generates the code you want!</p>
<h3><a class="header" href="#function-like-macros" id="function-like-macros">Function-like macros</a></h3>
<p>Function-like macros define macros that look like function calls. Similarly to
<code>macro_rules!</code> macros, they’re more flexible than functions; for example, they
can take an unknown number of arguments. However, <code>macro_rules!</code> macros can be
defined only using the match-like syntax we discussed in the section
<a href="rustbook/ch19-06-macros.html#declarative-macros-with-macro_rules-for-general-metaprogramming">“Declarative Macros with <code>macro_rules!</code> for General Metaprogramming”</a>
earlier. Function-like macros take a <code>TokenStream</code> parameter and their
definition manipulates that <code>TokenStream</code> using Rust code as the other two
types of procedural macros do. An example of a function-like macro is an <code>sql!</code>
macro that might be called like so:</p>
<pre><code class="language-rust ignore">let sql = sql!(SELECT * FROM posts WHERE id=1);
</code></pre>
<p>This macro would parse the SQL statement inside it and check that it’s
syntactically correct, which is much more complex processing than a
<code>macro_rules!</code> macro can do. The <code>sql!</code> macro would be defined like this:</p>
<pre><code class="language-rust ignore">#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
</code></pre>
<p>This definition is similar to the custom derive macro’s signature: we receive
the tokens that are inside the parentheses and return the code we wanted to
generate.</p>
<h2><a class="header" href="#summary-18" id="summary-18">Summary</a></h2>
<p>Whew! Now you have some Rust features in your toolbox that you won’t use often,
but you’ll know they’re available in very particular circumstances. We’ve
introduced several complex topics so that when you encounter them in error
message suggestions or in other peoples’ code, you’ll be able to recognize
these concepts and syntax. Use this chapter as a reference to guide you to
solutions.</p>
<p>Next, we’ll put everything we’ve discussed throughout the book into practice
and do one more project!</p>
<h1><a class="header" href="#final-project-building-a-multithreaded-web-server" id="final-project-building-a-multithreaded-web-server">Final Project: Building a Multithreaded Web Server</a></h1>
<p>It’s been a long journey, but we’ve reached the end of the book. In this
chapter, we’ll build one more project together to demonstrate some of the
concepts we covered in the final chapters, as well as recap some earlier
lessons.</p>
<p>For our final project, we’ll make a web server that says “hello” and looks like
Figure 20-1 in a web browser.</p>
<p><img src="rustbook/img/trpl20-01.png" alt="hello from rust" /></p>
<p><span class="caption">Figure 20-1: Our final shared project</span></p>
<p>Here is the plan to build the web server:</p>
<ol>
<li>Learn a bit about TCP and HTTP.</li>
<li>Listen for TCP connections on a socket.</li>
<li>Parse a small number of HTTP requests.</li>
<li>Create a proper HTTP response.</li>
<li>Improve the throughput of our server with a thread pool.</li>
</ol>
<p>But before we get started, we should mention one detail: the method we’ll use
won’t be the best way to build a web server with Rust. A number of
production-ready crates are available on <a href="https://crates.io/">crates.io</a> that
provide more complete web server and thread pool implementations than we’ll
build.</p>
<p>However, our intention in this chapter is to help you learn, not to take the
easy route. Because Rust is a systems programming language, we can choose the
level of abstraction we want to work with and can go to a lower level than is
possible or practical in other languages. We’ll write the basic HTTP server and
thread pool manually so you can learn the general ideas and techniques behind
the crates you might use in the future.</p>
<h2><a class="header" href="#building-a-single-threaded-web-server" id="building-a-single-threaded-web-server">Building a Single-Threaded Web Server</a></h2>
<p>We’ll start by getting a single-threaded web server working. Before we begin,
let’s look at a quick overview of the protocols involved in building web
servers. The details of these protocols are beyond the scope of this book, but
a brief overview will give you the information you need.</p>
<p>The two main protocols involved in web servers are the <em>Hypertext Transfer
Protocol</em> <em>(HTTP)</em> and the <em>Transmission Control Protocol</em> <em>(TCP)</em>. Both
protocols are <em>request-response</em> protocols, meaning a <em>client</em> initiates
requests and a <em>server</em> listens to the requests and provides a response to the
client. The contents of those requests and responses are defined by the
protocols.</p>
<p>TCP is the lower-level protocol that describes the details of how information
gets from one server to another but doesn’t specify what that information is.
HTTP builds on top of TCP by defining the contents of the requests and
responses. It’s technically possible to use HTTP with other protocols, but in
the vast majority of cases, HTTP sends its data over TCP. We’ll work with the
raw bytes of TCP and HTTP requests and responses.</p>
<h3><a class="header" href="#listening-to-the-tcp-connection" id="listening-to-the-tcp-connection">Listening to the TCP Connection</a></h3>
<p>Our web server needs to listen to a TCP connection, so that’s the first part
we’ll work on. The standard library offers a <code>std::net</code> module that lets us do
this. Let’s make a new project in the usual fashion:</p>
<pre><code class="language-text">$ cargo new hello
     Created binary (application) `hello` project
$ cd hello
</code></pre>
<p>Now enter the code in Listing 20-1 in <em>src/main.rs</em> to start. This code will
listen at the address <code>127.0.0.1:7878</code> for incoming TCP streams. When it gets
an incoming stream, it will print <code>Connection established!</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        println!(&quot;Connection established!&quot;);
    }
}
</code></pre></pre>
<p><span class="caption">Listing 20-1: Listening for incoming streams and printing
a message when we receive a stream</span></p>
<p>Using <code>TcpListener</code>, we can listen for TCP connections at the address
<code>127.0.0.1:7878</code>. In the address, the section before the colon is an IP address
representing your computer (this is the same on every computer and doesn’t
represent the authors’ computer specifically), and <code>7878</code> is the port. We’ve
chosen this port for two reasons: HTTP is normally accepted on this port, and
7878 is <em>rust</em> typed on a telephone.</p>
<p>The <code>bind</code> function in this scenario works like the <code>new</code> function in that it
will return a new <code>TcpListener</code> instance. The reason the function is called
<code>bind</code> is that in networking, connecting to a port to listen to is known as
“binding to a port.”</p>
<p>The <code>bind</code> function returns a <code>Result&lt;T, E&gt;</code>, which indicates that binding
might fail. For example, connecting to port 80 requires administrator
privileges (nonadministrators can listen only on ports higher than 1024), so if
we tried to connect to port 80 without being an administrator, binding wouldn’t
work. As another example, binding wouldn’t work if we ran two instances of our
program and so had two programs listening to the same port. Because we’re
writing a basic server just for learning purposes, we won’t worry about
handling these kinds of errors; instead, we use <code>unwrap</code> to stop the program if
errors happen.</p>
<p>The <code>incoming</code> method on <code>TcpListener</code> returns an iterator that gives us a
sequence of streams (more specifically, streams of type <code>TcpStream</code>). A single
<em>stream</em> represents an open connection between the client and the server. A
<em>connection</em> is the name for the full request and response process in which a
client connects to the server, the server generates a response, and the server
closes the connection. As such, <code>TcpStream</code> will read from itself to see what
the client sent and then allow us to write our response to the stream. Overall,
this <code>for</code> loop will process each connection in turn and produce a series of
streams for us to handle.</p>
<p>For now, our handling of the stream consists of calling <code>unwrap</code> to terminate
our program if the stream has any errors; if there aren’t any errors, the
program prints a message. We’ll add more functionality for the success case in
the next listing. The reason we might receive errors from the <code>incoming</code> method
when a client connects to the server is that we’re not actually iterating over
connections. Instead, we’re iterating over <em>connection attempts</em>. The
connection might not be successful for a number of reasons, many of them
operating system specific. For example, many operating systems have a limit to
the number of simultaneous open connections they can support; new connection
attempts beyond that number will produce an error until some of the open
connections are closed.</p>
<p>Let’s try running this code! Invoke <code>cargo run</code> in the terminal and then load
<em>127.0.0.1:7878</em> in a web browser. The browser should show an error message
like “Connection reset,” because the server isn’t currently sending back any
data. But when you look at your terminal, you should see several messages that
were printed when the browser connected to the server!</p>
<pre><code class="language-text">     Running `target/debug/hello`
Connection established!
Connection established!
Connection established!
</code></pre>
<p>Sometimes, you’ll see multiple messages printed for one browser request; the
reason might be that the browser is making a request for the page as well as a
request for other resources, like the <em>favicon.ico</em> icon that appears in the
browser tab.</p>
<p>It could also be that the browser is trying to connect to the server multiple
times because the server isn’t responding with any data. When <code>stream</code> goes out
of scope and is dropped at the end of the loop, the connection is closed as
part of the <code>drop</code> implementation. Browsers sometimes deal with closed
connections by retrying, because the problem might be temporary. The important
factor is that we’ve successfully gotten a handle to a TCP connection!</p>
<p>Remember to stop the program by pressing <span class="keystroke">ctrl-c</span>
when you’re done running a particular version of the code. Then restart <code>cargo run</code> after you’ve made each set of code changes to make sure you’re running the
newest code.</p>
<h3><a class="header" href="#reading-the-request" id="reading-the-request">Reading the Request</a></h3>
<p>Let’s implement the functionality to read the request from the browser! To
separate the concerns of first getting a connection and then taking some action
with the connection, we’ll start a new function for processing connections. In
this new <code>handle_connection</code> function, we’ll read data from the TCP stream and
print it so we can see the data being sent from the browser. Change the code to
look like Listing 20-2.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::io::prelude::*;
use std::net::TcpStream;
use std::net::TcpListener;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        handle_connection(stream);
    }
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    println!(&quot;Request: {}&quot;, String::from_utf8_lossy(&amp;buffer[..]));
}
</code></pre></pre>
<p><span class="caption">Listing 20-2: Reading from the <code>TcpStream</code> and printing
the data</span></p>
<p>We bring <code>std::io::prelude</code> into scope to get access to certain traits that let
us read from and write to the stream. In the <code>for</code> loop in the <code>main</code> function,
instead of printing a message that says we made a connection, we now call the
new <code>handle_connection</code> function and pass the <code>stream</code> to it.</p>
<p>In the <code>handle_connection</code> function, we’ve made the <code>stream</code> parameter mutable.
The reason is that the <code>TcpStream</code> instance keeps track of what data it returns
to us internally. It might read more data than we asked for and save that data
for the next time we ask for data. It therefore needs to be <code>mut</code> because its
internal state might change; usually, we think of “reading” as not needing
mutation, but in this case we need the <code>mut</code> keyword.</p>
<p>Next, we need to actually read from the stream. We do this in two steps: first,
we declare a <code>buffer</code> on the stack to hold the data that is read in. We’ve made
the buffer 512 bytes in size, which is big enough to hold the data of a basic
request and sufficient for our purposes in this chapter. If we wanted to handle
requests of an arbitrary size, buffer management would need to be more
complicated; we’ll keep it simple for now. We pass the buffer to <code>stream.read</code>,
which will read bytes from the <code>TcpStream</code> and put them in the buffer.</p>
<p>Second, we convert the bytes in the buffer to a string and print that string.
The <code>String::from_utf8_lossy</code> function takes a <code>&amp;[u8]</code> and produces a <code>String</code>
from it. The “lossy” part of the name indicates the behavior of this function
when it sees an invalid UTF-8 sequence: it will replace the invalid sequence
with <code>�</code>, the <code>U+FFFD REPLACEMENT CHARACTER</code>. You might see replacement
characters for characters in the buffer that aren’t filled by request data.</p>
<p>Let’s try this code! Start the program and make a request in a web browser
again. Note that we’ll still get an error page in the browser, but our
program’s output in the terminal will now look similar to this:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42 secs
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
</code></pre>
<p>Depending on your browser, you might get slightly different output. Now that
we’re printing the request data, we can see why we get multiple connections
from one browser request by looking at the path after <code>Request: GET</code>. If the
repeated connections are all requesting <em>/</em>, we know the browser is trying to
fetch <em>/</em> repeatedly because it’s not getting a response from our program.</p>
<p>Let’s break down this request data to understand what the browser is asking of
our program.</p>
<h3><a class="header" href="#a-closer-look-at-an-http-request" id="a-closer-look-at-an-http-request">A Closer Look at an HTTP Request</a></h3>
<p>HTTP is a text-based protocol, and a request takes this format:</p>
<pre><code class="language-text">Method Request-URI HTTP-Version CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is the <em>request line</em> that holds information about what the
client is requesting. The first part of the request line indicates the <em>method</em>
being used, such as <code>GET</code> or <code>POST</code>, which describes how the client is making
this request. Our client used a <code>GET</code> request.</p>
<p>The next part of the request line is <em>/</em>, which indicates the <em>Uniform Resource
Identifier</em> <em>(URI)</em> the client is requesting: a URI is almost, but not quite,
the same as a <em>Uniform Resource Locator</em> <em>(URL)</em>. The difference between URIs
and URLs isn’t important for our purposes in this chapter, but the HTTP spec
uses the term URI, so we can just mentally substitute URL for URI here.</p>
<p>The last part is the HTTP version the client uses, and then the request line
ends in a <em>CRLF sequence</em>. (CRLF stands for <em>carriage return</em> and <em>line feed</em>,
which are terms from the typewriter days!) The CRLF sequence can also be
written as <code>\r\n</code>, where <code>\r</code> is a carriage return and <code>\n</code> is a line feed. The
CRLF sequence separates the request line from the rest of the request data.
Note that when the CRLF is printed, we see a new line start rather than <code>\r\n</code>.</p>
<p>Looking at the request line data we received from running our program so far,
we see that <code>GET</code> is the method, <em>/</em> is the request URI, and <code>HTTP/1.1</code> is the
version.</p>
<p>After the request line, the remaining lines starting from <code>Host:</code> onward are
headers. <code>GET</code> requests have no body.</p>
<p>Try making a request from a different browser or asking for a different
address, such as <em>127.0.0.1:7878/test</em>, to see how the request data changes.</p>
<p>Now that we know what the browser is asking for, let’s send back some data!</p>
<h3><a class="header" href="#writing-a-response" id="writing-a-response">Writing a Response</a></h3>
<p>Now we’ll implement sending data in response to a client request. Responses
have the following format:</p>
<pre><code class="language-text">HTTP-Version Status-Code Reason-Phrase CRLF
headers CRLF
message-body
</code></pre>
<p>The first line is a <em>status line</em> that contains the HTTP version used in the
response, a numeric status code that summarizes the result of the request, and
a reason phrase that provides a text description of the status code. After the
CRLF sequence are any headers, another CRLF sequence, and the body of the
response.</p>
<p>Here is an example response that uses HTTP version 1.1, has a status code of
200, an OK reason phrase, no headers, and no body:</p>
<pre><code class="language-text">HTTP/1.1 200 OK\r\n\r\n
</code></pre>
<p>The status code 200 is the standard success response. The text is a tiny
successful HTTP response. Let’s write this to the stream as our response to a
successful request! From the <code>handle_connection</code> function, remove the
<code>println!</code> that was printing the request data and replace it with the code in
Listing 20-3.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span>fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];

    stream.read(&amp;mut buffer).unwrap();

    let response = &quot;HTTP/1.1 200 OK\r\n\r\n&quot;;

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-3: Writing a tiny successful HTTP response to
the stream</span></p>
<p>The first new line defines the <code>response</code> variable that holds the success
message’s data. Then we call <code>as_bytes</code> on our <code>response</code> to convert the string
data to bytes. The <code>write</code> method on <code>stream</code> takes a <code>&amp;[u8]</code> and sends those
bytes directly down the connection.</p>
<p>Because the <code>write</code> operation could fail, we use <code>unwrap</code> on any error result
as before. Again, in a real application you would add error handling here.
Finally, <code>flush</code> will wait and prevent the program from continuing until all
the bytes are written to the connection; <code>TcpStream</code> contains an internal
buffer to minimize calls to the underlying operating system.</p>
<p>With these changes, let’s run our code and make a request. We’re no longer
printing any data to the terminal, so we won’t see any output other than the
output from Cargo. When you load <em>127.0.0.1:7878</em> in a web browser, you should
get a blank page instead of an error. You’ve just hand-coded an HTTP request
and response!</p>
<h3><a class="header" href="#returning-real-html" id="returning-real-html">Returning Real HTML</a></h3>
<p>Let’s implement the functionality for returning more than a blank page. Create
a new file, <em>hello.html</em>, in the root of your project directory, not in the
<em>src</em> directory. You can input any HTML you want; Listing 20-4 shows one
possibility.</p>
<p><span class="filename">Filename: hello.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;p&gt;Hi from Rust&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-4: A sample HTML file to return in a
response</span></p>
<p>This is a minimal HTML5 document with a heading and some text. To return this
from the server when a request is received, we’ll modify <code>handle_connection</code> as
shown in Listing 20-5 to read the HTML file, add it to the response as a body,
and send it.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span>use std::fs;
// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();

    let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-5: Sending the contents of <em>hello.html</em> as the
body of the response</span></p>
<p>We’ve added a line at the top to bring the standard library’s filesystem module
into scope. The code for reading the contents of a file to a string should look
familiar; we used it in Chapter 12 when we read the contents of a file for our
I/O project in Listing 12-4.</p>
<p>Next, we use <code>format!</code> to add the file’s contents as the body of the success
response.</p>
<p>Run this code with <code>cargo run</code> and load <em>127.0.0.1:7878</em> in your browser; you
should see your HTML rendered!</p>
<p>Currently, we’re ignoring the request data in <code>buffer</code> and just sending back
the contents of the HTML file unconditionally. That means if you try requesting
<em>127.0.0.1:7878/something-else</em> in your browser, you’ll still get back this
same HTML response. Our server is very limited and is not what most web servers
do. We want to customize our responses depending on the request and only send
back the HTML file for a well-formed request to <em>/</em>.</p>
<h3><a class="header" href="#validating-the-request-and-selectively-responding" id="validating-the-request-and-selectively-responding">Validating the Request and Selectively Responding</a></h3>
<p>Right now, our web server will return the HTML in the file no matter what the
client requested. Let’s add functionality to check that the browser is
requesting <em>/</em> before returning the HTML file and return an error if the
browser requests anything else. For this we need to modify <code>handle_connection</code>,
as shown in Listing 20-6. This new code checks the content of the request
received against what we know a request for <em>/</em> looks like and adds <code>if</code> and
<code>else</code> blocks to treat requests differently.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs;
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;

    if buffer.starts_with(get) {
        let contents = fs::read_to_string(&quot;hello.html&quot;).unwrap();

        let response = format!(&quot;HTTP/1.1 200 OK\r\n\r\n{}&quot;, contents);

        stream.write(response.as_bytes()).unwrap();
        stream.flush().unwrap();
    } else {
        // some other request
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-6: Matching the request and handling requests
to <em>/</em> differently from other requests</span></p>
<p>First, we hardcode the data corresponding to the <em>/</em> request into the <code>get</code>
variable. Because we’re reading raw bytes into the buffer, we transform <code>get</code>
into a byte string by adding the <code>b&quot;&quot;</code> byte string syntax at the start of the
content data. Then we check whether <code>buffer</code> starts with the bytes in <code>get</code>. If
it does, it means we’ve received a well-formed request to <em>/</em>, which is the
success case we’ll handle in the <code>if</code> block that returns the contents of our
HTML file.</p>
<p>If <code>buffer</code> does <em>not</em> start with the bytes in <code>get</code>, it means we’ve received
some other request. We’ll add code to the <code>else</code> block in a moment to respond
to all other requests.</p>
<p>Run this code now and request <em>127.0.0.1:7878</em>; you should get the HTML in
<em>hello.html</em>. If you make any other request, such as
<em>127.0.0.1:7878/something-else</em>, you’ll get a connection error like those you
saw when running the code in Listing 20-1 and Listing 20-2.</p>
<p>Now let’s add the code in Listing 20-7 to the <code>else</code> block to return a response
with the status code 404, which signals that the content for the request was
not found. We’ll also return some HTML for a page to render in the browser
indicating the response to the end user.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs;
</span><span class="boring">fn handle_connection(mut stream: TcpStream) {
</span><span class="boring">if true {
</span>// --snip--

} else {
    let status_line = &quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;;
    let contents = fs::read_to_string(&quot;404.html&quot;).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-7: Responding with status code 404 and an
error page if anything other than <em>/</em> was requested</span></p>
<p>Here, our response has a status line with status code 404 and the reason
phrase <code>NOT FOUND</code>. We’re still not returning headers, and the body of the
response will be the HTML in the file <em>404.html</em>. You’ll need to create a
<em>404.html</em> file next to <em>hello.html</em> for the error page; again feel free to use
any HTML you want or use the example HTML in Listing 20-8.</p>
<p><span class="filename">Filename: 404.html</span></p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Hello!&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;h1&gt;Oops!&lt;/h1&gt;
    &lt;p&gt;Sorry, I don't know what you're asking for.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><span class="caption">Listing 20-8: Sample content for the page to send back
with any 404 response</span></p>
<p>With these changes, run your server again. Requesting <em>127.0.0.1:7878</em>
should return the contents of <em>hello.html</em>, and any other request, like
<em>127.0.0.1:7878/foo</em>, should return the error HTML from <em>404.html</em>.</p>
<h3><a class="header" href="#a-touch-of-refactoring" id="a-touch-of-refactoring">A Touch of Refactoring</a></h3>
<p>At the moment the <code>if</code> and <code>else</code> blocks have a lot of repetition: they’re both
reading files and writing the contents of the files to the stream. The only
differences are the status line and the filename. Let’s make the code more
concise by pulling out those differences into separate <code>if</code> and <code>else</code> lines
that will assign the values of the status line and the filename to variables;
we can then use those variables unconditionally in the code to read the file
and write the response. Listing 20-9 shows the resulting code after replacing
the large <code>if</code> and <code>else</code> blocks.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs;
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
<span class="boring">    let mut buffer = [0; 512];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span><span class="boring">
</span><span class="boring">    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
</span>    // --snip--

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-9: Refactoring the <code>if</code> and <code>else</code> blocks to
contain only the code that differs between the two cases</span></p>
<p>Now the <code>if</code> and <code>else</code> blocks only return the appropriate values for the
status line and filename in a tuple; we then use destructuring to assign these
two values to <code>status_line</code> and <code>filename</code> using a pattern in the <code>let</code>
statement, as discussed in Chapter 18.</p>
<p>The previously duplicated code is now outside the <code>if</code> and <code>else</code> blocks and
uses the <code>status_line</code> and <code>filename</code> variables. This makes it easier to see
the difference between the two cases, and it means we have only one place to
update the code if we want to change how the file reading and response writing
work. The behavior of the code in Listing 20-9 will be the same as that in
Listing 20-8.</p>
<p>Awesome! We now have a simple web server in approximately 40 lines of Rust code
that responds to one request with a page of content and responds to all other
requests with a 404 response.</p>
<p>Currently, our server runs in a single thread, meaning it can only serve one
request at a time. Let’s examine how that can be a problem by simulating some
slow requests. Then we’ll fix it so our server can handle multiple requests at
once.</p>
<h2><a class="header" href="#turning-our-single-threaded-server-into-a-multithreaded-server" id="turning-our-single-threaded-server-into-a-multithreaded-server">Turning Our Single-Threaded Server into a Multithreaded Server</a></h2>
<p>Right now, the server will process each request in turn, meaning it won’t
process a second connection until the first is finished processing. If the
server received more and more requests, this serial execution would be less and
less optimal. If the server receives a request that takes a long time to
process, subsequent requests will have to wait until the long request is
finished, even if the new requests can be processed quickly. We’ll need to fix
this, but first, we’ll look at the problem in action.</p>
<h3><a class="header" href="#simulating-a-slow-request-in-the-current-server-implementation" id="simulating-a-slow-request-in-the-current-server-implementation">Simulating a Slow Request in the Current Server Implementation</a></h3>
<p>We’ll look at how a slow-processing request can affect other requests made to
our current server implementation. Listing 20-10 implements handling a request
to <em>/sleep</em> with a simulated slow response that will cause the server to sleep
for 5 seconds before responding.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::time::Duration;
<span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">use std::fs::File;
</span>// --snip--

fn handle_connection(mut stream: TcpStream) {
<span class="boring">    let mut buffer = [0; 512];
</span><span class="boring">    stream.read(&amp;mut buffer).unwrap();
</span>    // --snip--

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-10: Simulating a slow request by recognizing
<em>/sleep</em> and sleeping for 5 seconds</span></p>
<p>This code is a bit messy, but it’s good enough for simulation purposes. We
created a second request <code>sleep</code>, whose data our server recognizes. We added an
<code>else if</code> after the <code>if</code> block to check for the request to <em>/sleep</em>. When that
request is received, the server will sleep for 5 seconds before rendering the
successful HTML page.</p>
<p>You can see how primitive our server is: real libraries would handle the
recognition of multiple requests in a much less verbose way!</p>
<p>Start the server using <code>cargo run</code>. Then open two browser windows: one for
<em>http://127.0.0.1:7878/</em> and the other for <em>http://127.0.0.1:7878/sleep</em>. If
you enter the <em>/</em> URI a few times, as before, you’ll see it respond quickly.
But if you enter <em>/sleep</em> and then load <em>/</em>, you’ll see that <em>/</em> waits until
<code>sleep</code> has slept for its full 5 seconds before loading.</p>
<p>There are multiple ways we could change how our web server works to avoid
having more requests back up behind a slow request; the one we’ll implement is
a thread pool.</p>
<h3><a class="header" href="#improving-throughput-with-a-thread-pool" id="improving-throughput-with-a-thread-pool">Improving Throughput with a Thread Pool</a></h3>
<p>A <em>thread pool</em> is a group of spawned threads that are waiting and ready to
handle a task. When the program receives a new task, it assigns one of the
threads in the pool to the task, and that thread will process the task. The
remaining threads in the pool are available to handle any other tasks that come
in while the first thread is processing. When the first thread is done
processing its task, it’s returned to the pool of idle threads, ready to handle
a new task. A thread pool allows you to process connections concurrently,
increasing the throughput of your server.</p>
<p>We’ll limit the number of threads in the pool to a small number to protect us
from Denial of Service (DoS) attacks; if we had our program create a new thread
for each request as it came in, someone making 10 million requests to our
server could create havoc by using up all our server’s resources and grinding
the processing of requests to a halt.</p>
<p>Rather than spawning unlimited threads, we’ll have a fixed number of threads
waiting in the pool. As requests come in, they’ll be sent to the pool for
processing. The pool will maintain a queue of incoming requests. Each of the
threads in the pool will pop off a request from this queue, handle the request,
and then ask the queue for another request. With this design, we can process
<code>N</code> requests concurrently, where <code>N</code> is the number of threads. If each thread
is responding to a long-running request, subsequent requests can still back up
in the queue, but we’ve increased the number of long-running requests we can
handle before reaching that point.</p>
<p>This technique is just one of many ways to improve the throughput of a web
server. Other options you might explore are the fork/join model and the
single-threaded async I/O model. If you’re interested in this topic, you can
read more about other solutions and try to implement them in Rust; with a
low-level language like Rust, all of these options are possible.</p>
<p>Before we begin implementing a thread pool, let’s talk about what using the
pool should look like. When you’re trying to design code, writing the client
interface first can help guide your design. Write the API of the code so it’s
structured in the way you want to call it; then implement the functionality
within that structure rather than implementing the functionality and then
designing the public API.</p>
<p>Similar to how we used test-driven development in the project in Chapter 12,
we’ll use compiler-driven development here. We’ll write the code that calls the
functions we want, and then we’ll look at errors from the compiler to determine
what we should change next to get the code to work.</p>
<h4><a class="header" href="#code-structure-if-we-could-spawn-a-thread-for-each-request" id="code-structure-if-we-could-spawn-a-thread-for-each-request">Code Structure If We Could Spawn a Thread for Each Request</a></h4>
<p>First, let’s explore how our code might look if it did create a new thread for
every connection. As mentioned earlier, this isn’t our final plan due to the
problems with potentially spawning an unlimited number of threads, but it is a
starting point. Listing 20-11 shows the changes to make to <code>main</code> to spawn a
new thread to handle each stream within the <code>for</code> loop.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">use std::thread;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">fn handle_connection(mut stream: TcpStream) {}
</span></code></pre></pre>
<p><span class="caption">Listing 20-11: Spawning a new thread for each
stream</span></p>
<p>As you learned in Chapter 16, <code>thread::spawn</code> will create a new thread and then
run the code in the closure in the new thread. If you run this code and load
<em>/sleep</em> in your browser, then <em>/</em> in two more browser tabs, you’ll indeed see
that the requests to <em>/</em> don’t have to wait for <em>/sleep</em> to finish. But as we
mentioned, this will eventually overwhelm the system because you’d be making
new threads without any limit.</p>
<h4><a class="header" href="#creating-a-similar-interface-for-a-finite-number-of-threads" id="creating-a-similar-interface-for-a-finite-number-of-threads">Creating a Similar Interface for a Finite Number of Threads</a></h4>
<p>We want our thread pool to work in a similar, familiar way so switching from
threads to a thread pool doesn’t require large changes to the code that uses
our API. Listing 20-12 shows the hypothetical interface for a <code>ThreadPool</code>
struct we want to use instead of <code>thread::spawn</code>.</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">use std::thread;
</span><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpListener;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">struct ThreadPool;
</span><span class="boring">impl ThreadPool {
</span><span class="boring">   fn new(size: u32) -&gt; ThreadPool { ThreadPool }
</span><span class="boring">   fn execute&lt;F&gt;(&amp;self, f: F)
</span><span class="boring">       where F: FnOnce() + Send + 'static {}
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }
}
<span class="boring">fn handle_connection(mut stream: TcpStream) {}
</span></code></pre></pre>
<p><span class="caption">Listing 20-12: Our ideal <code>ThreadPool</code> interface</span></p>
<p>We use <code>ThreadPool::new</code> to create a new thread pool with a configurable number
of threads, in this case four. Then, in the <code>for</code> loop, <code>pool.execute</code> has a
similar interface as <code>thread::spawn</code> in that it takes a closure the pool should
run for each stream. We need to implement <code>pool.execute</code> so it takes the
closure and gives it to a thread in the pool to run. This code won’t yet
compile, but we’ll try so the compiler can guide us in how to fix it.</p>
<h4><a class="header" href="#building-the-threadpool-struct-using-compiler-driven-development" id="building-the-threadpool-struct-using-compiler-driven-development">Building the <code>ThreadPool</code> Struct Using Compiler Driven Development</a></h4>
<p>Make the changes in Listing 20-12 to <em>src/main.rs</em>, and then let’s use the
compiler errors from <code>cargo check</code> to drive our development. Here is the first
error we get:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0433]: failed to resolve. Use of undeclared type or module `ThreadPool`
  --&gt; src\main.rs:10:16
   |
10 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ Use of undeclared type or module
   `ThreadPool`

error: aborting due to previous error
</code></pre>
<p>Great! This error tells us we need a <code>ThreadPool</code> type or module, so we’ll
build one now. Our <code>ThreadPool</code> implementation will be independent of the kind
of work our web server is doing. So, let’s switch the <code>hello</code> crate from a
binary crate to a library crate to hold our <code>ThreadPool</code> implementation. After
we change to a library crate, we could also use the separate thread pool
library for any work we want to do using a thread pool, not just for serving
web requests.</p>
<p>Create a <em>src/lib.rs</em> that contains the following, which is the simplest
definition of a <code>ThreadPool</code> struct that we can have for now:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;
<span class="boring">}
</span></code></pre></pre>
<p>Then create a new directory, <em>src/bin</em>, and move the binary crate rooted in
<em>src/main.rs</em> into <em>src/bin/main.rs</em>. Doing so will make the library crate the
primary crate in the <em>hello</em> directory; we can still run the binary in
<em>src/bin/main.rs</em> using <code>cargo run</code>. After moving the <em>main.rs</em> file, edit it
to bring the library crate in and bring <code>ThreadPool</code> into scope by adding the
following code to the top of <em>src/bin/main.rs</em>:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;
</code></pre>
<p>This code still won’t work, but let’s check it again to get the next error that
we need to address:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0599]: no function or associated item named `new` found for type
`hello::ThreadPool` in the current scope
 --&gt; src/bin/main.rs:13:16
   |
13 |     let pool = ThreadPool::new(4);
   |                ^^^^^^^^^^^^^^^ function or associated item not found in
   `hello::ThreadPool`
</code></pre>
<p>This error indicates that next we need to create an associated function named
<code>new</code> for <code>ThreadPool</code>. We also know that <code>new</code> needs to have one parameter
that can accept <code>4</code> as an argument and should return a <code>ThreadPool</code> instance.
Let’s implement the simplest <code>new</code> function that will have those
characteristics:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&gt; ThreadPool {
        ThreadPool
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We chose <code>usize</code> as the type of the <code>size</code> parameter, because we know that a
negative number of threads doesn’t make any sense. We also know we’ll use this
4 as the number of elements in a collection of threads, which is what the
<code>usize</code> type is for, as discussed in the <a href="rustbook/ch03-02-data-types.html#integer-types">“Integer Types”</a><!--
ignore --> section of Chapter 3.</p>
<p>Let’s check the code again:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

error[E0599]: no method named `execute` found for type `hello::ThreadPool` in the current scope
  --&gt; src/bin/main.rs:18:14
   |
18 |         pool.execute(|| {
   |              ^^^^^^^
</code></pre>
<p>Now we get a warning and an error. Ignoring the warning for a moment, the error
occurs because we don’t have an <code>execute</code> method on <code>ThreadPool</code>. Recall from
the <a href="rustbook/ch20-02-multithreaded.html#creating-a-similar-interface-for-a-finite-number-of-threads">“Creating a Similar Interface for a Finite Number of
Threads”</a><!--
ignore --> section that we decided our thread pool should have an interface
similar to <code>thread::spawn</code>. In addition, we’ll implement the <code>execute</code> function
so it takes the closure it’s given and gives it to an idle thread in the pool
to run.</p>
<p>We’ll define the <code>execute</code> method on <code>ThreadPool</code> to take a closure as a
parameter. Recall from the <a href="rustbook/ch13-01-closures.html#storing-closures-using-generic-parameters-and-the-fn-traits">“Storing Closures Using Generic Parameters and the
<code>Fn</code> Traits”</a><!--
ignore --> section in Chapter 13 that we can take closures as parameters with
three different traits: <code>Fn</code>, <code>FnMut</code>, and <code>FnOnce</code>. We need to decide which
kind of closure to use here. We know we’ll end up doing something similar to
the standard library <code>thread::spawn</code> implementation, so we can look at what
bounds the signature of <code>thread::spawn</code> has on its parameter. The documentation
shows us the following:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>The <code>F</code> type parameter is the one we’re concerned with here; the <code>T</code> type
parameter is related to the return value, and we’re not concerned with that. We
can see that <code>spawn</code> uses <code>FnOnce</code> as the trait bound on <code>F</code>. This is probably
what we want as well, because we’ll eventually pass the argument we get in
<code>execute</code> to <code>spawn</code>. We can be further confident that <code>FnOnce</code> is the trait we
want to use because the thread for running a request will only execute that
request’s closure one time, which matches the <code>Once</code> in <code>FnOnce</code>.</p>
<p>The <code>F</code> type parameter also has the trait bound <code>Send</code> and the lifetime bound
<code>'static</code>, which are useful in our situation: we need <code>Send</code> to transfer the
closure from one thread to another and <code>'static</code> because we don’t know how long
the thread will take to execute. Let’s create an <code>execute</code> method on
<code>ThreadPool</code> that will take a generic parameter of type <code>F</code> with these bounds:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct ThreadPool;
</span>impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {

    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We still use the <code>()</code> after <code>FnOnce</code> because this <code>FnOnce</code> represents a closure
that takes no parameters and doesn’t return a value. Just like function
definitions, the return type can be omitted from the signature, but even if we
have no parameters, we still need the parentheses.</p>
<p>Again, this is the simplest implementation of the <code>execute</code> method: it does
nothing, but we’re trying only to make our code compile. Let’s check it again:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
warning: unused variable: `size`
 --&gt; src/lib.rs:4:16
  |
4 |     pub fn new(size: usize) -&gt; ThreadPool {
  |                ^^^^
  |
  = note: #[warn(unused_variables)] on by default
  = note: to avoid this warning, consider using `_size` instead

warning: unused variable: `f`
 --&gt; src/lib.rs:8:30
  |
8 |     pub fn execute&lt;F&gt;(&amp;self, f: F)
  |                              ^
  |
  = note: to avoid this warning, consider using `_f` instead
</code></pre>
<p>We’re receiving only warnings now, which means it compiles! But note that if
you try <code>cargo run</code> and make a request in the browser, you’ll see the errors in
the browser that we saw at the beginning of the chapter. Our library isn’t
actually calling the closure passed to <code>execute</code> yet!</p>
<blockquote>
<p>Note: A saying you might hear about languages with strict compilers, such as
Haskell and Rust, is “if the code compiles, it works.” But this saying is not
universally true. Our project compiles, but it does absolutely nothing! If we
were building a real, complete project, this would be a good time to start
writing unit tests to check that the code compiles <em>and</em> has the behavior we
want.</p>
</blockquote>
<h4><a class="header" href="#validating-the-number-of-threads-in-new" id="validating-the-number-of-threads-in-new">Validating the Number of Threads in <code>new</code></a></h4>
<p>We’ll continue to get warnings because we aren’t doing anything with the
parameters to <code>new</code> and <code>execute</code>. Let’s implement the bodies of these
functions with the behavior we want. To start, let’s think about <code>new</code>. Earlier
we chose an unsigned type for the <code>size</code> parameter, because a pool with a
negative number of threads makes no sense. However, a pool with zero threads
also makes no sense, yet zero is a perfectly valid <code>usize</code>. We’ll add code to
check that <code>size</code> is greater than zero before we return a <code>ThreadPool</code> instance
and have the program panic if it receives a zero by using the <code>assert!</code> macro,
as shown in Listing 20-13.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct ThreadPool;
</span>impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        ThreadPool
    }

    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-13: Implementing <code>ThreadPool::new</code> to panic if
<code>size</code> is zero</span></p>
<p>We’ve added some documentation for our <code>ThreadPool</code> with doc comments. Note
that we followed good documentation practices by adding a section that calls
out the situations in which our function can panic, as discussed in Chapter 14.
Try running <code>cargo doc --open</code> and clicking the <code>ThreadPool</code> struct to see what
the generated docs for <code>new</code> look like!</p>
<p>Instead of adding the <code>assert!</code> macro as we’ve done here, we could make <code>new</code>
return a <code>Result</code> like we did with <code>Config::new</code> in the I/O project in Listing
12-9. But we’ve decided in this case that trying to create a thread pool
without any threads should be an unrecoverable error. If you’re feeling
ambitious, try to write a version of <code>new</code> with the following signature to
compare both versions:</p>
<pre><code class="language-rust ignore">pub fn new(size: usize) -&gt; Result&lt;ThreadPool, PoolCreationError&gt; {
</code></pre>
<h4><a class="header" href="#creating-space-to-store-the-threads" id="creating-space-to-store-the-threads">Creating Space to Store the Threads</a></h4>
<p>Now that we have a way to know we have a valid number of threads to store in
the pool, we can create those threads and store them in the <code>ThreadPool</code> struct
before returning it. But how do we “store” a thread? Let’s take another look at
the <code>thread::spawn</code> signature:</p>
<pre><code class="language-rust ignore">pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
    where
        F: FnOnce() -&gt; T + Send + 'static,
        T: Send + 'static
</code></pre>
<p>The <code>spawn</code> function returns a <code>JoinHandle&lt;T&gt;</code>, where <code>T</code> is the type that the
closure returns. Let’s try using <code>JoinHandle</code> too and see what happens. In our
case, the closures we’re passing to the thread pool will handle the connection
and not return anything, so <code>T</code> will be the unit type <code>()</code>.</p>
<p>The code in Listing 20-14 will compile but doesn’t create any threads yet.
We’ve changed the definition of <code>ThreadPool</code> to hold a vector of
<code>thread::JoinHandle&lt;()&gt;</code> instances, initialized the vector with a capacity of
<code>size</code>, set up a <code>for</code> loop that will run some code to create the threads, and
returned a <code>ThreadPool</code> instance containing them.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">use std::thread;

pub struct ThreadPool {
    threads: Vec&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut threads = Vec::with_capacity(size);

        for _ in 0..size {
            // create some threads and store them in the vector
        }

        ThreadPool {
            threads
        }
    }

    // --snip--
}
</code></pre>
<p><span class="caption">Listing 20-14: Creating a vector for <code>ThreadPool</code> to hold
the threads</span></p>
<p>We’ve brought <code>std::thread</code> into scope in the library crate, because we’re
using <code>thread::JoinHandle</code> as the type of the items in the vector in
<code>ThreadPool</code>.</p>
<p>Once a valid size is received, our <code>ThreadPool</code> creates a new vector that can
hold <code>size</code> items. We haven’t used the <code>with_capacity</code> function in this book
yet, which performs the same task as <code>Vec::new</code> but with an important
difference: it preallocates space in the vector. Because we know we need to
store <code>size</code> elements in the vector, doing this allocation up front is slightly
more efficient than using <code>Vec::new</code>, which resizes itself as elements are
inserted.</p>
<p>When you run <code>cargo check</code> again, you’ll get a few more warnings, but it should
succeed.</p>
<h4><a class="header" href="#a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread" id="a-worker-struct-responsible-for-sending-code-from-the-threadpool-to-a-thread">A <code>Worker</code> Struct Responsible for Sending Code from the <code>ThreadPool</code> to a Thread</a></h4>
<p>We left a comment in the <code>for</code> loop in Listing 20-14 regarding the creation of
threads. Here, we’ll look at how we actually create threads. The standard
library provides <code>thread::spawn</code> as a way to create threads, and
<code>thread::spawn</code> expects to get some code the thread should run as soon as the
thread is created. However, in our case, we want to create the threads and have
them <em>wait</em> for code that we’ll send later. The standard library’s
implementation of threads doesn’t include any way to do that; we have to
implement it manually.</p>
<p>We’ll implement this behavior by introducing a new data structure between the
<code>ThreadPool</code> and the threads that will manage this new behavior. We’ll call
this data structure <code>Worker</code>, which is a common term in pooling
implementations. Think of people working in the kitchen at a restaurant: the
workers wait until orders come in from customers, and then they’re responsible
for taking those orders and filling them.</p>
<p>Instead of storing a vector of <code>JoinHandle&lt;()&gt;</code> instances in the thread pool,
we’ll store instances of the <code>Worker</code> struct. Each <code>Worker</code> will store a single
<code>JoinHandle&lt;()&gt;</code> instance. Then we’ll implement a method on <code>Worker</code> that will
take a closure of code to run and send it to the already running thread for
execution. We’ll also give each worker an <code>id</code> so we can distinguish between
the different workers in the pool when logging or debugging.</p>
<p>Let’s make the following changes to what happens when we create a <code>ThreadPool</code>.
We’ll implement the code that sends the closure to the thread after we have
<code>Worker</code> set up in this way:</p>
<ol>
<li>Define a <code>Worker</code> struct that holds an <code>id</code> and a <code>JoinHandle&lt;()&gt;</code>.</li>
<li>Change <code>ThreadPool</code> to hold a vector of <code>Worker</code> instances.</li>
<li>Define a <code>Worker::new</code> function that takes an <code>id</code> number and returns a
<code>Worker</code> instance that holds the <code>id</code> and a thread spawned with an empty
closure.</li>
<li>In <code>ThreadPool::new</code>, use the <code>for</code> loop counter to generate an <code>id</code>, create
a new <code>Worker</code> with that <code>id</code>, and store the worker in the vector.</li>
</ol>
<p>If you’re up for a challenge, try implementing these changes on your own before
looking at the code in Listing 20-15.</p>
<p>Ready? Here is Listing 20-15 with one way to make the preceding modifications.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::thread;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
}

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers
        }
    }
    // --snip--
}

struct Worker {
    id: usize,
    thread: thread::JoinHandle&lt;()&gt;,
}

impl Worker {
    fn new(id: usize) -&gt; Worker {
        let thread = thread::spawn(|| {});

        Worker {
            id,
            thread,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-15: Modifying <code>ThreadPool</code> to hold <code>Worker</code>
instances instead of holding threads directly</span></p>
<p>We’ve changed the name of the field on <code>ThreadPool</code> from <code>threads</code> to <code>workers</code>
because it’s now holding <code>Worker</code> instances instead of <code>JoinHandle&lt;()&gt;</code>
instances. We use the counter in the <code>for</code> loop as an argument to
<code>Worker::new</code>, and we store each new <code>Worker</code> in the vector named <code>workers</code>.</p>
<p>External code (like our server in <em>src/bin/main.rs</em>) doesn’t need to know the
implementation details regarding using a <code>Worker</code> struct within <code>ThreadPool</code>,
so we make the <code>Worker</code> struct and its <code>new</code> function private. The
<code>Worker::new</code> function uses the <code>id</code> we give it and stores a <code>JoinHandle&lt;()&gt;</code>
instance that is created by spawning a new thread using an empty closure.</p>
<p>This code will compile and will store the number of <code>Worker</code> instances we
specified as an argument to <code>ThreadPool::new</code>. But we’re <em>still</em> not processing
the closure that we get in <code>execute</code>. Let’s look at how to do that next.</p>
<h4><a class="header" href="#sending-requests-to-threads-via-channels" id="sending-requests-to-threads-via-channels">Sending Requests to Threads via Channels</a></h4>
<p>Now we’ll tackle the problem that the closures given to <code>thread::spawn</code> do
absolutely nothing. Currently, we get the closure we want to execute in the
<code>execute</code> method. But we need to give <code>thread::spawn</code> a closure to run when we
create each <code>Worker</code> during the creation of the <code>ThreadPool</code>.</p>
<p>We want the <code>Worker</code> structs that we just created to fetch code to run from a
queue held in the <code>ThreadPool</code> and send that code to its thread to run.</p>
<p>In Chapter 16, you learned about <em>channels</em>—a simple way to communicate between
two threads—that would be perfect for this use case. We’ll use a channel to
function as the queue of jobs, and <code>execute</code> will send a job from the
<code>ThreadPool</code> to the <code>Worker</code> instances, which will send the job to its thread.
Here is the plan:</p>
<ol>
<li>The <code>ThreadPool</code> will create a channel and hold on to the sending side of
the channel.</li>
<li>Each <code>Worker</code> will hold on to the receiving side of the channel.</li>
<li>We’ll create a new <code>Job</code> struct that will hold the closures we want to send
down the channel.</li>
<li>The <code>execute</code> method will send the job it wants to execute down the sending
side of the channel.</li>
<li>In its thread, the <code>Worker</code> will loop over its receiving side of the channel
and execute the closures of any jobs it receives.</li>
</ol>
<p>Let’s start by creating a channel in <code>ThreadPool::new</code> and holding the sending
side in the <code>ThreadPool</code> instance, as shown in Listing 20-16. The <code>Job</code> struct
doesn’t hold anything for now but will be the type of item we’re sending down
the channel.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span>// --snip--
use std::sync::mpsc;

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Job&gt;,
}

struct Job;

impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}
<span class="boring">
</span><span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Worker {
</span><span class="boring">    fn new(id: usize) -&gt; Worker {
</span><span class="boring">        let thread = thread::spawn(|| {});
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-16: Modifying <code>ThreadPool</code> to store the
sending end of a channel that sends <code>Job</code> instances</span></p>
<p>In <code>ThreadPool::new</code>, we create our new channel and have the pool hold the
sending end. This will successfully compile, still with warnings.</p>
<p>Let’s try passing a receiving end of the channel into each worker as the thread
pool creates the channel. We know we want to use the receiving end in the
thread that the workers spawn, so we’ll reference the <code>receiver</code> parameter in
the closure. The code in Listing 20-17 won’t quite compile yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver));
        }

        ThreadPool {
            workers,
            sender,
        }
    }
    // --snip--
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: mpsc::Receiver&lt;Job&gt;) -&gt; Worker {
        let thread = thread::spawn(|| {
            receiver;
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-17: Passing the receiving end of the channel
to the workers</span></p>
<p>We’ve made some small and straightforward changes: we pass the receiving end of
the channel into <code>Worker::new</code>, and then we use it inside the closure.</p>
<p>When we try to check this code, we get this error:</p>
<pre><code class="language-text">$ cargo check
   Compiling hello v0.1.0 (file:///projects/hello)
error[E0382]: use of moved value: `receiver`
  --&gt; src/lib.rs:27:42
   |
27 |             workers.push(Worker::new(id, receiver));
   |                                          ^^^^^^^^ value moved here in
   previous iteration of loop
   |
   = note: move occurs because `receiver` has type
   `std::sync::mpsc::Receiver&lt;Job&gt;`, which does not implement the `Copy` trait
</code></pre>
<p>The code is trying to pass <code>receiver</code> to multiple <code>Worker</code> instances. This
won’t work, as you’ll recall from Chapter 16: the channel implementation that
Rust provides is multiple <em>producer</em>, single <em>consumer</em>. This means we can’t
just clone the consuming end of the channel to fix this code. Even if we could,
that is not the technique we would want to use; instead, we want to distribute
the jobs across threads by sharing the single <code>receiver</code> among all the workers.</p>
<p>Additionally, taking a job off the channel queue involves mutating the
<code>receiver</code>, so the threads need a safe way to share and modify <code>receiver</code>;
otherwise, we might get race conditions (as covered in Chapter 16).</p>
<p>Recall the thread-safe smart pointers discussed in Chapter 16: to share
ownership across multiple threads and allow the threads to mutate the value, we
need to use <code>Arc&lt;Mutex&lt;T&gt;&gt;</code>. The <code>Arc</code> type will let multiple workers own the
receiver, and <code>Mutex</code> will ensure that only one worker gets a job from the
receiver at a time. Listing 20-18 shows the changes we need to make.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span><span class="boring">use std::sync::mpsc;
</span>use std::sync::Arc;
use std::sync::Mutex;
// --snip--

<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">struct Job;
</span><span class="boring">
</span>impl ThreadPool {
    // --snip--
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    // --snip--
}

<span class="boring">struct Worker {
</span><span class="boring">    id: usize,
</span><span class="boring">    thread: thread::JoinHandle&lt;()&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--
<span class="boring">        let thread = thread::spawn(|| {
</span><span class="boring">           receiver;
</span><span class="boring">        });
</span><span class="boring">
</span><span class="boring">        Worker {
</span><span class="boring">            id,
</span><span class="boring">            thread,
</span><span class="boring">        }
</span>    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-18: Sharing the receiving end of the channel
among the workers using <code>Arc</code> and <code>Mutex</code></span></p>
<p>In <code>ThreadPool::new</code>, we put the receiving end of the channel in an <code>Arc</code> and a
<code>Mutex</code>. For each new worker, we clone the <code>Arc</code> to bump the reference count so
the workers can share ownership of the receiving end.</p>
<p>With these changes, the code compiles! We’re getting there!</p>
<h4><a class="header" href="#implementing-the-execute-method" id="implementing-the-execute-method">Implementing the <code>execute</code> Method</a></h4>
<p>Let’s finally implement the <code>execute</code> method on <code>ThreadPool</code>. We’ll also change
<code>Job</code> from a struct to a type alias for a trait object that holds the type of
closure that <code>execute</code> receives. As discussed in the <a href="rustbook/ch19-04-advanced-types.html#creating-type-synonyms-with-type-aliases">“Creating Type Synonyms
with Type Aliases”</a><!-- ignore -->
section of Chapter 19, type aliases allow us to make long types shorter. Look
at Listing 20-19.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// --snip--
<span class="boring">pub struct ThreadPool {
</span><span class="boring">    workers: Vec&lt;Worker&gt;,
</span><span class="boring">    sender: mpsc::Sender&lt;Job&gt;,
</span><span class="boring">}
</span><span class="boring">use std::sync::mpsc;
</span><span class="boring">struct Worker {}
</span>
type Job = Box&lt;FnOnce() + Send + 'static&gt;;

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

// --snip--
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Listing 20-19: Creating a <code>Job</code> type alias for a <code>Box</code>
that holds each closure and then sending the job down the channel</span></p>
<p>After creating a new <code>Job</code> instance using the closure we get in <code>execute</code>, we
send that job down the sending end of the channel. We’re calling <code>unwrap</code> on
<code>send</code> for the case that sending fails. This might happen if, for example, we
stop all our threads from executing, meaning the receiving end has stopped
receiving new messages. At the moment, we can’t stop our threads from
executing: our threads continue executing as long as the pool exists. The
reason we use <code>unwrap</code> is that we know the failure case won’t happen, but the
compiler doesn’t know that.</p>
<p>But we’re not quite done yet! In the worker, our closure being passed to
<code>thread::spawn</code> still only <em>references</em> the receiving end of the channel.
Instead, we need the closure to loop forever, asking the receiving end of the
channel for a job and running the job when it gets one. Let’s make the change
shown in Listing 20-20 to <code>Worker::new</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                (*job)();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-20: Receiving and executing the jobs in the
worker’s thread</span></p>
<p>Here, we first call <code>lock</code> on the <code>receiver</code> to acquire the mutex, and then we
call <code>unwrap</code> to panic on any errors. Acquiring a lock might fail if the mutex
is in a <em>poisoned</em> state, which can happen if some other thread panicked while
holding the lock rather than releasing the lock. In this situation, calling
<code>unwrap</code> to have this thread panic is the correct action to take. Feel free to
change this <code>unwrap</code> to an <code>expect</code> with an error message that is meaningful to
you.</p>
<p>If we get the lock on the mutex, we call <code>recv</code> to receive a <code>Job</code> from the
channel. A final <code>unwrap</code> moves past any errors here as well, which might occur
if the thread holding the sending side of the channel has shut down, similar to
how the <code>send</code> method returns <code>Err</code> if the receiving side shuts down.</p>
<p>The call to <code>recv</code> blocks, so if there is no job yet, the current thread will
wait until a job becomes available. The <code>Mutex&lt;T&gt;</code> ensures that only one
<code>Worker</code> thread at a time is trying to request a job.</p>
<p>Theoretically, this code should compile. Unfortunately, the Rust compiler isn’t
perfect yet, and we get this error:</p>
<pre><code class="language-text">error[E0161]: cannot move a value of type std::ops::FnOnce() +
std::marker::Send: the size of std::ops::FnOnce() + std::marker::Send cannot be
statically determined
  --&gt; src/lib.rs:63:17
   |
63 |                 (*job)();
   |                 ^^^^^^
</code></pre>
<p>This error is fairly cryptic because the problem is fairly cryptic. To call a
<code>FnOnce</code> closure that is stored in a <code>Box&lt;T&gt;</code> (which is what our <code>Job</code> type
alias is), the closure needs to move itself <em>out</em> of the <code>Box&lt;T&gt;</code> because the
closure takes ownership of <code>self</code> when we call it. In general, Rust doesn’t
allow us to move a value out of a <code>Box&lt;T&gt;</code> because Rust doesn’t know how big
the value inside the <code>Box&lt;T&gt;</code> will be: recall in Chapter 15 that we used
<code>Box&lt;T&gt;</code> precisely because we had something of an unknown size that we wanted
to store in a <code>Box&lt;T&gt;</code> to get a value of a known size.</p>
<p>As you saw in Listing 17-15, we can write methods that use the syntax <code>self: Box&lt;Self&gt;</code>, which allows the method to take ownership of a <code>Self</code> value stored
in a <code>Box&lt;T&gt;</code>. That’s exactly what we want to do here, but unfortunately Rust
won’t let us: the part of Rust that implements behavior when a closure is
called isn’t implemented using <code>self: Box&lt;Self&gt;</code>. So Rust doesn’t yet
understand that it could use <code>self: Box&lt;Self&gt;</code> in this situation to take
ownership of the closure and move the closure out of the <code>Box&lt;T&gt;</code>.</p>
<p>Rust is still a work in progress with places where the compiler could be
improved, but in the future, the code in Listing 20-20 should work just fine.
People just like you are working to fix this and other issues! After you’ve
finished this book, we would love for you to join in.</p>
<p>But for now, let’s work around this problem using a handy trick. We can tell
Rust explicitly that in this case we can take ownership of the value inside the
<code>Box&lt;T&gt;</code> using <code>self: Box&lt;Self&gt;</code>; then, once we have ownership of the closure,
we can call it. This involves defining a new trait <code>FnBox</code> with the method
<code>call_box</code> that will use <code>self: Box&lt;Self&gt;</code> in its signature, defining <code>FnBox</code>
for any type that implements <code>FnOnce()</code>, changing our type alias to use the new
trait, and changing <code>Worker</code> to use the <code>call_box</code> method. These changes are
shown in Listing 20-21.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;dyn FnBox + Send + 'static&gt;;

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            loop {
                let job = receiver.lock().unwrap().recv().unwrap();

                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-21: Adding a new trait <code>FnBox</code> to work around
the current limitations of <code>Box&lt;FnOnce()&gt;</code></span></p>
<p>First, we create a new trait named <code>FnBox</code>. This trait has the one method
<code>call_box</code>, which is similar to the <code>call</code> methods on the other <code>Fn*</code> traits
except that it takes <code>self: Box&lt;Self&gt;</code> to take ownership of <code>self</code> and move the
value out of the <code>Box&lt;T&gt;</code>.</p>
<p>Next, we implement the <code>FnBox</code> trait for any type <code>F</code> that implements the
<code>FnOnce()</code> trait. Effectively, this means that any <code>FnOnce()</code> closures can use
our <code>call_box</code> method. The implementation of <code>call_box</code> uses <code>(*self)()</code> to
move the closure out of the <code>Box&lt;T&gt;</code> and call the closure.</p>
<p>We now need our <code>Job</code> type alias to be a <code>Box</code> of anything that implements our
new trait <code>FnBox</code>. This will allow us to use <code>call_box</code> in <code>Worker</code> when we get
a <code>Job</code> value instead of invoking the closure directly. Implementing the
<code>FnBox</code> trait for any <code>FnOnce()</code> closure means we don’t have to change anything
about the actual values we’re sending down the channel. Now Rust is able to
recognize that what we want to do is fine.</p>
<p>This trick is very sneaky and complicated. Don’t worry if it doesn’t make
perfect sense; someday, it will be completely unnecessary.</p>
<p>With the implementation of this trick, our thread pool is in a working state!
Give it a <code>cargo run</code> and make some requests:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
warning: field is never used: `workers`
 --&gt; src/lib.rs:7:5
  |
7 |     workers: Vec&lt;Worker&gt;,
  |     ^^^^^^^^^^^^^^^^^^^^
  |
  = note: #[warn(dead_code)] on by default

warning: field is never used: `id`
  --&gt; src/lib.rs:61:5
   |
61 |     id: usize,
   |     ^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

warning: field is never used: `thread`
  --&gt; src/lib.rs:62:5
   |
62 |     thread: thread::JoinHandle&lt;()&gt;,
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: #[warn(dead_code)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.99 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
Worker 1 got a job; executing.
Worker 3 got a job; executing.
Worker 0 got a job; executing.
Worker 2 got a job; executing.
</code></pre>
<p>Success! We now have a thread pool that executes connections asynchronously.
There are never more than four threads created, so our system won’t get
overloaded if the server receives a lot of requests. If we make a request to
<em>/sleep</em>, the server will be able to serve other requests by having another
thread run them.</p>
<blockquote>
<p>Note: if you open <em>/sleep</em> in multiple browser windows simultaneously, they
might load one at a time in 5 second intervals. Some web browsers execute
multiple instances of the same request sequentially for caching reasons. This
limitation is not caused by our web server.</p>
</blockquote>
<p>After learning about the <code>while let</code> loop in Chapter 18, you might be wondering
why we didn’t write the worker thread code as shown in Listing 20-22.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore not_desired_behavior">// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        let thread = thread::spawn(move || {
            while let Ok(job) = receiver.lock().unwrap().recv() {
                println!(&quot;Worker {} got a job; executing.&quot;, id);

                job.call_box();
            }
        });

        Worker {
            id,
            thread,
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-22: An alternative implementation of
<code>Worker::new</code> using <code>while let</code></span></p>
<p>This code compiles and runs but doesn’t result in the desired threading
behavior: a slow request will still cause other requests to wait to be
processed. The reason is somewhat subtle: the <code>Mutex</code> struct has no public
<code>unlock</code> method because the ownership of the lock is based on the lifetime of
the <code>MutexGuard&lt;T&gt;</code> within the <code>LockResult&lt;MutexGuard&lt;T&gt;&gt;</code> that the <code>lock</code>
method returns. At compile time, the borrow checker can then enforce the rule
that a resource guarded by a <code>Mutex</code> cannot be accessed unless we hold the
lock. But this implementation can also result in the lock being held longer
than intended if we don’t think carefully about the lifetime of the
<code>MutexGuard&lt;T&gt;</code>. Because the values in the <code>while</code> expression remain in scope
for the duration of the block, the lock remains held for the duration of the
call to <code>job.call_box()</code>, meaning other workers cannot receive jobs.</p>
<p>By using <code>loop</code> instead and acquiring the lock and a job within the block
rather than outside it, the <code>MutexGuard</code> returned from the <code>lock</code> method is
dropped as soon as the <code>let job</code> statement ends. This ensures that the lock is
held during the call to <code>recv</code>, but it is released before the call to
<code>job.call_box()</code>, allowing multiple requests to be serviced concurrently.</p>
<h2><a class="header" href="#graceful-shutdown-and-cleanup" id="graceful-shutdown-and-cleanup">Graceful Shutdown and Cleanup</a></h2>
<p>The code in Listing 20-21 is responding to requests asynchronously through the
use of a thread pool, as we intended. We get some warnings about the <code>workers</code>,
<code>id</code>, and <code>thread</code> fields that we’re not using in a direct way that reminds us
we’re not cleaning up anything. When we use the less elegant <span
class="keystroke">ctrl-c</span> method to halt the main thread, all other
threads are stopped immediately as well, even if they’re in the middle of
serving a request.</p>
<p>Now we’ll implement the <code>Drop</code> trait to call <code>join</code> on each of the threads in
the pool so they can finish the requests they’re working on before closing.
Then we’ll implement a way to tell the threads they should stop accepting new
requests and shut down. To see this code in action, we’ll modify our server to
accept only two requests before gracefully shutting down its thread pool.</p>
<h3><a class="header" href="#implementing-the-drop-trait-on-threadpool" id="implementing-the-drop-trait-on-threadpool">Implementing the <code>Drop</code> Trait on <code>ThreadPool</code></a></h3>
<p>Let’s start with implementing <code>Drop</code> on our thread pool. When the pool is
dropped, our threads should all join to make sure they finish their work.
Listing 20-23 shows a first attempt at a <code>Drop</code> implementation; this code won’t
quite work yet.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            worker.thread.join().unwrap();
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-23: Joining each thread when the thread pool
goes out of scope</span></p>
<p>First, we loop through each of the thread pool <code>workers</code>. We use <code>&amp;mut</code> for
this because <code>self</code> is a mutable reference, and we also need to be able to
mutate <code>worker</code>. For each worker, we print a message saying that this
particular worker is shutting down, and then we call <code>join</code> on that worker’s
thread. If the call to <code>join</code> fails, we use <code>unwrap</code> to make Rust panic and go
into an ungraceful shutdown.</p>
<p>Here is the error we get when we compile this code:</p>
<pre><code class="language-text">error[E0507]: cannot move out of borrowed content
  --&gt; src/lib.rs:65:13
   |
65 |             worker.thread.join().unwrap();
   |             ^^^^^^ cannot move out of borrowed content
</code></pre>
<p>The error tells us we can’t call <code>join</code> because we only have a mutable borrow
of each <code>worker</code> and <code>join</code> takes ownership of its argument. To solve this
issue, we need to move the thread out of the <code>Worker</code> instance that owns
<code>thread</code> so <code>join</code> can consume the thread. We did this in Listing 17-15: if
<code>Worker</code> holds an <code>Option&lt;thread::JoinHandle&lt;()&gt;&gt;</code> instead, we can call the
<code>take</code> method on the <code>Option</code> to move the value out of the <code>Some</code> variant and
leave a <code>None</code> variant in its place. In other words, a <code>Worker</code> that is running
will have a <code>Some</code> variant in <code>thread</code>, and when we want to clean up a
<code>Worker</code>, we’ll replace <code>Some</code> with <code>None</code> so the <code>Worker</code> doesn’t have a
thread to run.</p>
<p>So we know we want to update the definition of <code>Worker</code> like this:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::thread;
</span>struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>Now let’s lean on the compiler to find the other places that need to change.
Checking this code, we get two errors:</p>
<pre><code class="language-text">error[E0599]: no method named `join` found for type
`std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;` in the current scope
  --&gt; src/lib.rs:65:27
   |
65 |             worker.thread.join().unwrap();
   |                           ^^^^

error[E0308]: mismatched types
  --&gt; src/lib.rs:89:13
   |
89 |             thread,
   |             ^^^^^^
   |             |
   |             expected enum `std::option::Option`, found struct
   `std::thread::JoinHandle`
   |             help: try using a variant of the expected type: `Some(thread)`
   |
   = note: expected type `std::option::Option&lt;std::thread::JoinHandle&lt;()&gt;&gt;`
              found type `std::thread::JoinHandle&lt;_&gt;`
</code></pre>
<p>Let’s address the second error, which points to the code at the end of
<code>Worker::new</code>; we need to wrap the <code>thread</code> value in <code>Some</code> when we create a
new <code>Worker</code>. Make the following changes to fix this error:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker {
        // --snip--

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p>The first error is in our <code>Drop</code> implementation. We mentioned earlier that we
intended to call <code>take</code> on the <code>Option</code> value to move <code>thread</code> out of <code>worker</code>.
The following changes will do so:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p>As discussed in Chapter 17, the <code>take</code> method on <code>Option</code> takes the <code>Some</code>
variant out and leaves <code>None</code> in its place. We’re using <code>if let</code> to destructure
the <code>Some</code> and get the thread; then we call <code>join</code> on the thread. If a worker’s
thread is already <code>None</code>, we know that worker has already had its thread
cleaned up, so nothing happens in that case.</p>
<h3><a class="header" href="#signaling-to-the-threads-to-stop-listening-for-jobs" id="signaling-to-the-threads-to-stop-listening-for-jobs">Signaling to the Threads to Stop Listening for Jobs</a></h3>
<p>With all the changes we’ve made, our code compiles without any warnings. But
the bad news is this code doesn’t function the way we want it to yet. The key
is the logic in the closures run by the threads of the <code>Worker</code> instances: at
the moment, we call <code>join</code>, but that won’t shut down the threads because they
<code>loop</code> forever looking for jobs. If we try to drop our <code>ThreadPool</code> with our
current implementation of <code>drop</code>, the main thread will block forever waiting
for the first thread to finish.</p>
<p>To fix this problem, we’ll modify the threads so they listen for either a <code>Job</code>
to run or a signal that they should stop listening and exit the infinite loop.
Instead of <code>Job</code> instances, our channel will send one of these two enum
variants.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Job;
</span>enum Message {
    NewJob(Job),
    Terminate,
}
<span class="boring">}
</span></code></pre></pre>
<p>This <code>Message</code> enum will either be a <code>NewJob</code> variant that holds the <code>Job</code> the
thread should run, or it will be a <code>Terminate</code> variant that will cause the
thread to exit its loop and stop.</p>
<p>We need to adjust the channel to use values of type <code>Message</code> rather than type
<code>Job</code>, as shown in Listing 20-24.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

// --snip--

impl ThreadPool {
    // --snip--

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

// --snip--

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-24: Sending and receiving <code>Message</code> values and
exiting the loop if a <code>Worker</code> receives <code>Message::Terminate</code></span></p>
<p>To incorporate the <code>Message</code> enum, we need to change <code>Job</code> to <code>Message</code> in two
places: the definition of <code>ThreadPool</code> and the signature of <code>Worker::new</code>. The
<code>execute</code> method of <code>ThreadPool</code> needs to send jobs wrapped in the
<code>Message::NewJob</code> variant. Then, in <code>Worker::new</code> where a <code>Message</code> is received
from the channel, the job will be processed if the <code>NewJob</code> variant is
received, and the thread will break out of the loop if the <code>Terminate</code> variant
is received.</p>
<p>With these changes, the code will compile and continue to function in the same
way as it did after Listing 20-21. But we’ll get a warning because we aren’t
creating any messages of the <code>Terminate</code> variety. Let’s fix this warning by
changing our <code>Drop</code> implementation to look like Listing 20-25.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><code class="language-rust ignore">impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}
</code></pre>
<p><span class="caption">Listing 20-25: Sending <code>Message::Terminate</code> to the
workers before calling <code>join</code> on each worker thread</span></p>
<p>We’re now iterating over the workers twice: once to send one <code>Terminate</code>
message for each worker and once to call <code>join</code> on each worker’s thread. If we
tried to send a message and <code>join</code> immediately in the same loop, we couldn’t
guarantee that the worker in the current iteration would be the one to get the
message from the channel.</p>
<p>To better understand why we need two separate loops, imagine a scenario with
two workers. If we used a single loop to iterate through each worker, on the
first iteration a terminate message would be sent down the channel and <code>join</code>
called on the first worker’s thread. If that first worker was busy processing a
request at that moment, the second worker would pick up the terminate message
from the channel and shut down. We would be left waiting on the first worker to
shut down, but it never would because the second thread picked up the terminate
message. Deadlock!</p>
<p>To prevent this scenario, we first put all of our <code>Terminate</code> messages on the
channel in one loop; then we join on all the threads in another loop. Each
worker will stop receiving requests on the channel once it gets a terminate
message. So, we can be sure that if we send the same number of terminate
messages as there are workers, each worker will receive a terminate message
before <code>join</code> is called on its thread.</p>
<p>To see this code in action, let’s modify <code>main</code> to accept only two requests
before gracefully shutting down the server, as shown in Listing 20-26.</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}
</code></pre>
<p><span class="caption">Listing 20-26: Shut down the server after serving two
requests by exiting the loop</span></p>
<p>You wouldn’t want a real-world web server to shut down after serving only two
requests. This code just demonstrates that the graceful shutdown and cleanup is
in working order.</p>
<p>The <code>take</code> method is defined in the <code>Iterator</code> trait and limits the iteration
to the first two items at most. The <code>ThreadPool</code> will go out of scope at the
end of <code>main</code>, and the <code>drop</code> implementation will run.</p>
<p>Start the server with <code>cargo run</code>, and make three requests. The third request
should error, and in your terminal you should see output similar to this:</p>
<pre><code class="language-text">$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 1.0 secs
     Running `target/debug/hello`
Worker 0 got a job; executing.
Worker 3 got a job; executing.
Shutting down.
Sending terminate message to all workers.
Shutting down all workers.
Shutting down worker 0
Worker 1 was told to terminate.
Worker 2 was told to terminate.
Worker 0 was told to terminate.
Worker 3 was told to terminate.
Shutting down worker 1
Shutting down worker 2
Shutting down worker 3
</code></pre>
<p>You might see a different ordering of workers and messages printed. We can see
how this code works from the messages: workers 0 and 3 got the first two
requests, and then on the third request, the server stopped accepting
connections. When the <code>ThreadPool</code> goes out of scope at the end of <code>main</code>, its
<code>Drop</code> implementation kicks in, and the pool tells all workers to terminate.
The workers each print a message when they see the terminate message, and then
the thread pool calls <code>join</code> to shut down each worker thread.</p>
<p>Notice one interesting aspect of this particular execution: the <code>ThreadPool</code>
sent the terminate messages down the channel, and before any worker received
the messages, we tried to join worker 0. Worker 0 had not yet received the
terminate message, so the main thread blocked waiting for worker 0 to finish.
In the meantime, each of the workers received the termination messages. When
worker 0 finished, the main thread waited for the rest of the workers to
finish. At that point, they had all received the termination message and were
able to shut down.</p>
<p>Congrats! We’ve now completed our project; we have a basic web server that uses
a thread pool to respond asynchronously. We’re able to perform a graceful
shutdown of the server, which cleans up all the threads in the pool.</p>
<p>Here’s the full code for reference:</p>
<p><span class="filename">Filename: src/bin/main.rs</span></p>
<pre><code class="language-rust ignore">use hello::ThreadPool;

use std::io::prelude::*;
use std::net::TcpListener;
use std::net::TcpStream;
use std::fs;
use std::thread;
use std::time::Duration;

fn main() {
    let listener = TcpListener::bind(&quot;127.0.0.1:7878&quot;).unwrap();
    let pool = ThreadPool::new(4);

    for stream in listener.incoming().take(2) {
        let stream = stream.unwrap();

        pool.execute(|| {
            handle_connection(stream);
        });
    }

    println!(&quot;Shutting down.&quot;);
}

fn handle_connection(mut stream: TcpStream) {
    let mut buffer = [0; 512];
    stream.read(&amp;mut buffer).unwrap();

    let get = b&quot;GET / HTTP/1.1\r\n&quot;;
    let sleep = b&quot;GET /sleep HTTP/1.1\r\n&quot;;

    let (status_line, filename) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else if buffer.starts_with(sleep) {
        thread::sleep(Duration::from_secs(5));
        (&quot;HTTP/1.1 200 OK\r\n\r\n&quot;, &quot;hello.html&quot;)
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND\r\n\r\n&quot;, &quot;404.html&quot;)
    };

    let contents = fs::read_to_string(filename).unwrap();

    let response = format!(&quot;{}{}&quot;, status_line, contents);

    stream.write(response.as_bytes()).unwrap();
    stream.flush().unwrap();
}
</code></pre>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::thread;
use std::sync::mpsc;
use std::sync::Arc;
use std::sync::Mutex;

enum Message {
    NewJob(Job),
    Terminate,
}

pub struct ThreadPool {
    workers: Vec&lt;Worker&gt;,
    sender: mpsc::Sender&lt;Message&gt;,
}

trait FnBox {
    fn call_box(self: Box&lt;Self&gt;);
}

impl&lt;F: FnOnce()&gt; FnBox for F {
    fn call_box(self: Box&lt;F&gt;) {
        (*self)()
    }
}

type Job = Box&lt;dyn FnBox + Send + 'static&gt;;

impl ThreadPool {
    /// Create a new ThreadPool.
    ///
    /// The size is the number of threads in the pool.
    ///
    /// # Panics
    ///
    /// The `new` function will panic if the size is zero.
    pub fn new(size: usize) -&gt; ThreadPool {
        assert!(size &gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, Arc::clone(&amp;receiver)));
        }

        ThreadPool {
            workers,
            sender,
        }
    }

    pub fn execute&lt;F&gt;(&amp;self, f: F)
        where
            F: FnOnce() + Send + 'static
    {
        let job = Box::new(f);

        self.sender.send(Message::NewJob(job)).unwrap();
    }
}

impl Drop for ThreadPool {
    fn drop(&amp;mut self) {
        println!(&quot;Sending terminate message to all workers.&quot;);

        for _ in &amp;mut self.workers {
            self.sender.send(Message::Terminate).unwrap();
        }

        println!(&quot;Shutting down all workers.&quot;);

        for worker in &amp;mut self.workers {
            println!(&quot;Shutting down worker {}&quot;, worker.id);

            if let Some(thread) = worker.thread.take() {
                thread.join().unwrap();
            }
        }
    }
}

struct Worker {
    id: usize,
    thread: Option&lt;thread::JoinHandle&lt;()&gt;&gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Message&gt;&gt;&gt;) -&gt;
        Worker {

        let thread = thread::spawn(move ||{
            loop {
                let message = receiver.lock().unwrap().recv().unwrap();

                match message {
                    Message::NewJob(job) =&gt; {
                        println!(&quot;Worker {} got a job; executing.&quot;, id);

                        job.call_box();
                    },
                    Message::Terminate =&gt; {
                        println!(&quot;Worker {} was told to terminate.&quot;, id);

                        break;
                    },
                }
            }
        });

        Worker {
            id,
            thread: Some(thread),
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>We could do more here! If you want to continue enhancing this project, here are
some ideas:</p>
<ul>
<li>Add more documentation to <code>ThreadPool</code> and its public methods.</li>
<li>Add tests of the library’s functionality.</li>
<li>Change calls to <code>unwrap</code> to more robust error handling.</li>
<li>Use <code>ThreadPool</code> to perform some task other than serving web requests.</li>
<li>Find a thread pool crate on <a href="https://crates.io/">crates.io</a> and implement a
similar web server using the crate instead. Then compare its API and
robustness to the thread pool we implemented.</li>
</ul>
<h2><a class="header" href="#summary-19" id="summary-19">Summary</a></h2>
<p>Well done! You’ve made it to the end of the book! We want to thank you for
joining us on this tour of Rust. You’re now ready to implement your own Rust
projects and help with other peoples’ projects. Keep in mind that there is a
welcoming community of other Rustaceans who would love to help you with any
challenges you encounter on your Rust journey.</p>
<h1><a class="header" href="#appendix" id="appendix">Appendix</a></h1>
<p>The following sections contain reference material you may find useful in your
Rust journey.</p>
<h2><a class="header" href="#appendix-a-keywords" id="appendix-a-keywords">Appendix A: Keywords</a></h2>
<p>The following list contains keywords that are reserved for current or future
use by the Rust language. As such, they cannot be used as identifiers (except
as raw identifiers as we’ll discuss in the “<a href="rustbook/appendix-01-keywords.html#raw-identifiers">Raw
Identifiers</a><!-- ignore -->” section), including names of
functions, variables, parameters, struct fields, modules, crates, constants,
macros, static values, attributes, types, traits, or lifetimes.</p>
<h3><a class="header" href="#keywords-currently-in-use" id="keywords-currently-in-use">Keywords Currently in Use</a></h3>
<p>The following keywords currently have the functionality described.</p>
<ul>
<li><code>as</code> - perform primitive casting, disambiguate the specific trait containing
an item, or rename items in <code>use</code> and <code>extern crate</code> statements</li>
<li><code>break</code> - exit a loop immediately</li>
<li><code>const</code> - define constant items or constant raw pointers</li>
<li><code>continue</code> - continue to the next loop iteration</li>
<li><code>crate</code> - link an external crate or a macro variable representing the crate in
which the macro is defined</li>
<li><code>dyn</code> - dynamic dispatch to a trait object</li>
<li><code>else</code> - fallback for <code>if</code> and <code>if let</code> control flow constructs</li>
<li><code>enum</code> - define an enumeration</li>
<li><code>extern</code> - link an external crate, function, or variable</li>
<li><code>false</code> - Boolean false literal</li>
<li><code>fn</code> - define a function or the function pointer type</li>
<li><code>for</code> - loop over items from an iterator, implement a trait, or specify a
higher-ranked lifetime</li>
<li><code>if</code> - branch based on the result of a conditional expression</li>
<li><code>impl</code> - implement inherent or trait functionality</li>
<li><code>in</code> - part of <code>for</code> loop syntax</li>
<li><code>let</code> - bind a variable</li>
<li><code>loop</code> - loop unconditionally</li>
<li><code>match</code> - match a value to patterns</li>
<li><code>mod</code> - define a module</li>
<li><code>move</code> - make a closure take ownership of all its captures</li>
<li><code>mut</code> - denote mutability in references, raw pointers, or pattern bindings</li>
<li><code>pub</code> - denote public visibility in struct fields, <code>impl</code> blocks, or modules</li>
<li><code>ref</code> - bind by reference</li>
<li><code>return</code> - return from function</li>
<li><code>Self</code> - a type alias for the type implementing a trait</li>
<li><code>self</code> - method subject or current module</li>
<li><code>static</code> - global variable or lifetime lasting the entire program execution</li>
<li><code>struct</code> - define a structure</li>
<li><code>super</code> - parent module of the current module</li>
<li><code>trait</code> - define a trait</li>
<li><code>true</code> - Boolean true literal</li>
<li><code>type</code> - define a type alias or associated type</li>
<li><code>unsafe</code> - denote unsafe code, functions, traits, or implementations</li>
<li><code>use</code> - bring symbols into scope</li>
<li><code>where</code> - denote clauses that constrain a type</li>
<li><code>while</code> - loop conditionally based on the result of an expression</li>
</ul>
<h3><a class="header" href="#keywords-reserved-for-future-use" id="keywords-reserved-for-future-use">Keywords Reserved for Future Use</a></h3>
<p>The following keywords do not have any functionality but are reserved by Rust
for potential future use.</p>
<ul>
<li><code>abstract</code></li>
<li><code>async</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3><a class="header" href="#raw-identifiers-1" id="raw-identifiers-1">Raw Identifiers</a></h3>
<p><em>Raw identifiers</em> are the syntax that lets you use keywords where they wouldn’t
normally be allowed. You use a raw identifier by prefixing a keyword with <code>r#</code>.</p>
<p>For example, <code>match</code> is a keyword. If you try to compile the following function
that uses <code>match</code> as its name:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><code class="language-rust ignore does_not_compile">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>you’ll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>The error shows that you can’t use the keyword <code>match</code> as the function
identifier. To use <code>match</code> as a function name, you need to use the raw
identifier syntax, like this:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>This code will compile without any errors. Note the <code>r#</code> prefix on the function
name in its definition as well as where the function is called in <code>main</code>.</p>
<p>Raw identifiers allow you to use any word you choose as an identifier, even if
that word happens to be a reserved keyword. In addition, raw identifiers allow
you to use libraries written in a different Rust edition than your crate uses.
For example, <code>try</code> isn’t a keyword in the 2015 edition but is in the 2018
edition. If you depend on a library that’s written using the 2015 edition and
has a <code>try</code> function, you’ll need to use the raw identifier syntax, <code>r#try</code> in
this case, to call that function from your 2018 edition code. See <a href="rustbook/appendix-05-editions.html">Appendix
E</a><!-- ignore --> for more information on editions.</p>
<h2><a class="header" href="#appendix-b-operators-and-symbols" id="appendix-b-operators-and-symbols">Appendix B: Operators and Symbols</a></h2>
<p>This appendix contains a glossary of Rust’s syntax, including operators and
other symbols that appear by themselves or in the context of paths, generics,
trait bounds, macros, attributes, comments, tuples, and brackets.</p>
<h3><a class="header" href="#operators" id="operators">Operators</a></h3>
<p>Table B-1 contains the operators in Rust, an example of how the operator would
appear in context, a short explanation, and whether that operator is
overloadable. If an operator is overloadable, the relevant trait to use to
overload that operator is listed.</p>
<p><span class="caption">Table B-1: Operators</span></p>
<table><thead><tr><th>Operator</th><th>Example</th><th>Explanation</th><th>Overloadable?</th></tr></thead><tbody>
<tr><td><code>!</code></td><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro expansion</td><td></td></tr>
<tr><td><code>!</code></td><td><code>!expr</code></td><td>Bitwise or logical complement</td><td><code>Not</code></td></tr>
<tr><td><code>!=</code></td><td><code>var != expr</code></td><td>Nonequality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>%</code></td><td><code>expr % expr</code></td><td>Arithmetic remainder</td><td><code>Rem</code></td></tr>
<tr><td><code>%=</code></td><td><code>var %= expr</code></td><td>Arithmetic remainder and assignment</td><td><code>RemAssign</code></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;expr</code>, <code>&amp;mut expr</code></td><td>Borrow</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>&amp;type</code>, <code>&amp;mut type</code>, <code>&amp;'a type</code>, <code>&amp;'a mut type</code></td><td>Borrowed pointer type</td><td></td></tr>
<tr><td><code>&amp;</code></td><td><code>expr &amp; expr</code></td><td>Bitwise AND</td><td><code>BitAnd</code></td></tr>
<tr><td><code>&amp;=</code></td><td><code>var &amp;= expr</code></td><td>Bitwise AND and assignment</td><td><code>BitAndAssign</code></td></tr>
<tr><td><code>&amp;&amp;</code></td><td><code>expr &amp;&amp; expr</code></td><td>Logical AND</td><td></td></tr>
<tr><td><code>*</code></td><td><code>expr * expr</code></td><td>Arithmetic multiplication</td><td><code>Mul</code></td></tr>
<tr><td><code>*=</code></td><td><code>var *= expr</code></td><td>Arithmetic multiplication and assignment</td><td><code>MulAssign</code></td></tr>
<tr><td><code>*</code></td><td><code>*expr</code></td><td>Dereference</td><td></td></tr>
<tr><td><code>*</code></td><td><code>*const type</code>, <code>*mut type</code></td><td>Raw pointer</td><td></td></tr>
<tr><td><code>+</code></td><td><code>trait + trait</code>, <code>'a + trait</code></td><td>Compound type constraint</td><td></td></tr>
<tr><td><code>+</code></td><td><code>expr + expr</code></td><td>Arithmetic addition</td><td><code>Add</code></td></tr>
<tr><td><code>+=</code></td><td><code>var += expr</code></td><td>Arithmetic addition and assignment</td><td><code>AddAssign</code></td></tr>
<tr><td><code>,</code></td><td><code>expr, expr</code></td><td>Argument and element separator</td><td></td></tr>
<tr><td><code>-</code></td><td><code>- expr</code></td><td>Arithmetic negation</td><td><code>Neg</code></td></tr>
<tr><td><code>-</code></td><td><code>expr - expr</code></td><td>Arithmetic subtraction</td><td><code>Sub</code></td></tr>
<tr><td><code>-=</code></td><td><code>var -= expr</code></td><td>Arithmetic subtraction and assignment</td><td><code>SubAssign</code></td></tr>
<tr><td><code>-&gt;</code></td><td><code>fn(...) -&gt; type</code>, <code>|...| -&gt; type</code></td><td>Function and closure return type</td><td></td></tr>
<tr><td><code>.</code></td><td><code>expr.ident</code></td><td>Member access</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..</code>, <code>expr..</code>, <code>..expr</code>, <code>expr..expr</code></td><td>Right-exclusive range literal</td><td></td></tr>
<tr><td><code>..=</code></td><td><code>..=expr</code>, <code>expr..=expr</code></td><td>Right-inclusive range literal</td><td></td></tr>
<tr><td><code>..</code></td><td><code>..expr</code></td><td>Struct literal update syntax</td><td></td></tr>
<tr><td><code>..</code></td><td><code>variant(x, ..)</code>, <code>struct_type { x, .. }</code></td><td>“And the rest” pattern binding</td><td></td></tr>
<tr><td><code>...</code></td><td><code>expr...expr</code></td><td>In a pattern: inclusive range pattern</td><td></td></tr>
<tr><td><code>/</code></td><td><code>expr / expr</code></td><td>Arithmetic division</td><td><code>Div</code></td></tr>
<tr><td><code>/=</code></td><td><code>var /= expr</code></td><td>Arithmetic division and assignment</td><td><code>DivAssign</code></td></tr>
<tr><td><code>:</code></td><td><code>pat: type</code>, <code>ident: type</code></td><td>Constraints</td><td></td></tr>
<tr><td><code>:</code></td><td><code>ident: expr</code></td><td>Struct field initializer</td><td></td></tr>
<tr><td><code>:</code></td><td><code>'a: loop {...}</code></td><td>Loop label</td><td></td></tr>
<tr><td><code>;</code></td><td><code>expr;</code></td><td>Statement and item terminator</td><td></td></tr>
<tr><td><code>;</code></td><td><code>[...; len]</code></td><td>Part of fixed-size array syntax</td><td></td></tr>
<tr><td><code>&lt;&lt;</code></td><td><code>expr &lt;&lt; expr</code></td><td>Left-shift</td><td><code>Shl</code></td></tr>
<tr><td><code>&lt;&lt;=</code></td><td><code>var &lt;&lt;= expr</code></td><td>Left-shift and assignment</td><td><code>ShlAssign</code></td></tr>
<tr><td><code>&lt;</code></td><td><code>expr &lt; expr</code></td><td>Less than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&lt;=</code></td><td><code>expr &lt;= expr</code></td><td>Less than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>=</code></td><td><code>var = expr</code>, <code>ident = type</code></td><td>Assignment/equivalence</td><td></td></tr>
<tr><td><code>==</code></td><td><code>expr == expr</code></td><td>Equality comparison</td><td><code>PartialEq</code></td></tr>
<tr><td><code>=&gt;</code></td><td><code>pat =&gt; expr</code></td><td>Part of match arm syntax</td><td></td></tr>
<tr><td><code>&gt;</code></td><td><code>expr &gt; expr</code></td><td>Greater than comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;=</code></td><td><code>expr &gt;= expr</code></td><td>Greater than or equal to comparison</td><td><code>PartialOrd</code></td></tr>
<tr><td><code>&gt;&gt;</code></td><td><code>expr &gt;&gt; expr</code></td><td>Right-shift</td><td><code>Shr</code></td></tr>
<tr><td><code>&gt;&gt;=</code></td><td><code>var &gt;&gt;= expr</code></td><td>Right-shift and assignment</td><td><code>ShrAssign</code></td></tr>
<tr><td><code>@</code></td><td><code>ident @ pat</code></td><td>Pattern binding</td><td></td></tr>
<tr><td><code>^</code></td><td><code>expr ^ expr</code></td><td>Bitwise exclusive OR</td><td><code>BitXor</code></td></tr>
<tr><td><code>^=</code></td><td><code>var ^= expr</code></td><td>Bitwise exclusive OR and assignment</td><td><code>BitXorAssign</code></td></tr>
<tr><td><code>|</code></td><td><code>pat | pat</code></td><td>Pattern alternatives</td><td></td></tr>
<tr><td><code>|</code></td><td><code>expr | expr</code></td><td>Bitwise OR</td><td><code>BitOr</code></td></tr>
<tr><td><code>|=</code></td><td><code>var |= expr</code></td><td>Bitwise OR and assignment</td><td><code>BitOrAssign</code></td></tr>
<tr><td><code>||</code></td><td><code>expr || expr</code></td><td>Logical OR</td><td></td></tr>
<tr><td><code>?</code></td><td><code>expr?</code></td><td>Error propagation</td><td></td></tr>
</tbody></table>
<h3><a class="header" href="#non-operator-symbols" id="non-operator-symbols">Non-operator Symbols</a></h3>
<p>The following list contains all non-letters that don’t function as operators;
that is, they don’t behave like a function or method call.</p>
<p>Table B-2 shows symbols that appear on their own and are valid in a variety of
locations.</p>
<p><span class="caption">Table B-2: Stand-Alone Syntax</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>'ident</code></td><td>Named lifetime or loop label</td></tr>
<tr><td><code>...u8</code>, <code>...i32</code>, <code>...f64</code>, <code>...usize</code>, etc.</td><td>Numeric literal of specific type</td></tr>
<tr><td><code>&quot;...&quot;</code></td><td>String literal</td></tr>
<tr><td><code>r&quot;...&quot;</code>, <code>r#&quot;...&quot;#</code>, <code>r##&quot;...&quot;##</code>, etc.</td><td>Raw string literal, escape characters not processed</td></tr>
<tr><td><code>b&quot;...&quot;</code></td><td>Byte string literal; constructs a <code>[u8]</code> instead of a string</td></tr>
<tr><td><code>br&quot;...&quot;</code>, <code>br#&quot;...&quot;#</code>, <code>br##&quot;...&quot;##</code>, etc.</td><td>Raw byte string literal, combination of raw and byte string literal</td></tr>
<tr><td><code>'...'</code></td><td>Character literal</td></tr>
<tr><td><code>b'...'</code></td><td>ASCII byte literal</td></tr>
<tr><td><code>|...| expr</code></td><td>Closure</td></tr>
<tr><td><code>!</code></td><td>Always empty bottom type for diverging functions</td></tr>
<tr><td><code>_</code></td><td>“Ignored” pattern binding; also used to make integer literals readable</td></tr>
</tbody></table>
<p>Table B-3 shows symbols that appear in the context of a path through the module
hierarchy to an item.</p>
<p><span class="caption">Table B-3: Path-Related Syntax</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>ident::ident</code></td><td>Namespace path</td></tr>
<tr><td><code>::path</code></td><td>Path relative to the crate root (i.e., an explicitly absolute path)</td></tr>
<tr><td><code>self::path</code></td><td>Path relative to the current module (i.e., an explicitly relative path).</td></tr>
<tr><td><code>super::path</code></td><td>Path relative to the parent of the current module</td></tr>
<tr><td><code>type::ident</code>, <code>&lt;type as trait&gt;::ident</code></td><td>Associated constants, functions, and types</td></tr>
<tr><td><code>&lt;type&gt;::...</code></td><td>Associated item for a type that cannot be directly named (e.g., <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;::...</code>, etc.)</td></tr>
<tr><td><code>trait::method(...)</code></td><td>Disambiguating a method call by naming the trait that defines it</td></tr>
<tr><td><code>type::method(...)</code></td><td>Disambiguating a method call by naming the type for which it’s defined</td></tr>
<tr><td><code>&lt;type as trait&gt;::method(...)</code></td><td>Disambiguating a method call by naming the trait and type</td></tr>
</tbody></table>
<p>Table B-4 shows symbols that appear in the context of using generic type
parameters.</p>
<p><span class="caption">Table B-4: Generics</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>path&lt;...&gt;</code></td><td>Specifies parameters to generic type in a type (e.g., <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td><code>path::&lt;...&gt;</code>, <code>method::&lt;...&gt;</code></td><td>Specifies parameters to generic type, function, or method in an expression; often referred to as turbofish (e.g., <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td><code>fn ident&lt;...&gt; ...</code></td><td>Define generic function</td></tr>
<tr><td><code>struct ident&lt;...&gt; ...</code></td><td>Define generic structure</td></tr>
<tr><td><code>enum ident&lt;...&gt; ...</code></td><td>Define generic enumeration</td></tr>
<tr><td><code>impl&lt;...&gt; ...</code></td><td>Define generic implementation</td></tr>
<tr><td><code>for&lt;...&gt; type</code></td><td>Higher-ranked lifetime bounds</td></tr>
<tr><td><code>type&lt;ident=type&gt;</code></td><td>A generic type where one or more associated types have specific assignments (e.g., <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
<p>Table B-5 shows symbols that appear in the context of constraining generic type
parameters with trait bounds.</p>
<p><span class="caption">Table B-5: Trait Bound Constraints</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>T: U</code></td><td>Generic parameter <code>T</code> constrained to types that implement <code>U</code></td></tr>
<tr><td><code>T: 'a</code></td><td>Generic type <code>T</code> must outlive lifetime <code>'a</code> (meaning the type cannot transitively contain any references with lifetimes shorter than <code>'a</code>)</td></tr>
<tr><td><code>T : 'static</code></td><td>Generic type <code>T</code> contains no borrowed references other than <code>'static</code> ones</td></tr>
<tr><td><code>'b: 'a</code></td><td>Generic lifetime <code>'b</code> must outlive lifetime <code>'a</code></td></tr>
<tr><td><code>T: ?Sized</code></td><td>Allow generic type parameter to be a dynamically sized type</td></tr>
<tr><td><code>'a + trait</code>, <code>trait + trait</code></td><td>Compound type constraint</td></tr>
</tbody></table>
<p>Table B-6 shows symbols that appear in the context of calling or defining
macros and specifying attributes on an item.</p>
<p><span class="caption">Table B-6: Macros and Attributes</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>#[meta]</code></td><td>Outer attribute</td></tr>
<tr><td><code>#![meta]</code></td><td>Inner attribute</td></tr>
<tr><td><code>$ident</code></td><td>Macro substitution</td></tr>
<tr><td><code>$ident:kind</code></td><td>Macro capture</td></tr>
<tr><td><code>$(…)…</code></td><td>Macro repetition</td></tr>
</tbody></table>
<p>Table B-7 shows symbols that create comments.</p>
<p><span class="caption">Table B-7: Comments</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>//</code></td><td>Line comment</td></tr>
<tr><td><code>//!</code></td><td>Inner line doc comment</td></tr>
<tr><td><code>///</code></td><td>Outer line doc comment</td></tr>
<tr><td><code>/*...*/</code></td><td>Block comment</td></tr>
<tr><td><code>/*!...*/</code></td><td>Inner block doc comment</td></tr>
<tr><td><code>/**...*/</code></td><td>Outer block doc comment</td></tr>
</tbody></table>
<p>Table B-8 shows symbols that appear in the context of using tuples.</p>
<p><span class="caption">Table B-8: Tuples</span></p>
<table><thead><tr><th>Symbol</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>()</code></td><td>Empty tuple (aka unit), both literal and type</td></tr>
<tr><td><code>(expr)</code></td><td>Parenthesized expression</td></tr>
<tr><td><code>(expr,)</code></td><td>Single-element tuple expression</td></tr>
<tr><td><code>(type,)</code></td><td>Single-element tuple type</td></tr>
<tr><td><code>(expr, ...)</code></td><td>Tuple expression</td></tr>
<tr><td><code>(type, ...)</code></td><td>Tuple type</td></tr>
<tr><td><code>expr(expr, ...)</code></td><td>Function call expression; also used to initialize tuple <code>struct</code>s and tuple <code>enum</code> variants</td></tr>
<tr><td><code>ident!(...)</code>, <code>ident!{...}</code>, <code>ident![...]</code></td><td>Macro invocation</td></tr>
<tr><td><code>expr.0</code>, <code>expr.1</code>, etc.</td><td>Tuple indexing</td></tr>
</tbody></table>
<p>Table B-9 shows the contexts in which curly braces are used.</p>
<p><span class="caption">Table B-9: Curly Brackets</span></p>
<table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>{...}</code></td><td>Block expression</td></tr>
<tr><td><code>Type {...}</code></td><td><code>struct</code> literal</td></tr>
</tbody></table>
<p>Table B-10 shows the contexts in which square brackets are used.</p>
<p><span class="caption">Table B-10: Square Brackets</span></p>
<table><thead><tr><th>Context</th><th>Explanation</th></tr></thead><tbody>
<tr><td><code>[...]</code></td><td>Array literal</td></tr>
<tr><td><code>[expr; len]</code></td><td>Array literal containing <code>len</code> copies of <code>expr</code></td></tr>
<tr><td><code>[type; len]</code></td><td>Array type containing <code>len</code> instances of <code>type</code></td></tr>
<tr><td><code>expr[expr]</code></td><td>Collection indexing. Overloadable (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td><code>expr[..]</code>, <code>expr[a..]</code>, <code>expr[..b]</code>, <code>expr[a..b]</code></td><td>Collection indexing pretending to be collection slicing, using <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code>, or <code>RangeFull</code> as the “index”</td></tr>
</tbody></table>
<h2><a class="header" href="#appendix-c-derivable-traits" id="appendix-c-derivable-traits">Appendix C: Derivable Traits</a></h2>
<p>In various places in the book, we’ve discussed the <code>derive</code> attribute, which
you can apply to a struct or enum definition. The <code>derive</code> attribute generates
code that will implement a trait with its own default implementation on the
type you’ve annotated with the <code>derive</code> syntax.</p>
<p>In this appendix, we provide a reference of all the traits in the standard
library that you can use with <code>derive</code>. Each section covers:</p>
<ul>
<li>What operators and methods deriving this trait will enable</li>
<li>What the implementation of the trait provided by <code>derive</code> does</li>
<li>What implementing the trait signifies about the type</li>
<li>The conditions in which you’re allowed or not allowed to implement the trait</li>
<li>Examples of operations that require the trait</li>
</ul>
<p>If you want different behavior from that provided by the <code>derive</code> attribute,
consult the <a href="rustbook/../std/index.html">standard library documentation</a><!-- ignore -->
for each trait for details of how to manually implement them.</p>
<p>The rest of the traits defined in the standard library can’t be implemented on
your types using <code>derive</code>. These traits don’t have sensible default behavior,
so it’s up to you to implement them in the way that makes sense for what you’re
trying to accomplish.</p>
<p>An example of a trait that can’t be derived is <code>Display</code>, which handles
formatting for end users. You should always consider the appropriate way to
display a type to an end user. What parts of the type should an end user be
allowed to see? What parts would they find relevant? What format of the data
would be most relevant to them? The Rust compiler doesn’t have this insight, so
it can’t provide appropriate default behavior for you.</p>
<p>The list of derivable traits provided in this appendix is not comprehensive:
libraries can implement <code>derive</code> for their own traits, making the list of
traits you can use <code>derive</code> with truly open-ended. Implementing <code>derive</code>
involves using a procedural macro, which is covered in the
<a href="rustbook/ch19-06-macros.html#macros">“Macros”</a><!-- ignore --> section of Chapter 19.</p>
<h3><a class="header" href="#debug-for-programmer-output" id="debug-for-programmer-output"><code>Debug</code> for Programmer Output</a></h3>
<p>The <code>Debug</code> trait enables debug formatting in format strings, which you
indicate by adding <code>:?</code> within <code>{}</code> placeholders.</p>
<p>The <code>Debug</code> trait allows you to print instances of a type for debugging
purposes, so you and other programmers using your type can inspect an instance
at a particular point in a program’s execution.</p>
<p>The <code>Debug</code> trait is required, for example, in use of the <code>assert_eq!</code> macro.
This macro prints the values of instances given as arguments if the equality
assertion fails so programmers can see why the two instances weren’t equal.</p>
<h3><a class="header" href="#partialeq-and-eq-for-equality-comparisons" id="partialeq-and-eq-for-equality-comparisons"><code>PartialEq</code> and <code>Eq</code> for Equality Comparisons</a></h3>
<p>The <code>PartialEq</code> trait allows you to compare instances of a type to check for
equality and enables use of the <code>==</code> and <code>!=</code> operators.</p>
<p>Deriving <code>PartialEq</code> implements the <code>eq</code> method. When <code>PartialEq</code> is derived on
structs, two instances are equal only if <em>all</em> fields are equal, and the
instances are not equal if any fields are not equal. When derived on enums,
each variant is equal to itself and not equal to the other variants.</p>
<p>The <code>PartialEq</code> trait is required, for example, with the use of the
<code>assert_eq!</code> macro, which needs to be able to compare two instances of a type
for equality.</p>
<p>The <code>Eq</code> trait has no methods. Its purpose is to signal that for every value of
the annotated type, the value is equal to itself. The <code>Eq</code> trait can only be
applied to types that also implement <code>PartialEq</code>, although not all types that
implement <code>PartialEq</code> can implement <code>Eq</code>. One example of this is floating point
number types: the implementation of floating point numbers states that two
instances of the not-a-number (<code>NaN</code>) value are not equal to each other.</p>
<p>An example of when <code>Eq</code> is required is for keys in a <code>HashMap&lt;K, V&gt;</code> so the
<code>HashMap&lt;K, V&gt;</code> can tell whether two keys are the same.</p>
<h3><a class="header" href="#partialord-and-ord-for-ordering-comparisons" id="partialord-and-ord-for-ordering-comparisons"><code>PartialOrd</code> and <code>Ord</code> for Ordering Comparisons</a></h3>
<p>The <code>PartialOrd</code> trait allows you to compare instances of a type for sorting
purposes. A type that implements <code>PartialOrd</code> can be used with the <code>&lt;</code>, <code>&gt;</code>,
<code>&lt;=</code>, and <code>&gt;=</code> operators. You can only apply the <code>PartialOrd</code> trait to types
that also implement <code>PartialEq</code>.</p>
<p>Deriving <code>PartialOrd</code> implements the <code>partial_cmp</code> method, which returns an
<code>Option&lt;Ordering&gt;</code> that will be <code>None</code> when the values given don’t produce an
ordering. An example of a value that doesn’t produce an ordering, even though
most values of that type can be compared, is the not-a-number (<code>NaN</code>) floating
point value. Calling <code>partial_cmp</code> with any floating point number and the <code>NaN</code>
floating point value will return <code>None</code>.</p>
<p>When derived on structs, <code>PartialOrd</code> compares two instances by comparing the
value in each field in the order in which the fields appear in the struct
definition. When derived on enums, variants of the enum declared earlier in the
enum definition are considered less than the variants listed later.</p>
<p>The <code>PartialOrd</code> trait is required, for example, for the <code>gen_range</code> method
from the <code>rand</code> crate that generates a random value in the range specified by a
low value and a high value.</p>
<p>The <code>Ord</code> trait allows you to know that for any two values of the annotated
type, a valid ordering will exist. The <code>Ord</code> trait implements the <code>cmp</code> method,
which returns an <code>Ordering</code> rather than an <code>Option&lt;Ordering&gt;</code> because a valid
ordering will always be possible. You can only apply the <code>Ord</code> trait to types
that also implement <code>PartialOrd</code> and <code>Eq</code> (and <code>Eq</code> requires <code>PartialEq</code>). When
derived on structs and enums, <code>cmp</code> behaves the same way as the derived
implementation for <code>partial_cmp</code> does with <code>PartialOrd</code>.</p>
<p>An example of when <code>Ord</code> is required is when storing values in a <code>BTreeSet&lt;T&gt;</code>,
a data structure that stores data based on the sort order of the values.</p>
<h3><a class="header" href="#clone-and-copy-for-duplicating-values" id="clone-and-copy-for-duplicating-values"><code>Clone</code> and <code>Copy</code> for Duplicating Values</a></h3>
<p>The <code>Clone</code> trait allows you to explicitly create a deep copy of a value, and
the duplication process might involve running arbitrary code and copying heap
data. See the <a href="rustbook/ch04-01-what-is-ownership.html#ways-variables-and-data-interact-clone">“Ways Variables and Data Interact:
Clone”</a><!-- ignore --> section in
Chapter 4 for more information on <code>Clone</code>.</p>
<p>Deriving <code>Clone</code> implements the <code>clone</code> method, which when implemented for the
whole type, calls <code>clone</code> on each of the parts of the type. This means all the
fields or values in the type must also implement <code>Clone</code> to derive <code>Clone</code>.</p>
<p>An example of when <code>Clone</code> is required is when calling the <code>to_vec</code> method on a
slice. The slice doesn’t own the type instances it contains, but the vector
returned from <code>to_vec</code> will need to own its instances, so <code>to_vec</code> calls
<code>clone</code> on each item. Thus, the type stored in the slice must implement <code>Clone</code>.</p>
<p>The <code>Copy</code> trait allows you to duplicate a value by only copying bits stored on
the stack; no arbitrary code is necessary. See the <a href="rustbook/ch04-01-what-is-ownership.html#stack-only-data-copy">“Stack-Only Data:
Copy”</a><!-- ignore --> section in Chapter 4 for more
information on <code>Copy</code>.</p>
<p>The <code>Copy</code> trait doesn’t define any methods to prevent programmers from
overloading those methods and violating the assumption that no arbitrary code
is being run. That way, all programmers can assume that copying a value will be
very fast.</p>
<p>You can derive <code>Copy</code> on any type whose parts all implement <code>Copy</code>. You can
only apply the <code>Copy</code> trait to types that also implement <code>Clone</code>, because a
type that implements <code>Copy</code> has a trivial implementation of <code>Clone</code> that
performs the same task as <code>Copy</code>.</p>
<p>The <code>Copy</code> trait is rarely required; types that implement <code>Copy</code> have
optimizations available, meaning you don’t have to call <code>clone</code>, which makes
the code more concise.</p>
<p>Everything possible with <code>Copy</code> you can also accomplish with <code>Clone</code>, but the
code might be slower or have to use <code>clone</code> in places.</p>
<h3><a class="header" href="#hash-for-mapping-a-value-to-a-value-of-fixed-size" id="hash-for-mapping-a-value-to-a-value-of-fixed-size"><code>Hash</code> for Mapping a Value to a Value of Fixed Size</a></h3>
<p>The <code>Hash</code> trait allows you to take an instance of a type of arbitrary size and
map that instance to a value of fixed size using a hash function. Deriving
<code>Hash</code> implements the <code>hash</code> method. The derived implementation of the <code>hash</code>
method combines the result of calling <code>hash</code> on each of the parts of the type,
meaning all fields or values must also implement <code>Hash</code> to derive <code>Hash</code>.</p>
<p>An example of when <code>Hash</code> is required is in storing keys in a <code>HashMap&lt;K, V&gt;</code>
to store data efficiently.</p>
<h3><a class="header" href="#default-for-default-values" id="default-for-default-values"><code>Default</code> for Default Values</a></h3>
<p>The <code>Default</code> trait allows you to create a default value for a type. Deriving
<code>Default</code> implements the <code>default</code> function. The derived implementation of the
<code>default</code> function calls the <code>default</code> function on each part of the type,
meaning all fields or values in the type must also implement <code>Default</code> to
derive <code>Default</code>.</p>
<p>The <code>Default::default</code> function is commonly used in combination with the struct
update syntax discussed in the <a href="rustbook/ch05-01-defining-structs.html#creating-instances-from-other-instances-with-struct-update-syntax">“Creating Instances From Other Instances With
Struct Update
Syntax”</a><!-- ignore -->
section in Chapter 5. You can customize a few fields of a struct and then
set and use a default value for the rest of the fields by using
<code>..Default::default()</code>.</p>
<p>The <code>Default</code> trait is required when you use the method <code>unwrap_or_default</code> on
<code>Option&lt;T&gt;</code> instances, for example. If the <code>Option&lt;T&gt;</code> is <code>None</code>, the method
<code>unwrap_or_default</code> will return the result of <code>Default::default</code> for the type
<code>T</code> stored in the <code>Option&lt;T&gt;</code>.</p>
<h1><a class="header" href="#appendix-d---useful-development-tools" id="appendix-d---useful-development-tools">Appendix D - Useful Development Tools</a></h1>
<p>In this appendix, we talk about some useful development tools that the Rust
project provides. We’ll look at automatic formatting, quick ways to apply
warning fixes, a linter, and integrating with IDEs.</p>
<h2><a class="header" href="#automatic-formatting-with-rustfmt" id="automatic-formatting-with-rustfmt">Automatic Formatting with <code>rustfmt</code></a></h2>
<p>The <code>rustfmt</code> tool reformats your code according to the community code style.
Many collaborative projects use <code>rustfmt</code> to prevent arguments about which
style to use when writing Rust: everyone formats their code using the tool.</p>
<p>To install <code>rustfmt</code>, enter the following:</p>
<pre><code class="language-text">$ rustup component add rustfmt
</code></pre>
<p>This command gives you <code>rustfmt</code> and <code>cargo-fmt</code>, similar to how Rust gives you
both <code>rustc</code> and <code>cargo</code>. To format any Cargo project, enter the following:</p>
<pre><code class="language-text">$ cargo fmt
</code></pre>
<p>Running this command reformats all the Rust code in the current crate. This
should only change the code style, not the code semantics. For more information
on <code>rustfmt</code>, see <a href="https://github.com/rust-lang/rustfmt">its documentation</a>.</p>
<h2><a class="header" href="#fix-your-code-with-rustfix" id="fix-your-code-with-rustfix">Fix Your Code with <code>rustfix</code></a></h2>
<p>The rustfix tool is included with Rust installations and can automatically fix
some compiler warnings. If you’ve written code in Rust, you’ve probably seen
compiler warnings. For example, consider this code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Here, we’re calling the <code>do_something</code> function 100 times, but we never use the
variable <code>i</code> in the body of the <code>for</code> loop. Rust warns us about that:</p>
<pre><code class="language-text">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>The warning suggests that we use <code>_i</code> as a name instead: the underscore
indicates that we intend for this variable to be unused. We can automatically
apply that suggestion using the <code>rustfix</code> tool by running the command <code>cargo fix</code>:</p>
<pre><code class="language-text">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>When we look at <em>src/main.rs</em> again, we’ll see that <code>cargo fix</code> has changed the
code:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>The <code>for</code> loop variable is now named <code>_i</code>, and the warning no longer appears.</p>
<p>You can also use the <code>cargo fix</code> command to transition your code between
different Rust editions. Editions are covered in Appendix E.</p>
<h2><a class="header" href="#more-lints-with-clippy" id="more-lints-with-clippy">More Lints with Clippy</a></h2>
<p>The Clippy tool is a collection of lints to analyze your code so you can catch
common mistakes and improve your Rust code.</p>
<p>To install Clippy, enter the following:</p>
<pre><code class="language-text">$ rustup component add clippy
</code></pre>
<p>To run Clippy’s lints on any Cargo project, enter the following:</p>
<pre><code class="language-text">$ cargo clippy
</code></pre>
<p>For example, say you write a program that uses an approximation of a
mathematical constant, such as pi, as this program does:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Running <code>cargo clippy</code> on this project results in this error:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>This error lets you know that Rust has this constant defined more precisely and
that your program would be more correct if you used the constant instead. You
would then change your code to use the <code>PI</code> constant. The following code
doesn’t result in any errors or warnings from Clippy:</p>
<p><span class="filename">Filename: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;the area of the circle is {}&quot;, x * r * r);
}
</code></pre></pre>
<p>For more information on Clippy, see <a href="https://github.com/rust-lang/rust-clippy">its documentation</a>.</p>
<h2><a class="header" href="#ide-integration-using-the-rust-language-server" id="ide-integration-using-the-rust-language-server">IDE Integration Using the Rust Language Server</a></h2>
<p>To help IDE integration, the Rust project distributes the <em>Rust Language
Server</em> (<code>rls</code>). This tool speaks the <a href="http://langserver.org/">Language Server
Protocol</a>, which is a specification for IDEs and programming
languages to communicate with each other. Different clients can use the <code>rls</code>,
such as <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">the Rust plug-in for Visual Studio Code</a>.</p>
<p>To install the <code>rls</code>, enter the following:</p>
<pre><code class="language-text">$ rustup component add rls
</code></pre>
<p>Then install the language server support in your particular IDE; you’ll gain
abilities such as autocompletion, jump to definition, and inline errors.</p>
<p>For more information on the <code>rls</code>, see <a href="https://github.com/rust-lang/rls">its documentation</a>.</p>
<h1><a class="header" href="#appendix-e---editions" id="appendix-e---editions">Appendix E - Editions</a></h1>
<p>In Chapter 1, you saw that <code>cargo new</code> adds a bit of metadata to your
<em>Cargo.toml</em> file about an edition. This appendix talks about what that means!</p>
<p>The Rust language and compiler have a six-week release cycle, meaning users get
a constant stream of new features. Other programming languages release larger
changes less often; Rust releases smaller updates more frequently. After a
while, all of these tiny changes add up. But from release to release, it can be
difficult to look back and say, “Wow, between Rust 1.10 and Rust 1.31, Rust has
changed a lot!”</p>
<p>Every two or three years, the Rust team produces a new Rust <em>edition</em>. Each
edition brings together the features that have landed into a clear package with
fully updated documentation and tooling. New editions ship as part of the usual
six-week release process.</p>
<p>Editions serve different purposes for different people:</p>
<ul>
<li>For active Rust users, a new edition brings together incremental changes into
an easy-to-understand package.</li>
<li>For non-users, a new edition signals that some major advancements have
landed, which might make Rust worth another look.</li>
<li>For those developing Rust, a new edition provides a rallying point for the
project as a whole.</li>
</ul>
<p>At the time of this writing, two Rust editions are available: Rust 2015 and
Rust 2018. This book is written using Rust 2018 edition idioms.</p>
<p>The <code>edition</code> key in <em>Cargo.toml</em> indicates which edition the compiler should
use for your code. If the key doesn’t exist, Rust uses <code>2015</code> as the edition
value for backward compatibility reasons.</p>
<p>Each project can opt in to an edition other than the default 2015 edition.
Editions can contain incompatible changes, such as including a new keyword that
conflicts with identifiers in code. However, unless you opt in to those
changes, your code will continue to compile even as you upgrade the Rust
compiler version you use.</p>
<p>All Rust compiler versions support any edition that existed prior to that
compiler’s release, and they can link crates of any supported editions
together. Edition changes only affect the way the compiler initially parses
code. Therefore, if you’re using Rust 2015 and one of your dependencies uses
Rust 2018, your project will compile and be able to use that dependency. The
opposite situation, where your project uses Rust 2018 and a dependency uses
Rust 2015, works as well.</p>
<p>To be clear: most features will be available on all editions. Developers using
any Rust edition will continue to see improvements as new stable releases are
made. However, in some cases, mainly when new keywords are added, some new
features might only be available in later editions. You will need to switch
editions if you want to take advantage of such features.</p>
<p>For more details, the <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Edition
Guide</em></a> is a complete book
about editions that enumerates the differences between editions and explains
how to automatically upgrade your code to a new edition via <code>cargo fix</code>.</p>
<h2><a class="header" href="#appendix-f-translations-of-the-book" id="appendix-f-translations-of-the-book">Appendix F: Translations of the Book</a></h2>
<p>For resources in languages other than English. Most are still in progress; see
<a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">the Translations label</a> to help or let us know about a new translation!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português</a> (BR)</li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português</a> (PT)</li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a>, <a href="https://github.com/ManRR/rust-book-es">alternate</a></li>
<li><a href="https://github.com/AgeOfWar/rust-book-it">Italiano</a></li>
<li><a href="https://github.com/ruRust/rust_book_2ed">Русский</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a></li>
<li><a href="https://github.com/hazama-yuinyan/book">日本語</a></li>
<li><a href="https://github.com/quadrifoglio/rust-book-fr">Français</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/idanmel/rust-book-heb">עברית</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
</ul>
<h1><a class="header" href="#appendix-g---how-rust-is-made-and-nightly-rust" id="appendix-g---how-rust-is-made-and-nightly-rust">Appendix G - How Rust is Made and “Nightly Rust”</a></h1>
<p>This appendix is about how Rust is made and how that affects you as a Rust
developer.</p>
<h3><a class="header" href="#stability-without-stagnation" id="stability-without-stagnation">Stability Without Stagnation</a></h3>
<p>As a language, Rust cares a <em>lot</em> about the stability of your code. We want
Rust to be a rock-solid foundation you can build on, and if things were
constantly changing, that would be impossible. At the same time, if we can’t
experiment with new features, we may not find out important flaws until after
their release, when we can no longer change things.</p>
<p>Our solution to this problem is what we call “stability without stagnation”,
and our guiding principle is this: you should never have to fear upgrading to a
new version of stable Rust. Each upgrade should be painless, but should also
bring you new features, fewer bugs, and faster compile times.</p>
<h3><a class="header" href="#choo-choo-release-channels-and-riding-the-trains" id="choo-choo-release-channels-and-riding-the-trains">Choo, Choo! Release Channels and Riding the Trains</a></h3>
<p>Rust development operates on a <em>train schedule</em>. That is, all development is
done on the <code>master</code> branch of the Rust repository. Releases follow a software
release train model, which has been used by Cisco IOS and other software
projects. There are three <em>release channels</em> for Rust:</p>
<ul>
<li>Nightly</li>
<li>Beta</li>
<li>Stable</li>
</ul>
<p>Most Rust developers primarily use the stable channel, but those who want to
try out experimental new features may use nightly or beta.</p>
<p>Here’s an example of how the development and release process works: let’s
assume that the Rust team is working on the release of Rust 1.5. That release
happened in December of 2015, but it will provide us with realistic version
numbers. A new feature is added to Rust: a new commit lands on the <code>master</code>
branch. Each night, a new nightly version of Rust is produced. Every day is a
release day, and these releases are created by our release infrastructure
automatically. So as time passes, our releases look like this, once a night:</p>
<pre><code class="language-text">nightly: * - - * - - *
</code></pre>
<p>Every six weeks, it’s time to prepare a new release! The <code>beta</code> branch of the
Rust repository branches off from the <code>master</code> branch used by nightly. Now,
there are two releases:</p>
<pre><code class="language-text">nightly: * - - * - - *
                     |
beta:                *
</code></pre>
<p>Most Rust users do not use beta releases actively, but test against beta in
their CI system to help Rust discover possible regressions. In the meantime,
there’s still a nightly release every night:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - *
                     |
beta:                *
</code></pre>
<p>Let’s say a regression is found. Good thing we had some time to test the beta
release before the regression snuck into a stable release! The fix is applied
to <code>master</code>, so that nightly is fixed, and then the fix is backported to the
<code>beta</code> branch, and a new release of beta is produced:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - *
                     |
beta:                * - - - - - - - - *
</code></pre>
<p>Six weeks after the first beta was created, it’s time for a stable release! The
<code>stable</code> branch is produced from the <code>beta</code> branch:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |
beta:                * - - - - - - - - *
                                       |
stable:                                *
</code></pre>
<p>Hooray! Rust 1.5 is done! However, we’ve forgotten one thing: because the six
weeks have gone by, we also need a new beta of the <em>next</em> version of Rust, 1.6.
So after <code>stable</code> branches off of <code>beta</code>, the next version of <code>beta</code> branches
off of <code>nightly</code> again:</p>
<pre><code class="language-text">nightly: * - - * - - * - - * - - * - - * - * - *
                     |                         |
beta:                * - - - - - - - - *       *
                                       |
stable:                                *
</code></pre>
<p>This is called the “train model” because every six weeks, a release “leaves the
station”, but still has to take a journey through the beta channel before it
arrives as a stable release.</p>
<p>Rust releases every six weeks, like clockwork. If you know the date of one Rust
release, you can know the date of the next one: it’s six weeks later. A nice
aspect of having releases scheduled every six weeks is that the next train is
coming soon. If a feature happens to miss a particular release, there’s no need
to worry: another one is happening in a short time! This helps reduce pressure
to sneak possibly unpolished features in close to the release deadline.</p>
<p>Thanks to this process, you can always check out the next build of Rust and
verify for yourself that it’s easy to upgrade to: if a beta release doesn’t
work as expected, you can report it to the team and get it fixed before the
next stable release happens! Breakage in a beta release is relatively rare, but
<code>rustc</code> is still a piece of software, and bugs do exist.</p>
<h3><a class="header" href="#unstable-features" id="unstable-features">Unstable Features</a></h3>
<p>There’s one more catch with this release model: unstable features. Rust uses a
technique called “feature flags” to determine what features are enabled in a
given release. If a new feature is under active development, it lands on
<code>master</code>, and therefore, in nightly, but behind a <em>feature flag</em>. If you, as a
user, wish to try out the work-in-progress feature, you can, but you must be
using a nightly release of Rust and annotate your source code with the
appropriate flag to opt in.</p>
<p>If you’re using a beta or stable release of Rust, you can’t use any feature
flags. This is the key that allows us to get practical use with new features
before we declare them stable forever. Those who wish to opt into the bleeding
edge can do so, and those who want a rock-solid experience can stick with
stable and know that their code won’t break. Stability without stagnation.</p>
<p>This book only contains information about stable features, as in-progress
features are still changing, and surely they’ll be different between when this
book was written and when they get enabled in stable builds. You can find
documentation for nightly-only features online.</p>
<h3><a class="header" href="#rustup-and-the-role-of-rust-nightly" id="rustup-and-the-role-of-rust-nightly">Rustup and the Role of Rust Nightly</a></h3>
<p>Rustup makes it easy to change between different release channels of Rust, on a
global or per-project basis. By default, you’ll have stable Rust installed. To
install nightly, for example:</p>
<pre><code class="language-text">$ rustup install nightly
</code></pre>
<p>You can see all of the <em>toolchains</em> (releases of Rust and associated
components) you have installed with <code>rustup</code> as well. Here’s an example on one
of your authors’ Windows computer:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>As you can see, the stable toolchain is the default. Most Rust users use stable
most of the time. You might want to use stable most of the time, but use
nightly on a specific project, because you care about a cutting-edge feature.
To do so, you can use <code>rustup override</code> in that project’s directory to set the
nightly toolchain as the one <code>rustup</code> should use when you’re in that directory:</p>
<pre><code class="language-text">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Now, every time you call <code>rustc</code> or <code>cargo</code> inside of
<em>~/projects/needs-nightly</em>, <code>rustup</code> will make sure that you are using nightly
Rust, rather than your default of stable Rust. This comes in handy when you
have a lot of Rust projects!</p>
<h3><a class="header" href="#the-rfc-process-and-teams" id="the-rfc-process-and-teams">The RFC Process and Teams</a></h3>
<p>So how do you learn about these new features? Rust’s development model follows
a <em>Request For Comments (RFC) process</em>. If you’d like an improvement in Rust,
you can write up a proposal, called an RFC.</p>
<p>Anyone can write RFCs to improve Rust, and the proposals are reviewed and
discussed by the Rust team, which is comprised of many topic subteams. There’s
a full list of the teams <a href="https://www.rust-lang.org/governance">on Rust’s
website</a>, which includes teams for
each area of the project: language design, compiler implementation,
infrastructure, documentation, and more. The appropriate team reads the
proposal and the comments, writes some comments of their own, and eventually,
there’s consensus to accept or reject the feature.</p>
<p>If the feature is accepted, an issue is opened on the Rust repository, and
someone can implement it. The person who implements it very well may not be the
person who proposed the feature in the first place! When the implementation is
ready, it lands on the <code>master</code> branch behind a feature gate, as we discussed
in the <a href="rustbook/appendix-07-nightly-rust.html#unstable-features">“Unstable Features”</a><!-- ignore --> section.</p>
<p>After some time, once Rust developers who use nightly releases have been able
to try out the new feature, team members will discuss the feature, how it’s
worked out on nightly, and decide if it should make it into stable Rust or not.
If the decision is to move forward, the feature gate is removed, and the
feature is now considered stable! It rides the trains into a new stable release
of Rust.</p>
<h1><a class="header" href="#rust-2018" id="rust-2018">Rust 2018</a></h1>
<p>The edition system was created for the release of Rust 2018. The theme of Rust 2018
is <em>productivity</em>. Rust 2018 improves upon Rust 2015 through new features,
simpler syntax in some cases, a smarter borrow-checker, and a host of other things.
These are all in service of the productivity goal. Rust 2015 was a foundation;
Rust 2018 smooths off rough edges, makes writing code simpler and easier,
and removes some inconsistencies.</p>
<h1><a class="header" href="#2018-specific-changes" id="2018-specific-changes">2018-Specific Changes</a></h1>
<p>The following is a summary of changes that only apply to code compiled with
the 2018 edition compared to the 2015 edition.</p>
<ul>
<li><a href="rustdoc-2018/module-system/path-clarity.html">Path changes</a>:
<ul>
<li>Paths in <code>use</code> declarations work the same as other paths.</li>
<li>Paths starting with <code>::</code> must be followed with an external crate.</li>
<li>Paths in <code>pub(in path)</code> visibility modifiers must start with <code>crate</code>,
<code>self</code>, or <code>super</code>.</li>
</ul>
</li>
<li><a href="rustdoc-2018/trait-system/no-anon-params.html">Anonymous trait function parameters</a> are not allowed.
<ul>
<li><a href="https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns">Trait function parameters</a> may use any irrefutable pattern when the
function has a body.</li>
</ul>
</li>
<li><a href="rustdoc-2018/trait-system/dyn-trait-for-trait-objects.html"><code>dyn</code></a> is a <a href="https://doc.rust-lang.org/reference/keywords.html#strict-keywords">strict keyword</a>, in 2015 it is a <a href="https://doc.rust-lang.org/reference/keywords.html#weak-keywords">weak keyword</a>.</li>
<li><code>async</code>, <code>await</code>, and <code>try</code> are <a href="https://doc.rust-lang.org/reference/keywords.html#reserved-keywords">reserved keywords</a>.</li>
<li>The following lints are now deny by default:
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/46906">tyvar_behind_raw_pointer</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#cargo-1" id="cargo-1">Cargo</a></h2>
<ul>
<li>If there is a target definition in a <code>Cargo.toml</code> manifest, it no longer
automatically disables automatic discovery of other targets.</li>
<li>Target paths of the form <code>src/{target_name}.rs</code> are no longer inferred for
targets where the <code>path</code> field is not set.</li>
<li><code>cargo install</code> for the current directory is no longer allowed, you must
specify <code>cargo install --path .</code> to install the current package.</li>
</ul>
<h1><a class="header" href="#module-system" id="module-system">Module system</a></h1>
<p>In this chapter of the guide, we discuss a few changes to the module system.
The most notable of these are the <a href="rustdoc-2018/module-system/path-clarity.html">path clarity changes</a>.</p>
<h1><a class="header" href="#raw-identifiers-2" id="raw-identifiers-2">Raw identifiers</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.30-brightgreen.svg" alt="Minimum Rust version: 1.30" /></p>
<p>Rust, like many programming languages, has the concept of &quot;keywords&quot;.
These identifiers mean something to the language, and so you cannot use them in
places like variable names, function names, and other places.
Raw identifiers let you use keywords where they would not normally be allowed.</p>
<p>For example, <code>match</code> is a keyword. If you try to compile this function:</p>
<pre><code class="language-rust ignore">fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
</code></pre>
<p>You'll get this error:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>You can write this with a raw identifier:</p>
<pre><pre class="playpen"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>Note the <code>r#</code> prefix on both the function name as well as the call.</p>
<h2><a class="header" href="#motivation" id="motivation">Motivation</a></h2>
<p>This feature is useful for a few reasons, but the primary motivation was
inter-edition situations. For example, <code>try</code> is not a keyword in the 2015
edition, but is in the 2018 edition. So if you have a library that is written
in Rust 2015 and has a <code>try</code> function, to call it in Rust 2018, you'll need
to use the raw identifier.</p>
<h2><a class="header" href="#new-keywords" id="new-keywords">New keywords</a></h2>
<p>The new confirmed keywords in edition 2018 are:</p>
<h3><a class="header" href="#async-and-await" id="async-and-await"><code>async</code> and <code>await</code></a></h3>
<p>Here, <code>async</code> is reserved for use in <code>async fn</code> as well as in <code>async ||</code> closures and
<code>async { .. }</code> blocks. Meanwhile, <code>await</code> is reserved to keep our options open
with respect to <code>await!(expr)</code> syntax. See <a href="https://github.com/rust-lang/rfcs/blob/master/text/2394-async_await.md#final-syntax-for-the-await-expression">RFC 2394</a> for more details.</p>
<h3><a class="header" href="#try" id="try"><code>try</code></a></h3>
<p>The <code>do catch { .. }</code> blocks have been renamed to <code>try { .. }</code> and to support
that, the keyword <code>try</code> is reserved in edition 2018.
See <a href="https://github.com/rust-lang/rfcs/pull/2388">RFC 2388</a> for more details.</p>
<h1><a class="header" href="#path-clarity" id="path-clarity">Path clarity</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>The module system is often one of the hardest things for people new to Rust. Everyone
has their own things that take time to master, of course, but there's a root
cause for why it's so confusing to many: while there are simple and
consistent rules defining the module system, their consequences can feel
inconsistent, counterintuitive and mysterious.</p>
<p>As such, the 2018 edition of Rust introduces a few new module system
features, but they end up <em>simplifying</em> the module system, to make it more
clear as to what is going on.</p>
<p>Here's a brief summary:</p>
<ul>
<li><code>extern crate</code> is no longer needed in 99% of circumstances.</li>
<li>The <code>crate</code> keyword refers to the current crate.</li>
<li>Paths may start with a crate name, even within submodules.</li>
<li>Paths starting with <code>::</code> must reference an external crate.</li>
<li>A <code>foo.rs</code> and <code>foo/</code> subdirectory may coexist; <code>mod.rs</code> is no longer needed
when placing submodules in a subdirectory.</li>
<li>Paths in <code>use</code> declarations work the same as other paths.</li>
</ul>
<p>These may seem like arbitrary new rules when put this way, but the mental
model is now significantly simplified overall. Read on for more details!</p>
<h2><a class="header" href="#more-details" id="more-details">More details</a></h2>
<p>Let's talk about each new feature in turn.</p>
<h3><a class="header" href="#no-more-extern-crate" id="no-more-extern-crate">No more <code>extern crate</code></a></h3>
<p>This one is quite straightforward: you no longer need to write <code>extern crate</code> to
import a crate into your project. Before:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

mod submodule {
    use futures::Future;
}
</code></pre>
<p>After:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;
}
</code></pre>
<p>Now, to add a new crate to your project, you can add it to your <code>Cargo.toml</code>,
and then there is no step two. If you're not using Cargo, you already had to pass
<code>--extern</code> flags to give <code>rustc</code> the location of external crates, so you'd just
keep doing what you were doing there as well.</p>
<blockquote>
<p>One small note here: <code>cargo fix</code> will not currently automate this change. We may
have it do this for you in the future.</p>
</blockquote>
<h4><a class="header" href="#an-exception" id="an-exception">An exception</a></h4>
<p>There's one exception to this rule, and that's the &quot;sysroot&quot; crates. These are the
crates distributed with Rust itself. We'd eventually like to remove the requirement
for <code>extern crate</code> for them as well, but it hasn't shipped yet.</p>
<p>You'll need to use <code>extern crate</code> for:</p>
<ul>
<li><code>proc_macro</code></li>
</ul>
<p>Additionally, you would need to use it for:</p>
<ul>
<li><code>core</code></li>
<li><code>std</code></li>
</ul>
<p>However, <code>extern crate std;</code> is already implicit, and with <code>#![no_std]</code>,
<code>extern crate core;</code> is already implicit. You'll only need these in highly
specialized situations.</p>
<p>Finally, on nightly, you'll need it for crates like:</p>
<ul>
<li><code>alloc</code></li>
<li><code>test</code></li>
</ul>
<h4><a class="header" href="#macros-1" id="macros-1">Macros</a></h4>
<p>One other use for <code>extern crate</code> was to import macros; that's no longer needed.
Check <a href="rustdoc-2018/module-system/../macros/macro-changes.html">the macro section</a> for more.</p>
<h4><a class="header" href="#renaming-crates" id="renaming-crates">Renaming crates</a></h4>
<p>If you've been using <code>as</code> to rename your crate like this:</p>
<pre><code class="language-rust ignore">extern crate futures as f;

use f::Future;
</code></pre>
<p>then removing the <code>extern crate</code> line on its own won't work. You'll need to do this:</p>
<pre><code class="language-rust ignore">use futures as f;

use self::f::Future;
</code></pre>
<p>This change will need to happen in any module that uses <code>f</code>.</p>
<h3><a class="header" href="#the-crate-keyword-refers-to-the-current-crate" id="the-crate-keyword-refers-to-the-current-crate">The <code>crate</code> keyword refers to the current crate</a></h3>
<p>In <code>use</code> declarations and in other code, you can refer to the root of the
current crate with the <code>crate::</code> prefix. For instance, <code>crate::foo::bar</code> will
always refer to the name <code>bar</code> inside the module <code>foo</code>, from anywhere else in
the same crate.</p>
<p>The prefix <code>::</code> previously referred to either the crate root or an external
crate; it now unambiguously refers to an external crate. For instance,
<code>::foo::bar</code> always refers to the name <code>bar</code> inside the external crate <code>foo</code>.</p>
<h3><a class="header" href="#extern-crate-paths" id="extern-crate-paths">Extern crate paths</a></h3>
<p>Previously, using an external crate in a module without a <code>use</code> import
required a leading <code>::</code> on the path.</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate chrono;

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // but in a submodule it requires a leading :: if not imported with `use`
        let x = ::chrono::Utc::now();
    }
}
</code></pre>
<p>Now, extern crate names are in scope in the entire crate, including
submodules.</p>
<pre><code class="language-rust ignore">// Rust 2018

fn foo() {
    // this works in the crate root
    let x = chrono::Utc::now();
}

mod submodule {
    fn function() {
        // crates may be referenced directly, even in submodules
        let x = chrono::Utc::now();
    }
}
</code></pre>
<h3><a class="header" href="#no-more-modrs" id="no-more-modrs">No more <code>mod.rs</code></a></h3>
<p>In Rust 2015, if you have a submodule:</p>
<pre><code class="language-rust ignore">///  foo.rs
///  or
///  foo/mod.rs

mod foo;
</code></pre>
<p>It can live in <code>foo.rs</code> or <code>foo/mod.rs</code>. If it has submodules of its own, it
<em>must</em> be <code>foo/mod.rs</code>. So a <code>bar</code> submodule of <code>foo</code> would live at
<code>foo/bar.rs</code>.</p>
<p>In Rust 2018, <code>mod.rs</code> is no longer needed.</p>
<pre><code class="language-rust ignore">///  foo.rs
///  foo/bar.rs

mod foo;

/// in foo.rs
mod bar;
</code></pre>
<p><code>foo.rs</code> can just be <code>foo.rs</code>,
and the submodule is still <code>foo/bar.rs</code>. This eliminates the special
name, and if you have a bunch of files open in your editor, you can clearly
see their names, instead of having a bunch of tabs named <code>mod.rs</code>.</p>
<h3><a class="header" href="#use-paths" id="use-paths"><code>use</code> paths</a></h3>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /></p>
<p>Rust 2018 simplifies and unifies path handling compared to Rust 2015. In Rust
2015, paths work differently in <code>use</code> declarations than they do elsewhere. In
particular, paths in <code>use</code> declarations would always start from the crate
root, while paths in other code implicitly started from the current scope.
Those differences didn't have any effect in the top-level module, which meant
that everything would seem straightforward until working on a project large
enough to have submodules.</p>
<p>In Rust 2018, paths in <code>use</code> declarations and in other code work the same way,
both in the top-level module and in any submodule. You can use a relative path
from the current scope, a path starting from an external crate name, or a path
starting with <code>crate</code>, <code>super</code>, or <code>self</code>.</p>
<p>Code that looked like this:</p>
<pre><code class="language-rust ignore">// Rust 2015

extern crate futures;

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>will look exactly the same in Rust 2018, except that you can delete the <code>extern crate</code> line:</p>
<pre><code class="language-rust ignore">// Rust 2018

use futures::Future;

mod foo {
    pub struct Bar;
}

use foo::Bar;

fn my_poll() -&gt; futures::Poll { ... }

enum SomeEnum {
    V1(usize),
    V2(String),
}

fn func() {
    let five = std::sync::Arc::new(5);
    use SomeEnum::*;
    match ... {
        V1(i) =&gt; { ... }
        V2(s) =&gt; { ... }
    }
}
</code></pre>
<p>The same code will also work completely unmodified in a submodule:</p>
<pre><code class="language-rust ignore">// Rust 2018

mod submodule {
    use futures::Future;

    mod foo {
        pub struct Bar;
    }

    use foo::Bar;

    fn my_poll() -&gt; futures::Poll { ... }

    enum SomeEnum {
        V1(usize),
        V2(String),
    }

    fn func() {
        let five = std::sync::Arc::new(5);
        use SomeEnum::*;
        match ... {
            V1(i) =&gt; { ... }
            V2(s) =&gt; { ... }
        }
    }
}
</code></pre>
<p>This makes it easy to move code around in a project, and avoids introducing
additional complexity to multi-module projects.</p>
<p>If a path is ambiguous, such as if you have an external crate and a local
module or item with the same name, you'll get an error, and you'll need to
either rename one of the conflicting names or explicitly disambiguate the path.
To explicitly disambiguate a path, use <code>::name</code> for an external crate name, or
<code>self::name</code> for a local module or item.</p>
<h1><a class="header" href="#more-visibility-modifiers" id="more-visibility-modifiers">More visibility modifiers</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.18-brightgreen.svg" alt="Minimum Rust version: 1.18" /></p>
<p>You can use the <code>pub</code> keyword to make something a part of a module's public interface. But in
addition, there are some new forms:</p>
<pre><code class="language-rust ignore">pub(crate) struct Foo;

pub(in a::b::c) struct Bar;
</code></pre>
<p>The first form makes the <code>Foo</code> struct public to your entire crate, but not
externally. The second form is similar, but makes <code>Bar</code> public for one other
module, <code>a::b::c</code> in this case.</p>
<h1><a class="header" href="#nested-imports-with-use" id="nested-imports-with-use">Nested imports with <code>use</code></a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p>A new way to write <code>use</code> statements has been added to Rust: nested import
groups. If you’ve ever written a set of imports like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
<span class="boring">}
</span></code></pre></pre>
<p>You can now write this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">mod foo {
</span>// on one line
use std::{fs::File, io::Read, path::{Path, PathBuf}};
<span class="boring">}
</span>
<span class="boring">mod bar {
</span>// with some more breathing room
use std::{
    fs::File,
    io::Read,
    path::{
        Path,
        PathBuf
    }
};
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>This can reduce some repetition, and make things a bit more clear.</p>
<h1><a class="header" href="#error-handling-and-panics" id="error-handling-and-panics">Error handling and Panics</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to error handling
in Rust. The most notable of these is <a href="rustdoc-2018/error-handling-and-panics/the-question-mark-operator-for-easier-error-handling.html">the introduction of the <code>?</code> operator</a>.</p>
<h1><a class="header" href="#the--operator-for-easier-error-handling" id="the--operator-for-easier-error-handling">The <code>?</code> operator for easier error handling</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.13-brightgreen.svg" alt="Minimum Rust version: 1.13" /> for <code>Result&lt;T, E&gt;</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.22-brightgreen.svg" alt="Minimum Rust version: 1.22" /> for <code>Option&lt;T&gt;</code></p>
<p>Rust has gained a new operator, <code>?</code>, that makes error handling more pleasant
by reducing the visual noise involved. It does this by solving one simple
problem. To illustrate, imagine we had some code to read some data from a
file:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{io::{self, prelude::*}, fs::File};
</span>fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;username.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Note: this code could be made simpler with a single call to
<a href="https://doc.rust-lang.org/stable/std/fs/fn.read_to_string.html"><code>std::fs::read_to_string</code></a>,
but we're writing it all out manually here to have an example with multiple
errors.</p>
</blockquote>
<p>This code has two paths that can fail, opening the file and reading the data
from it. If either of these fail to work, we'd like to return an error from
<code>read_username_from_file</code>. Doing so involves <code>match</code>ing on the result of the
I/O operations. In simple cases like this though, where we are only
propagating errors up the call stack, the matching is just boilerplate -
seeing it written out, in the same pattern every time, doesn't provide the
reader with a great deal of useful information.</p>
<p>With <code>?</code>, the above code looks like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{io::{self, prelude::*}, fs::File};
</span>fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;username.txt&quot;)?;
    let mut s = String::new();

    f.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>?</code> is shorthand for the entire match statements we wrote earlier. In
other words, <code>?</code> applies to a <code>Result</code> value, and if it was an <code>Ok</code>, it
unwraps it and gives the inner value. If it was an <code>Err</code>, it returns from the
function you're currently in. Visually, it is much more straightforward.
Instead of an entire match statement, now we are just using the single &quot;?&quot;
character to indicate that here we are handling errors in the standard way,
by passing them up the call stack.</p>
<p>Seasoned Rustaceans may recognize that this is the same as the <code>try!</code> macro
that's been available since Rust <code>1.0</code>. And indeed, they are the same.
Previously, <code>read_username_from_file</code> could have been implemented like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::{io::{self, prelude::*}, fs::File};
</span>fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = try!(File::open(&quot;username.txt&quot;));
    let mut s = String::new();

    try!(f.read_to_string(&amp;mut s));

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p>So why extend the language when we already have a macro? There are multiple
reasons. First, <code>try!</code> has proved to be extremely useful, and is used often
in idiomatic Rust. It is used so often that we think it's worth having a
sweet syntax. This sort of evolution is one of the great advantages of a
powerful macro system: speculative extensions to the language syntax can be
prototyped and iterated on without modifying the language itself, and in
return, macros that turn out to be especially useful can indicate missing
language features. This evolution, from <code>try!</code> to <code>?</code> is a great example.</p>
<p>One of the reasons <code>try!</code> needs a sweeter syntax is that it is quite
unattractive when multiple invocations of <code>try!</code> are used in succession.
Consider:</p>
<pre><code class="language-rust ignore">try!(try!(try!(foo()).bar()).baz())
</code></pre>
<p>as opposed to</p>
<pre><code class="language-rust ignore">foo()?.bar()?.baz()?
</code></pre>
<p>The first is quite difficult to scan visually, and each layer of error
handling prefixes the expression with an additional call to <code>try!</code>. This
brings undue attention to the trivial error propagation, obscuring the main
code path, in this example the calls to <code>foo</code>, <code>bar</code> and <code>baz</code>. This sort of
method chaining with error handling occurs in situations like the builder
pattern.</p>
<p>Finally, the dedicated syntax will make it easier in the future to produce
nicer error messages tailored specifically to <code>?</code>, whereas it is difficult to
produce nice errors for macro-expanded code generally.</p>
<p>You can use <code>?</code> with <code>Result&lt;T, E&gt;</code>s, but also with <code>Option&lt;T&gt;</code>. In that
case, <code>?</code> will return a value for <code>Some(T)</code> and return <code>None</code> for <code>None</code>. One
current restriction is that you cannot use <code>?</code> for both in the same function,
as the return type needs to match the type you use <code>?</code> on. In the future,
this restriction will be lifted.</p>
<h1><a class="header" href="#-in-main-and-tests" id="-in-main-and-tests"><code>?</code> in <code>main</code> and tests</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Rust's error handling revolves around returning <code>Result&lt;T, E&gt;</code> and using <code>?</code>
to propagate errors. For those who write many small programs and, hopefully,
many tests, one common paper cut has been mixing entry points such as <code>main</code>
and <code>#[test]</code>s with error handling.</p>
<p>As an example, you might have tried to write:</p>
<pre><code class="language-rust ignore">use std::fs::File;

fn main() {
    let f = File::open(&quot;bar.txt&quot;)?;
}
</code></pre>
<p>Since <code>?</code> works by propagating the <code>Result</code> with an early return to the
enclosing function, the snippet above does not work, and results today
in the following error:</p>
<pre><code class="language-rust ignore">error[E0277]: the `?` operator can only be used in a function that returns `Result`
              or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:5:13
  |
5 |     let f = File::open(&quot;bar.txt&quot;)?;
  |             ^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`
</code></pre>
<p>To solve this problem in Rust 2015, you might have written something like:</p>
<pre><pre class="playpen"><code class="language-rust">// Rust 2015

<span class="boring">use std::process;
</span><span class="boring">use std::error::Error;
</span>
fn run() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    // real logic..
    Ok(())
}

fn main() {
    if let Err(e) = run() {
        println!(&quot;Application error: {}&quot;, e);
        process::exit(1);
    }
}
</code></pre></pre>
<p>However, in this case, the <code>run</code> function has all the interesting logic and
<code>main</code> is just boilerplate. The problem is even worse for <code>#[test]</code>s, since
there tend to be a lot more of them.</p>
<p>In Rust 2018 you can instead let your <code>#[test]</code>s and <code>main</code> functions return
a <code>Result</code>:</p>
<pre><pre class="playpen"><code class="language-rust no_run">// Rust 2018

use std::fs::File;

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let f = File::open(&quot;bar.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>In this case, if say the file doesn't exist and there is an <code>Err(err)</code> somewhere,
then <code>main</code> will exit with an error code (not <code>0</code>) and print out a <code>Debug</code>
representation of <code>err</code>.</p>
<h2><a class="header" href="#more-details-1" id="more-details-1">More details</a></h2>
<p>Getting <code>-&gt; Result&lt;..&gt;</code> to work in the context of <code>main</code> and <code>#[test]</code>s is not
magic. It is all backed up by a <code>Termination</code> trait which all valid return
types of <code>main</code> and testing functions must implement. The trait is defined as:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Termination {
    fn report(self) -&gt; i32;
}
<span class="boring">}
</span></code></pre></pre>
<p>When setting up the entry point for your application, the compiler will use this
trait and call <code>.report()</code> on the <code>Result</code> of the <code>main</code> function you have written.</p>
<p>Two simplified example implementations of this trait for <code>Result</code> and <code>()</code> are:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#![feature(process_exitcode_placeholder, termination_trait_lib)]
</span><span class="boring">use std::process::ExitCode;
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">pub trait Termination { fn report(self) -&gt; i32; }
</span>
impl Termination for () {
    fn report(self) -&gt; i32 {
<span class="boring">        use std::process::Termination;
</span>        ExitCode::SUCCESS.report()
    }
}

impl&lt;E: fmt::Debug&gt; Termination for Result&lt;(), E&gt; {
    fn report(self) -&gt; i32 {
        match self {
            Ok(()) =&gt; ().report(),
            Err(err) =&gt; {
                eprintln!(&quot;Error: {:?}&quot;, err);
<span class="boring">                use std::process::Termination;
</span>                ExitCode::FAILURE.report()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see in the case of <code>()</code>, a success code is simply returned.
In the case of <code>Result</code>, the success case delegates to the implementation for
<code>()</code> but prints out an error message and a failure exit code on <code>Err(..)</code>.</p>
<p>To learn more about the finer details, consult either <a href="https://github.com/rust-lang/rust/issues/43301">the tracking issue</a> or <a href="https://github.com/rust-lang/rfcs/blob/master/text/1937-ques-in-main.md">the RFC</a>.</p>
<h1><a class="header" href="#controlling-panics-with-stdpanic" id="controlling-panics-with-stdpanic">Controlling panics with <code>std::panic</code></a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.9-brightgreen.svg" alt="Minimum Rust version: 1.9" /></p>
<p>There is a <code>std::panic</code> module, which includes methods for halting the
unwinding process started by a panic:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::panic;

let result = panic::catch_unwind(|| {
    println!(&quot;hello!&quot;);
});
assert!(result.is_ok());

let result = panic::catch_unwind(|| {
    panic!(&quot;oh no!&quot;);
});
assert!(result.is_err());
<span class="boring">}
</span></code></pre></pre>
<p>In general, Rust distinguishes between two ways that an operation can fail:</p>
<ul>
<li>Due to an <em>expected problem</em>, like a file not being found.</li>
<li>Due to an <em>unexpected problem</em>, like an index being out of bounds for an array.</li>
</ul>
<p>Expected problems usually arise from conditions that are outside of your
control; robust code should be prepared for anything its environment might throw
at it. In Rust, expected problems are handled via <a href="http://doc.rust-lang.org/std/result/index.html">the <code>Result</code> type</a>,
which allows a function to return information about the problem to its caller,
which can then handle the error in a fine-grained way.</p>
<p>Unexpected problems are <em>bugs</em>: they arise due to a contract or assertion being
violated. Since they are unexpected, it doesn't make sense to handle them in a
fine-grained way. Instead, Rust employs a &quot;fail fast&quot; approach by <em>panicking</em>,
which by default unwinds the stack (running destructors but no other code) of
the thread which discovered the error. Other threads continue running, but will
discover the panic any time they try to communicate with the panicked thread
(whether through channels or shared memory). Panics thus abort execution up to
some &quot;isolation boundary&quot;, with code on the other side of the boundary still
able to run, and perhaps to &quot;recover&quot; from the panic in some very coarse-grained
way. A server, for example, does not necessarily need to go down just because of
an assertion failure in one of its threads.</p>
<p>It's also worth noting that programs may choose to <em>abort</em> instead of unwind,
and so catching panics may not work. If your code relies on <code>catch_unwind</code>, you
should add this to your Cargo.toml:</p>
<pre><code class="language-toml">[profile.dev]
panic = &quot;unwind&quot;

[profile.release]
panic = &quot;unwind&quot;
</code></pre>
<p>If any of your users choose to abort, they'll get a compile-time failure.</p>
<p>The <code>catch_unwind</code> API offers a way to introduce new isolation boundaries
<em>within a thread</em>. There are a couple of key motivating examples:</p>
<ul>
<li>Embedding Rust in other languages</li>
<li>Abstractions that manage threads</li>
<li>Test frameworks, because tests may panic and you don't want that to kill the test runner</li>
</ul>
<p>For the first case, unwinding across a language boundary is undefined behavior,
and often leads to segfaults in practice. Allowing panics to be caught means
that you can safely expose Rust code via a C API, and translate unwinding into
an error on the C side.</p>
<p>For the second case, consider a threadpool library. If a thread in the pool
panics, you generally don't want to kill the thread itself, but rather catch the
panic and communicate it to the client of the pool. The <code>catch_unwind</code> API is
paired with <code>resume_unwind</code>, which can then be used to restart the panicking
process on the client of the pool, where it belongs.</p>
<p>In both cases, you're introducing a new isolation boundary within a thread, and
then translating the panic into some other form of error elsewhere.</p>
<h1><a class="header" href="#aborting-on-panic" id="aborting-on-panic">Aborting on panic</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.10-brightgreen.svg" alt="Minimum Rust version: 1.10" /></p>
<p>By default, Rust programs will unwind the stack when a <code>panic!</code> happens. If you'd prefer an
immediate abort instead, you can configure this in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[profile.dev]
panic = &quot;abort&quot;

[profile.release]
panic = &quot;abort&quot;
</code></pre>
<p>Why might you choose to do this? By removing support for unwinding, you'll
get smaller binaries. You will lose the ability to catch panics. Which choice
is right for you depends on exactly what you're doing.</p>
<h1><a class="header" href="#control-flow-1" id="control-flow-1">Control flow</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to control flow.
The most notable of these <em>will</em> be <a href="rustdoc-2018/control-flow/async-await-for-easier-concurrency.html"><code>async</code> and <code>await</code></a>.</p>
<h1><a class="header" href="#loops-can-break-with-a-value" id="loops-can-break-with-a-value"><code>loop</code>s can break with a value</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.19-brightgreen.svg" alt="Minimum Rust version: 1.19" /></p>
<p><code>loop</code>s can now break with a value:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// old code
let x;

loop {
    x = 7;
    break;
}

// new code
let x = loop { break 7; };
<span class="boring">}
</span></code></pre></pre>
<p>Rust has traditionally positioned itself as an “expression oriented
language”, that is, most things are expressions that evaluate to a value,
rather than statements. <code>loop</code> stuck out as strange in this way, as it was
previously a statement.</p>
<p>For now, this only applies to <code>loop</code>, and not things like <code>while</code> or <code>for</code>.
See the rationale for this decision in RFC issue <a href="https://github.com/rust-lang/rfcs/issues/1767">#1767</a>.</p>
<h1><a class="header" href="#asyncawait-for-easier-concurrency" id="asyncawait-for-easier-concurrency">async/await for easier concurrency</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /></p>
<p>The initial release of Rust 2018 won't ship with <code>async</code>/<code>await</code> support, but
we have reserved the keywords so that a future release will contain them.
We'll update this page when it's closer to shipping!</p>
<h1><a class="header" href="#trait-system" id="trait-system">Trait system</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to the trait system.
The most notable of these is <a href="rustdoc-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html"><code>impl Trait</code></a>.</p>
<h1><a class="header" href="#impl-trait-for-returning-complex-types-with-ease" id="impl-trait-for-returning-complex-types-with-ease"><code>impl Trait</code> for returning complex types with ease</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p><code>impl Trait</code> is the new way to specify unnamed but concrete types that
implement a specific trait. There are two places you can put it: argument
position, and return position.</p>
<pre><code class="language-rust ignore">trait Trait {}

// argument position
fn foo(arg: impl Trait) {
}

// return position
fn foo() -&gt; impl Trait {
}
</code></pre>
<h2><a class="header" href="#argument-position" id="argument-position">Argument Position</a></h2>
<p>In argument position, this feature is quite simple. These two forms are
almost the same:</p>
<pre><code class="language-rust ignore">trait Trait {}

fn foo&lt;T: Trait&gt;(arg: T) {
}

fn foo(arg: impl Trait) {
}
</code></pre>
<p>That is, it's a slightly shorter syntax for a generic type parameter. It
means, &quot;<code>arg</code> is an argument that takes any type that implements the <code>Trait</code>
trait.&quot;</p>
<p>However, there's also an important technical difference between <code>T: Trait</code>
and <code>impl Trait</code> here. When you write the former, you can specify the type of
<code>T</code> at the call site with turbo-fish syntax as with <code>foo::&lt;usize&gt;(1)</code>. In the
case of <code>impl Trait</code>, if it is used anywhere in the function definition, then
you can't use turbo-fish at all. Therefore, you should be mindful that
changing both from and to <code>impl Trait</code> can constitute a breaking change for
the users of your code.</p>
<h2><a class="header" href="#return-position" id="return-position">Return Position</a></h2>
<p>In return position, this feature is more interesting. It means &quot;I am
returning some type that implements the <code>Trait</code> trait, but I'm not going to
tell you exactly what the type is.&quot; Before <code>impl Trait</code>, you could do this
with trait objects:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl Trait for i32 {}

fn returns_a_trait_object() -&gt; Box&lt;dyn Trait&gt; {
    Box::new(5)
}
<span class="boring">}
</span></code></pre></pre>
<p>However, this has some overhead: the <code>Box&lt;T&gt;</code> means that there's a heap
allocation here, and this will use dynamic dispatch. See the <code>dyn Trait</code>
section for an explanation of this syntax. But we only ever return one
possible thing here, the <code>Box&lt;i32&gt;</code>. This means that we're paying for dynamic
dispatch, even though we don't use it!</p>
<p>With <code>impl Trait</code>, the code above could be written like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl Trait for i32 {}

fn returns_a_trait_object() -&gt; impl Trait {
    5
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we have no <code>Box&lt;T&gt;</code>, no trait object, and no dynamic dispatch. But we
still can obscure the <code>i32</code> return type.</p>
<p>With <code>i32</code>, this isn't super useful. But there's one major place in Rust
where this is much more useful: closures.</p>
<h3><a class="header" href="#impl-trait-and-closures" id="impl-trait-and-closures"><code>impl Trait</code> and closures</a></h3>
<blockquote>
<p>If you need to catch up on closures, check out <a href="https://doc.rust-lang.org/book/second-edition/ch13-01-closures.html">their chapter in the
book</a>.</p>
</blockquote>
<p>In Rust, closures have a unique, un-writable type. They do implement the <code>Fn</code>
family of traits, however. This means that previously, the only way to return
a closure from a function was to use a trait object:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; Box&lt;dyn Fn(i32) -&gt; i32&gt; {
    Box::new(|x| x + 1)
}
<span class="boring">}
</span></code></pre></pre>
<p>You couldn't write the type of the closure, only use the <code>Fn</code> trait. That means
that the trait object is necessary. However, with <code>impl Trait</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn returns_closure() -&gt; impl Fn(i32) -&gt; i32 {
    |x| x + 1
}
<span class="boring">}
</span></code></pre></pre>
<p>We can now return closures by value, just like any other type!</p>
<h2><a class="header" href="#more-details-2" id="more-details-2">More details</a></h2>
<p>The above is all you need to know to get going with <code>impl Trait</code>, but for
some more nitty-gritty details: type parameters and <code>impl Trait</code> work
slightly differently when they're in argument position versus return
position. Consider this function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Trait&gt;(x: T) {
</code></pre>
<p>When you call it, you set the type, <code>T</code>. &quot;you&quot; being the caller here. This
signature says &quot;I accept any type that implements <code>Trait</code>.&quot; (&quot;any type&quot; ==
universal in the jargon)</p>
<p>This version:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Trait&gt;() -&gt; T {
</code></pre>
<p>is similar, but also different. You, the caller, provide the type you want,
<code>T</code>, and then the function returns it. You can see this in Rust today with
things like parse or collect:</p>
<pre><code class="language-rust ignore">let x: i32 = &quot;5&quot;.parse()?;
let x: u64 = &quot;5&quot;.parse()?;
</code></pre>
<p>Here, <code>.parse</code> has this signature:</p>
<pre><code class="language-rust ignore">pub fn parse&lt;F&gt;(&amp;self) -&gt; Result&lt;F, &lt;F as FromStr&gt;::Err&gt; where
    F: FromStr,
</code></pre>
<p>Same general idea, though with a result type and <code>FromStr</code> has an associated
type... anyway, you can see how <code>F</code> is in the return position here. So you
have the ability to choose.</p>
<p>With <code>impl Trait</code>, you're saying &quot;hey, some type exists that implements this
trait, but I'm not gonna tell you what it is.&quot; So now, the caller can't
choose, and the function itself gets to choose. If we tried to define parse
with <code>Result&lt;impl F,...</code> as the return type, it wouldn't work.</p>
<h3><a class="header" href="#using-impl-trait-in-more-places" id="using-impl-trait-in-more-places">Using <code>impl Trait</code> in more places</a></h3>
<p>As previously mentioned, as a start, you will only be able to use <code>impl Trait</code>
as the argument or return type of a free or inherent function. However,
<code>impl Trait</code> can't be used inside implementations of traits, nor can it be
used as the type of a let binding or inside a type alias. Some of these
restrictions will eventually be lifted. For more information, see the
<a href="https://github.com/rust-lang/rust/issues/34511">tracking issue on <code>impl Trait</code></a>.</p>
<h1><a class="header" href="#dyn-trait-for-trait-objects" id="dyn-trait-for-trait-objects"><code>dyn Trait</code> for trait objects</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg" alt="Minimum Rust version: 1.27" /></p>
<p>The <code>dyn Trait</code> feature is the new syntax for using trait objects. In short:</p>
<ul>
<li><code>Box&lt;Trait&gt;</code> becomes <code>Box&lt;dyn Trait&gt;</code></li>
<li><code>&amp;Trait</code> and <code>&amp;mut Trait</code> become <code>&amp;dyn Trait</code> and <code>&amp;mut dyn Trait</code></li>
</ul>
<p>And so on. In code:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Trait {}

impl Trait for i32 {}

// old
fn function1() -&gt; Box&lt;Trait&gt; {
<span class="boring">unimplemented!()
</span>}

// new
fn function2() -&gt; Box&lt;dyn Trait&gt; {
<span class="boring">unimplemented!()
</span>}
<span class="boring">}
</span></code></pre></pre>
<p>That's it!</p>
<h2><a class="header" href="#more-details-3" id="more-details-3">More details</a></h2>
<p>Using just the trait name for trait objects turned out to be a bad decision.
The current syntax is often ambiguous and confusing, even to veterans,
and favors a feature that is not more frequently used than its alternatives,
is sometimes slower, and often cannot be used at all when its alternatives can.</p>
<p>Furthermore, with <code>impl Trait</code> arriving, &quot;<code>impl Trait</code> vs <code>dyn Trait</code>&quot; is much
more symmetric, and therefore a bit nicer, than &quot;<code>impl Trait</code> vs <code>Trait</code>&quot;.
<code>impl Trait</code> is explained <a href="rustdoc-2018/trait-system/impl-trait-for-returning-complex-types-with-ease.html">here</a>.</p>
<p>In the new edition, you should therefore prefer <code>dyn Trait</code> to just <code>Trait</code>
where you need a trait object.</p>
<h1><a class="header" href="#more-container-types-support-trait-objects" id="more-container-types-support-trait-objects">More container types support trait objects</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.2-brightgreen.svg" alt="Minimum Rust version: 1.2" /></p>
<p>In Rust 1.0, only certain, special types could be used to create <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait
objects</a>.</p>
<p>With Rust 1.2, that restriction was lifted, and more types became able to do this. For example,
<code>Rc&lt;T&gt;</code>, one of Rust's reference-counted types:</p>
<pre><pre class="playpen"><code class="language-rust">use std::rc::Rc;

trait Foo {}

impl Foo for i32 {

}

fn main() {
    let obj: Rc&lt;dyn Foo&gt; = Rc::new(5);
}
</code></pre></pre>
<p>This code would not work with Rust 1.0, but now works.</p>
<blockquote>
<p>If you haven't seen the <code>dyn</code> syntax before, see <a href="rustdoc-2018/trait-system/dyn-trait-for-trait-objects.html">the section on
it</a>. For versions that do not support it, replace <code>Rc&lt;dyn Foo&gt;</code>
with <code>Rc&lt;Foo&gt;</code>.</p>
</blockquote>
<h1><a class="header" href="#associated-constants" id="associated-constants">Associated constants</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.20-brightgreen.svg" alt="Minimum Rust version: 1.20" /></p>
<p>You can define traits, structs, and enums that have “associated functions”:</p>
<pre><pre class="playpen"><code class="language-rust">struct Struct;

impl Struct {
    fn foo() {
        println!(&quot;foo is an associated function of Struct&quot;);
    }
}

fn main() {
    Struct::foo();
}
</code></pre></pre>
<p>These are called “associated functions” because they are functions that are
associated with the type, that is, they’re attached to the type itself, and
not any particular instance.</p>
<p>Rust 1.20 adds the ability to define “associated constants” as well:</p>
<pre><pre class="playpen"><code class="language-rust">struct Struct;

impl Struct {
    const ID: u32 = 0;
}

fn main() {
    println!(&quot;the ID of Struct is: {}&quot;, Struct::ID);
}
</code></pre></pre>
<p>That is, the constant <code>ID</code> is associated with <code>Struct</code>. Like functions,
associated constants work with traits and enums as well.</p>
<p>Traits have an extra ability with associated constants that gives them some
extra power. With a trait, you can use an associated constant in the same way
you’d use an associated type: by declaring it, but not giving it a value. The
implementor of the trait then declares its value upon implementation:</p>
<pre><pre class="playpen"><code class="language-rust">trait Trait {
    const ID: u32;
}

struct Struct;

impl Trait for Struct {
    const ID: u32 = 5;
}

fn main() {
    println!(&quot;{}&quot;, Struct::ID);
}
</code></pre></pre>
<p>Before this feature, if you wanted to make a trait that represented floating
point numbers, you’d have to write this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Float {
    fn nan() -&gt; Self;
    fn infinity() -&gt; Self;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This is slightly unwieldy, but more importantly, because they’re functions,
they cannot be used in constant expressions, even though they only return a
constant. Because of this, a design for <code>Float</code> would also have to include
constants as well:</p>
<pre><code class="language-rust ignore">mod f32 {
    const NAN: f32 = 0.0f32 / 0.0f32;
    const INFINITY: f32 = 1.0f32 / 0.0f32;

    impl Float for f32 {
        fn nan() -&gt; Self {
            f32::NAN
        }
        fn infinity() -&gt; Self {
            f32::INFINITY
        }
    }
}
</code></pre>
<p>Associated constants let you do this in a much cleaner way. This trait
definition:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Float {
    const NAN: Self;
    const INFINITY: Self;
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>Leads to this implementation:</p>
<pre><code class="language-rust ignore">mod f32 {
    impl Float for f32 {
        const NAN: f32 = 0.0f32 / 0.0f32;
        const INFINITY: f32 = 1.0f32 / 0.0f32;
    }
}
</code></pre>
<p>much cleaner, and more versatile.</p>
<h1><a class="header" href="#no-more-anonymous-trait-parameters" id="no-more-anonymous-trait-parameters">No more anonymous trait parameters</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>In accordance with RFC <a href="https://github.com/rust-lang/rfcs/pull/1685">#1685</a>,
parameters in trait method declarations are no longer allowed to be anonymous.</p>
<p>For example, in the 2015 edition, this was allowed:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, u8);
}
<span class="boring">}
</span></code></pre></pre>
<p>In the 2018 edition, all parameters must be given an argument name  (even if it's just
<code>_</code>):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn foo(&amp;self, baz: u8);
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#slice-patterns" id="slice-patterns">Slice patterns</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Have you ever tried to pattern match on the contents and structure of a slice?
Rust 2018 will let you do just that.</p>
<p>For example, say we want to accept a list of names and respond to that with a
greeting. With slice patterns, we can do that easy as pie with:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    greet(&amp;[]);
    // output: Bummer, there's no one here :(
    greet(&amp;[&quot;Alan&quot;]);
    // output: Hey, there Alan! You seem to be alone.
    greet(&amp;[&quot;Joan&quot;, &quot;Hugh&quot;]);
    // output: Hello, Joan and Hugh. Nice to see you are at least 2!
    greet(&amp;[&quot;John&quot;, &quot;Peter&quot;, &quot;Stewart&quot;]);
    // output: Hey everyone, we seem to be 3 here today.
}

fn greet(people: &amp;[&amp;str]) {
    match people {
        [] =&gt; println!(&quot;Bummer, there's no one here :(&quot;),
        [only_one] =&gt; println!(&quot;Hey, there {}! You seem to be alone.&quot;, only_one),
        [first, second] =&gt; println!(
            &quot;Hello, {} and {}. Nice to see you are at least 2!&quot;,
            first, second
        ),
        _ =&gt; println!(&quot;Hey everyone, we seem to be {} here today.&quot;, people.len()),
    }
}
</code></pre></pre>
<p>Now, you don't have to check the length first.</p>
<p>We can also match on arrays like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let arr = [1, 2, 3];

assert_eq!(&quot;ends with 3&quot;, match arr {
    [_, _, 3] =&gt; &quot;ends with 3&quot;,
    [a, b, c] =&gt; &quot;ends with something else&quot;,
});
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#more-details-4" id="more-details-4">More details</a></h2>
<h3><a class="header" href="#exhaustive-patterns" id="exhaustive-patterns">Exhaustive patterns</a></h3>
<p>In the first example, note in particular the <code>_ =&gt; ...</code> pattern.
Since we are matching on a slice, it could be of any length, so we need a
<em>&quot;catch all pattern&quot;</em> to handle it. If we forgot the <code>_ =&gt; ...</code> or
<code>identifier =&gt; ...</code> pattern, we would instead get an error saying:</p>
<pre><code class="language-ignore">error[E0004]: non-exhaustive patterns: `&amp;[_, _, _]` not covered
</code></pre>
<p>If we added a case for a slice of size <code>3</code> we would instead get:</p>
<pre><code class="language-ignore">error[E0004]: non-exhaustive patterns: `&amp;[_, _, _, _]` not covered
</code></pre>
<p>and so on...</p>
<h3><a class="header" href="#arrays-and-exact-lengths" id="arrays-and-exact-lengths">Arrays and exact lengths</a></h3>
<p>In the second example above, since arrays in Rust are of known lengths,
we have to match on exactly three elements.
If we try to match on 2 or 4 elements,we get the errors:</p>
<pre><code class="language-ignore">error[E0527]: pattern requires 2 elements but array has 3
</code></pre>
<p>and</p>
<pre><code class="language-ignore">error[E0527]: pattern requires 4 elements but array has 3
</code></pre>
<h3><a class="header" href="#in-the-pipeline" id="in-the-pipeline">In the pipeline</a></h3>
<p>When it comes to slice patterns, more advanced forms are planned but
have not been stabilized yet. To learn more, follow <a href="https://github.com/rust-lang/rust/issues/23121">the tracking issue</a>.</p>
<h1><a class="header" href="#ownership-and-lifetimes" id="ownership-and-lifetimes">Ownership and lifetimes</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to ownership and lifetimes.
One of the most notable of these is <a href="rustdoc-2018/ownership-and-lifetimes/default-match-bindings.html">default match binding modes</a>.</p>
<h1><a class="header" href="#non-lexical-lifetimes" id="non-lexical-lifetimes">Non-lexical lifetimes</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /> for 2018 edition</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.36-brightgreen.svg" alt="Minimum Rust version: 1.36" /> for 2015 edition</p>
<p>The borrow checker has been enhanced to accept more code, via a mechanism
called &quot;non-lexical lifetimes.&quot; Consider this example:</p>
<pre><code class="language-rust ignore">fn main() {
    let mut x = 5;

    let y = &amp;x;

    let z = &amp;mut x;
}
</code></pre>
<p>In older Rust, this is a compile-time error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:5:18
  |
4 |     let y = &amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;mut x;
  |                  ^ mutable borrow occurs here
6 | }
  | - immutable borrow ends here
</code></pre>
<p>This is because lifetimes follow &quot;lexical scope&quot;; that is, the borrow from <code>y</code> is
considered to be held until <code>y</code> goes out of scope at the end of <code>main</code>, even though
we never use <code>y</code> again. This code is fine, but the borrow checker could not handle it.</p>
<p>Today, this code will compile just fine.</p>
<h2><a class="header" href="#better-errors" id="better-errors">Better errors</a></h2>
<p>What if we did use <code>y</code>, like this?</p>
<pre><code class="language-rust ignore">fn main() {
    let mut x = 5;
    let y = &amp;x;
    let z = &amp;mut x;

    println!(&quot;y: {}&quot;, y);
}
</code></pre>
<p>Here's the error:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:5:18
  |
4 |     let y = &amp;x;
  |              - immutable borrow occurs here
5 |     let z = &amp;mut x;
  |                  ^ mutable borrow occurs here
...
8 | }
  | - immutable borrow ends here
</code></pre>
<p>With non-lexical lifetimes, the error changes slightly:</p>
<pre><code class="language-text">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:5:13
  |
4 |     let y = &amp;x;
  |             -- immutable borrow occurs here
5 |     let z = &amp;mut x;
  |             ^^^^^^ mutable borrow occurs here
6 |
7 |     println!(&quot;y: {}&quot;, y);
  |                       - borrow later used here
</code></pre>
<p>Instead of pointing to where <code>y</code> goes out of scope, it shows you where
the conflicting borrow occurs. This makes these sorts of errors <em>far</em> easier to debug.</p>
<h1><a class="header" href="#default-match-bindings" id="default-match-bindings">Default match bindings</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Have you ever had a borrowed <code>Option&lt;T&gt;</code> and tried to match on it? You
probably wrote this:</p>
<pre><code class="language-rust ignore">let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());

match s {
    Some(s) =&gt; println!(&quot;s is: {}&quot;, s),
    _ =&gt; (),
};
</code></pre>
<p>In Rust 2015, this would fail to compile, and you would have to write the
following instead:</p>
<pre><code class="language-rust ignore">// Rust 2015

let s: &amp;Option&lt;String&gt; = &amp;Some(&quot;hello&quot;.to_string());

match s {
    &amp;Some(ref s) =&gt; println!(&quot;s is: {}&quot;, s),
    _ =&gt; (),
};
</code></pre>
<p>Rust 2018, by contrast, will infer the <code>&amp;</code>s and <code>ref</code>s, and your original
code will Just Work.</p>
<p>This affects not just <code>match</code>, but patterns everywhere, such as in <code>let</code>
statements, closure arguments, and <code>for</code> loops.</p>
<h2><a class="header" href="#more-details-5" id="more-details-5">More details</a></h2>
<p>The mental model of patterns has shifted a bit with this change, to bring it
into line with other aspects of the language. For example, when writing a
<code>for</code> loop, you can iterate over borrowed contents of a collection by
borrowing the collection itself:</p>
<pre><code class="language-rust ignore">let my_vec: Vec&lt;i32&gt; = vec![0, 1, 2];

for x in &amp;my_vec { ... }
</code></pre>
<p>The idea is that an <code>&amp;T</code> can be understood as a <em>borrowed view of <code>T</code></em>, and
so when you iterate, match, or otherwise destructure a <code>&amp;T</code> you get a
borrowed view of its internals as well.</p>
<p>More formally, patterns have a &quot;binding mode,&quot; which is either by value
(<code>x</code>), by reference (<code>ref x</code>), or by mutable reference (<code>ref mut x</code>). In Rust
2015, <code>match</code> always started in by-value mode, and required you to explicitly
write <code>ref</code> or <code>ref mut</code> in patterns to switch to a borrowing mode. In Rust
2018, the type of the value being matched informs the binding mode, so that
if you match against an <code>&amp;Option&lt;String&gt;</code> with a <code>Some</code> variant, you are put
into <code>ref</code> mode automatically, giving you a borrowed view of the internal
data. Similarly, <code>&amp;mut Option&lt;String&gt;</code> would give you a <code>ref mut</code> view.</p>
<h1><a class="header" href="#_-the-anonymous-lifetime" id="_-the-anonymous-lifetime"><code>'_</code>, the anonymous lifetime</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>Rust 2018 allows you to explicitly mark where a lifetime is elided, for types
where this elision might otherwise be unclear. To do this, you can use the
special lifetime <code>'_</code> much like you can explicitly mark that a type is inferred
with the syntax <code>let x: _ = ..;</code>.</p>
<p>Let's say, for whatever reason, that we have a simple wrapper around <code>&amp;'a str</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct StrWrap&lt;'a&gt;(&amp;'a str);
<span class="boring">}
</span></code></pre></pre>
<p>In Rust 2015, you might have written:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Rust 2015

use std::fmt;

<span class="boring">struct StrWrap&lt;'a&gt;(&amp;'a str);
</span>
fn make_wrapper(string: &amp;str) -&gt; StrWrap {
    StrWrap(string)
}

impl&lt;'a&gt; fmt::Debug for StrWrap&lt;'a&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        fmt.write_str(self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>In Rust 2018, you can instead write:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt;
</span><span class="boring">struct StrWrap&lt;'a&gt;(&amp;'a str);
</span>
// Rust 2018

fn make_wrapper(string: &amp;str) -&gt; StrWrap&lt;'_&gt; {
    StrWrap(string)
}

impl fmt::Debug for StrWrap&lt;'_&gt; {
    fn fmt(&amp;self, fmt: &amp;mut fmt::Formatter&lt;'_&gt;) -&gt; fmt::Result {
        fmt.write_str(self.0)
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#more-details-6" id="more-details-6">More details</a></h2>
<p>In the Rust 2015 snippet above, we've used <code>-&gt; StrWrap</code>. However, unless you take
a look at the definition of <code>StrWrap</code>, it is not clear that the returned value
is actually borrowing something. Therefore, starting with Rust 2018, it is
deprecated to leave off the lifetime parameters for non-reference-types (types
other than <code>&amp;</code> and <code>&amp;mut</code>). Instead, where you previously wrote <code>-&gt; StrWrap</code>,
you should now write <code>-&gt; StrWrap&lt;'_&gt;</code>, making clear that borrowing is occurring.</p>
<p>What exactly does <code>'_</code> mean? It depends on the context!
In output contexts, as in the return type of <code>make_wrapper</code>,
it refers to a single lifetime for  all &quot;output&quot; locations.
In input contexts, a fresh lifetime is generated for each &quot;input location&quot;.
More concretely, to understand input contexts, consider the following example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Rust 2015

struct Foo&lt;'a, 'b: 'a&gt; {
    field: &amp;'a &amp;'b str,
}

impl&lt;'a, 'b: 'a&gt; Foo&lt;'a, 'b&gt; {
    // some methods...
}
<span class="boring">}
</span></code></pre></pre>
<p>We can rewrite this as:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">struct Foo&lt;'a, 'b: 'a&gt; {
</span><span class="boring">    field: &amp;'a &amp;'b str,
</span><span class="boring">}
</span>
// Rust 2018

impl Foo&lt;'_, '_&gt; {
    // some methods...
}
<span class="boring">}
</span></code></pre></pre>
<p>This is the same, because for each <code>'_</code>, a fresh lifetime is generated.
Finally, the relationship <code>'a: 'b</code> which the struct requires must be upheld.</p>
<p>For more details, see the <a href="https://github.com/rust-lang/rust/issues/44524">tracking issue on In-band lifetime bindings</a>.</p>
<h1><a class="header" href="#lifetime-elision-in-impl" id="lifetime-elision-in-impl">Lifetime elision in impl</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>When writing <code>impl</code> blocks, you can now elide lifetime annotations in some
situations.</p>
<p>Consider a trait like <code>MyIterator</code>:</p>
<pre><code class="language-rust ignore">trait MyIterator {
    type Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;
}
</code></pre>
<p>In Rust 2015, if we wanted to implement this iterator for mutable references
to <code>Iterators</code>, we'd need to write this:</p>
<pre><code class="language-rust ignore">impl&lt;'a, I: MyIterator&gt; MyIterator for &amp;'a mut I {
    type Item = I::Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        (*self).next()
    }
}
</code></pre>
<p>Note all of the <code>'a</code> annotations. In Rust 2018, we can write this:</p>
<pre><code class="language-rust ignore">impl&lt;I: MyIterator&gt; MyIterator for &amp;mut I {
    type Item = I::Item;
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        (*self).next()
    }
}
</code></pre>
<p>Similarly, lifetime annotations can appear due to a struct that contains
references:</p>
<pre><code class="language-rust ignore">struct SetOnDrop&lt;'a, T&gt; {
    borrow: &amp;'a mut T,
    value: Option&lt;T&gt;,
}
</code></pre>
<p>In Rust 2015, to implement <code>Drop</code> on this struct, we'd write:</p>
<pre><code class="language-rust ignore">impl&lt;'a, T&gt; Drop for SetOnDrop&lt;'a, T&gt; {
    fn drop(&amp;mut self) {
        if let Some(x) = self.value.take() {
            *self.borrow = x;
        }
    }
}
</code></pre>
<p>But in Rust 2018, we can combine elision with <a href="rustdoc-2018/ownership-and-lifetimes/the-anonymous-lifetime.html">the anonymous lifetime</a> and
write this instead.</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Drop for SetOnDrop&lt;'_, T&gt; {
    fn drop(&amp;mut self) {
        if let Some(x) = self.value.take() {
            *self.borrow = x;
        }
    }
}
</code></pre>
<h1><a class="header" href="#t-a-inference-in-structs" id="t-a-inference-in-structs"><code>T: 'a</code> inference in structs</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<p>An annotation in the form of <code>T: 'a</code>, where <code>T</code> is either a type or another
lifetime, is called an <em>&quot;outlives&quot;</em> requirement. Note that <em>&quot;outlives&quot;</em> also
implies <code>'a: 'a</code>.</p>
<p>One way in which edition 2018 helps you out in maintaining flow when writing
programs is by removing the need to explicitly annotate these <code>T: 'a</code> outlives
requirements in <code>struct</code> definitions. Instead, the requirements will be
inferred from the fields present in the definitions.</p>
<p>Consider the following <code>struct</code> definitions in Rust 2015:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Rust 2015

struct Ref&lt;'a, T: 'a&gt; {
    field: &amp;'a T
}

// or written with a `where` clause:

struct WhereRef&lt;'a, T&gt; where T: 'a {
    data: &amp;'a T
}

// with nested references:

struct RefRef&lt;'a, 'b: 'a, T: 'b&gt; {
    field: &amp;'a &amp;'b T,
}

// using an associated type:

struct ItemRef&lt;'a, T: Iterator&gt;
where
    T::Item: 'a
{
    field: &amp;'a T::Item
}
<span class="boring">}
</span></code></pre></pre>
<p>In Rust 2018, since the requirements are inferred, you can instead write:</p>
<pre><code class="language-rust ignore">// Rust 2018

struct Ref&lt;'a, T&gt; {
    field: &amp;'a T
}

struct WhereRef&lt;'a, T&gt; {
    data: &amp;'a T
}

struct RefRef&lt;'a, 'b, T&gt; {
    field: &amp;'a &amp;'b T,
}

struct ItemRef&lt;'a, T: Iterator&gt; {
    field: &amp;'a T::Item
}
</code></pre>
<p>If you prefer to be more explicit in some cases, that is still possible.</p>
<h2><a class="header" href="#more-details-7" id="more-details-7">More details</a></h2>
<p>For more details, see <a href="https://github.com/rust-lang/rust/issues/44493">the tracking issue</a>
and <a href="https://github.com/rust-lang/rfcs/pull/2093">the RFC</a>.</p>
<h1><a class="header" href="#simpler-lifetimes-in-static-and-const" id="simpler-lifetimes-in-static-and-const">Simpler lifetimes in <code>static</code> and <code>const</code></a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.17-brightgreen.svg" alt="Minimum Rust version: 1.17" /></p>
<p>In older Rust, you had to explicitly write the <code>'static</code> lifetime in any
<code>static</code> or <code>const</code> that needed a lifetime:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">mod foo {
</span>const NAME: &amp;'static str = &quot;Ferris&quot;;
<span class="boring">}
</span><span class="boring">mod bar {
</span>static NAME: &amp;'static str = &quot;Ferris&quot;;
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>But <code>'static</code> is the only possible lifetime there. So Rust now assumes the <code>'static</code> lifetime,
and you don't have to write it out:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">mod foo {
</span>const NAME: &amp;str = &quot;Ferris&quot;;
<span class="boring">}
</span><span class="boring">mod bar {
</span>static NAME: &amp;str = &quot;Ferris&quot;;
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>In some situations, this can remove a <em>lot</em> of boilerplate:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">mod foo {
</span>// old
const NAMES: &amp;'static [&amp;'static str; 2] = &amp;[&quot;Ferris&quot;, &quot;Bors&quot;];
<span class="boring">}
</span><span class="boring">mod bar {
</span>
// new
const NAMES: &amp;[&amp;str; 2] = &amp;[&quot;Ferris&quot;, &quot;Bors&quot;];
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#data-types-1" id="data-types-1">Data types</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to data types.
One of these are <a href="rustdoc-2018/data-types/field-init-shorthand.html">field-init-shorthand</a>.</p>
<h1><a class="header" href="#field-init-shorthand" id="field-init-shorthand">Field init shorthand</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.17-brightgreen.svg" alt="Minimum Rust version: 1.17" /></p>
<p>In older Rust, when initializing a struct, you must always give the full set of <code>key: value</code> pairs
for its fields:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

let a = 5;
let b = 6;

let p = Point {
    x: a,
    y: b,
};
<span class="boring">}
</span></code></pre></pre>
<p>However, often these variables would have the same names as the fields. So you'd end up
with code that looks like this:</p>
<pre><code class="language-rust ignore">let p = Point {
    x: x,
    y: y,
};
</code></pre>
<p>Now, if the variable is of the same name, you don't have to write out both, just write out the key:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Point {
    x: i32,
    y: i32,
}

let x = 5;
let y = 6;

// new
let p = Point {
    x,
    y,
};
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#-for-inclusive-ranges" id="-for-inclusive-ranges"><code>..=</code> for inclusive ranges</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>Since well before Rust 1.0, you’ve been able to create exclusive ranges with
<code>..</code> like this:</p>
<pre><code>for i in 1..3 {
    println!(&quot;i: {}&quot;, i);
}
</code></pre>
<p>This will print <code>i: 1</code> and then <code>i: 2</code>. Today, you can now create an
inclusive range, like this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for i in 1..=3 {
    println!(&quot;i: {}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will print <code>i: 1</code> and then <code>i: 2</code> like before, but also <code>i: 3</code>; the
three is included in the range. Inclusive ranges are especially useful if you
want to iterate over every possible value in a range. For example, this is a
surprising Rust program:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn takes_u8(x: u8) {
    // ...
}

fn main() {
    for i in 0..256 {
        println!(&quot;i: {}&quot;, i);
        takes_u8(i);
    }
}
</code></pre></pre>
<p>What does this program do? The answer: it fails to compile. The error we get
when compiling has a hint:</p>
<pre><code class="language-text">error: literal out of range for u8
 --&gt; src/main.rs:6:17
  |
6 |     for i in 0..256 {
  |                 ^^^
  |
  = note: #[deny(overflowing_literals)] on by default
</code></pre>
<p>That’s right, since <code>i</code> is a <code>u8</code>, this overflows, and the compiler produces
an error.</p>
<p>We can do this with inclusive ranges, however:</p>
<pre><pre class="playpen"><code class="language-rust">fn takes_u8(x: u8) {
    // ...
}

fn main() {
    for i in 0..=255 {
        println!(&quot;i: {}&quot;, i);
        takes_u8(i);
    }
}
</code></pre></pre>
<p>This will produce those 256 lines of output you might have been expecting.</p>
<h1><a class="header" href="#128-bit-integers" id="128-bit-integers">128 bit integers</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /></p>
<p>A very simple feature: Rust now has 128 bit integers!</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x: i128 = 0;
let y: u128 = 0;
<span class="boring">}
</span></code></pre></pre>
<p>These are twice the size of <code>u64</code>, and so can hold more values. More specifically,</p>
<ul>
<li><code>u128</code>: <code>0</code> - <code>340,282,366,920,938,463,463,374,607,431,768,211,455</code></li>
<li><code>i128</code>: <code>−170,141,183,460,469,231,731,687,303,715,884,105,728</code> - <code>170,141,183,460,469,231,731,687,303,715,884,105,727</code></li>
</ul>
<p>Whew!</p>
<h1><a class="header" href="#operator-equals-are-now-implementable" id="operator-equals-are-now-implementable">&quot;Operator-equals&quot; are now implementable</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.8-brightgreen.svg" alt="Minimum Rust version: 1.8" /></p>
<p>The various “operator equals” operators, such as <code>+=</code> and <code>-=</code>, are
implementable via various traits. For example, to implement <code>+=</code> on
a type of your own:</p>
<pre><pre class="playpen"><code class="language-rust">use std::ops::AddAssign;

#[derive(Debug)]
struct Count { 
    value: i32,
}

impl AddAssign for Count {
    fn add_assign(&amp;mut self, other: Count) {
        self.value += other.value;
    }
}

fn main() {
    let mut c1 = Count { value: 1 };
    let c2 = Count { value: 5 };

    c1 += c2;

    println!(&quot;{:?}&quot;, c1);
}
</code></pre></pre>
<p>This will print <code>Count { value: 6 }</code>.</p>
<h1><a class="header" href="#union-for-an-unsafe-form-of-enum" id="union-for-an-unsafe-form-of-enum"><code>union</code> for an unsafe form of <code>enum</code></a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.19-brightgreen.svg" alt="Minimum Rust version: 1.19" /></p>
<p>Rust now supports <code>unions</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>union MyUnion {
    f1: u32,
    f2: f32,
}
<span class="boring">}
</span></code></pre></pre>
<p>Unions are kind of like enums, but they are “untagged”. Enums have a “tag”
that stores which variant is the correct one at runtime; unions don't have
this tag.</p>
<p>Since we can interpret the data held in the union using the wrong variant and
Rust can’t check this for us, that means reading a union’s field is unsafe:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion {
</span><span class="boring">    f1: u32,
</span><span class="boring">    f2: f32,
</span><span class="boring">}
</span>let mut u = MyUnion { f1: 1 };

u.f1 = 5;

let value = unsafe { u.f1 };
<span class="boring">}
</span></code></pre></pre>
<p>Pattern matching works too:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">union MyUnion {
</span><span class="boring">    f1: u32,
</span><span class="boring">    f2: f32,
</span><span class="boring">}
</span>fn f(u: MyUnion) {
    unsafe {
        match u {
            MyUnion { f1: 10 } =&gt; { println!(&quot;ten&quot;); }
            MyUnion { f2 } =&gt; { println!(&quot;{}&quot;, f2); }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>When are unions useful? One major use-case is interoperability with C. C APIs
can (and depending on the area, often do) expose unions, and so this makes
writing API wrappers for those libraries significantly easier. Additionally,
unions also simplify Rust implementations of space-efficient or
cache-efficient structures relying on value representation, such as
machine-word-sized unions using the least-significant bits of aligned
pointers to distinguish cases.</p>
<p>There’s still more improvements to come. For now, unions can only include
<code>Copy</code> types and may not implement <code>Drop</code>. We expect to lift these
restrictions in the future.</p>
<h1><a class="header" href="#choosing-alignment-with-the-repr-attribute" id="choosing-alignment-with-the-repr-attribute">Choosing alignment with the repr attribute</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p>From <a href="https://en.wikipedia.org/wiki/Data_structure_alignment">Wikipedia</a>:</p>
<blockquote>
<p>The CPU in modern computer hardware performs reads and writes to memory
most efficiently when the data is naturally aligned, which generally means
that the data address is a multiple of the data size. Data alignment refers
to aligning elements according to their natural alignment. To ensure natural
alignment, it may be necessary to insert some padding between structure
elements or after the last element of a structure.</p>
</blockquote>
<p>The <code>#[repr]</code> attribute has a new parameter, <code>align</code>, that sets the alignment of your struct:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Number(i32);

assert_eq!(std::mem::align_of::&lt;Number&gt;(), 4);
assert_eq!(std::mem::size_of::&lt;Number&gt;(), 4);

#[repr(align(16))]
struct Align16(i32);

assert_eq!(std::mem::align_of::&lt;Align16&gt;(), 16);
assert_eq!(std::mem::size_of::&lt;Align16&gt;(), 16);
<span class="boring">}
</span></code></pre></pre>
<p>If you’re working with low-level stuff, control of these kinds of things can
be very important!</p>
<p>The alignment of a type is normally not worried about as the compiler will
&quot;do the right thing&quot; of picking an appropriate alignment for general use
cases. There are situations, however, where a nonstandard alignment may be
desired when operating with foreign systems. For example these sorts of
situations tend to necessitate or be much easier with a custom alignment:</p>
<ul>
<li>Hardware can often have obscure requirements such as &quot;this structure is
aligned to 32 bytes&quot; when it in fact is only composed of 4-byte values. While
this can typically be manually calculated and managed, it's often also useful
to express this as a property of a type to get the compiler to do a little
extra work instead.</li>
<li>C compilers like <code>gcc</code> and <code>clang</code> offer the ability to specify a custom
alignment for structures, and Rust can much more easily interoperate with
these types if Rust can also mirror the request for a custom alignment (e.g.
passing a structure to C correctly is much easier).</li>
<li>Custom alignment can often be used for various tricks here and there and is
often convenient as &quot;let's play around with an implementation&quot; tool. For
example this can be used to statically allocate page tables in a kernel or
create an at-least cache-line-sized structure easily for concurrent
programming.</li>
</ul>
<p>The purpose of this feature is to provide a lightweight annotation to alter
the compiler-inferred alignment of a structure to enable these situations
much more easily.</p>
<h1><a class="header" href="#simd-for-faster-computing" id="simd-for-faster-computing">SIMD for faster computing</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg" alt="Minimum Rust version: 1.27" /></p>
<p>The basics of <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> are now available!
SIMD stands for “single instruction, multiple data.” Consider a function like
this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn foo(a: &amp;[u8], b: &amp;[u8], c: &amp;mut [u8]) {
    for ((a, b), c) in a.iter().zip(b).zip(c) {
        *c = *a + *b;
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here, we’re taking two slices, and adding the numbers together, placing the
result in a third slice. The simplest possible way to do this would be to do
exactly what the code does, and loop through each set of elements, add them
together, and store it in the result. However, compilers can often do better.
LLVM will usually “autovectorize” code like this, which is a fancy term for
“use SIMD.” Imagine that <code>a</code> and <code>b</code> were both 16 elements long. Each element
is a <code>u8</code>, and so that means that each slice would be 128 bits of data. Using
SIMD, we could put both <code>a</code> and <code>b</code> into 128 bit registers, add them together
in a <em>single</em> instruction, and then copy the resulting 128 bits into <code>c</code>.
That’d be much faster!</p>
<p>While stable Rust has always been able to take advantage of
autovectorization, sometimes, the compiler just isn’t smart enough to realize
that we can do something like this. Additionally, not every CPU has these
features, and so LLVM may not use them so your program can be used on a wide
variety of hardware. The <code>std::arch</code> module allows us to use these kinds of
instructions directly, which means we don’t need to rely on a smart compiler.
Additionally, it includes some features that allow us to choose a particular
implementation based on various criteria. For example:</p>
<pre><code class="language-rust ignore">#[cfg(all(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;),
      target_feature = &quot;avx2&quot;))]
fn foo() {
    #[cfg(target_arch = &quot;x86&quot;)]
    use std::arch::x86::_mm256_add_epi64;
    #[cfg(target_arch = &quot;x86_64&quot;)]
    use std::arch::x86_64::_mm256_add_epi64;

    unsafe {
        _mm256_add_epi64(...);
    }
}
</code></pre>
<p>Here, we use cfg flags to choose the correct version based on the machine
we’re targeting; on x86 we use that version, and on x86_64 we use its
version. We can also choose at runtime:</p>
<pre><code class="language-rust ignore">fn foo() {
    #[cfg(any(target_arch = &quot;x86&quot;, target_arch = &quot;x86_64&quot;))]
    {
        if is_x86_feature_detected!(&quot;avx2&quot;) {
            return unsafe { foo_avx2() };
        }
    }

    foo_fallback();
}
</code></pre>
<p>Here, we have two versions of the function: one which uses AVX2, a specific
kind of SIMD feature that lets you do 256-bit operations. The
<code>is_x86_feature_detected!</code> macro will generate code that detects if your CPU
supports AVX2, and if so, calls the foo_avx2 function. If not, then we fall
back to a non-AVX implementation, foo_fallback. This means that our code will
run super fast on CPUs that support AVX2, but still work on ones that don’t,
albeit slower.</p>
<p>If all of this seems a bit low-level and fiddly, well, it is! <code>std::arch</code> is
specifically primitives for building these kinds of things. We hope to
eventually stabilize a <code>std::simd</code> module with higher-level stuff in the
future. But landing the basics now lets the ecosystem experiment with higher
level libraries starting today. For example, check out the
<a href="https://github.com/AdamNiederer/faster">faster</a> crate. Here’s a code snippet
with no SIMD:</p>
<pre><code class="language-rust ignore">let lots_of_3s = (&amp;[-123.456f32; 128][..]).iter()
    .map(|v| {
        9.0 * v.abs().sqrt().sqrt().recip().ceil().sqrt() - 4.0 - 2.0
    })
    .collect::&lt;Vec&lt;f32&gt;&gt;();
</code></pre>
<p>To use SIMD with this code via faster, you’d change it to this:</p>
<pre><code class="language-rust ignore">let lots_of_3s = (&amp;[-123.456f32; 128][..]).simd_iter()
    .simd_map(f32s(0.0), |v| {
        f32s(9.0) * v.abs().sqrt().rsqrt().ceil().sqrt() - f32s(4.0) - f32s(2.0)
    })
    .scalar_collect();
</code></pre>
<p>It looks almost the same: <code>simd_iter</code> instead of <code>iter</code>, <code>simd_map</code> instead of <code>map</code>,
<code>f32s(2.0)</code> instead of <code>2.0</code>. But you get a SIMD-ified version generated for you.</p>
<p>Beyond that, you may never write any of this yourself, but as always, the
libraries you depend on may. For example, the regex crate contains these SIMD
speedups without you needing to do anything at all!</p>
<h1><a class="header" href="#macros-2" id="macros-2">Macros</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to the macro system.
A notable addition here is the introduction of <a href="rustdoc-2018/macros/custom-derive.html">custom derive macros</a>.</p>
<h1><a class="header" href="#custom-derive" id="custom-derive">Custom Derive</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.15-brightgreen.svg" alt="Minimum Rust version: 1.15" /></p>
<p>In Rust, you’ve always been able to automatically implement some traits
through the derive attribute:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Pet {
    name: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>Debug</code> trait is then implemented for <code>Pet</code>, with vastly less boilerplate. For example, without <code>derive</code>, you'd have
to write this:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt;

struct Pet {
    name: String,
}

impl fmt::Debug for Pet {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            Pet { name } =&gt; {
                let mut debug_trait_builder = f.debug_struct(&quot;Pet&quot;);

                let _ = debug_trait_builder.field(&quot;name&quot;, name);

                debug_trait_builder.finish()
            }
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Whew!</p>
<p>However, this only worked for traits provided as part of the standard
library; it was not customizable. But now, you can tell Rust what to do when
someone wants to derive your trait. This is used heavily in popular crates
like <a href="https://serde.rs/">serde</a> and <a href="http://diesel.rs/">Diesel</a>.</p>
<p>For more, including learning how to build your own custom derive, see <a href="https://doc.rust-lang.org/book/ch19-06-macros.html#how-to-write-a-custom-derive-macro">The
Rust Programming
Language</a>.</p>
<h1><a class="header" href="#macro-changes" id="macro-changes">Macro changes</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /></p>
<h2><a class="header" href="#macro_rules-style-macros" id="macro_rules-style-macros"><code>macro_rules!</code> style macros</a></h2>
<p>In Rust 2018, you can import specific macros from external crates via <code>use</code>
statements, rather than the old <code>#[macro_use]</code> attribute.</p>
<p>For example, consider a <code>bar</code> crate that implements a <code>baz!</code> macro. In
<code>src/lib.rs</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[macro_export]
macro_rules! baz {
    () =&gt; ()
}
<span class="boring">}
</span></code></pre></pre>
<p>In your crate, you would have written</p>
<pre><code class="language-rust ignore">// Rust 2015

#[macro_use]
extern crate bar;

fn main() {
    baz!();
}
</code></pre>
<p>Now, you write:</p>
<pre><code class="language-rust ignore">// Rust 2018

use bar::baz;

fn main() {
    baz!();
}
</code></pre>
<p>This moves <code>macro_rules</code> macros to be a bit closer to other kinds of items.</p>
<p>Note that you'll still need <code>#[macro_use]</code> to use macros you've defined
in your own crate; this feature only works for importing macros from
external crates.</p>
<h2><a class="header" href="#procedural-macros" id="procedural-macros">Procedural macros</a></h2>
<p>When using procedural macros to derive traits, you will have to name the macro
that provides the custom derive. This generally matches the name of the trait,
but check with the documentation of the crate providing the derives to be sure.</p>
<p>For example, with Serde you would have written</p>
<pre><code class="language-rust ignore">// Rust 2015
extern crate serde;
#[macro_use] extern crate serde_derive;

#[derive(Serialize, Deserialize)]
struct Bar;
</code></pre>
<p>Now, you write instead:</p>
<pre><code class="language-rust ignore">// Rust 2018
use serde_derive::{Serialize, Deserialize};

#[derive(Serialize, Deserialize)]
struct Bar;
</code></pre>
<h2><a class="header" href="#more-details-8" id="more-details-8">More details</a></h2>
<p>This only works for macros defined in external crates.
For macros defined locally, <code>#[macro_use] mod foo;</code> is still required, as it was in Rust 2015.</p>
<h3><a class="header" href="#local-helper-macros" id="local-helper-macros">Local helper macros</a></h3>
<p>Sometimes it is helpful or necessary to have helper macros inside your module. This can make
supporting both versions of rust more complicated.</p>
<p>For example, let's make a simplified (and slightly contrived) version of the <code>log</code> crate in 2015
edition style:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt;

/// How important/severe the log message is.
#[derive(Copy, Clone)]
pub enum LogLevel {
    Warn,
    Error
}

impl fmt::Display for LogLevel {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            LogLevel::Warn =&gt; write!(f, &quot;warning&quot;),
            LogLevel::Error =&gt; write!(f, &quot;error&quot;),
        }
    }
}

// A helper macro to log the message.
#[doc(hidden)]
#[macro_export]
macro_rules! __impl_log {
    ($level:expr, $msg:expr) =&gt; {{
        println!(&quot;{}: {}&quot;, $level, $msg)
    }}
}

/// Warn level log message
#[macro_export]
macro_rules! warn {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Warn, format_args!($($args)*))
    }
}

/// Error level log message
#[macro_export]
macro_rules! error {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Error, format_args!($($args)*))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Our <code>__impl_log!</code> macro is private to our module, but needs to be exported as it is called by other
macros, and in 2015 edition all used macros must be exported.</p>
<p>Now, in 2018 this example will not compile:</p>
<pre><code class="language-rust ignore">use log::error;

fn main() {
    error!(&quot;error message&quot;);
}
</code></pre>
<p>will give an error message about not finding the <code>__impl_log!</code> macro. This is because unlike in 
the 2015 edition, macros are namespaced and we must import them. We could do</p>
<pre><code class="language-rust ignore">use log::{__impl_log, error};
</code></pre>
<p>which would make our code compile, but <code>__impl_log</code> is meant to be an implementation detail!</p>
<h4><a class="header" href="#macros-with-crate-prefix" id="macros-with-crate-prefix">Macros with <code>$crate::</code> prefix.</a></h4>
<p>The cleanest way to handle this situation is to use the <code>$crate::</code> prefix for macros, the same as
you would for any other path. Versions of the compiler &gt;= 1.30 will handle this in both editions:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! warn {
    ($($args:tt)*) =&gt; {
        $crate::__impl_log!($crate::LogLevel::Warn, format_args!($($args)*))
    }
}

// ...
<span class="boring">}
</span></code></pre></pre>
<p>However, this will not work for older versions of the compiler that don't understand the
<code>$crate::</code> prefix for macros.</p>
<h4><a class="header" href="#macros-using-local_inner_macros" id="macros-using-local_inner_macros">Macros using <code>local_inner_macros</code></a></h4>
<p>We also have the <code>local_inner_macros</code> modifier that we can add to our <code>#[macro_export]</code> attribute.
This has the advantage of working with older rustc versions (older versions just ignore the extra
modifier). The downside is that it's a bit messier:</p>
<pre><code class="language-rust ignore">#[macro_export(local_inner_macros)]
macro_rules! warn {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Warn, format_args!($($args)*))
    }
}
</code></pre>
<p>So the code knows to look for any macros used locally. But wait - this won't compile, because we
use the <code>format_args!</code> macro that isn't in our local crate (hence the convoluted example). The
solution is to add a level of indirection: we create a macro that wraps <code>format_args</code>, but is local 
to our crate. That way everything works in both editions (sadly we have to pollute the global
namespace a bit, but that's ok).</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// I've used the pattern `_&lt;my crate  name&gt;__&lt;macro name&gt;` to name this macro, hopefully avoiding
// name clashes.
#[doc(hidden)]
#[macro_export]
macro_rules! _log__format_args {
    ($($inner:tt)*) =&gt; {
        format_args! { $($inner)* }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Here we're using the most general macro pattern possible, a list of token trees. We just pass
whatever tokens we get to the inner macro, and rely on it to report errors.</p>
<p>So the full 2015/2018 working example would be:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt;

/// How important/severe the log message is.
#[derive(Debug, Copy, Clone)]
pub enum LogLevel {
    Warn,
    Error
}

impl fmt::Display for LogLevel {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match self {
            LogLevel::Warn =&gt; write!(f, &quot;warning&quot;),
            LogLevel::Error =&gt; write!(f, &quot;error&quot;),
        }
    }
}

// A helper macro to log the message.
#[doc(hidden)]
#[macro_export]
macro_rules! __impl_log {
    ($level:expr, $msg:expr) =&gt; {{
        println!(&quot;{}: {}&quot;, $level, $msg)
    }}
}

/// Warn level log message
#[macro_export(local_inner_macros)]
macro_rules! warn {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Warn, _log__format_args!($($args)*))
    }
}

/// Error level log message
#[macro_export(local_inner_macros)]
macro_rules! error {
    ($($args:tt)*) =&gt; {
        __impl_log!($crate::LogLevel::Error, _log__format_args!($($args)*))
    }
}

#[doc(hidden)]
#[macro_export]
macro_rules! _log__format_args {
    ($($inner:tt)*) =&gt; {
        format_args! { $($inner)* }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Once everyone is using a rustc version &gt;= 1.30, we can all just use the <code>$crate::</code> method (2015
crates are guaranteed to carry on compiling fine with later versions of the compiler). We need to
wait for package managers and larger organisations to update their compilers before this happens,
so in the mean time we can use the <code>local_inner_macros</code> method to support everybody. :)</p>
<h1><a class="header" href="#at-most-one-repetition" id="at-most-one-repetition">At most one repetition</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg" alt="Minimum Rust version: 1.32" /> for 2018 edition</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.37-brightgreen.svg" alt="Minimum Rust version: 1.37" /> for 2015 edition</p>
<p>In Rust 2018, we have made a couple of changes to the macros-by-example syntax.</p>
<ol>
<li>We have added a new Kleene operator <code>?</code> which means &quot;at most one&quot;
repetition. This operator does not accept a separator token.</li>
<li>We have disallowed using <code>?</code> as a separator to remove ambiguity with <code>?</code>.</li>
</ol>
<p>For example, consider the following Rust 2015 code:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($a:ident, $b:expr) =&gt; {
        println!(&quot;{}&quot;, $a);
        println!(&quot;{}&quot;, $b);
    };
    ($a:ident) =&gt; {
        println!(&quot;{}&quot;, $a);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Macro <code>foo</code> can be called with 1 or 2 arguments; the second one is optional,
but you need a whole other matcher to represent this possibility. This is
annoying if your matchers are long. In Rust 2018, one can simply write the
following:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>macro_rules! foo {
    ($a:ident $(, $b:expr)?) =&gt; {
        println!(&quot;{}&quot;, $a);

        $(
            println!(&quot;{}&quot;, $b);
         )?
    }
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#the-compiler" id="the-compiler">The compiler</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to the compiler.
A notable addition here is our new and <a href="rustdoc-2018/the-compiler/improved-error-messages.html">improved error messages</a>.</p>
<h1><a class="header" href="#improved-error-messages" id="improved-error-messages">Improved error messages</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.12-brightgreen.svg" alt="Minimum Rust version: 1.12" /></p>
<p>We're always working on error improvements, and there are little improvements
in almost every Rust version, but in Rust 1.12, a significant overhaul of the
error message system was created.</p>
<p>For example, here's some code that produces an error:</p>
<pre><pre class="playpen"><code class="language-rust compile_fail">fn main() {
    let mut x = 5;
    let y = &amp;x;
    x += 1;
    println!(&quot;{} {}&quot;, x, y);
}
</code></pre></pre>
<p>Here's the error in Rust 1.11:</p>
<pre><code class="language-text">foo.rs:4:5: 4:11 error: cannot assign to `x` because it is borrowed [E0506]
foo.rs:4     x += 1;
             ^~~~~~
foo.rs:3:14: 3:15 note: borrow of `x` occurs here
foo.rs:3     let y = &amp;x;
                      ^
foo.rs:4:5: 4:11 help: run `rustc --explain E0506` to see a detailed explanation
error: aborting due to previous error
</code></pre>
<p>Here's the error in Rust 1.28:</p>
<pre><code class="language-text">error[E0506]: cannot assign to `x` because it is borrowed
 --&gt; foo.rs:4:5
  |
3 |     let y = &amp;x;
  |              - borrow of `x` occurs here
4 |     x += 1;
  |     ^^^^^^ assignment to borrowed `x` occurs here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0506`.
</code></pre>
<p>This error isn't terribly different, but shows off how the format has changed. It shows
off your code in context, rather than just showing the text of the lines themselves.</p>
<h1><a class="header" href="#incremental-compilation" id="incremental-compilation">Incremental Compilation</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.24-brightgreen.svg" alt="Minimum Rust version: 1.24" /></p>
<p>Back in September of 2016, we <a href="https://blog.rust-lang.org/2016/09/08/incremental.html">blogged about Incremental
Compilation</a>. While
that post goes into the details, the idea is basically this: when you’re
working on a project, you often compile it, then change something small, then
compile again. Historically, the compiler has compiled your entire project,
no matter how little you’ve changed the code. The idea with incremental
compilation is that you only need to compile the code you’ve actually
changed, which means that that second build is faster.</p>
<p>This is now turned on by default. This means that your builds should be
faster! Don’t forget about <code>cargo check</code> when trying to get the lowest possible
build times.</p>
<p>This is still not the end story for compiler performance generally, nor
incremental compilation specifically. We have a lot more work planned in the
future.</p>
<p>One small note about this change: it makes builds faster, but makes the final
binary a bit slower. For this reason, it's not turned on in release builds.</p>
<h1><a class="header" href="#an-attribute-for-deprecation" id="an-attribute-for-deprecation">An attribute for deprecation</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.9-brightgreen.svg" alt="Minimum Rust version: 1.9" /></p>
<p>If you're writing a library, and you'd like to deprecate something, you can
use the <code>deprecated</code> attribute:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[deprecated(
    since = &quot;0.2.1&quot;,
    note = &quot;Please use the bar function instead&quot;
)]
pub fn foo() {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>This will give your users a warning if they use the deprecated functionality:</p>
<pre><code class="language-text">   Compiling playground v0.0.1 (file:///playground)
warning: use of deprecated item 'foo': Please use the bar function instead
  --&gt; src/main.rs:10:5
   |
10 |     foo();
   |     ^^^
   |
   = note: #[warn(deprecated)] on by default

</code></pre>
<p>Both <code>since</code> and <code>note</code> are optional.</p>
<p><code>since</code> can be in the future; you can put whatever you'd like, and what's put in
there isn't checked.</p>
<h1><a class="header" href="#rustup-for-managing-rust-versions" id="rustup-for-managing-rust-versions">Rustup for managing Rust versions</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-various-brightgreen.svg" alt="Minimum Rust version: various" /> (this tool has its own versioning scheme and works with all Rust versions)</p>
<p>The <a href="https://rustup.rs/">Rustup</a> tool has become <em>the</em> recommended way to
install Rust, and is advertised on our website. Its powers go further than
that though, allowing you to manage various versions, components, and
platforms.</p>
<h2><a class="header" href="#for-installing-rust" id="for-installing-rust">For installing Rust</a></h2>
<p>To install Rust through Rustup, you can go to
<a href="https://www.rust-lang.org/install.html">https://www.rust-lang.org/install.html</a>, which will let you know how to do
so on your platform. This will install both <code>rustup</code> itself and the <code>stable</code>
version of <code>rustc</code> and <code>cargo</code>.</p>
<p>To install a specific Rust version, you can use <code>rustup install</code>:</p>
<pre><code class="language-console">$ rustup install 1.30.0
</code></pre>
<p>This works for a specific nightly, as well:</p>
<pre><code class="language-console">$ rustup install nightly-2018-08-01
</code></pre>
<p>As well as any of our release channels:</p>
<pre><code class="language-console">$ rustup install stable
$ rustup install beta
$ rustup install nightly
</code></pre>
<h2><a class="header" href="#for-updating-your-installation" id="for-updating-your-installation">For updating your installation</a></h2>
<p>To update all of the various channels you may have installed:</p>
<pre><code class="language-console">$ rustup update
</code></pre>
<p>This will look at everything you've installed, and if there are new releases,
will update anything that has one.</p>
<h2><a class="header" href="#managing-versions" id="managing-versions">Managing versions</a></h2>
<p>To set the default toolchain to something other than <code>stable</code>:</p>
<pre><code class="language-console">$ rustup default nightly
</code></pre>
<p>To use a toolchain other than the default, use <code>rustup run</code>:</p>
<pre><code class="language-console">$ rustup run nightly cargo build
</code></pre>
<p>There's also an alias for this that's a little shorter:</p>
<pre><code class="language-console">$ cargo +nightly build
</code></pre>
<p>If you'd like to have a different default per-directory, that's easy too!
If you run this inside of a project:</p>
<pre><code class="language-console">$ rustup override set nightly
</code></pre>
<p>Or, if you'd like to target a different version of Rust:</p>
<pre><code class="language-console">$ rustup override set 1.30.0
</code></pre>
<p>Then when you're in that directory, any invocations of <code>rustc</code> or <code>cargo</code>
will use that toolchain. To share this with others, you can create a
<code>rust-toolchain</code> file with the contents of a toolchain, and check it into
source control. Now, when someone clones your project, they'll get the
right version without needing to <code>override set</code> themselves.</p>
<h2><a class="header" href="#installing-other-targets" id="installing-other-targets">Installing other targets</a></h2>
<p>Rust supports cross-compiling to other targets, and Rustup can help you
manage them. For example, to use MUSL:</p>
<pre><code class="language-console">$ rustup target add x86_64-unknown-linux-musl
</code></pre>
<p>And then you can</p>
<pre><code class="language-console">$ cargo build --target=x86_64-unknown-linux-musl
</code></pre>
<p>To see the full list of targets you can install:</p>
<pre><code class="language-console">$ rustup target list
</code></pre>
<h2><a class="header" href="#installing-components" id="installing-components">Installing components</a></h2>
<p>Components are used to install certain kinds of tools. While <code>cargo-install</code>
has you covered for most tools, some tools need deep integration into the
compiler. Rustup knows exactly what version of the compiler you're using, and
so it's got just the information that these tools need.</p>
<p>Components are per-toolchain, so if you want them to be available to more
than one toolchain, you'll need to install them multiple times. In the
following examples, add a <code>--toolchain</code> flag, set to the toolchain you
want to install for, <code>nightly</code> for example. Without this flag, it will
install the component for the default toolchain.</p>
<p>To see the full list of components you can install:</p>
<pre><code class="language-console">$ rustup component list
</code></pre>
<p>Next, let's talk about some popular components and when you might want to
install them.</p>
<h3><a class="header" href="#rust-docs-for-local-documentation" id="rust-docs-for-local-documentation"><code>rust-docs</code>, for local documentation</a></h3>
<p>This first component is installed by default when you install a toolchain. It
contains a copy of Rust's documentation, so that you can read it offline.</p>
<p>This component cannot be removed for now; if that's of interest, please
comment on <a href="https://github.com/rust-lang-nursery/rustup.rs/issues/998">this
issue</a>.</p>
<h3><a class="header" href="#rust-src-for-a-copy-of-rusts-source-code" id="rust-src-for-a-copy-of-rusts-source-code"><code>rust-src</code> for a copy of Rust's source code</a></h3>
<p>The <code>rust-src</code> component can give you a local copy of Rust's source code. Why
might you need this? Well, autocompletion tools like Racer use this
information to know more about the functions you're trying to call.</p>
<pre><code class="language-console">$ rustup component add rust-src
</code></pre>
<h3><a class="header" href="#the-preview-components" id="the-preview-components">The &quot;preview&quot; components</a></h3>
<p>There are several components in a &quot;preview&quot; stage. These components currently
have <code>-preview</code> in their name, and this indicates that they're not quite 100%
ready for general consumption yet. Please try them out and give us feedback,
but know that they do not follow Rust's stability guarantees, and are still
actively changing, possibly in backwards-incompatible ways.</p>
<h4><a class="header" href="#rustfmt-preview-for-automatic-code-formatting" id="rustfmt-preview-for-automatic-code-formatting"><code>rustfmt-preview</code> for automatic code formatting</a></h4>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.24-brightgreen.svg" alt="Minimum Rust version: 1.24" /></p>
<p>If you'd like to have your code automatically formatted, you can
install this component:</p>
<pre><code class="language-console">$ rustup component add rustfmt-preview
</code></pre>
<p>This will install two tools, <code>rustfmt</code> and <code>cargo-fmt</code>, that will reformat your
code for you! For example:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>will reformat your entire Cargo project.</p>
<h4><a class="header" href="#rls-preview-for-ide-integration" id="rls-preview-for-ide-integration"><code>rls-preview</code> for IDE integration</a></h4>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>Many IDE features are built off of the <a href="http://langserver.org/"><code>langserver</code>
protocol</a>. To gain support for Rust with these IDEs,
you'll need to install the Rust language sever, aka the &quot;RLS&quot;:</p>
<pre><code class="language-console">$ rustup component add rls-preview
</code></pre>
<p>Your IDE should take it from there.</p>
<h4><a class="header" href="#clippy-preview-for-more-lints" id="clippy-preview-for-more-lints"><code>clippy-preview</code> for more lints</a></h4>
<p>For even more lints to help you write Rust code, you can install <code>clippy</code>:</p>
<pre><code class="language-console">$ rustup component add clippy-preview
</code></pre>
<p>This will install <code>cargo-clippy</code> for you:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>For more, check out <a href="https://github.com/rust-lang-nursery/rust-clippy">clippy's
documentation</a>.</p>
<h4><a class="header" href="#llvm-tools-preview-for-using-extra-llvm-tools" id="llvm-tools-preview-for-using-extra-llvm-tools"><code>llvm-tools-preview</code> for using extra LLVM tools</a></h4>
<p>If you'd like to use the <code>lld</code> linker, or other tools like <code>llvm-objdump</code> or
<code>llvm-objcopy</code>, you can install this component:</p>
<pre><code class="language-console">$ rustup component add llvm-tools-preview
</code></pre>
<p>This is the newest component, and so doesn't have good documentation at the
moment.</p>
<h1><a class="header" href="#cargo-and-cratesio" id="cargo-and-cratesio">Cargo and crates.io</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to <code>cargo</code> and <a href="https://crates.io">crates.io</a>.
A notable addition here is the new <a href="rustdoc-2018/cargo-and-crates-io/cargo-check-for-faster-checking.html"><code>cargo check</code></a> command.</p>
<h1><a class="header" href="#cargo-check-for-faster-checking" id="cargo-check-for-faster-checking"><code>cargo check</code> for faster checking</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.16-brightgreen.svg" alt="Minimum Rust version: 1.16" /></p>
<p><code>cargo check</code> is a new subcommand that should speed up the development
workflow in many cases.</p>
<p>What does it do? Let's take a step back and talk about how <code>rustc</code> compiles
your code. Compilation has many &quot;passes&quot;, that is, there are many distinct
steps that the compiler takes on the road from your source code to producing
the final binary. However, you can think of this process in two big steps:
first, <code>rustc</code> does all of its safety checks, makes sure your syntax is
correct, all that stuff. Second, once it's satisfied that everything is in
order, it produces the actual binary code that you end up executing.</p>
<p>It turns out that that second step takes a lot of time. And most of the time,
it's not neccesary. That is, when you're working on some Rust code, many
developers will get into a workflow like this:</p>
<ol>
<li>Write some code.</li>
<li>Run <code>cargo build</code> to make sure it compiles.</li>
<li>Repeat 1-2 as needed.</li>
<li>Run <code>cargo test</code> to make sure your tests pass.</li>
<li>Try the binary yourself</li>
<li>GOTO 1.</li>
</ol>
<p>In step two, you never actually run your code. You're looking for feedback
from the compiler, not to actually run the binary. <code>cargo check</code> supports
exactly this use-case: it runs all of the compiler's checks, but doesn't
produce the final binary. To use it:</p>
<pre><code class="language-console">$ cargo check
</code></pre>
<p>where you may normally <code>cargo build</code>. The workflow now looks like:</p>
<ol>
<li>Write some code.</li>
<li>Run <code>cargo check</code> to make sure it compiles.</li>
<li>Repeat 1-2 as needed.</li>
<li>Run <code>cargo test</code> to make sure your tests pass.</li>
<li>Run <code>cargo build</code> to build a binary and try it yourself</li>
<li>GOTO 1.</li>
</ol>
<p>So how much speedup do you actually get? Like most performance related
questions, the answer is &quot;it depends.&quot; Here are some very un-scientific
benchmarks at the time of writing.</p>
<table><thead><tr><th>build</th><th>performance</th><th>check performance</th><th>speedup</th></tr></thead><tbody>
<tr><td>initial compile</td><td>11s</td><td>5.6s</td><td>1.96x</td></tr>
<tr><td>second compile (no changes)</td><td>3s</td><td>1.9s</td><td>1.57x</td></tr>
<tr><td>third compile with small change</td><td>5.8s</td><td>3s</td><td>1.93x</td></tr>
</tbody></table>
<h1><a class="header" href="#cargo-install-for-easy-installation-of-tools" id="cargo-install-for-easy-installation-of-tools"><code>cargo install</code> for easy installation of tools</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.5-brightgreen.svg" alt="Minimum Rust version: 1.5" /></p>
<p>Cargo has grown a new <code>install</code> command. This is intended to be used for installing
new subcommands for Cargo, or tools for Rust developers. This doesn't replace the need
to build real, native packages for end-users on the platforms you support.</p>
<p>For example, this guide is created with <a href="https://crates.io/crates/mdbook"><code>mdbook</code></a>. You
can install it on your system with</p>
<pre><code class="language-console">$ cargo install mdbook
</code></pre>
<p>And then use it with</p>
<pre><code class="language-console">$ mdbook --help
</code></pre>
<p>As an example of extending Cargo, you can use the <a href="https://crates.io/crates/cargo-update"><code>cargo-update</code></a>
package. To install it:</p>
<pre><code class="language-console">$ cargo install cargo-update
</code></pre>
<p>This will allow you to use this command, which checks everything you've <code>cargo install</code>'d and
updates it to the latest version:</p>
<pre><code class="language-console">$ cargo install-update -a
</code></pre>
<h1><a class="header" href="#cargo-new-defaults-to-a-binary-project" id="cargo-new-defaults-to-a-binary-project"><code>cargo new</code> defaults to a binary project</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p><code>cargo new</code> will now default to generating a binary, rather than a library.
We try to keep Cargo’s CLI quite stable, but this change is important, and is
unlikely to cause breakage.</p>
<p>For some background, <code>cargo new</code> accepts two flags: <code>--lib</code>, for creating
libraries, and <code>--bin</code>, for creating binaries, or executables. If you don’t
pass one of these flags, it used to default to <code>--lib</code>. At the time, we made
this decision because each binary (often) depends on many libraries, and so
we thought the library case would be more common. However, this is incorrect;
each library is depended upon by many binaries. Furthermore, when getting
started, what you often want is a program you can run and play around with.
It’s not just new Rustaceans though; even very long-time community members
have said that they find this default surprising. As such, we’ve changed it,
and it now defaults to <code>--bin</code>.</p>
<h1><a class="header" href="#cargo-rustc-for-passing-arbitrary-flags-to-rustc" id="cargo-rustc-for-passing-arbitrary-flags-to-rustc"><code>cargo rustc</code> for passing arbitrary flags to rustc</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.1-brightgreen.svg" alt="Minimum Rust version: 1.1" /></p>
<p><code>cargo rustc</code> is a new subcommand for Cargo that allows you to pass arbitrary
<code>rustc</code> flags through Cargo.</p>
<p>For example, Cargo does not have a way to pass unstable flags built-in. But
if we'd like to use <code>print-type-sizes</code> to see what layout information our
types have, we can run this:</p>
<pre><code class="language-console">$ cargo rustc -- -Z print-type-sizes
</code></pre>
<p>And we'll get a bunch of output describing the size of our types.</p>
<h2><a class="header" href="#note" id="note">Note</a></h2>
<p><code>cargo rustc</code> only passes these flags to invocations of your crate, and not to any <code>rustc</code>
invocations used to build dependencies. If you'd like to do that, see <code>$RUSTFLAGS</code>.</p>
<h1><a class="header" href="#cargo-workspaces-for-multi-package-projects" id="cargo-workspaces-for-multi-package-projects">Cargo workspaces for multi-package projects</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.12-brightgreen.svg" alt="Minimum Rust version: 1.12" /></p>
<p>Cargo used to have two levels of organization:</p>
<ul>
<li>A <em>package</em> contains one or more crates</li>
<li>A crate has one or more modules</li>
</ul>
<p>Cargo now has an additional level:</p>
<ul>
<li>A <em>workspace</em> contains one or more packages</li>
</ul>
<p>This can be useful for larger projects. For example, <a href="https://github.com/rust-lang-nursery/futures-rs">the <code>futures</code> package</a>
is a <em>workspace</em> that contains many related packages:</p>
<ul>
<li>futures</li>
<li>futures-util</li>
<li>futures-io</li>
<li>futures-channel</li>
</ul>
<p>and more.</p>
<p>Workspaces allow these packages to be developed individually, but they share
a single set of dependencies, and therefore have a single target directory
and a single <code>Cargo.lock</code>.</p>
<p>For more details about workspaces, please see <a href="https://doc.rust-lang.org/stable/cargo/reference/manifest.html#the-workspace-section">the Cargo documentation</a>.</p>
<h1><a class="header" href="#multi-file-examples" id="multi-file-examples">Multi-file examples</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.22-brightgreen.svg" alt="Minimum Rust version: 1.22" /></p>
<p>Cargo has an <code>examples</code> feature for showing people how to use your package.
By putting individual files inside of the top-level <code>examples</code> directory, you
can create multiple examples.</p>
<p>But what if your example is too big for a single file? Cargo supports adding
sub-directories inside of <code>examples</code>, and looks for a <code>main.rs</code> inside of
them to build the example. It looks like this:</p>
<pre><code class="language-text">my-package
 └──src
     └── lib.rs // code here
 └──examples 
     └── simple-example.rs // a single-file example
     └── complex-example
        └── helper.rs
        └── main.rs // a more complex example that also uses `helper` as a submodule
</code></pre>
<h1><a class="header" href="#replacing-dependencies-with-patch" id="replacing-dependencies-with-patch">Replacing dependencies with patch</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>The <code>[patch]</code> section of your <code>Cargo.toml</code> can be used when you want to
override certain parts of your dependency graph.</p>
<blockquote>
<p>Cargo has a <code>[replace]</code> feature that is similar; while we don't intend to deprecate
or remove <code>[replace]</code>, you should prefer <code>[patch]</code> in all circumstances.</p>
</blockquote>
<p>So what’s it look like? Let’s say we have a Cargo.toml that looks like this:</p>
<pre><code class="language-toml">[dependencies]
foo = &quot;1.2.3&quot;
</code></pre>
<p>In addition, our <code>foo</code> package depends on a <code>bar</code> crate, and we find a bug in <code>bar</code>.
To test this out, we’d download the source code for <code>bar</code>, and then update our
<code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
foo = &quot;1.2.3&quot;

[patch.crates-io]
bar = { path = '/path/to/bar' }
</code></pre>
<p>Now, when you <code>cargo build</code>, it will use the local version of <code>bar</code>, rather
than the one from crates.io that <code>foo</code> depends on. You can then try out your
changes, and fix that bug!</p>
<p>For more details, see <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-patch-section">the documentation for
<code>patch</code></a>.</p>
<h1><a class="header" href="#cargo-can-use-a-local-registry-replacement" id="cargo-can-use-a-local-registry-replacement">Cargo can use a local registry replacement</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.12-brightgreen.svg" alt="Minimum Rust version: 1.12" /></p>
<p>Cargo finds its packages in a &quot;source&quot;. The default source is <a href="https://crates.io">crates.io</a>. However, you
can choose a different source in your <code>.cargo/config</code>:</p>
<pre><code class="language-toml">[source.crates-io]
replace-with = 'my-awesome-registry'

[source.my-awesome-registry]
registry = 'https://github.com/my-awesome/registry-index'
</code></pre>
<p>This configuration means that instead of using crates.io, Cargo will query
the <code>my-awesome-registry</code> source instead (configured to a different index
here). This alternate source <em>must be the exact same</em> as the crates.io index.
Cargo assumes that replacement sources are exact 1:1 mirrors in this respect,
and the following support is designed around that assumption.</p>
<p>When generating a lock file for crate using a replacement registry, the
original registry will be encoded into the lock file. For example in the
configuration above, all lock files will still mention crates.io as the
registry that packages originated from. This semantically represents how
crates.io is the source of truth for all crates, and this is upheld because
all replacements have a 1:1 correspondance.</p>
<p>Overall, this means that no matter what replacement source you're working
with, you can ship your lock file to anyone else and you'll all still have
verifiably reproducible builds!</p>
<p>This has enabled tools like
<a href="https://github.com/alexcrichton/cargo-vendor"><code>cargo-vendor</code></a> and
<a href="https://github.com/alexcrichton/cargo-local-registry"><code>cargo-local-registry</code></a>,
which are often useful for &quot;offline builds.&quot; They prepare the list of all
Rust dependencies ahead of time, which lets you ship them to a build machine
with ease.</p>
<h1><a class="header" href="#cratesio-disallows-wildcard-dependencies" id="cratesio-disallows-wildcard-dependencies">Crates.io disallows wildcard dependencies</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.6-brightgreen.svg" alt="Minimum Rust version: 1.6" /></p>
<p>Crates.io will not allow you to upload a package with a wildcard dependency.
In other words, these:</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;*&quot;
</code></pre>
<p>A wildcard dependency means that you work with any possible version of your
dependency. This is highly unlikely to be true, and would cause unnecessary
breakage in the ecosystem.</p>
<p>Instead, depend on a version range. For example, <code>^</code> is the default, so
you could use</p>
<pre><code class="language-toml">[dependencies]
regex = &quot;1.0.0&quot;
</code></pre>
<p>instead. <code>&gt;</code>, <code>&lt;=</code>, and all of the other, non-<code>*</code> ranges work as well.</p>
<h1><a class="header" href="#documentation-1" id="documentation-1">Documentation</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to documentation.
A notable addition here is the <a href="rustdoc-2018/documentation/new-editions-of-the-book.html">second edition of &quot;the book&quot;</a>.</p>
<h1><a class="header" href="#new-editions-of-the-the-book" id="new-editions-of-the-the-book">New editions of the &quot;the book&quot;</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.26-brightgreen.svg" alt="Minimum Rust version: 1.26" /> for the final version of the second edition</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg" alt="Minimum Rust version: 1.31" /> for the 2018 edition</p>
<p>We've distributed a copy of &quot;The Rust Programming Language,&quot; affectionately
nicknamed &quot;the book&quot;, with every version of Rust since Rust 1.0.</p>
<p>However, because it was written before Rust 1.0, it started showing its age.
Many parts of the book are vague, because it was written before the true
details were nailed down for the 1.0 release. It didn't do a fantastic job of
teaching lifetimes.</p>
<p>Starting with Rust 1.18, we shipped drafts of a second edition of the book.
The final version was shipped with Rust 1.26. The second edition is a complete
re-write from the ground up, using the last two years of knowledge we’ve
gained from teaching people Rust.</p>
<p>You can purchase <a href="https://nostarch.com/Rust">a printed version of the second edition from No Starch
Press</a>. Now that the print version has shipped, the
second edition is frozen.</p>
<p>As of 1.31, the book has been completely updated for the 2018 Edition release.
It's still pretty close to the second edition, but contains information about
newer features since the book's content was frozen. Additionally, instead of
publishing separate editions of the book, only the latest version of the book
is published online. You’ll find brand-new explanations for a lot of Rust’s
core concepts, new projects to build, and all kinds of other good stuff.
Please <a href="https://doc.rust-lang.org/book/index.html">check it out</a> and let us
know what you think!</p>
<h1><a class="header" href="#the-rust-bookshelf" id="the-rust-bookshelf">The Rust Bookshelf</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-various-brightgreen.svg" alt="Minimum Rust version: various" />, each book is different.</p>
<p>As Rust's documentation has grown, we've gained far more than just &quot;The book&quot;
and the reference. We now have a collection of various long-form docs,
nicknamed &quot;the Rust Bookshelf.&quot; Different resources are added at various
times, and we're adding new ones as more get written.</p>
<h2><a class="header" href="#the-cargo-book" id="the-cargo-book">The Cargo book</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>Historically, Cargo’s docs were hosted on <a href="http://doc.crates.io">http://doc.crates.io</a>, which
doesn’t follow the release train model, even though Cargo itself does. This
led to situations where a feature would land in Cargo nightly, the docs would
be updated, and then for up to twelve weeks, users would think that it should
work, but it wouldn’t yet. <a href="https://doc.rust-lang.org/cargo">https://doc.rust-lang.org/cargo</a> is the new home
of Cargo’s docs, and <a href="http://doc.crates.io">http://doc.crates.io</a> now redirects there.</p>
<h2><a class="header" href="#the-rustdoc-book" id="the-rustdoc-book">The <code>rustdoc</code> book</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>Rustdoc, our documentation tool, now has a guide at <a href="https://doc.rust-lang.org/rustdoc">https://doc.rust-lang.org/rustdoc</a>.</p>
<h2><a class="header" href="#rust-by-example-1" id="rust-by-example-1">Rust By Example</a></h2>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /></p>
<p>Rust by Example used to live at <a href="https://rustbyexample.com">https://rustbyexample.com</a>, but now is part of the Bookshelf!
It can be found at <a href="https://doc.rust-lang.org/rust-by-example/">https://doc.rust-lang.org/rust-by-example/</a>. RBE lets you learn Rust through
short code examples and exercises, as opposed to the lengthy prose of The Book.</p>
<h1><a class="header" href="#the-rustonomicon" id="the-rustonomicon">The Rustonomicon</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.3-brightgreen.svg" alt="Minimum Rust version: 1.3" /></p>
<p>We now have a draft book, <a href="https://doc.rust-lang.org/stable/nomicon/">The Rustonomicon: the Dark Arts of Advanced and
Unsafe Rust Programming</a>.</p>
<p>From the title, I'm sure you can guess: this book discusses some advanced
topics, including <code>unsafe</code>. It's a must-read for anyone who's working at the
lowest levels with Rust.</p>
<h1><a class="header" href="#stdos-has-documentation-for-all-platforms" id="stdos-has-documentation-for-all-platforms"><code>std::os</code> has documentation for all platforms</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.21-brightgreen.svg" alt="Minimum Rust version: 1.21" /></p>
<p>The <code>std::os</code> module contains operating system specific functionality. You’ll
now see more than just linux, the platform we build the documentation on.</p>
<p>We’ve long regretted that the hosted version of the documentation has been
Linux-specific; this is a first step towards rectifying that. This is
specific to the standard library and not for general use; we hope to improve
this further in the future.</p>
<h1><a class="header" href="#rustdoc" id="rustdoc"><code>rustdoc</code></a></h1>
<p>In this chapter of the guide, we discuss a few improvements to <code>rustdoc</code>.
A notable addition to it was <a href="rustdoc-2018/rustdoc/documentation-tests-can-now-compile-fail.html">that documentation tests can now compile-fail</a>.</p>
<h1><a class="header" href="#documentation-tests-can-now-compile-fail" id="documentation-tests-can-now-compile-fail">Documentation tests can now compile-fail</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.22-brightgreen.svg" alt="Minimum Rust version: 1.22" /></p>
<p>You can now create <code>compile-fail</code> tests in Rustdoc, like this:</p>
<pre><code>/// ```compile_fail
/// let x = 5;
/// x += 2; // shouldn't compile!
/// ```
# fn foo() {}
</code></pre>
<p>Please note that these kinds of tests can be more fragile than others, as
additions to Rust may cause code to compile when it previously would not.
Consider the first release with <code>?</code>, for example: code using <code>?</code> would fail
to compile on Rust 1.21, but compile successfully on Rust 1.22, causing your
test suite to start failing.</p>
<h1><a class="header" href="#rustdoc-uses-commonmark" id="rustdoc-uses-commonmark">Rustdoc uses CommonMark</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.25-brightgreen.svg" alt="Minimum Rust version: 1.25" /> for support by default</p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.23-red.svg" alt="Minimum Rust version: 1.23" /> for support via a flag</p>
<p>Rustdoc lets you write documentation comments in Markdown. At Rust 1.0, we
were using the <code>hoedown</code> markdown implementation, written in C. Markdown is
more of a family of implementations of an idea, and so <code>hoedown</code> had its own
dialect, like many parsers. The <a href="https://commonmark.org/">CommonMark project</a>
has attempted to define a more strict version of Markdown, and so now, Rustdoc
uses it by default.</p>
<p>As of Rust 1.23, we still defaulted to <code>hoedown</code>, but you could enable
Commonmark via a flag, <code>--enable-commonmark</code>. Today, we only support
CommonMark.</p>
<h1><a class="header" href="#platform-and-target-support" id="platform-and-target-support">Platform and target support</a></h1>
<p>In this chapter of the guide, we discuss a few improvements to platform and target support.
A notable addition to it was <a href="rustdoc-2018/platform-and-target-support/libcore-for-low-level-rust.html">that the <code>libcore</code> library now works on stable Rust</a>.</p>
<h1><a class="header" href="#libcore-for-low-level-rust" id="libcore-for-low-level-rust">libcore for low-level Rust</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.6-brightgreen.svg" alt="Minimum Rust version: 1.6" /></p>
<p>Rust’s standard library is two-tiered: there’s a small core library,
<code>libcore</code>, and the full standard library, <code>libstd</code>, that builds on top of it.
<code>libcore</code> is completely platform agnostic, and requires only a handful of
external symbols to be defined. Rust’s <code>libstd</code> builds on top of <code>libcore</code>,
adding support for things like memory allocation and I/O. Applications using
Rust in the embedded space, as well as those writing operating systems, often
eschew <code>libstd</code>, using only <code>libcore</code>.</p>
<p>As an additional note, while building <em>libraries</em> with <code>libcore</code> is supported
today, building full applications is not yet stable.</p>
<p>To use <code>libcore</code>, add this flag to your crate root:</p>
<pre><code class="language-rust ignore">#![no_std]
</code></pre>
<p>This will remove the standard library, and bring the <code>core</code> crate into your
namespace for use:</p>
<pre><code class="language-rust ignore">#![no_std]

use core::cell::Cell;
</code></pre>
<p>You can find <code>libcore</code>'s documentation <a href="https://doc.rust-lang.org/core/">here</a>.</p>
<h1><a class="header" href="#webassembly-support" id="webassembly-support">WebAssembly support</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.14-brightgreen.svg" alt="Minimum Rust version: 1.14" /> for <code>emscripten</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-nightly-red.svg" alt="Minimum Rust version: nightly" /> for <code>wasm32-unknown-unknown</code></p>
<p>Rust has gained support for <a href="https://webassembly.org/">WebAssembly</a>, meaning
that you can run Rust code in your browser, client-side.</p>
<p>In Rust 1.14, we gained support through
<a href="http://kripken.github.io/emscripten-site/index.html">emscripten</a>. With it
installed, you can write Rust code and have it produce
<a href="http://asmjs.org/">asm.js</a> (the precusor to wasm) and/or WebAssembly.</p>
<p>Here's an example of using this support:</p>
<pre><code class="language-console">$ rustup target add wasm32-unknown-emscripten
$ echo 'fn main() { println!(&quot;Hello, Emscripten!&quot;); }' &gt; hello.rs
$ rustc --target=wasm32-unknown-emscripten hello.rs
$ node hello.js
</code></pre>
<p>However, in the meantime, Rust has also grown its own support, independent
from Emscripten. This is known as &quot;the unknown target&quot;, because instead of
<code>wasm32-unknown-emscripten</code>, it's <code>wasm32-unknown-unknown</code>. This will be
the preferred target to use once it's ready, but for now, it's really
only well-supported in nightly.</p>
<h1><a class="header" href="#global-allocators" id="global-allocators">Global allocators</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.28-brightgreen.svg" alt="Minimum Rust version: 1.28" /></p>
<p>Allocators are the way that programs in Rust obtain memory from the system at
runtime. Previously, Rust did not allow changing the way memory is obtained,
which prevented some use cases. On some platforms, this meant using jemalloc,
on others, the system allocator, but there was no way for users to control
this key component. With 1.28.0, the <code>#[global_allocator]</code> attribute is now
stable, which allows Rust programs to set their allocator to the system
allocator, as well as define new allocators by implementing the <code>GlobalAlloc</code>
trait.</p>
<p>The default allocator for Rust programs on some platforms is jemalloc. The
standard library now provides a handle to the system allocator, which can be
used to switch to the system allocator when desired, by declaring a static
and marking it with the <code>#[global_allocator]</code> attribute.</p>
<pre><pre class="playpen"><code class="language-rust">use std::alloc::System;

#[global_allocator]
static GLOBAL: System = System;

fn main() {
    let mut v = Vec::new();
    // This will allocate memory using the system allocator.
    v.push(1);
}
</code></pre></pre>
<p>However, sometimes you want to define a custom allocator for a given
application domain. This is also relatively easy to do by implementing the
<code>GlobalAlloc</code> trait. You can read more about how to do this in <a href="https://doc.rust-lang.org/std/alloc/trait.GlobalAlloc.html">the
documentation</a>.</p>
<h1><a class="header" href="#msvc-toolchain-support" id="msvc-toolchain-support">MSVC toolchain support</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.2-brightgreen.svg" alt="Minimum Rust version: 1.2" /></p>
<p>At the release of Rust 1.0, we only supported the GNU toolchain on Windows. With the
release of Rust 1.2, we introduced initial support for the MSVC toolchain. After that,
as support matured, we eventually made it the default choice for Windows users.</p>
<p>The difference between the two matters for interacting with C. If you're using a library
built with one toolchain or another, you need to match that with the appropriate Rust
toolchain. If you're not sure, go with MSVC; it's the default for good reason.</p>
<p>To use this feature, simply use Rust on Windows, and the installer will default to it.
If you'd prefer to switch to the GNU toolchain, you can install it with Rustup:</p>
<pre><code class="language-console">$ rustup toolchain install stable-x86_64-pc-windows-gnu
</code></pre>
<h1><a class="header" href="#musl-support-for-fully-static-binaries" id="musl-support-for-fully-static-binaries">MUSL support for fully static binaries</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.1-brightgreen.svg" alt="Minimum Rust version: 1.1" /></p>
<p>By default, Rust will statically link all Rust code. However, if you use the
standard library, it will dynamically link to the system's <code>libc</code>
implementation.</p>
<p>If you'd like a 100% static binary, the <a href="https://www.musl-libc.org/"><code>MUSL libc</code></a> can be used on Linux.</p>
<h2><a class="header" href="#installing-musl-support" id="installing-musl-support">Installing MUSL support</a></h2>
<p>To add support for MUSL, you need to choose the correct target. <a href="https://forge.rust-lang.org/platform-support.html">The forge
has a full list of
targets</a> supported,
with a number of ones using <code>musl</code>.</p>
<p>If you're not sure what you want, it's probably <code>x86_64-unknown-linux-musl</code>,
for 64-bit Linux. We'll be using this target in this guide, but the
instructions remain the same for other targets, just change the name wherever
we mention the target.</p>
<p>To get support for this target, you use <code>rustup</code>:</p>
<pre><code class="language-console">$ rustup target add x86_64-unknown-linux-musl
</code></pre>
<p>This will install support for the default toolchain; to install for other toolchains,
add the <code>--toolchain</code> flag. For example:</p>
<pre><code class="language-console">$ rustup target add x86_64-unknown-linux-musl --toolchain=nightly
</code></pre>
<h2><a class="header" href="#building-with-musl" id="building-with-musl">Building with MUSL</a></h2>
<p>To use this new target, pass the <code>--target</code> flag to Cargo:</p>
<pre><code class="language-console">$ cargo build --target x86_64-unknown-linux-musl
</code></pre>
<p>The binary produced will now be built with MUSL!</p>
<h1><a class="header" href="#cdylib-crates-for-c-interoperability" id="cdylib-crates-for-c-interoperability">cdylib crates for C interoperability</a></h1>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.10-brightgreen.svg" alt="Minimum Rust version: 1.10" /> for <code>rustc</code></p>
<p><img src="https://img.shields.io/badge/Minimum%20Rust%20Version-1.11-brightgreen.svg" alt="Minimum Rust version: 1.11" /> for <code>cargo</code></p>
<p>If you're producing a library that you intend to be used from C (or another
language through a C FFI), there's no need for Rust to include Rust-specific
stuff in the final object code. For libraries like that, you'll want to use
the <code>cdylib</code> crate type in your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[lib]
crate-type = [&quot;cdylib&quot;]
</code></pre>
<p>This will produce a smaller binary, with no Rust-specific information inside
of it.</p>
<h1><a class="header" href="#about-this-guide" id="about-this-guide">About this guide</a></h1>
<p>This guide is meant to help document how rustc – the Rust compiler –
works, as well as to help new contributors get involved in rustc
development. It is not meant to replace code documentation – each
chapter gives only high-level details – the kinds of things that
(ideally) don't change frequently.</p>
<p>There are three parts to this guide. Part 1 contains information that should
be useful no matter how you are contributing. Part 2 contains information
about how the compiler works. Finally, there are some appendices at the
end with useful reference information.</p>
<p>The guide itself is of course open-source as well, and the sources can
be found at the <a href="https://github.com/rust-lang/rustc-guide/">GitHub repository</a>. If you find any mistakes in the
guide, please file an issue about it, or even better, open a PR
with a correction!</p>
<h2><a class="header" href="#other-places-to-find-information" id="other-places-to-find-information">Other places to find information</a></h2>
<p>You might also find the following sites useful:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/">Rustc API docs</a> -- rustdoc documentation for the compiler</li>
<li><a href="https://forge.rust-lang.org/">Forge</a> -- contains documentation about rust infrastructure, team procedures, and more</li>
<li><a href="https://github.com/rust-lang/compiler-team/">compiler-team</a> -- the home-base for the rust compiler team, with description
of the team procedures, active working groups, and the team calendar.</li>
</ul>
<h1><a class="header" href="#part-1-building-debugging-and-contributing-to-rustc" id="part-1-building-debugging-and-contributing-to-rustc">Part 1: Building, debugging, and contributing to Rustc</a></h1>
<p>This section of the rustc-guide contains knowledge that should be useful to you
regardless of what part of the compiler you are working on. This includes both
technical info and tips (e.g. how to compile and debug the compiler) and info
about processes in the Rust project (e.g. stabilization and info about the
compiler team).</p>
<h1><a class="header" href="#about-the-compiler-team" id="about-the-compiler-team">About the compiler team</a></h1>
<p>rustc is maintained by the <a href="https://www.rust-lang.org/governance/teams/language-and-compiler">Rust compiler team</a>. The people who belong to
this team collectively work to track regressions and implement new features.
Members of the Rust compiler team are people who have made significant
contributions to rustc and its design.</p>
<h2><a class="header" href="#discussion" id="discussion">Discussion</a></h2>
<p>Currently the compiler team chats in 2 places:</p>
<ul>
<li>The <code>t-compiler</code> stream on <a href="https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler">the Zulip instance</a></li>
<li>The <code>compiler</code> channel on the <a href="https://discord.gg/rust-lang">rust-lang discord</a></li>
</ul>
<h2><a class="header" href="#expert-map" id="expert-map">Expert map</a></h2>
<p>If you're interested in figuring out who can answer questions about a
particular part of the compiler, or you'd just like to know who works on what,
check out our <a href="https://github.com/rust-lang/compiler-team/blob/master/experts/MAP.md">experts directory</a>.
It contains a listing of the various parts of the compiler and a list of people
who are experts on each one.</p>
<h2><a class="header" href="#rust-compiler-meeting" id="rust-compiler-meeting">Rust compiler meeting</a></h2>
<p>The compiler team has a weekly meeting where we do triage and try to
generally stay on top of new bugs, regressions, and other things. This
general plan for this meeting can be found in
<a href="https://public.etherpad-mozilla.org/p/rust-compiler-meeting">the rust-compiler-meeting etherpad</a>. It works roughly as
follows:</p>
<ul>
<li><strong>Review P-high bugs:</strong> P-high bugs are those that are sufficiently
important for us to actively track progress. P-high bugs should
ideally always have an assignee.</li>
<li><strong>Look over new regressions:</strong> we then look for new cases where the
compiler broke previously working code in the wild. Regressions are
almost always marked as P-high; the major exception would be bug
fixes (though even there we often
<a href="https://forge.rust-lang.org/rustc-bug-fix-procedure.html">aim to give warnings first</a>).</li>
<li><strong>Check I-nominated issues:</strong> These are issues where feedback from
the team is desired.</li>
<li><strong>Check for beta nominations:</strong> These are nominations of things to
backport to beta.</li>
</ul>
<p>The meeting currently takes place on Thursdays at 10am Boston time
(UTC-4 typically, but daylight savings time sometimes makes things
complicated).</p>
<p>The meeting is held over a &quot;chat medium&quot;, currently on <a href="https://rust-lang.zulipchat.com/#narrow/stream/131828-t-compiler">zulip</a>.</p>
<h2><a class="header" href="#team-membership" id="team-membership">Team membership</a></h2>
<p>Membership in the Rust team is typically offered when someone has been
making significant contributions to the compiler for some
time. Membership is both a recognition but also an obligation:
compiler team members are generally expected to help with upkeep as
well as doing reviews and other work.</p>
<p>If you are interested in becoming a compiler team member, the first
thing to do is to start fixing some bugs, or get involved in a working
group. One good way to find bugs is to look for
<a href="https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-easy">open issues tagged with E-easy</a>
or
<a href="https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AE-mentor">E-mentor</a>.</p>
<h3><a class="header" href="#r-rights" id="r-rights">r+ rights</a></h3>
<p>Once you have made a number of individual PRs to rustc, we will often
offer r+ privileges. This means that you have the right to instruct
&quot;bors&quot; (the robot that manages which PRs get landed into rustc) to
merge a PR
(<a href="https://buildbot2.rust-lang.org/homu/">here are some instructions for how to talk to bors</a>).</p>
<p>The guidelines for reviewers are as follows:</p>
<ul>
<li>You are always welcome to review any PR, regardless of who it is
assigned to.  However, do not r+ PRs unless:
<ul>
<li>You are confident in that part of the code.</li>
<li>You are confident that nobody else wants to review it first.
<ul>
<li>For example, sometimes people will express a desire to review a
PR before it lands, perhaps because it touches a particularly
sensitive part of the code.</li>
</ul>
</li>
</ul>
</li>
<li>Always be polite when reviewing: you are a representative of the
Rust project, so it is expected that you will go above and beyond
when it comes to the <a href="https://www.rust-lang.org/policies/code-of-conduct">Code of Conduct</a>.</li>
</ul>
<h3><a class="header" href="#high-five" id="high-five">high-five</a></h3>
<p>Once you have r+ rights, you can also be added to the <a href="https://github.com/rust-highfive">high-five</a>
rotation. high-five is the bot that assigns incoming PRs to
reviewers. If you are added, you will be randomly selected to review
PRs. If you find you are assigned a PR that you don't feel comfortable
reviewing, you can also leave a comment like <code>r? @so-and-so</code> to assign
to someone else — if you don't know who to request, just write <code>r? @nikomatsakis for reassignment</code> and @nikomatsakis will pick someone
for you.</p>
<p>Getting on the high-five list is much appreciated as it lowers the
review burden for all of us! However, if you don't have time to give
people timely feedback on their PRs, it may be better that you don't
get on the list.</p>
<h3><a class="header" href="#full-team-membership" id="full-team-membership">Full team membership</a></h3>
<p>Full team membership is typically extended once someone made many
contributions to the Rust compiler over time, ideally (but not
necessarily) to multiple areas. Sometimes this might be implementing a
new feature, but it is also important — perhaps more important! — to
have time and willingness to help out with general upkeep such as
bugfixes, tracking regressions, and other less glamorous work.</p>
<h1><a class="header" href="#how-to-build-and-run-the-compiler" id="how-to-build-and-run-the-compiler">How to Build and Run the Compiler</a></h1>
<p>The compiler is built using a tool called <code>x.py</code>. You will need to
have Python installed to run it. But before we get to that, if you're going to
be hacking on <code>rustc</code>, you'll want to tweak the configuration of the compiler.
The default configuration is oriented towards running the compiler as a user,
not a developer.</p>
<h3><a class="header" href="#create-a-configtoml" id="create-a-configtoml">Create a config.toml</a></h3>
<p>To start, copy <a href="https://github.com/rust-lang/rust/blob/master/config.toml.example"><code>config.toml.example</code></a> to <code>config.toml</code>:</p>
<pre><code class="language-bash">&gt; cd $RUST_CHECKOUT
&gt; cp config.toml.example config.toml
</code></pre>
<p>Then you will want to open up the file and change the following
settings (and possibly others, such as <code>llvm.ccache</code>):</p>
<pre><code class="language-toml">[llvm]
# Enables LLVM assertions, which will check that the LLVM bitcode generated
# by the compiler is internally consistent. These are particularly helpful
# if you edit `codegen`.
assertions = true

[rust]
# This will make your build more parallel; it costs a bit of runtime
# performance perhaps (less inlining) but it's worth it.
codegen-units = 0

# This enables full debuginfo and debug assertions. The line debuginfo is also
# enabled by `debuginfo-level = 1`. Full debuginfo is also enabled by
# `debuginfo-level = 2`. Debug assertions can also be enabled with
# `debug-assertions = true`. Note that `debug = true` will make your build
# slower, so you may want to try individually enabling debuginfo and assertions
# or enable only line debuginfo which is basically free.
debug = true
</code></pre>
<p>If you have already built <code>rustc</code>, then you may have to execute <code>rm -rf build</code> for subsequent
configuration changes to take effect. Note that <code>./x.py clean</code> will not cause a
rebuild of LLVM, so if your configuration change affects LLVM, you will need to
manually <code>rm -rf build/</code> before rebuilding.</p>
<h3><a class="header" href="#what-is-xpy" id="what-is-xpy">What is <code>x.py</code>?</a></h3>
<p><code>x.py</code> is the script used to orchestrate the tooling in the <code>rustc</code> repository.
It is the script that can build docs, run tests, and compile <code>rustc</code>.
It is the now preferred way to build <code>rustc</code> and it replaces the old makefiles
from before. Below are the different ways to utilize <code>x.py</code> in order to
effectively deal with the repo for various common tasks.</p>
<h3><a class="header" href="#running-xpy-and-building-a-stage1-compiler" id="running-xpy-and-building-a-stage1-compiler">Running <code>x.py</code> and building a stage1 compiler</a></h3>
<p>One thing to keep in mind is that <code>rustc</code> is a <em>bootstrapping</em>
compiler. That is, since <code>rustc</code> is written in Rust, we need to use an
older version of the compiler to compile the newer version. In
particular, the newer version of the compiler and some of the artifacts needed
to build it, such as <code>libstd</code> and other tooling, may use some unstable features
internally, requiring a specific version which understands these unstable
features.</p>
<p>The result is that compiling <code>rustc</code> is done in stages:</p>
<ul>
<li><strong>Stage 0:</strong> the stage0 compiler is usually (you can configure <code>x.py</code> to use
something else) the current <em>beta</em> <code>rustc</code> compiler and its associated dynamic
libraries (which <code>x.py</code> will download for you). This stage0 compiler is then
used only to compile <code>rustbuild</code>, <code>std</code>, <code>test</code>, and <code>rustc</code>. When compiling
<code>test</code> and <code>rustc</code>, this stage0 compiler uses the freshly compiled <code>std</code>.
There are two concepts at play here: a compiler (with its set of dependencies)
and its 'target' or 'object' libraries (<code>std</code>, <code>test</code>, and <code>rustc</code>).
Both are staged, but in a staggered manner.</li>
<li><strong>Stage 1:</strong> the code in your clone (for new version) is then
compiled with the stage0 compiler to produce the stage1 compiler.
However, it was built with an older compiler (stage0), so to
optimize the stage1 compiler we go to next the stage.
<ul>
<li>In theory, the stage1 compiler is functionally identical to the
stage2 compiler, but in practice there are subtle differences. In
particular, the stage1 compiler itself was built by stage0 and
hence not by the source in your working directory: this means that
the symbol names used in the compiler source may not match the
symbol names that would have been made by the stage1 compiler.
This can be important when using dynamic linking (e.g., with
derives. Sometimes this means that some tests don't work when run
with stage1.</li>
</ul>
</li>
<li><strong>Stage 2:</strong> we rebuild our stage1 compiler with itself to produce
the stage2 compiler (i.e. it builds itself) to have all the <em>latest
optimizations</em>. (By default, we copy the stage1 libraries for use by
the stage2 compiler, since they ought to be identical.)</li>
<li><em>(Optional)</em> <strong>Stage 3</strong>: to sanity check our new compiler, we
can build the libraries with the stage2 compiler. The result ought
to be identical to before, unless something has broken.</li>
</ul>
<h4><a class="header" href="#a-note-on-stage-meanings" id="a-note-on-stage-meanings">A note on stage meanings</a></h4>
<p>When running <code>x.py</code> you will see output such as:</p>
<pre><code class="language-txt">Building stage0 std artifacts
Copying stage0 std from stage0
Building stage0 test artifacts
Copying stage0 test from stage0
Building stage0 compiler artifacts
Copying stage0 rustc from stage0
Building LLVM for x86_64-apple-darwin
Building stage0 codegen artifacts
Assembling stage1 compiler
Building stage1 std artifacts
Copying stage1 std from stage1
Building stage1 test artifacts
Copying stage1 test from stage1
Building stage1 compiler artifacts
Copying stage1 rustc from stage1
Building stage1 codegen artifacts
Assembling stage2 compiler
Uplifting stage1 std
Copying stage2 std from stage1
Generating unstable book md files
Building stage0 tool unstable-book-gen
Building stage0 tool rustbook
Documenting standalone
Building rustdoc for stage2
Documenting book redirect pages
Documenting stage2 std
Building rustdoc for stage1
Documenting stage2 test
Documenting stage2 whitelisted compiler
Documenting stage2 compiler
Documenting stage2 rustdoc
Documenting error index
Uplifting stage1 test
Copying stage2 test from stage1
Uplifting stage1 rustc
Copying stage2 rustc from stage1
Building stage2 tool error_index_generator
</code></pre>
<p>A deeper look into <code>x.py</code>'s phases can be seen here:</p>
<img alt="A diagram of the rustc compilation phases" src="rustc-guide/img/rustc_stages.svg" class="center" />
<p>Keep in mind this diagram is a simplification, i.e. <code>rustdoc</code> can be built at
different stages, the process is a bit different when passing flags such as
<code>--keep-stage</code>, or if there are non-host targets.</p>
<p>The following tables indicate the outputs of various stage actions:</p>
<table><thead><tr><th>Stage 0 Action</th><th>Output</th></tr></thead><tbody>
<tr><td><code>beta</code> extracted</td><td><code>build/HOST/stage0</code></td></tr>
<tr><td><code>stage0</code> builds <code>bootstrap</code></td><td><code>build/bootstrap</code></td></tr>
<tr><td><code>stage0</code> builds <code>libstd</code></td><td><code>build/HOST/stage0-std/TARGET</code></td></tr>
<tr><td>copy <code>stage0-std</code> (HOST only)</td><td><code>build/HOST/stage0-sysroot/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage0</code> builds <code>libtest</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-test/TARGET</code></td></tr>
<tr><td>copy <code>stage0-test</code> (HOST only)</td><td><code>build/HOST/stage0-sysroot/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage0</code> builds <code>rustc</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-rustc/HOST</code></td></tr>
<tr><td>copy <code>stage0-rustc (except executable)</code></td><td><code>build/HOST/stage0-sysroot/lib/rustlib/HOST</code></td></tr>
<tr><td>build <code>llvm</code></td><td><code>build/HOST/llvm</code></td></tr>
<tr><td><code>stage0</code> builds <code>codegen</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-codgen/HOST</code></td></tr>
<tr><td><code>stage0</code> builds <code>rustdoc</code> with <code>stage0-sysroot</code></td><td><code>build/HOST/stage0-tools/HOST</code></td></tr>
</tbody></table>
<p><code>--stage=0</code> stops here.</p>
<table><thead><tr><th>Stage 1 Action</th><th>Output</th></tr></thead><tbody>
<tr><td>copy (uplift) <code>stage0-rustc</code> executable to <code>stage1</code></td><td><code>build/HOST/stage1/bin</code></td></tr>
<tr><td>copy (uplift) <code>stage0-codegen</code> to <code>stage1</code></td><td><code>build/HOST/stage1/lib</code></td></tr>
<tr><td>copy (uplift) <code>stage0-sysroot</code> to <code>stage1</code></td><td><code>build/HOST/stage1/lib</code></td></tr>
<tr><td><code>stage1</code> builds <code>libstd</code></td><td><code>build/HOST/stage1-std/TARGET</code></td></tr>
<tr><td>copy <code>stage1-std</code> (HOST only)</td><td><code>build/HOST/stage1/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage1</code> builds <code>libtest</code></td><td><code>build/HOST/stage1-test/TARGET</code></td></tr>
<tr><td>copy <code>stage1-test</code> (HOST only)</td><td><code>build/HOST/stage1/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage1</code> builds <code>rustc</code></td><td><code>build/HOST/stage1-rustc/HOST</code></td></tr>
<tr><td>copy <code>stage1-rustc</code> (except executable)</td><td><code>build/HOST/stage1/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage1</code> builds <code>codegen</code></td><td><code>build/HOST/stage1-codegen/HOST</code></td></tr>
</tbody></table>
<p><code>--stage=1</code> stops here.</p>
<table><thead><tr><th>Stage 2 Action</th><th>Output</th></tr></thead><tbody>
<tr><td>copy (uplift) <code>stage1-rustc</code> executable</td><td><code>build/HOST/stage2/bin</code></td></tr>
<tr><td>copy (uplift) <code>stage1-sysroot</code></td><td><code>build/HOST/stage2/lib and build/HOST/stage2/lib/rustlib/HOST</code></td></tr>
<tr><td><code>stage2</code> builds <code>libstd</code> (except HOST?)</td><td><code>build/HOST/stage2-std/TARGET</code></td></tr>
<tr><td>copy <code>stage2-std</code> (not HOST targets)</td><td><code>build/HOST/stage2/lib/rustlib/TARGET</code></td></tr>
<tr><td><code>stage2</code> builds <code>libtest</code> (except HOST?)</td><td><code>build/HOST/stage2-test/TARGET</code></td></tr>
<tr><td>copy <code>stage2-test</code> (not HOST targets)</td><td><code>build/HOST/stage2/lib/rustlib/TARGET</code></td></tr>
<tr><td><code>stage2</code> builds <code>rustdoc</code></td><td><code>build/HOST/stage2-tools/HOST</code></td></tr>
<tr><td>copy <code>rustdoc</code></td><td><code>build/HOST/stage2/bin</code></td></tr>
</tbody></table>
<p><code>--stage=2</code> stops here.</p>
<p>Note that the convention <code>x.py</code> uses is that:</p>
<ul>
<li>A &quot;stage N artifact&quot; is an artifact that is <em>produced</em> by the stage N compiler.</li>
<li>The &quot;stage (N+1) compiler&quot; is assembled from &quot;stage N artifacts&quot;.</li>
<li>A <code>--stage N</code> flag means build <em>with</em> stage N.</li>
</ul>
<p>In short, <em>stage 0 uses the stage0 compiler to create stage0 artifacts which
will later be uplifted to stage1</em>.</p>
<p>Every time any of the main artifacts (<code>std</code>, <code>test</code>, <code>rustc</code>) are compiled, two
steps are performed.
When <code>std</code> is compiled by a stage N compiler, that <code>std</code> will be linked to
programs built by the stage N compiler (including test and <code>rustc</code> built later
on). It will also be used by the stage (N+1) compiler to link against itself.
This is somewhat intuitive if one thinks of the stage (N+1) compiler as &quot;just&quot;
another program we are building with the stage N compiler. In some ways, <code>rustc</code>
(the binary, not the <code>rustbuild</code> step) could be thought of as one of the few
<code>no_core</code> binaries out there.</p>
<p>So &quot;stage0 std artifacts&quot; are in fact the output of the downloaded stage0
compiler, and are going to be used for anything built by the stage0 compiler:
e.g. <code>rustc</code>, <code>test</code> artifacts. When it announces that it is &quot;building stage1
std artifacts&quot; it has moved on to the next bootstrapping phase. This pattern
continues in latter stages.</p>
<p>Also note that building host <code>std</code> and target <code>std</code> are different based on the
stage (e.g. see in the table how stage2 only builds non-host <code>std</code> targets.
This is because during stage2, the host <code>std</code> is uplifted from the &quot;stage 1&quot;
<code>std</code> -- specifically, when &quot;Building stage 1 artifacts&quot; is announced, it is
later copied into stage2 as well (both the compiler's <code>libdir</code> and the
<code>sysroot</code>).</p>
<p>This <code>std</code> is pretty much necessary for any useful work with the compiler.
Specifically, it's used as the <code>std</code> for programs compiled by the newly compiled
compiler (so when you compile <code>fn main() { }</code> it is linked to the last <code>std</code>
compiled with <code>x.py build --stage 1 src/libstd</code>).</p>
<p>The <code>rustc</code> generated by the stage0 compiler is linked to the freshly-built
<code>libstd</code>, which means that for the most part only <code>std</code> needs to be cfg-gated,
so that <code>rustc</code> can use featured added to std immediately after their addition,
without need for them to get into the downloaded beta. The <code>libstd</code> built by the
<code>stage1/bin/rustc</code> compiler, also known as &quot;stage1 std artifacts&quot;, is not
necessarily ABI-compatible with that compiler.
That is, the <code>rustc</code> binary most likely could not use this <code>std</code> itself.
It is however ABI-compatible with any programs that the <code>stage1/bin/rustc</code>
binary builds (including itself), so in that sense they're paired.</p>
<p>This is also where <code>--keep-stage 1 src/libstd</code> comes into play. Since most
changes to the compiler don't actually change the ABI, once you've produced a
<code>libstd</code> in stage 1, you can probably just reuse it with a different compiler.
If the ABI hasn't changed, you're good to go, no need to spend the time
recompiling that <code>std</code>.
<code>--keep-stage</code> simply assumes the previous compile is fine and copies those
artifacts into the appropriate place, skipping the cargo invocation.</p>
<p>The reason we first build <code>std</code>, then <code>test</code>, then <code>rustc</code>, is largely just
because we want to minimize <code>cfg(stage0)</code> in the code for <code>rustc</code>.
Currently <code>rustc</code> is always linked against a &quot;new&quot; <code>std</code>/<code>test</code> so it doesn't
ever need to be concerned with differences in std; it can assume that the std is
as fresh as possible.</p>
<p>The reason we need to build it twice is because of ABI compatibility.
The beta compiler has it's own ABI, and then the <code>stage1/bin/rustc</code> compiler
will produce programs/libraries with the new ABI.
We used to build three times, but because we assume that the ABI is constant
within a codebase, we presume that the libraries produced by the &quot;stage2&quot;
compiler (produced by the <code>stage1/bin/rustc</code> compiler) is ABI-compatible with
the <code>stage1/bin/rustc</code> compiler's produced libraries.
What this means is that we can skip that final compilation -- and simply use the
same libraries as the <code>stage2/bin/rustc</code> compiler uses itself for programs it
links against.</p>
<p>This <code>stage2/bin/rustc</code> compiler is shipped to end-users, along with the
<code>stage 1 {std,test,rustc}</code> artifacts.</p>
<p>If you want to learn more about <code>x.py</code>, read its README.md
<a href="https://github.com/rust-lang/rust/blob/master/src/bootstrap/README.md">here</a>.</p>
<h4><a class="header" href="#build-flags" id="build-flags">Build Flags</a></h4>
<p>There are other flags you can pass to the build command of <code>x.py</code> that can be
beneficial to cutting down compile times or fitting other things you might
need to change. They are:</p>
<pre><code class="language-txt">Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
</code></pre>
<p>For hacking, often building the stage 1 compiler is enough, but for
final testing and release, the stage 2 compiler is used.</p>
<p><code>./x.py check</code> is really fast to build the rust compiler.
It is, in particular, very useful when you're doing some kind of
&quot;type-based refactoring&quot;, like renaming a method, or changing the
signature of some function.</p>
<p><a name=command></a></p>
<p>Once you've created a config.toml, you are now ready to run
<code>x.py</code>. There are a lot of options here, but let's start with what is
probably the best &quot;go to&quot; command for building a local rust:</p>
<pre><code class="language-bash">&gt; ./x.py build -i --stage 1 src/libstd
</code></pre>
<p>This may <em>look</em> like it only builds libstd, but that is not the case.
What this command does is the following:</p>
<ul>
<li>Build <code>libstd</code> using the stage0 compiler (using incremental)</li>
<li>Build <code>librustc</code> using the stage0 compiler (using incremental)
<ul>
<li>This produces the stage1 compiler</li>
</ul>
</li>
<li>Build libstd using the stage1 compiler (cannot use incremental)</li>
</ul>
<p>This final product (stage1 compiler + libs built using that compiler)
is what you need to build other rust programs (unless you use <code>#![no_std]</code> or
<code>#![no_core]</code>).</p>
<p>The command includes the <code>-i</code> switch which enables incremental compilation.
This will be used to speed up the first two steps of the process:
in particular, if you make a small change, we ought to be able to use your old
results to make producing the stage1 <strong>compiler</strong> faster.</p>
<p>Unfortunately, incremental cannot be used to speed up making the
stage1 libraries.  This is because incremental only works when you run
the <em>same compiler</em> twice in a row.  In this case, we are building a
<em>new stage1 compiler</em> every time. Therefore, the old incremental
results may not apply. <strong>As a result, you will probably find that
building the stage1 <code>libstd</code> is a bottleneck for you</strong> -- but fear not,
there is a (hacky) workaround.  See <a href="rustc-guide/how-to-build-and-run.html#workflow">the section on &quot;recommended
workflows&quot;</a> below.</p>
<p>Note that this whole command just gives you a subset of the full <code>rustc</code>
build. The <strong>full</strong> <code>rustc</code> build (what you get if you just say <code>./x.py build</code>) has quite a few more steps:</p>
<ul>
<li>Build <code>librustc</code> and <code>rustc</code> with the stage1 compiler.
<ul>
<li>The resulting compiler here is called the &quot;stage2&quot; compiler.</li>
</ul>
</li>
<li>Build libstd with stage2 compiler.</li>
<li>Build librustdoc and a bunch of other things with the stage2 compiler.</li>
</ul>
<p><a name=toolchain></a></p>
<h3><a class="header" href="#build-specific-components" id="build-specific-components">Build specific components</a></h3>
<p>Build only the libcore library</p>
<pre><code class="language-bash">&gt; ./x.py build src/libcore
</code></pre>
<p>Build the libcore and libproc_macro library only</p>
<pre><code class="language-bash">&gt; ./x.py build src/libcore src/libproc_macro
</code></pre>
<p>Build only libcore up to Stage 1</p>
<pre><code class="language-bash">&gt; ./x.py build src/libcore --stage 1
</code></pre>
<p>Sometimes you might just want to test if the part you’re working on can
compile. Using these commands you can test that it compiles before doing
a bigger build to make sure it works with the compiler. As shown before
you can also pass flags at the end such as --stage.</p>
<h3><a class="header" href="#creating-a-rustup-toolchain" id="creating-a-rustup-toolchain">Creating a rustup toolchain</a></h3>
<p>Once you have successfully built <code>rustc</code>, you will have created a bunch
of files in your <code>build</code> directory. In order to actually run the
resulting <code>rustc</code>, we recommend creating rustup toolchains. The first
one will run the stage1 compiler (which we built above). The second
will execute the stage2 compiler (which we did not build, but which
you will likely need to build at some point; for example, if you want
to run the entire test suite).</p>
<pre><code class="language-bash">&gt; rustup toolchain link stage1 build/&lt;host-triple&gt;/stage1
&gt; rustup toolchain link stage2 build/&lt;host-triple&gt;/stage2
</code></pre>
<p>The <code>&lt;host-triple&gt;</code> would typically be one of the following:</p>
<ul>
<li>Linux: <code>x86_64-unknown-linux-gnu</code></li>
<li>Mac: <code>x86_64-apple-darwin</code></li>
<li>Windows: <code>x86_64-pc-windows-msvc</code></li>
</ul>
<p>Now you can run the <code>rustc</code> you built with. If you run with <code>-vV</code>, you
should see a version number ending in <code>-dev</code>, indicating a build from
your local environment:</p>
<pre><code class="language-bash">&gt; rustc +stage1 -vV
rustc 1.25.0-dev
binary: rustc
commit-hash: unknown
commit-date: unknown
host: x86_64-unknown-linux-gnu
release: 1.25.0-dev
LLVM version: 4.0
</code></pre>
<p><a name=workflow></a></p>
<h3><a class="header" href="#suggested-workflows-for-faster-builds-of-the-compiler" id="suggested-workflows-for-faster-builds-of-the-compiler">Suggested workflows for faster builds of the compiler</a></h3>
<p>There are two workflows that are useful for faster builds of the compiler.</p>
<p><strong>Check, check, and check again.</strong> The first workflow, which is useful
when doing simple refactorings, is to run <code>./x.py check</code>
continuously. Here you are just checking that the compiler can
<strong>build</strong>, but often that is all you need (e.g., when renaming a
method). You can then run <code>./x.py build</code> when you actually need to
run tests.</p>
<p>In fact, it is sometimes useful to put off tests even when you are not
100% sure the code will work. You can then keep building up
refactoring commits and only run the tests at some later time. You can
then use <code>git bisect</code> to track down <strong>precisely</strong> which commit caused
the problem. A nice side-effect of this style is that you are left
with a fairly fine-grained set of commits at the end, all of which
build and pass tests. This often helps reviewing.</p>
<p><strong>Incremental builds with <code>--keep-stage</code>.</strong> Sometimes just checking
whether the compiler builds is not enough. A common example is that
you need to add a <code>debug!</code> statement to inspect the value of some
state or better understand the problem. In that case, you really need
a full build.  By leveraging incremental, though, you can often get
these builds to complete very fast (e.g., around 30 seconds): the only
catch is this requires a bit of fudging and may produce compilers that
don't work (but that is easily detected and fixed).</p>
<p>The sequence of commands you want is as follows:</p>
<ul>
<li>Initial build: <code>./x.py build -i --stage 1 src/libstd</code>
<ul>
<li>As <a href="rustc-guide/how-to-build-and-run.html#command">documented above</a>, this will build a functional
stage1 compiler as part of running all stage0 commands (which include
building a <code>libstd</code> compatible with the stage1 compiler) as well as the
first few steps of the &quot;stage 1 actions&quot; up to &quot;stage1 (sysroot stage1)
builds libstd&quot;.</li>
</ul>
</li>
<li>Subsequent builds: <code>./x.py build -i --stage 1 src/libstd --keep-stage 1</code>
<ul>
<li>Note that we added the <code>--keep-stage 1</code> flag here</li>
</ul>
</li>
</ul>
<p>As mentioned, the effect of <code>--keep-stage 1</code> is that we just <em>assume</em> that the
old standard library can be re-used. If you are editing the compiler, this
is almost always true: you haven't changed the standard library, after
all.  But sometimes, it's not true: for example, if you are editing
the &quot;metadata&quot; part of the compiler, which controls how the compiler
encodes types and other states into the <code>rlib</code> files, or if you are
editing things that wind up in the metadata (such as the definition of
the MIR).</p>
<p><strong>The TL;DR is that you might get weird behavior from a compile when
using <code>--keep-stage 1</code></strong> -- for example, strange
<a href="rustc-guide/appendix/glossary.html">ICEs</a> or other panics. In that case, you
should simply remove the <code>--keep-stage 1</code> from the command and
rebuild.  That ought to fix the problem.</p>
<p>You can also use <code>--keep-stage 1</code> when running tests. Something like this:</p>
<ul>
<li>Initial test run: <code>./x.py test -i --stage 1 src/test/ui</code></li>
<li>Subsequent test run: <code>./x.py test -i --stage 1 src/test/ui --keep-stage 1</code></li>
</ul>
<h3><a class="header" href="#other-xpy-commands" id="other-xpy-commands">Other <code>x.py</code> commands</a></h3>
<p>Here are a few other useful <code>x.py</code> commands. We'll cover some of them in detail
in other sections:</p>
<ul>
<li>Building things:
<ul>
<li><code>./x.py clean</code> – clean up the build directory (<code>rm -rf build</code> works too,
but then you have to rebuild LLVM)</li>
<li><code>./x.py build --stage 1</code> – builds everything using the stage 1 compiler,
not just up to libstd</li>
<li><code>./x.py build</code> – builds the stage2 compiler</li>
</ul>
</li>
<li>Running tests (see the <a href="rustc-guide/./tests/running.html">section on running tests</a> for
more details):
<ul>
<li><code>./x.py test --stage 1 src/libstd</code> – runs the <code>#[test]</code> tests from libstd</li>
<li><code>./x.py test --stage 1 src/test/run-pass</code> – runs the <code>run-pass</code> test suite</li>
<li><code>./x.py test --stage 1 src/test/ui/const-generics</code> - runs all the tests in
the <code>const-generics/</code> subdirectory of the <code>ui</code> test suite</li>
<li><code>./x.py test --stage 1 src/test/ui/const-generics/const-types.rs</code> - runs
the single test <code>const-types.rs</code> from the <code>ui</code> test suite</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#ctags" id="ctags">ctags</a></h3>
<p>One of the challenges with rustc is that the RLS can't handle it, since it's a
bootstrapping compiler. This makes code navigation difficult. One solution is to
use <code>ctags</code>.</p>
<p><code>ctags</code> has a long history and several variants. Exhuberant CTags seems to be
quite commonly distributed but it does not have out-of-box Rust support. Some
distributions seem to use <a href="https://github.com/universal-ctags/ctags">Universal Ctags</a>, which is a maintained fork
and does have built-in Rust support.</p>
<p>The following script can be used to set up Exhuberant Ctags:
<a href="https://github.com/nikomatsakis/rust-etags">https://github.com/nikomatsakis/rust-etags</a>.</p>
<p><code>ctags</code> integrates into emacs and vim quite easily. The following can then be
used to build and generate tags:</p>
<pre><code class="language-console">$ rust-ctags src/lib* &amp;&amp; ./x.py build &lt;something&gt;
</code></pre>
<p>This allows you to do &quot;jump-to-def&quot; with whatever functions were around when
you last built, which is ridiculously useful.</p>
<h3><a class="header" href="#cleaning-out-build-directories" id="cleaning-out-build-directories">Cleaning out build directories</a></h3>
<p>Sometimes you need to start fresh, but this is normally not the case.
If you need to run this then rustbuild is most likely not acting right and
you should file a bug as to what is going wrong. If you do need to clean
everything up then you only need to run one command!</p>
<pre><code class="language-bash">&gt; ./x.py clean
</code></pre>
<h3><a class="header" href="#compiler-documentation" id="compiler-documentation">Compiler Documentation</a></h3>
<p>The documentation for the rust components are found at <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/">rustc doc</a>.</p>
<h1><a class="header" href="#build-distribution-artifacts" id="build-distribution-artifacts">Build distribution artifacts</a></h1>
<p>You might want to build and package up the compiler for distribution.
You’ll want to run this command to do it:</p>
<pre><code class="language-bash">./x.py dist
</code></pre>
<h1><a class="header" href="#install-distribution-artifacts" id="install-distribution-artifacts">Install distribution artifacts</a></h1>
<p>If you’ve built a distribution artifact you might want to install it and
test that it works on your target system. You’ll want to run this command:</p>
<pre><code class="language-bash">./x.py install
</code></pre>
<p>Note: If you are testing out a modification to a compiler, you
might want to use it to compile some project.
Usually, you do not want to use ./x.py install for testing.
Rather, you should create a toolchain as discussed in
<a href="rustc-guide/./how-to-build-and-run.html#creating-a-rustup-toolchain">here</a>.</p>
<p>For example, if the toolchain you created is called foo, you
would then invoke it with <code>rustc +foo ...</code> (where ... represents
the rest of the arguments).</p>
<h1><a class="header" href="#documenting-rustc" id="documenting-rustc">Documenting rustc</a></h1>
<p>You might want to build documentation of the various components 
available like the standard library. There’s two ways to go about this.
You can run rustdoc directly on the file to make sure the HTML is 
correct, which is fast. Alternatively, you can build the documentation 
as part of the  build process through x.py. Both are viable methods 
since documentation  is more about the content.</p>
<h2><a class="header" href="#document-everything" id="document-everything">Document everything</a></h2>
<pre><code class="language-bash">./x.py doc
</code></pre>
<h2><a class="header" href="#if-you-want-to-avoid-the-whole-stage-2-build" id="if-you-want-to-avoid-the-whole-stage-2-build">If you want to avoid the whole Stage 2 build</a></h2>
<pre><code class="language-bash">./x.py doc --stage 1
</code></pre>
<p>First the compiler and rustdoc get built to make sure everything is okay
and then it documents the files.</p>
<h2><a class="header" href="#document-specific-components" id="document-specific-components">Document specific components</a></h2>
<pre><code class="language-bash">   ./x.py doc src/doc/book
   ./x.py doc src/doc/nomicon
   ./x.py doc src/doc/book src/libstd
</code></pre>
<p>Much like individual tests or building certain components you can build only
the documentation you want.</p>
<h2><a class="header" href="#document-internal-rustc-items" id="document-internal-rustc-items">Document internal rustc items</a></h2>
<p>Compiler documentation is not built by default. There's a flag in
config.toml for achieving the same.
But, when enabled, compiler documentation does include internal items.</p>
<p>Next open up config.toml and make sure these two lines are set to true:</p>
<pre><code class="language-bash">docs = true
compiler-docs = true
</code></pre>
<p>When you want to build the compiler docs as well run this command:</p>
<pre><code class="language-bash">./x.py doc
</code></pre>
<p>This will see that the docs and compiler-docs options are set to true
and build the normally hidden compiler docs!</p>
<h3><a class="header" href="#compiler-documentation-1" id="compiler-documentation-1">Compiler Documentation</a></h3>
<p>The documentation for the rust components are found at <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/">rustc doc</a>.</p>
<h1><a class="header" href="#the-compiler-testing-framework" id="the-compiler-testing-framework">The compiler testing framework</a></h1>
<p>The Rust project runs a wide variety of different tests, orchestrated
by the build system (<code>x.py test</code>).  The main test harness for testing
the compiler itself is a tool called compiletest (sources in the
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest"><code>src/tools/compiletest</code></a>). This section gives a brief overview of how
the testing framework is setup, and then gets into some of the details
on <a href="rustc-guide/tests/./running.html#ui">how to run tests</a> as well as
<a href="rustc-guide/tests/./adding.html">how to add new tests</a>.</p>
<h2><a class="header" href="#compiletest-test-suites" id="compiletest-test-suites">Compiletest test suites</a></h2>
<p>The compiletest tests are located in the tree in the <a href="https://github.com/rust-lang/rust/tree/master/src/test"><code>src/test</code></a>
directory. Immediately within you will see a series of subdirectories
(e.g. <code>ui</code>, <code>run-make</code>, and so forth). Each of those directories is
called a <strong>test suite</strong> – they house a group of tests that are run in
a distinct mode.</p>
<p>Here is a brief summary of the test suites as of this writing and what
they mean. In some cases, the test suites are linked to parts of the manual
that give more details.</p>
<ul>
<li><a href="rustc-guide/tests/./adding.html#ui"><code>ui</code></a> – tests that check the exact
stdout/stderr from compilation and/or running the test</li>
<li><code>run-pass</code> – tests that are expected to compile and execute
successfully (no panics)
<ul>
<li><code>run-pass-valgrind</code> – tests that ought to run with valgrind</li>
</ul>
</li>
<li><code>run-fail</code> – tests that are expected to compile but then panic
during execution</li>
<li><code>compile-fail</code> – tests that are expected to fail compilation.</li>
<li><code>parse-fail</code> – tests that are expected to fail to parse</li>
<li><code>pretty</code> – tests targeting the Rust &quot;pretty printer&quot;, which
generates valid Rust code from the AST</li>
<li><code>debuginfo</code> – tests that run in gdb or lldb and query the debug info</li>
<li><code>codegen</code> – tests that compile and then test the generated LLVM
code to make sure that the optimizations we want are taking effect.</li>
<li><code>assembly</code> – similar to <code>codegen</code> tests, but verifies assembly output
to make sure LLVM target backend can handle provided code.</li>
<li><code>mir-opt</code> – tests that check parts of the generated MIR to make
sure we are building things correctly or doing the optimizations we
expect.</li>
<li><code>incremental</code> – tests for incremental compilation, checking that
when certain modifications are performed, we are able to reuse the
results from previous compilations.</li>
<li><code>run-make</code> – tests that basically just execute a <code>Makefile</code>; the
ultimate in flexibility but quite annoying to write.</li>
<li><code>rustdoc</code> – tests for rustdoc, making sure that the generated files
contain the expected documentation.</li>
<li><code>*-fulldeps</code> – same as above, but indicates that the test depends
on things other than <code>libstd</code> (and hence those things must be built)</li>
</ul>
<h2><a class="header" href="#other-tests" id="other-tests">Other Tests</a></h2>
<p>The Rust build system handles running tests for various other things,
including:</p>
<ul>
<li>
<p><strong>Tidy</strong> – This is a custom tool used for validating source code
style and formatting conventions, such as rejecting long lines.
There is more information in the
<a href="rustc-guide/tests/../conventions.html#formatting">section on coding conventions</a>.</p>
<p>Example: <code>./x.py test src/tools/tidy</code></p>
</li>
<li>
<p><strong>Unit tests</strong> – The Rust standard library and many of the Rust packages
include typical Rust <code>#[test]</code> unittests.  Under the hood, <code>x.py</code> will run
<code>cargo test</code> on each package to run all the tests.</p>
<p>Example: <code>./x.py test src/libstd</code></p>
</li>
<li>
<p><strong>Doc tests</strong> – Example code embedded within Rust documentation is executed
via <code>rustdoc --test</code>.  Examples:</p>
<p><code>./x.py test src/doc</code> – Runs <code>rustdoc --test</code> for all documentation in
<code>src/doc</code>.</p>
<p><code>./x.py test --doc src/libstd</code> – Runs <code>rustdoc --test</code> on the standard
library.</p>
</li>
<li>
<p><strong>Link checker</strong> – A small tool for verifying <code>href</code> links within
documentation.</p>
<p>Example: <code>./x.py test src/tools/linkchecker</code></p>
</li>
<li>
<p><strong>Dist check</strong> – This verifies that the source distribution tarball created
by the build system will unpack, build, and run all tests.</p>
<p>Example: <code>./x.py test distcheck</code></p>
</li>
<li>
<p><strong>Tool tests</strong> – Packages that are included with Rust have all of their
tests run as well (typically by running <code>cargo test</code> within their
directory).  This includes things such as cargo, clippy, rustfmt, rls, miri,
bootstrap (testing the Rust build system itself), etc.</p>
</li>
<li>
<p><strong>Cargo test</strong> – This is a small tool which runs <code>cargo test</code> on a few
significant projects (such as <code>servo</code>, <code>ripgrep</code>, <code>tokei</code>, etc.) just to
ensure there aren't any significant regressions.</p>
<p>Example: <code>./x.py test src/tools/cargotest</code></p>
</li>
</ul>
<h2><a class="header" href="#testing-infrastructure" id="testing-infrastructure">Testing infrastructure</a></h2>
<p>When a Pull Request is opened on Github, <a href="https://travis-ci.org/rust-lang/rust">Travis</a> will automatically launch a
build that will run all tests on a single configuration (x86-64 linux). In
essence, it runs <code>./x.py test</code> after building.</p>
<p>The integration bot <a href="https://github.com/servo/homu">bors</a> is used for coordinating merges to the master
branch. When a PR is approved, it goes into a <a href="https://buildbot2.rust-lang.org/homu/queue/rust">queue</a> where merges are tested
one at a time on a wide set of platforms using Travis and <a href="https://ci.appveyor.com/project/rust-lang/rust">Appveyor</a>
(currently over 50 different configurations).  Most platforms only run the
build steps, some run a restricted set of tests, only a subset run the full
suite of tests (see Rust's <a href="https://forge.rust-lang.org/platform-support.html">platform tiers</a>).</p>
<h2><a class="header" href="#testing-with-docker-images" id="testing-with-docker-images">Testing with Docker images</a></h2>
<p>The Rust tree includes <a href="https://www.docker.com/">Docker</a> image definitions for the platforms used on
Travis in <a href="https://github.com/rust-lang/rust/tree/master/src/ci/docker">src/ci/docker</a>.  The script <a href="https://github.com/rust-lang/rust/blob/master/src/ci/docker/run.sh">src/ci/docker/run.sh</a> is used to build
the Docker image, run it, build Rust within the image, and run the tests.</p>
<blockquote>
<p>TODO: What is a typical workflow for testing/debugging on a platform that
you don't have easy access to?  Do people build Docker images and enter them
to test things out?</p>
</blockquote>
<h2><a class="header" href="#testing-on-emulators" id="testing-on-emulators">Testing on emulators</a></h2>
<p>Some platforms are tested via an emulator for architectures that aren't
readily available.  There is a set of tools for orchestrating running the
tests within the emulator.  Platforms such as <code>arm-android</code> and
<code>arm-unknown-linux-gnueabihf</code> are set up to automatically run the tests under
emulation on Travis.  The following will take a look at how a target's tests
are run under emulation.</p>
<p>The Docker image for <a href="https://github.com/rust-lang/rust/tree/master/src/ci/docker/armhf-gnu">armhf-gnu</a> includes <a href="https://www.qemu.org/">QEMU</a> to emulate the ARM CPU
architecture.  Included in the Rust tree are the tools <a href="https://github.com/rust-lang/rust/tree/master/src/tools/remote-test-client">remote-test-client</a>
and <a href="https://github.com/rust-lang/rust/tree/master/src/tools/remote-test-server">remote-test-server</a> which are programs for sending test programs and
libraries to the emulator, and running the tests within the emulator, and
reading the results.  The Docker image is set up to launch
<code>remote-test-server</code> and the build tools use <code>remote-test-client</code> to
communicate with the server to coordinate running tests (see
<a href="https://github.com/rust-lang/rust/tree/master/src/bootstrap/test.rs">src/bootstrap/test.rs</a>).</p>
<blockquote>
<p>TODO: What are the steps for manually running tests within an emulator?
<code>./src/ci/docker/run.sh armhf-gnu</code> will do everything, but takes hours to
run and doesn't offer much help with interacting within the emulator.</p>
<p>Is there any support for emulating other (non-Android) platforms, such as
running on an iOS emulator?</p>
<p>Is there anything else interesting that can be said here about running tests
remotely on real hardware?</p>
<p>It's also unclear to me how the wasm or asm.js tests are run.</p>
</blockquote>
<h2><a class="header" href="#crater" id="crater">Crater</a></h2>
<p><a href="https://github.com/rust-lang-nursery/crater">Crater</a> is a tool for compiling
and running tests for <em>every</em> crate on <a href="https://crates.io">crates.io</a> (and a
few on GitHub). It is mainly used for checking for extent of breakage when
implementing potentially breaking changes and ensuring lack of breakage by
running beta vs stable compiler versions.</p>
<h3><a class="header" href="#when-to-run-crater" id="when-to-run-crater">When to run Crater</a></h3>
<p>You should request a crater run if your PR makes large changes to the compiler
or could cause breakage. If you are unsure, feel free to ask your PR's reviewer.</p>
<h3><a class="header" href="#requesting-crater-runs" id="requesting-crater-runs">Requesting Crater Runs</a></h3>
<p>The rust team maintains a few machines that can be used for running crater runs
on the changes introduced by a PR. If your PR needs a crater run, leave a
comment for the triage team in the PR thread. Please inform the team whether
you require a &quot;check-only&quot; crater run, a &quot;build only&quot; crater run, or a
&quot;build-and-test&quot; crater run. The difference is primarily in time; the
conservative (if you're not sure) option is to go for the build-and-test run.
If making changes that will only have an effect at compile-time (e.g.,
implementing a new trait) then you only need a check run.</p>
<p>Your PR will be enqueued by the triage team and the results will be posted when
they are ready. Check runs will take around ~3-4 days, with the other two
taking 5-6 days on average.</p>
<p>While crater is really useful, it is also important to be aware of a few
caveats:</p>
<ul>
<li>
<p>Not all code is on crates.io! There is a lot of code in repos on GitHub and
elsewhere. Also, companies may not wish to publish their code. Thus, a
successful crater run is not a magically green light that there will be no
breakage; you still need to be careful.</p>
</li>
<li>
<p>Crater only runs Linux builds on x86_64. Thus, other architectures and
platforms are not tested. Critically, this includes Windows.</p>
</li>
<li>
<p>Many crates are not tested. This could be for a lot of reasons, including
that the crate doesn't compile any more (e.g. used old nightly features),
has broken or flaky tests, requires network access, or other reasons.</p>
</li>
<li>
<p>Before crater can be run, <code>@bors try</code> needs to succeed in building artifacts.
This means that if your code doesn't compile, you cannot run crater.</p>
</li>
</ul>
<h2><a class="header" href="#perf-runs" id="perf-runs">Perf runs</a></h2>
<p>A lot of work is put into improving the performance of the compiler and
preventing performance regressions. A &quot;perf run&quot; is used to compare the
performance of the compiler in different configurations for a large collection
of popular crates. Different configurations include &quot;fresh builds&quot;, builds
with incremental compilation, etc.</p>
<p>The result of a perf run is a comparison between two versions of the
compiler (by their commit hashes).</p>
<p>You should request a perf run if your PR may affect performance, especially
if it can affect performance adversely.</p>
<h2><a class="header" href="#further-reading" id="further-reading">Further reading</a></h2>
<p>The following blog posts may also be of interest:</p>
<ul>
<li>brson's classic <a href="https://brson.github.io/2017/07/10/how-rust-is-tested">&quot;How Rust is tested&quot;</a></li>
</ul>
<h1><a class="header" href="#running-tests" id="running-tests">Running tests</a></h1>
<p>You can run the tests using <code>x.py</code>. The most basic command – which
you will almost never want to use! – is as follows:</p>
<pre><code class="language-bash">&gt; ./x.py test
</code></pre>
<p>This will build the full stage 2 compiler and then run the whole test
suite. You probably don't want to do this very often, because it takes
a very long time, and anyway bors / travis will do it for you. (Often,
I will run this command in the background after opening a PR that I
think is done, but rarely otherwise. -nmatsakis)</p>
<p>The test results are cached and previously successful tests are
<code>ignored</code> during testing. The stdout/stderr contents as well as a
timestamp file for every test can be found under <code>build/ARCH/test/</code>.
To force-rerun a test (e.g. in case the test runner fails to notice
a change) you can simply remove the timestamp file.</p>
<p>Note that some tests require a Python-enabled gdb. You can test if
your gdb install supports Python by using the <code>python</code> command from
within gdb. Once invoked you can type some Python code (e.g.
<code>print(&quot;hi&quot;)</code>) followed by return and then <code>CTRL+D</code> to execute it.
If you are building gdb from source, you will need to configure with
<code>--with-python=&lt;path-to-python-binary&gt;</code>.</p>
<h2><a class="header" href="#running-a-subset-of-the-test-suites" id="running-a-subset-of-the-test-suites">Running a subset of the test suites</a></h2>
<p>When working on a specific PR, you will usually want to run a smaller
set of tests, and with a stage 1 build. For example, a good &quot;smoke
test&quot; that can be used after modifying rustc to see if things are
generally working correctly would be the following:</p>
<pre><code class="language-bash">&gt; ./x.py test --stage 1 src/test/{ui,compile-fail,run-pass}
</code></pre>
<p>This will run the <code>ui</code>, <code>compile-fail</code>, and <code>run-pass</code> test suites,
and only with the stage 1 build. Of course, the choice of test suites
is somewhat arbitrary, and may not suit the task you are doing. For
example, if you are hacking on debuginfo, you may be better off with
the debuginfo test suite:</p>
<pre><code class="language-bash">&gt; ./x.py test --stage 1 src/test/debuginfo
</code></pre>
<p>If you only need to test a specific subdirectory of tests for any
given test suite, you can pass that directory to <code>x.py test</code>:</p>
<pre><code class="language-bash">&gt; ./x.py test --stage 1 src/test/ui/const-generics
</code></pre>
<p>Likewise, you can test a single file by passing its path:</p>
<pre><code class="language-bash">&gt; ./x.py test --stage 1 src/test/ui/const-generics/const-test.rs
</code></pre>
<h3><a class="header" href="#run-only-the-tidy-script" id="run-only-the-tidy-script">Run only the tidy script</a></h3>
<pre><code class="language-bash">&gt; ./x.py test src/tools/tidy
</code></pre>
<h3><a class="header" href="#run-tests-on-the-standard-library" id="run-tests-on-the-standard-library">Run tests on the standard library</a></h3>
<pre><code class="language-bash">&gt; ./x.py test src/libstd
</code></pre>
<h3><a class="header" href="#run-tests-on-the-standard-library-and-run-the-tidy-script" id="run-tests-on-the-standard-library-and-run-the-tidy-script">Run tests on the standard library and run the tidy script</a></h3>
<pre><code class="language-bash">&gt; ./x.py test src/libstd src/tools/tidy
</code></pre>
<h3><a class="header" href="#run-tests-on-the-standard-library-using-a-stage-1-compiler" id="run-tests-on-the-standard-library-using-a-stage-1-compiler">Run tests on the standard library using a stage 1 compiler</a></h3>
<pre><code class="language-bash">&gt;   ./x.py test src/libstd --stage 1
</code></pre>
<p>By listing which test suites you want to run you avoid having to run
tests for components you did not change at all.</p>
<p><strong>Warning:</strong> Note that bors only runs the tests with the full stage 2
build; therefore, while the tests <strong>usually</strong> work fine with stage 1,
there are some limitations. In particular, the stage1 compiler doesn't
work well with procedural macros or custom derive tests.</p>
<h2><a class="header" href="#running-an-individual-test" id="running-an-individual-test">Running an individual test</a></h2>
<p>Another common thing that people want to do is to run an <strong>individual
test</strong>, often the test they are trying to fix. As mentioned earlier,
you may pass the full file path to achieve this, or alternatively one
may invoke <code>x.py</code> with the <code>--test-args</code> option:</p>
<pre><code class="language-bash">&gt; ./x.py test --stage 1 src/test/ui --test-args issue-1234
</code></pre>
<p>Under the hood, the test runner invokes the standard rust test runner
(the same one you get with <code>#[test]</code>), so this command would wind up
filtering for tests that include &quot;issue-1234&quot; in the name. (Thus
<code>--test-args</code> is a good way to run a collection of related tests.)</p>
<h2><a class="header" href="#using-incremental-compilation" id="using-incremental-compilation">Using incremental compilation</a></h2>
<p>You can further enable the <code>--incremental</code> flag to save additional
time in subsequent rebuilds:</p>
<pre><code class="language-bash">&gt; ./x.py test --stage 1 src/test/ui --incremental --test-args issue-1234
</code></pre>
<p>If you don't want to include the flag with every command, you can
enable it in the <code>config.toml</code>, too:</p>
<pre><code class="language-toml"># Whether to always use incremental compilation when building rustc
incremental = true
</code></pre>
<p>Note that incremental compilation will use more disk space than usual.
If disk space is a concern for you, you might want to check the size
of the <code>build</code> directory from time to time.</p>
<h2><a class="header" href="#running-tests-manually" id="running-tests-manually">Running tests manually</a></h2>
<p>Sometimes it's easier and faster to just run the test by hand. Most tests are
just <code>rs</code> files, so you can do something like</p>
<pre><code class="language-bash">&gt; rustc +stage1 src/test/ui/issue-1234.rs
</code></pre>
<p>This is much faster, but doesn't always work. For example, some tests
include directives that specify specific compiler flags, or which rely
on other crates, and they may not run the same without those options.</p>
<h1><a class="header" href="#adding-new-tests" id="adding-new-tests">Adding new tests</a></h1>
<p><strong>In general, we expect every PR that fixes a bug in rustc to come
accompanied by a regression test of some kind.</strong> This test should fail
in master but pass after the PR. These tests are really useful for
preventing us from repeating the mistakes of the past.</p>
<p>To add a new test, the first thing you generally do is to create a
file, typically a Rust source file. Test files have a particular
structure:</p>
<ul>
<li>They should have some kind of
<a href="rustc-guide/tests/adding.html#explanatory_comment">comment explaining what the test is about</a>;</li>
<li>next, they can have one or more <a href="rustc-guide/tests/adding.html#header_commands">header commands</a>, which
are special comments that the test interpreter knows how to interpret.</li>
<li>finally, they have the Rust source. This may have various <a href="rustc-guide/tests/adding.html#error_annotations">error
annotations</a> which indicate expected compilation errors or
warnings.</li>
</ul>
<p>Depending on the test suite, there may be some other details to be aware of:</p>
<ul>
<li>For <a href="rustc-guide/tests/adding.html#ui">the <code>ui</code> test suite</a>, you need to generate reference output files.</li>
</ul>
<h2><a class="header" href="#what-kind-of-test-should-i-add" id="what-kind-of-test-should-i-add">What kind of test should I add?</a></h2>
<p>It can be difficult to know what kind of test to use. Here are some
rough heuristics:</p>
<ul>
<li>Some tests have specialized needs:
<ul>
<li>need to run gdb or lldb? use the <code>debuginfo</code> test suite</li>
<li>need to inspect LLVM IR or MIR IR? use the <code>codegen</code> or <code>mir-opt</code> test
suites</li>
<li>need to run rustdoc? Prefer a <code>rustdoc</code> test</li>
<li>need to inspect the resulting binary in some way? Then use <code>run-make</code></li>
</ul>
</li>
<li>For most other things, <a href="rustc-guide/tests/adding.html#ui">a <code>ui</code> (or <code>ui-fulldeps</code>) test</a> is to be
preferred:
<ul>
<li><code>ui</code> tests subsume both run-pass, compile-fail, and parse-fail tests</li>
<li>in the case of warnings or errors, <code>ui</code> tests capture the full output,
which makes it easier to review but also helps prevent &quot;hidden&quot; regressions
in the output</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#naming-your-test" id="naming-your-test">Naming your test</a></h2>
<p>We have not traditionally had a lot of structure in the names of
tests.  Moreover, for a long time, the rustc test runner did not
support subdirectories (it now does), so test suites like
<a href="https://github.com/rust-lang/rust/tree/master/src/test/run-pass/"><code>src/test/run-pass</code></a> have a huge mess of files in them. This is not
considered an ideal setup.</p>
<p>For regression tests – basically, some random snippet of code that
came in from the internet – we often just name the test after the
issue. For example, <code>src/test/run-pass/issue-12345.rs</code>. If possible,
though, it is better if you can put the test into a directory that
helps identify what piece of code is being tested here (e.g.,
<code>borrowck/issue-12345.rs</code> is much better), or perhaps give it a more
meaningful name. Still, <strong>do include the issue number somewhere</strong>.</p>
<p>When writing a new feature, <strong>create a subdirectory to store your
tests</strong>. For example, if you are implementing RFC 1234 (&quot;Widgets&quot;),
then it might make sense to put the tests in directories like:</p>
<ul>
<li><code>src/test/ui/rfc1234-widgets/</code></li>
<li><code>src/test/run-pass/rfc1234-widgets/</code></li>
<li>etc</li>
</ul>
<p>In other cases, there may already be a suitable directory. (The proper
directory structure to use is actually an area of active debate.)</p>
<p><a name="explanatory_comment"></a></p>
<h2><a class="header" href="#comment-explaining-what-the-test-is-about" id="comment-explaining-what-the-test-is-about">Comment explaining what the test is about</a></h2>
<p>When you create a test file, <strong>include a comment summarizing the point
of the test at the start of the file</strong>. This should highlight which
parts of the test are more important, and what the bug was that the
test is fixing. Citing an issue number is often very helpful.</p>
<p>This comment doesn't have to be super extensive. Just something like
&quot;Regression test for #18060: match arms were matching in the wrong
order.&quot;  might already be enough.</p>
<p>These comments are very useful to others later on when your test
breaks, since they often can highlight what the problem is. They are
also useful if for some reason the tests need to be refactored, since
they let others know which parts of the test were important (often a
test must be rewritten because it no longer tests what is was meant to
test, and then it's useful to know what it <em>was</em> meant to test
exactly).</p>
<p><a name="header_commands"></a></p>
<h2><a class="header" href="#header-commands-configuring-rustc" id="header-commands-configuring-rustc">Header commands: configuring rustc</a></h2>
<p>Header commands are special comments that the test runner knows how to
interpret.  They must appear before the Rust source in the test. They
are normally put after the short comment that explains the point of
this test. For example, this test uses the <code>// compile-flags</code> command
to specify a custom flag to give to rustc when the test is compiled:</p>
<pre><code class="language-rust ignore">// Test the behavior of `0 - 1` when overflow checks are disabled.

// compile-flags: -Coverflow-checks=off

fn main() {
    let x = 0 - 1;
    ...
}
</code></pre>
<h3><a class="header" href="#ignoring-tests-1" id="ignoring-tests-1">Ignoring tests</a></h3>
<p>These are used to ignore the test in some situations, which means the test won't
be compiled or run.</p>
<ul>
<li><code>ignore-X</code> where <code>X</code> is a target detail or stage will ignore the
test accordingly (see below)</li>
<li><code>only-X</code> is like <code>ignore-X</code>, but will <em>only</em> run the test on that
target or stage</li>
<li><code>ignore-pretty</code> will not compile the pretty-printed test (this is
done to test the pretty-printer, but might not always work)</li>
<li><code>ignore-test</code> always ignores the test</li>
<li><code>ignore-lldb</code> and <code>ignore-gdb</code> will skip a debuginfo test on that
debugger.</li>
<li><code>ignore-gdb-version</code> can be used to ignore the test when certain gdb
versions are used</li>
</ul>
<p>Some examples of <code>X</code> in <code>ignore-X</code>:</p>
<ul>
<li>Architecture: <code>aarch64</code>, <code>arm</code>, <code>asmjs</code>, <code>mips</code>, <code>wasm32</code>, <code>x86_64</code>,
<code>x86</code>, ...</li>
<li>OS: <code>android</code>, <code>emscripten</code>, <code>freebsd</code>, <code>ios</code>, <code>linux</code>, <code>macos</code>,
<code>windows</code>, ...</li>
<li>Environment (fourth word of the target triple): <code>gnu</code>, <code>msvc</code>,
<code>musl</code>.</li>
<li>Pointer width: <code>32bit</code>, <code>64bit</code>.</li>
<li>Stage: <code>stage0</code>, <code>stage1</code>, <code>stage2</code>.</li>
</ul>
<h3><a class="header" href="#other-header-commands" id="other-header-commands">Other Header Commands</a></h3>
<p>Here is a list of other header commands. This list is not
exhaustive. Header commands can generally be found by browsing the
<code>TestProps</code> structure found in <a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs"><code>header.rs</code></a> from the compiletest
source.</p>
<ul>
<li><code>run-rustfix</code> for UI tests, indicates that the test produces
structured suggestions. The test writer should create a <code>.fixed</code>
file, which contains the source with the suggestions applied.
When the test is run, compiletest first checks that the correct
lint/warning is generated. Then, it applies the suggestion and
compares against <code>.fixed</code> (they must match). Finally, the fixed
source is compiled, and this compilation is required to succeed.
The <code>.fixed</code> file can also be generated automatically with the
<code>--bless</code> option, discussed <a href="rustc-guide/tests/adding.html#bless">below</a>.</li>
<li><code>min-gdb-version</code> specifies the minimum gdb version required for
this test; see also <code>ignore-gdb-version</code></li>
<li><code>min-lldb-version</code> specifies the minimum lldb version required for
this test</li>
<li><code>rust-lldb</code> causes the lldb part of the test to only be run if the
lldb in use contains the Rust plugin</li>
<li><code>no-system-llvm</code> causes the test to be ignored if the system llvm is used</li>
<li><code>min-llvm-version</code> specifies the minimum llvm version required for
this test</li>
<li><code>min-system-llvm-version</code> specifies the minimum system llvm version
required for this test; the test is ignored if the system llvm is in
use and it doesn't meet the minimum version.  This is useful when an
llvm feature has been backported to rust-llvm</li>
<li><code>ignore-llvm-version</code> can be used to skip the test when certain LLVM
versions are used.  This takes one or two arguments; the first
argument is the first version to ignore.  If no second argument is
given, all subsequent versions are ignored; otherwise, the second
argument is the last version to ignore.</li>
<li><code>build-pass</code> for UI tests, indicates that the test is supposed to
successfully compile and link, as opposed to the default where the test is
supposed to error out.</li>
<li><code>compile-flags</code> passes extra command-line args to the compiler,
e.g. <code>compile-flags -g</code> which forces debuginfo to be enabled.</li>
<li><code>should-fail</code> indicates that the test should fail; used for &quot;meta
testing&quot;, where we test the compiletest program itself to check that
it will generate errors in appropriate scenarios. This header is
ignored for pretty-printer tests.</li>
<li><code>gate-test-X</code> where <code>X</code> is a feature marks the test as &quot;gate test&quot;
for feature X.  Such tests are supposed to ensure that the compiler
errors when usage of a gated feature is attempted without the proper
<code>#![feature(X)]</code> tag.  Each unstable lang feature is required to
have a gate test.</li>
</ul>
<p><a name="error_annotations"></a></p>
<h2><a class="header" href="#error-annotations" id="error-annotations">Error annotations</a></h2>
<p>Error annotations specify the errors that the compiler is expected to
emit. They are &quot;attached&quot; to the line in source where the error is
located.</p>
<ul>
<li><code>~</code>: Associates the following error level and message with the
current line</li>
<li><code>~|</code>: Associates the following error level and message with the same
line as the previous comment</li>
<li><code>~^</code>: Associates the following error level and message with the
previous line. Each caret (<code>^</code>) that you add adds a line to this, so
<code>~^^^^^^^</code> is seven lines up.</li>
</ul>
<p>The error levels that you can have are:</p>
<ol>
<li><code>ERROR</code></li>
<li><code>WARNING</code></li>
<li><code>NOTE</code></li>
<li><code>HELP</code> and <code>SUGGESTION</code>*</li>
</ol>
<p>* <strong>Note</strong>: <code>SUGGESTION</code> must follow immediately after <code>HELP</code>.</p>
<h2><a class="header" href="#revisions" id="revisions">Revisions</a></h2>
<p>Certain classes of tests support &quot;revisions&quot; (as of the time of this
writing, this includes run-pass, compile-fail, run-fail, and
incremental, though incremental tests are somewhat
different). Revisions allow a single test file to be used for multiple
tests. This is done by adding a special header at the top of the file:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// revisions: foo bar baz
<span class="boring">}
</span></code></pre></pre>
<p>This will result in the test being compiled (and tested) three times,
once with <code>--cfg foo</code>, once with <code>--cfg bar</code>, and once with <code>--cfg baz</code>. You can therefore use <code>#[cfg(foo)]</code> etc within the test to tweak
each of these results.</p>
<p>You can also customize headers and expected error messages to a particular
revision. To do this, add <code>[foo]</code> (or <code>bar</code>, <code>baz</code>, etc) after the <code>//</code>
comment, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// A flag to pass in only for cfg `foo`:
//[foo]compile-flags: -Z verbose

#[cfg(foo)]
fn test_foo() {
    let x: usize = 32_u32; //[foo]~ ERROR mismatched types
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that not all headers have meaning when customized to a revision.
For example, the <code>ignore-test</code> header (and all &quot;ignore&quot; headers)
currently only apply to the test as a whole, not to particular
revisions. The only headers that are intended to really work when
customized to a revision are error patterns and compiler flags.</p>
<p><a name="ui"></a></p>
<h2><a class="header" href="#guide-to-the-ui-tests" id="guide-to-the-ui-tests">Guide to the UI tests</a></h2>
<p>The UI tests are intended to capture the compiler's complete output,
so that we can test all aspects of the presentation. They work by
compiling a file (e.g., <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/hello_world/main.rs"><code>ui/hello_world/main.rs</code></a>),
capturing the output, and then applying some normalization (see
below). This normalized result is then compared against reference
files named <code>ui/hello_world/main.stderr</code> and
<code>ui/hello_world/main.stdout</code>. If either of those files doesn't exist,
the output must be empty (that is actually the case for
<a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/hello_world/">this particular test</a>). If the test run fails, we will print out
the current output, but it is also saved in
<code>build/&lt;target-triple&gt;/test/ui/hello_world/main.stdout</code> (this path is
printed as part of the test failure message), so you can run <code>diff</code>
and so forth.</p>
<h3><a class="header" href="#tests-that-do-not-result-in-compile-errors" id="tests-that-do-not-result-in-compile-errors">Tests that do not result in compile errors</a></h3>
<p>By default, a UI test is expected <strong>not to compile</strong> (in which case,
it should contain at least one <code>//~ ERROR</code> annotation). However, you
can also make UI tests where compilation is expected to succeed, and
you can even run the resulting program. Just add one of the following
<a href="rustc-guide/tests/adding.html#header_commands">header commands</a>:</p>
<ul>
<li><code>// check-pass</code> - compilation should succeed but skip codegen
(which is expensive and isn't supposed to fail in most cases)</li>
<li><code>// build-pass</code> – compilation and linking should succeed but do
not run the resulting binary</li>
<li><code>// run-pass</code> – compilation should succeed and we should run the
resulting binary</li>
</ul>
<p><a name="bless"></a></p>
<h3><a class="header" href="#editing-and-updating-the-reference-files" id="editing-and-updating-the-reference-files">Editing and updating the reference files</a></h3>
<p>If you have changed the compiler's output intentionally, or you are
making a new test, you can pass <code>--bless</code> to the test subcommand. E.g.
if some tests in <code>src/test/ui</code> are failing, you can run</p>
<pre><code class="language-text">./x.py test --stage 1 src/test/ui --bless
</code></pre>
<p>to automatically adjust the <code>.stderr</code>, <code>.stdout</code> or <code>.fixed</code> files of
all tests. Of course you can also target just specific tests with the
<code>--test-args your_test_name</code> flag, just like when running the tests.</p>
<h3><a class="header" href="#normalization" id="normalization">Normalization</a></h3>
<p>The normalization applied is aimed at eliminating output difference
between platforms, mainly about filenames:</p>
<ul>
<li>the test directory is replaced with <code>$DIR</code></li>
<li>all backslashes (<code>\</code>) are converted to forward slashes (<code>/</code>) (for Windows)</li>
<li>all CR LF newlines are converted to LF</li>
</ul>
<p>Sometimes these built-in normalizations are not enough. In such cases, you
may provide custom normalization rules using the header commands, e.g.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// normalize-stdout-test: &quot;foo&quot; -&gt; &quot;bar&quot;
// normalize-stderr-32bit: &quot;fn\(\) \(32 bits\)&quot; -&gt; &quot;fn\(\) \($$PTR bits\)&quot;
// normalize-stderr-64bit: &quot;fn\(\) \(64 bits\)&quot; -&gt; &quot;fn\(\) \($$PTR bits\)&quot;
<span class="boring">}
</span></code></pre></pre>
<p>This tells the test, on 32-bit platforms, whenever the compiler writes
<code>fn() (32 bits)</code> to stderr, it should be normalized to read <code>fn() ($PTR bits)</code>
instead. Similar for 64-bit. The replacement is performed by regexes using
default regex flavor provided by <code>regex</code> crate.</p>
<p>The corresponding reference file will use the normalized output to test both
32-bit and 64-bit platforms:</p>
<pre><code class="language-text">...
   |
   = note: source type: fn() ($PTR bits)
   = note: target type: u16 (16 bits)
...
</code></pre>
<p>Please see <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/transmute/main.rs"><code>ui/transmute/main.rs</code></a> and <a href="https://github.com/rust-lang/rust/blob/master/src/test/ui/transmute/main.stderr"><code>main.stderr</code></a> for a
concrete usage example.</p>
<p>Besides <code>normalize-stderr-32bit</code> and <code>-64bit</code>, one may use any target
information or stage supported by <code>ignore-X</code> here as well (e.g.
<code>normalize-stderr-windows</code> or simply <code>normalize-stderr-test</code> for unconditional
replacement).</p>
<h1><a class="header" href="#compiletest" id="compiletest"><code>compiletest</code></a></h1>
<h2><a class="header" href="#introduction-1" id="introduction-1">Introduction</a></h2>
<p><code>compiletest</code> is the main test harness of the Rust test suite.  It allows
test authors to organize large numbers of tests (the Rust compiler has many
thousands), efficient test execution (parallel execution is supported), and
allows the test author to configure behavior and expected results of both
individual and groups of tests.</p>
<p><code>compiletest</code> tests may check test code for success, for failure or in some
cases, even failure to compile.  Tests are typically organized as a Rust source
file with annotations in comments before and/or within the test code, which
serve to direct <code>compiletest</code> on if or how to run the test, what behavior to
expect, and more.  If you are unfamiliar with the compiler testing framework,
see <a href="rustc-guide/./tests/intro.html">this chapter</a> for additional background.</p>
<p>The tests themselves are typically (but not always) organized into
&quot;suites&quot; – for example, <code>run-pass</code>, a folder representing tests that should
succeed, <code>run-fail</code>, a folder holding tests that should compile successfully,
but return a failure (non-zero status), <code>compile-fail</code>, a folder holding tests
that should fail to compile, and many more.  The various suites are defined in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/common.rs">src/tools/compiletest/src/common.rs</a> in the <code>pub struct Config</code>
declaration.  And a very good introduction to the different suites of compiler
tests along with details about them can be found in <a href="rustc-guide/./tests/adding.html">Adding new
tests</a>.</p>
<h2><a class="header" href="#adding-a-new-test-file" id="adding-a-new-test-file">Adding a new test file</a></h2>
<p>Briefly, simply create your new test in the appropriate location under
<a href="https://github.com/rust-lang/rust/tree/master/src/test">src/test</a>. No registration of test files is necessary as <code>compiletest</code>
will scan the <a href="https://github.com/rust-lang/rust/tree/master/src/test">src/test</a> subfolder recursively, and will execute any Rust
source files it finds as tests.  See <a href="rustc-guide/./tests/adding.html"><code>Adding new tests</code></a>
for a complete guide on how to adding new tests.</p>
<h2><a class="header" href="#header-commands" id="header-commands">Header Commands</a></h2>
<p>Source file annotations which appear in comments near the top of the source
file <em>before</em> any test code are known as header commands.  These commands can
instruct <code>compiletest</code> to ignore this test, set expectations on whether it is
expected to succeed at compiling, or what the test's return code is expected to
be.  Header commands (and their inline counterparts, Error Info commands) are
described more fully
<a href="rustc-guide/./tests/adding.html#header-commands-configuring-rustc">here</a>.</p>
<h3><a class="header" href="#adding-a-new-header-command" id="adding-a-new-header-command">Adding a new header command</a></h3>
<p>Header commands are defined in the <code>TestProps</code> struct in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a>.  At a high level, there are
dozens of test properties defined here, all set to default values in the
<code>TestProp</code> struct's <code>impl</code> block. Any test can override this default value by
specifying the property in question as header command as a comment (<code>//</code>) in
the test source file, before any source code.</p>
<h4><a class="header" href="#using-a-header-command" id="using-a-header-command">Using a header command</a></h4>
<p>Here is an example, specifying the <code>must-compile-successfully</code> header command,
which takes no arguments, followed by the <code>failure-status</code> header command,
which takes a single argument (which, in this case is a value of 1).
<code>failure-status</code> is instructing <code>compiletest</code> to expect a failure status of 1
(rather than the current Rust default of 101 at the time of this writing).  The
header command and the argument list (if present) are typically separated by a
colon:</p>
<pre><code class="language-rust ignore">// must-compile-successfully
// failure-status: 1

#![feature(termination_trait)]

use std::io::{Error, ErrorKind};

fn main() -&gt; Result&lt;(), Box&lt;Error&gt;&gt; {
    Err(Box::new(Error::new(ErrorKind::Other, &quot;returned Box&lt;Error&gt; from main()&quot;)))
}
</code></pre>
<h4><a class="header" href="#adding-a-new-header-command-property" id="adding-a-new-header-command-property">Adding a new header command property</a></h4>
<p>One would add a new header command if there is a need to define some test
property or behavior on an individual, test-by-test basis.  A header command
property serves as the header command's backing store (holds the command's
current value) at runtime.</p>
<p>To add a new header command property:
1. Look for the <code>pub struct TestProps</code> declaration in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a> and add the new public
property to the end of the declaration.
2. Look for the <code>impl TestProps</code> implementation block immediately following
the struct declaration and initialize the new property to its default
value.</p>
<h4><a class="header" href="#adding-a-new-header-command-parser" id="adding-a-new-header-command-parser">Adding a new header command parser</a></h4>
<p>When <code>compiletest</code> encounters a test file, it parses the file a line at a time
by calling every parser defined in the <code>Config</code> struct's implementation block,
also in <a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a> (note the <code>Config</code>
struct's declaration block is found in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/common.rs">src/tools/compiletest/src/common.rs</a>.  <code>TestProps</code>'s <code>load_from()</code>
method will try passing the current line of text to each parser, which, in turn
typically checks to see if the line begins with a particular commented (<code>//</code>)
header command such as <code>// must-compile-successfully</code> or <code>// failure-status</code>.
Whitespace after the comment marker is optional.</p>
<p>Parsers will override a given header command property's default value merely by
being specified in the test file as a header command or by having a parameter
value specified in the test file, depending on the header command.</p>
<p>Parsers defined in <code>impl Config</code> are typically named <code>parse_&lt;header_command&gt;</code>
(note kebab-case <code>&lt;header-command&gt;</code> transformed to snake-case
<code>&lt;header_command&gt;</code>).  <code>impl Config</code> also defines several 'low-level' parsers
which make it simple to parse common patterns like simple presence or not
(<code>parse_name_directive()</code>), header-command:parameter(s)
(<code>parse_name_value_directive()</code>), optional parsing only if a particular <code>cfg</code>
attribute is defined (<code>has_cfg_prefix()</code>) and many more.  The low-level parsers
are found near the end of the <code>impl Config</code> block; be sure to look through them
and their associated parsers immediately above to see how they are used to
avoid writing additional parsing code unnecessarily.</p>
<p>As a concrete example, here is the implementation for the
<code>parse_failure_status()</code> parser, in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/header.rs">src/tools/compiletest/src/header.rs</a>:</p>
<pre><code class="language-diff">@@ -232,6 +232,7 @@ pub struct TestProps {
     // customized normalization rules
     pub normalize_stdout: Vec&lt;(String, String)&gt;,
     pub normalize_stderr: Vec&lt;(String, String)&gt;,
+    pub failure_status: i32,
 }

 impl TestProps {
@@ -260,6 +261,7 @@ impl TestProps {
             run_pass: false,
             normalize_stdout: vec![],
             normalize_stderr: vec![],
+            failure_status: 101,
         }
     }

@@ -383,6 +385,10 @@ impl TestProps {
             if let Some(rule) = config.parse_custom_normalization(ln, &quot;normalize-stderr&quot;) {
                 self.normalize_stderr.push(rule);
             }
+
+            if let Some(code) = config.parse_failure_status(ln) {
+                self.failure_status = code;
+            }
         });

         for key in &amp;[&quot;RUST_TEST_NOCAPTURE&quot;, &quot;RUST_TEST_THREADS&quot;] {
@@ -488,6 +494,13 @@ impl Config {
         self.parse_name_directive(line, &quot;pretty-compare-only&quot;)
     }

+    fn parse_failure_status(&amp;self, line: &amp;str) -&gt; Option&lt;i32&gt; {
+        match self.parse_name_value_directive(line, &quot;failure-status&quot;) {
+            Some(code) =&gt; code.trim().parse::&lt;i32&gt;().ok(),
+            _ =&gt; None,
+        }
+    }
</code></pre>
<h2><a class="header" href="#implementing-the-behavior-change" id="implementing-the-behavior-change">Implementing the behavior change</a></h2>
<p>When a test invokes a particular header command, it is expected that some
behavior will change as a result.  What behavior, obviously, will depend on the
purpose of the header command.  In the case of <code>failure-status</code>, the behavior
that changes is that <code>compiletest</code> expects the failure code defined by the
header command invoked in the test, rather than the default value.</p>
<p>Although specific to <code>failure-status</code> (as every header command will have a
different implementation in order to invoke behavior change) perhaps it is
helpful to see the behavior change implementation of one case, simply as an
example.  To implement <code>failure-status</code>, the <code>check_correct_failure_status()</code>
function found in the <code>TestCx</code> implementation block, located in
<a href="https://github.com/rust-lang/rust/tree/master/src/tools/compiletest/src/runtest.rs">src/tools/compiletest/src/runtest.rs</a>,
was modified as per below:</p>
<pre><code class="language-diff">@@ -295,11 +295,14 @@ impl&lt;'test&gt; TestCx&lt;'test&gt; {
     }

     fn check_correct_failure_status(&amp;self, proc_res: &amp;ProcRes) {
-        // The value the rust runtime returns on failure
-        const RUST_ERR: i32 = 101;
-        if proc_res.status.code() != Some(RUST_ERR) {
+        let expected_status = Some(self.props.failure_status);
+        let received_status = proc_res.status.code();
+
+        if expected_status != received_status {
             self.fatal_proc_rec(
-                &amp;format!(&quot;failure produced the wrong error: {}&quot;, proc_res.status),
+                &amp;format!(&quot;Error: expected failure status ({:?}) but received status {:?}.&quot;,
+                         expected_status,
+                         received_status),
                 proc_res,
             );
         }
@@ -320,7 +323,6 @@ impl&lt;'test&gt; TestCx&lt;'test&gt; {
         );

         let proc_res = self.exec_compiled_test();
-
         if !proc_res.status.success() {
             self.fatal_proc_rec(&quot;test run failed!&quot;, &amp;proc_res);
         }
@@ -499,7 +501,6 @@ impl&lt;'test&gt; TestCx&lt;'test&gt; {
                 expected,
                 actual
             );
-            panic!();
         }
     }
</code></pre>
<p>Note the use of <code>self.props.failure_status</code> to access the header command
property.  In tests which do not specify the failure status header command,
<code>self.props.failure_status</code> will evaluate to the default value of 101 at the
time of this writing.  But for a test which specifies a header command of, for
example, <code>// failure-status: 1</code>, <code>self.props.failure_status</code> will evaluate to
1, as <code>parse_failure_status()</code> will have overridden the <code>TestProps</code> default
value, for that test specifically.</p>
<h1><a class="header" href="#walkthrough-a-typical-contribution" id="walkthrough-a-typical-contribution">Walkthrough: a typical contribution</a></h1>
<p>There are <em>a lot</em> of ways to contribute to the rust compiler, including fixing
bugs, improving performance, helping design features, providing feedback on
existing features, etc. This chapter does not claim to scratch the surface.
Instead, it walks through the design and implementation of a new feature. Not
all of the steps and processes described here are needed for every
contribution, and I will try to point those out as they arise.</p>
<p>In general, if you are interested in making a contribution and aren't sure
where to start, please feel free to ask!</p>
<h2><a class="header" href="#overview" id="overview">Overview</a></h2>
<p>The feature I will discuss in this chapter is the <code>?</code> Kleene operator for
macros. Basically, we want to be able to write something like this:</p>
<pre><code class="language-rust ignore">macro_rules! foo {
    ($arg:ident $(, $optional_arg:ident)?) =&gt; {
        println!(&quot;{}&quot;, $arg);

        $(
            println!(&quot;{}&quot;, $optional_arg);
        )?
    }
}

fn main() {
    let x = 0;
    foo!(x); // ok! prints &quot;0&quot;
    foo!(x, x); // ok! prints &quot;0 0&quot;
}
</code></pre>
<p>So basically, the <code>$(pat)?</code> matcher in the macro means &quot;this pattern can occur
0 or 1 times&quot;, similar to other regex syntaxes.</p>
<p>There were a number of steps to go from an idea to stable rust feature. Here is
a quick list.  We will go through each of these in order below. As I mentioned
before, not all of these are needed for every type of contribution.</p>
<ul>
<li><strong>Idea discussion/Pre-RFC</strong>  A Pre-RFC is an early draft or design discussion
of a feature. This stage is intended to flesh out the design space a bit and
get a grasp on the different merits and problems with an idea. It's a great
way to get early feedback on your idea before presenting it the wider
audience. You can find the original discussion <a href="https://internals.rust-lang.org/t/pre-rfc-at-most-one-repetition-macro-patterns/6557">here</a>.</li>
<li><strong>RFC</strong>  This is when you formally present your idea to the community for
consideration. You can find the RFC <a href="https://github.com/rust-lang/rfcs/pull/2298">here</a>.</li>
<li><strong>Implementation</strong> Implement your idea unstabley in the compiler. You can
find the original implementation <a href="https://github.com/rust-lang/rust/pull/47752">here</a>.</li>
<li><strong>Possibly iterate/refine</strong> As the community gets experience with your
feature on the nightly compiler and in <code>libstd</code>, there may be additional
feedback about design choice that might be adjusted. This particular feature
went <a href="https://github.com/rust-lang/rust/pull/49719">through</a> a <a href="https://github.com/rust-lang/rust/pull/51336">number</a> of <a href="https://github.com/rust-lang/rust/pull/51587">iterations</a>.</li>
<li><strong>Stabilization</strong> When your feature has baked enough, a rust team member may
<a href="https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613">propose to stabilize it</a>. If there is consensus, this is done.</li>
<li><strong>Relax</strong> Your feature is now a stable rust feature!</li>
</ul>
<h2><a class="header" href="#pre-rfc-and-rfc" id="pre-rfc-and-rfc">Pre-RFC and RFC</a></h2>
<blockquote>
<p>NOTE: In general, if you are not proposing a <em>new</em> feature or substantial
change to rust or the ecosystem, you don't need to follow the RFC process.
Instead, you can just jump to <a href="rustc-guide/walkthrough.html#impl">implementation</a>.</p>
<p>You can find the official guidelines for when to open an RFC <a href="https://github.com/rust-lang/rfcs#when-you-need-to-follow-this-process">here</a>.</p>
</blockquote>
<p>An RFC is a document that describes the feature or change you are proposing in
detail. Anyone can write an RFC; the process is the same for everyone,
including rust team members.</p>
<p>To open an RFC, open a PR on the
<a href="https://github.com/rust-lang/rfcs">rust-lang/rfcs</a> repo on GitHub. You can
find detailed instructions in the
<a href="https://github.com/rust-lang/rfcs#what-the-process-is">README</a>.</p>
<p>Before opening an RFC, you should do the research to &quot;flesh out&quot; your idea.
Hastily-proposed RFCs tend not to be accepted. You should generally have a good
description of the motivation, impact, disadvantages, and potential
interactions with other features.</p>
<p>If that sounds like a lot of work, it's because it is. But no fear! Even if
you're not a compiler hacker, you can get great feedback by doing a <em>pre-RFC</em>.
This is an <em>informal</em> discussion of the idea. The best place to do this is
internals.rust-lang.org. Your post doesn't have to follow any particular
structure.  It doesn't even need to be a cohesive idea. Generally, you will get
tons of feedback that you can integrate back to produce a good RFC.</p>
<p>(Another pro-tip: try searching the RFCs repo and internals for prior related
ideas. A lot of times an idea has already been considered and was either
rejected or postponed to be tried again later. This can save you and everybody
else some time)</p>
<p>In the case of our example, a participant in the pre-RFC thread pointed out a
syntax ambiguity and a potential resolution. Also, the overall feedback seemed
positive. In this case, the discussion converged pretty quickly, but for some
ideas, a lot more discussion can happen (e.g. see <a href="https://github.com/rust-lang/rfcs/pull/2457">this RFC</a> which
received a whopping 684 comments!). If that happens, don't be discouraged; it
means the community is interested in your idea, but it perhaps needs some
adjustments.</p>
<p>The RFC for our <code>?</code> macro feature did receive some discussion on the RFC thread
too.  As with most RFCs, there were a few questions that we couldn't answer by
discussion: we needed experience using the feature to decide. Such questions
are listed in the &quot;Unresolved Questions&quot; section of the RFC. Also, over the
course of the RFC discussion, you will probably want to update the RFC document
itself to reflect the course of the discussion (e.g. new alternatives or prior
work may be added or you may decide to change parts of the proposal itself).</p>
<p>In the end, when the discussion seems to reach a consensus and die down a bit,
a rust team member may propose to move to FCP with one of three possible dispositions.
This means that they want the other members of the appropriate teams to review
and comment on the RFC. More discussion may ensue, which may result in more changes
or unresolved questions being added. At some point, when everyone is
satisfied, the RFC enters the &quot;final comment period&quot; (FCP), which is the last
chance for people to bring up objections. When the FCP is over, the disposition is
adopted. Here are the three possible dispositions:</p>
<ul>
<li><em>Merge</em>: accept the feature. Here is the proposal to merge for our <a href="https://github.com/rust-lang/rfcs/pull/2298#issuecomment-360582667"><code>?</code> macro
feature</a>.</li>
<li><em>Close</em>: this feature in its current form is not a good fit for rust. Don't
be discouraged if this happens to your RFC, and don't take it personally.
This is not a reflection on you, but rather a community decision that rust
will go a different direction.</li>
<li><em>Postpone</em>: there is interest in going this direction but not at the moment.
This happens most often because the appropriate rust team doesn't have the
bandwidth to shepherd the feature through the process to stabilization. Often
this is the case when the feature doesn't fit into the team's roadmap.
Postponed ideas may be revisited later.</li>
</ul>
<p>When an RFC is merged, the PR is merged into the RFCs repo. A new <em>tracking
issue</em> is created in the <a href="https://github.com/rust-lang/rust">rust-lang/rust</a> repo to track progress on the feature
and discuss unresolved questions, implementation progress and blockers, etc.
Here is the tracking issue on for our <a href="https://github.com/rust-lang/rust/issues/48075"><code>?</code> macro feature</a>.</p>
<p><a name="impl"></a></p>
<h2><a class="header" href="#implementation-1" id="implementation-1">Implementation</a></h2>
<p>To make a change to the compiler, open a PR against the <a href="https://github.com/rust-lang/rust">rust-lang/rust</a> repo.</p>
<p>Depending on the feature/change/bug fix/improvement, implementation may be
relatively-straightforward or it may be a major undertaking. You can always ask
for help or mentorship from more experienced compiler devs.  Also, you don't
have to be the one to implement your feature; but keep in mind that if you
don't it might be a while before someone else does.</p>
<p>For the <code>?</code> macro feature, I needed to go understand the relevant parts of
macro expansion in the compiler. Personally, I find that <a href="https://github.com/rust-lang/rust/pull/47732">improving the
comments</a> in the code is a helpful way of making sure I understand
it, but you don't have to do that if you don't want to.</p>
<p>I then <a href="https://github.com/rust-lang/rust/pull/47752">implemented</a> the original feature, as described in the RFC. When
a new feature is implemented, it goes behind a <em>feature gate</em>, which means that
you have to use <code>#![feature(my_feature_name)]</code> to use the feature. The feature
gate is removed when the feature is stabilized.</p>
<p><strong>Most bug fixes and improvements</strong> don't require a feature gate. You can just
make your changes/improvements.</p>
<p>When you open a PR on the <a href="https://github.com/rust-lang/rust">rust-lang/rust</a>, a bot will assign your PR to a
review. If there is a particular rust team member you are working with, you can
request that reviewer by leaving a comment on the thread with <code>r? @reviewer-github-id</code> (e.g. <code>r? @eddyb</code>). If you don't know who to request,
don't request anyone; the bot will assign someone automatically.</p>
<p>The reviewer may request changes before they approve your PR. Feel free to ask
questions or discuss things you don't understand or disagree with. However,
recognize that the PR won't be merged unless someone on the rust team approves
it.</p>
<p>When your review approves the PR, it will go into a queue for yet another bot
called <code>@bors</code>.  <code>@bors</code> manages the CI build/merge queue. When your PR reaches
the head of the <code>@bors</code> queue, <code>@bors</code> will test out the merge by running all
tests against your PR on Travis CI. This takes about 2 hours as of this
writing.  If all tests pass, the PR is merged and becomes part of the next
nightly compiler!</p>
<p>There are a couple of things that may happen for some PRs during the review process</p>
<ul>
<li>If the change is substantial enough, the reviewer may request an FCP on
the PR. This gives all members of the appropriate team a chance to review the
changes.</li>
<li>If the change may cause breakage, the reviewer may request a <a href="rustc-guide/./tests/intro.html#crater">crater</a> run.
This compiles the compiler with your changes and then attempts to compile all
crates on crates.io with your modified compiler. This is a great smoke test
to check if you introduced a change to compiler behavior that affects a large
portion of the ecosystem.</li>
<li>If the diff of your PR is large or the reviewer is busy, your PR may have
some merge conflicts with other PRs that happen to get merged first. You
should fix these merge conflicts using the normal git procedures.</li>
</ul>
<p>If you are not doing a new feature or something like that (e.g. if you are
fixing a bug), then that's it! Thanks for your contribution :)</p>
<h2><a class="header" href="#refining-your-implementation" id="refining-your-implementation">Refining your implementation</a></h2>
<p>As people get experience with your new feature on nightly, slight changes may
be proposed and unresolved questions may become resolved. Updates/changes go
through the same process for implementing any other changes, as described
above (i.e. submit a PR, go through review, wait for <code>@bors</code>, etc).</p>
<p>Some changes may be major enough to require an FCP and some review by rust team
members.</p>
<p>For the <code>?</code> macro feature, we went through a few different iterations after the
original implementation: <a href="https://github.com/rust-lang/rust/pull/49719">1</a>, <a href="https://github.com/rust-lang/rust/pull/51336">2</a>, <a href="https://github.com/rust-lang/rust/pull/51587">3</a>.</p>
<p>Along the way, we decided that <code>?</code> should not take a separator, which was
previously an unresolved question listed in the RFC. We also changed the
disambiguation strategy: we decided to remove the ability to use <code>?</code> as a
separator token for other repetition operators (e.g. <code>+</code> or <code>*</code>). However,
since this was a breaking change, we decided to do it over an edition boundary.
Thus, the new feature can be enabled only in edition 2018. These deviations
from the original RFC required <a href="https://github.com/rust-lang/rust/issues/51934">another
FCP</a>.</p>
<h2><a class="header" href="#stabilization" id="stabilization">Stabilization</a></h2>
<p>Finally, after the feature had baked for a while on nightly, a language team member
<a href="https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613">moved to stabilize it</a>.</p>
<p>A <em>stabilization report</em> needs to be written that includes</p>
<ul>
<li>brief description of the behavior and any deviations from the RFC</li>
<li>which edition(s) are affected and how</li>
<li>links to a few tests to show the interesting aspects</li>
</ul>
<p>The stabilization report for our feature is <a href="https://github.com/rust-lang/rust/issues/48075#issuecomment-433243048">here</a>.</p>
<p>After this, <a href="https://github.com/rust-lang/rust/pull/56245">a PR is made</a> to remove the feature gate, enabling the feature by
default (on the 2018 edition). A note is added to the <a href="https://github.com/rust-lang/rust/blob/master/RELEASES.md">Release notes</a>
about the feature.</p>
<p>Steps to stabilize the feature can be found at <a href="rustc-guide/./stabilization_guide.html">Stabilizing Features</a>.</p>
<h1><a class="header" href="#implement-new-feature" id="implement-new-feature">Implement New Feature</a></h1>
<p>When you want to implement a new significant feature in the compiler,
you need to go through this process to make sure everything goes
smoothly.</p>
<h2><a class="header" href="#the-rfcbot-pfcp-process" id="the-rfcbot-pfcp-process">The @rfcbot (p)FCP process</a></h2>
<p>When the change is small and uncontroversial, then it can be done
with just writing a PR and getting r+ from someone who knows that
part of the code. However, if the change is potentially controversial,
it would be a bad idea to push it without consensus from the rest
of the team (both in the &quot;distributed system&quot; sense to make sure
you don't break anything you don't know about, and in the social
sense to avoid PR fights).</p>
<p>If such a change seems to be too small to require a full formal RFC
process (e.g. a big refactoring of the code, or a
&quot;technically-breaking&quot; change, or a &quot;big bugfix&quot; that basically
amounts to a small feature) but is still too controversial or
big to get by with a single r+, you can start a pFCP (or, if you
don't have r+ rights, ask someone who has them to start one - and
unless they have a concern themselves, they should).</p>
<p>Again, the pFCP process is only needed if you need consensus - if you
don't think anyone would have a problem with your change, it's ok to
get by with only an r+. For example, it is OK to add or modify
unstable command-line flags or attributes without an pFCP for
compiler development or standard library use, as long as you don't
expect them to be in wide use in the nightly ecosystem.</p>
<p>You don't need to have the implementation fully ready for r+ to ask
for a pFCP, but it is generally a good idea to have at least a proof
of concept so that people can see what you are talking about.</p>
<p>That starts a &quot;proposed final comment period&quot; (pFCP), which requires
all members of the team to sign off the FCP. After they all do so,
there's a week long &quot;final comment period&quot; where everybody can comment,
and if no new concerns are raised, the PR/issue gets FCP approval.</p>
<h2><a class="header" href="#the-logistics-of-writing-features" id="the-logistics-of-writing-features">The logistics of writing features</a></h2>
<p>There are a few &quot;logistic&quot; hoops you might need to go through in
order to implement a feature in a working way.</p>
<h3><a class="header" href="#warning-cycles" id="warning-cycles">Warning Cycles</a></h3>
<p>In some cases, a feature or bugfix might break some existing programs
in some edge cases. In that case, you might want to do a crater run
to assess the impact and possibly add a future-compatibility lint,
similar to those used for
<a href="rustc-guide/diagnostics.html#edition-gated-lints">edition-gated lints</a>.</p>
<h3><a class="header" href="#stability" id="stability">Stability</a></h3>
<p>We <a href="https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md">value the stability of Rust</a>. Code that works and runs on stable
should (mostly) not break. Because of that, we don't want to release
a feature to the world with only team consensus and code review -
we want to gain real-world experience on using that feature on nightly,
and we might want to change the feature based on that experience.</p>
<p>To allow for that, we must make sure users don't accidentally depend
on that new feature - otherwise, especially if experimentation takes
time or is delayed and the feature takes the trains to stable,
it would end up de facto stable and we'll not be able to make changes
in it without breaking people's code.</p>
<p>The way we do that is that we make sure all new features are feature
gated - they can't be used without a enabling a feature gate
(<code>#[feature(foo)]</code>), which can't be done in a stable/beta compiler.
See the <a href="rustc-guide/implementing_new_features.html#stability-in-code">stability in code</a> section for the technical details.</p>
<p>Eventually, after we gain enough experience using the feature,
make the necessary changes, and are satisfied, we expose it to
the world using the stabilization process described <a href="https://rust-lang.github.io/rustc-guide/stabilization_guide.html">here</a>.
Until then, the feature is not set in stone: every part of the
feature can be changed, or the feature might be completely
rewritten or removed. Features are not supposed to gain tenure
by being unstable and unchanged for a year.</p>
<p><a name = "tracking-issue"></a></p>
<h3><a class="header" href="#tracking-issues" id="tracking-issues">Tracking Issues</a></h3>
<p>To keep track of the status of an unstable feature, the
experience we get while using it on nightly, and of the
concerns that block its stabilization, every feature-gate
needs a tracking issue.</p>
<p>General discussions about the feature should be done on
the tracking issue.</p>
<p>For features that have an RFC, you should use the RFC's
tracking issue for the feature.</p>
<p>For other features, you'll have to make a tracking issue
for that feature. The issue title should be &quot;Tracking issue
for YOUR FEATURE&quot;.</p>
<p>For tracking issues for features (as opposed to future-compat
warnings), I don't think the description has to contain
anything specific. Generally we put the list of items required
for stabilization using a github list, e.g.</p>
<pre><code class="language-txt">    **Steps:**

    - [ ] Implement the RFC (cc @rust-lang/compiler -- can anyone write
          up mentoring instructions?)
    - [ ] Adjust documentation ([see instructions on forge][doc-guide])
    - Note: no stabilization step here.
</code></pre>
<p><a name="stability-in-code"></a></p>
<h2><a class="header" href="#stability-in-code" id="stability-in-code">Stability in code</a></h2>
<p>The below steps needs to be followed in order to implement
a new unstable feature:</p>
<ol>
<li>
<p>Open a <a href="rustc-guide/implementing_new_features.html#tracking-issue">tracking issue</a> -
if you have an RFC, you can use the tracking issue for the RFC.</p>
</li>
<li>
<p>Pick a name for the feature gate (for RFCs, use the name
in the RFC).</p>
</li>
<li>
<p>Add a feature gate declaration to <code>libsyntax/feature_gate.rs</code>
in the active <code>declare_features</code> block:</p>
</li>
</ol>
<pre><code class="language-rust ignore">    // description of feature
    (active, $feature_name, &quot;$current_nightly_version&quot;, Some($tracking_issue_number), $edition)
</code></pre>
<p>where <code>$edition</code> has the type <code>Option&lt;Edition&gt;</code>, and is typically
just <code>None</code>.</p>
<p>For example:</p>
<pre><code class="language-rust ignore">    // allow '|' at beginning of match arms (RFC 1925)
(   active, match_beginning_vert, &quot;1.21.0&quot;, Some(44101), None),
</code></pre>
<p>The current version is not actually important – the important
version is when you are stabilizing a feature.</p>
<ol start="4">
<li>
<p>Prevent usage of the new feature unless the feature gate is set.
You can check it in most places in the compiler using the
expression <code>tcx.features().$feature_name</code> (or
<code>sess.features_untracked().$feature_name</code> if the
tcx is unavailable)</p>
<p>If the feature gate is not set, you should either maintain
the pre-feature behavior or raise an error, depending on
what makes sense.</p>
</li>
<li>
<p>Add a test to ensure the feature cannot be used without
a feature gate, by creating <code>feature-gate-$feature_name.rs</code>
and <code>feature-gate-$feature_name.stderr</code> files under the
<code>src/test/ui/feature-gates</code> directory.</p>
</li>
<li>
<p>Add a section to the unstable book, in
<code>src/doc/unstable-book/src/language-features/$feature_name.md</code>.</p>
</li>
<li>
<p>Write a lots of tests for the new feature.
PRs without tests will not be accepted!</p>
</li>
<li>
<p>Get your PR reviewed and land it. You have now successfully
implemented a feature in Rust!</p>
</li>
</ol>
<h1><a class="header" href="#request-for-stabilization" id="request-for-stabilization">Request for stabilization</a></h1>
<p>Once an unstable feature has been well-tested with no outstanding
concern, anyone may push for its stabilization. It involves the
following steps.</p>
<ul>
<li>Documentation PRs</li>
<li>Write a stabilization report</li>
<li>FCP</li>
<li>Stabilization PR</li>
</ul>
<h2><a class="header" href="#documentation-prs" id="documentation-prs">Documentation PRs</a></h2>
<p><a name="updating-documentation"></a></p>
<p>If any documentation for this feature exists, it should be
in the <a href="https://doc.rust-lang.org/unstable-book/index.html"><code>Unstable Book</code></a>, located at <a href="https://github.com/rust-lang/rust/tree/master/src/doc/unstable-book"><code>src/doc/unstable-book</code></a>.
If it exists, the page for the feature gate should be removed.</p>
<p>If there was documentation there, integrating it into the
existing documentation is needed.</p>
<p>If there wasn't documentation there, it needs to be added.</p>
<p>Places that may need updated documentation:</p>
<ul>
<li><a href="https://github.com/rust-lang-nursery/reference">The Reference</a>: This must be updated, in full detail.</li>
<li><a href="https://github.com/rust-lang/book">The Book</a>: This may or may not need updating, depends.
If you're not sure, please open an issue on this repository
and it can be discussed.</li>
<li>standard library documentation: As needed. Language features
often don't need this, but if it's a feature that changes
how good examples are written, such as when <code>?</code> was added
to the language, updating examples is important.</li>
<li><a href="https://github.com/rust-lang/rust-by-example">Rust by Example</a>: As needed.</li>
</ul>
<p>Prepare PRs to update documentations invovling this new feature
for  repositories mentioned above. Maintainers of these repositories
will keep these PRs open until the whole stabilization process
has completed. Meanwhile, we can proceed to the next step.</p>
<h2><a class="header" href="#write-a-stabilization-report" id="write-a-stabilization-report">Write a stabilization report</a></h2>
<p>Find the tracking issue of the feature, and create a short
stabilization report. Essentially this would be a brief summary
of the feature plus some links to test cases showing it works
as expected, along with a list of edge cases that came up and
and were considered. This is a minimal &quot;due diligence&quot; that
we do before stabilizing.</p>
<p>The report should contain:</p>
<ul>
<li>A summary, showing examples (e.g. code snippets) what is
enabled by this feature.</li>
<li>Links to test cases in our test suite regarding this feature
and describe the feature's behavior on encountering edge cases.</li>
<li>Links to the documentations (the PRs we have made in the
previous steps).</li>
<li>Any other relevant information(Examples of such reports can
be found in rust-lang/rust#44494 and rust-lang/rust#28237).</li>
<li>The resolutions of any unresolved questions if the stabilization
is for an RFC.</li>
</ul>
<h2><a class="header" href="#fcp" id="fcp">FCP</a></h2>
<p>If any member of the team responsible for tracking this
feature agrees with stabilizing this feature, they will
start the FCP (final-comment-period) process by commenting</p>
<pre><code class="language-bash">@rfcbot fcp merge
</code></pre>
<p>The rest of the team members will review the proposal. If the final
decision is to stabilize, we proceed to do the actual code modification.</p>
<h2><a class="header" href="#stabilization-pr" id="stabilization-pr">Stabilization PR</a></h2>
<p>Once we have decided to stabilize a feature, we need to have
a PR that actually makes that stabilization happen. These kinds
of PRs are a great way to get involved in Rust, as they take
you on a little tour through the source code.</p>
<p>Here is a general guide to how to stabilize a feature --
every feature is different, of course, so some features may
require steps beyond what this guide talks about.</p>
<p>Note: Before we stabilize any feature, it's the rule that it
should appear in the documentation.</p>
<h3><a class="header" href="#updating-the-feature-gate-listing" id="updating-the-feature-gate-listing">Updating the feature-gate listing</a></h3>
<p>There is a central listing of feature-gates in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/feature_gate/index.html"><code>src/libsyntax/feature_gate.rs</code></a>. Search for the <code>declare_features!</code>
macro. There should be an entry for the feature you are aiming
to stabilize, something like (this example is taken from
<a href="https://github.com/rust-lang/rust/issues/32409">rust-lang/rust#32409</a>:</p>
<pre><code class="language-rust ignore">// pub(restricted) visibilities (RFC 1422)
(active, pub_restricted, &quot;1.9.0&quot;, Some(32409)),
</code></pre>
<p>The above line should be moved down to the area for &quot;accepted&quot;
features, declared below in a separate call to <code>declare_features!</code>.
When it is done, it should look like:</p>
<pre><code class="language-rust ignore">// pub(restricted) visibilities (RFC 1422)
(accepted, pub_restricted, &quot;1.31.0&quot;, Some(32409)),
// note that we changed this
</code></pre>
<p>Note that, the version number is updated to be the version number
of the stable release where this feature will appear. This can be
found by consulting <a href="https://forge.rust-lang.org/">the forge</a>, which will guide
you the next stable release number. You want to add 1 to that,
because the code that lands today will become go into beta on that
date, and then become stable after that. So, at the time of this
writing, the next stable release (i.e. what is currently beta) was
1.30.0, hence I wrote 1.31.0 above.</p>
<h3><a class="header" href="#removing-existing-uses-of-the-feature-gate" id="removing-existing-uses-of-the-feature-gate">Removing existing uses of the feature-gate</a></h3>
<p>Next search for the feature string (in this case, <code>pub_restricted</code>)
in the codebase to find where it appears. Change uses of
<code>#![feature(XXX)]</code> from the <code>libstd</code> and any rustc crates to be
<code>#![cfg_attr(bootstrap, feature(XXX))]</code>. This includes the feature-gate
only for stage0, which is built using the current beta (this is
needed because the feature is still unstable in the current beta).</p>
<p>Also, remove those strings from any tests. If there are tests
specifically targeting the feature-gate (i.e., testing that the
feature-gate is required to use the feature, but nothing else),
simply remove the test.</p>
<h3><a class="header" href="#do-not-require-the-feature-gate-to-use-the-feature" id="do-not-require-the-feature-gate-to-use-the-feature">Do not require the feature-gate to use the feature</a></h3>
<p>Most importantly, remove the code which flags an error if the
feature-gate is not present (since the feature is now considered
stable). If the feature can be detected because it employs some
new syntax, then a common place for that code to be is in the
same <code>feature_gate.rs</code>. For example, you might see code like this:</p>
<pre><code class="language-rust ignore">gate_feature_post!(&amp;self, pub_restricted, span,
 &quot;`pub(restricted)` syntax is experimental&quot;);
</code></pre>
<p>This <code>gate_feature_post!</code> macro prints an error if the
<code>pub_restricted</code> feature is not enabled. It is not needed
now that <code>#[pub_restricted]</code> is stable.</p>
<p>For more subtle features, you may find code like this:</p>
<pre><code class="language-rust ignore">if self.tcx.sess.features.borrow().pub_restricted { /* XXX */ }
</code></pre>
<p>This <code>pub_restricted</code> field (obviously named after the feature)
would ordinarily be false if the feature flag is not present
and true if it is. So transform the code to assume that the field
is true. In this case, that would mean removing the <code>if</code> and
leaving just the <code>/* XXX */</code>.</p>
<pre><code class="language-rust ignore">if self.tcx.sess.features.borrow().pub_restricted { /* XXX */ }
becomes
/* XXX */

if self.tcx.sess.features.borrow().pub_restricted &amp;&amp; something { /* XXX */ }
 becomes
if something { /* XXX */ }
</code></pre>
<h1><a class="header" href="#debugging-the-compiler" id="debugging-the-compiler">Debugging the compiler</a></h1>
<p>This chapter contains a few tips to debug the compiler. These tips aim to be
useful no matter what you are working on.  Some of the other chapters have
advice about specific parts of the compiler (e.g. the <a href="rustc-guide/./incrcomp-debugging.html">Queries Debugging and
Testing
chapter</a> or
the <a href="rustc-guide/./codegen/debugging.html">LLVM Debugging chapter</a>).</p>
<h2><a class="header" href="#-z-flags" id="-z-flags"><code>-Z</code> flags</a></h2>
<p>The compiler has a bunch of <code>-Z</code> flags. These are unstable flags that are only
enabled on nightly. Many of them are useful for debugging. To get a full listing
of <code>-Z</code> flags, use <code>-Z help</code>.</p>
<p>One useful flag is <code>-Z verbose</code>, which generally enables printing more info that
could be useful for debugging.</p>
<h2><a class="header" href="#getting-a-backtrace" id="getting-a-backtrace">Getting a backtrace</a></h2>
<p>When you have an ICE (panic in the compiler), you can set
<code>RUST_BACKTRACE=1</code> to get the stack trace of the <code>panic!</code> like in
normal Rust programs.  IIRC backtraces <strong>don't work</strong> on Mac and on MinGW,
sorry. If you have trouble or the backtraces are full of <code>unknown</code>,
you might want to find some way to use Linux or MSVC on Windows.</p>
<p>In the default configuration, you don't have line numbers enabled, so the
backtrace looks like this:</p>
<pre><code class="language-text">stack backtrace:
   0: std::sys::imp::backtrace::tracing::imp::unwind_backtrace
   1: std::sys_common::backtrace::_print
   2: std::panicking::default_hook::{{closure}}
   3: std::panicking::default_hook
   4: std::panicking::rust_panic_with_hook
   5: std::panicking::begin_panic
   (~~~~ LINES REMOVED BY ME FOR BREVITY ~~~~)
  32: rustc_typeck::check_crate
  33: &lt;std::thread::local::LocalKey&lt;T&gt;&gt;::with
  34: &lt;std::thread::local::LocalKey&lt;T&gt;&gt;::with
  35: rustc::ty::context::TyCtxt::create_and_enter
  36: rustc_driver::driver::compile_input
  37: rustc_driver::run_compiler
</code></pre>
<p>If you want line numbers for the stack trace, you can enable <code>debug = true</code> in
your config.toml and rebuild the compiler (<code>debuginfo-level = 1</code> will also add
line numbers, but <code>debug = true</code> gives full debuginfo). Then the backtrace will
look like this:</p>
<pre><code class="language-text">stack backtrace:
   (~~~~ LINES REMOVED BY ME FOR BREVITY ~~~~)
             at /home/user/rust/src/librustc_typeck/check/cast.rs:110
   7: rustc_typeck::check::cast::CastCheck::check
             at /home/user/rust/src/librustc_typeck/check/cast.rs:572
             at /home/user/rust/src/librustc_typeck/check/cast.rs:460
             at /home/user/rust/src/librustc_typeck/check/cast.rs:370
   (~~~~ LINES REMOVED BY ME FOR BREVITY ~~~~)
  33: rustc_driver::driver::compile_input
             at /home/user/rust/src/librustc_driver/driver.rs:1010
             at /home/user/rust/src/librustc_driver/driver.rs:212
  34: rustc_driver::run_compiler
             at /home/user/rust/src/librustc_driver/lib.rs:253
</code></pre>
<h2><a class="header" href="#getting-a-backtrace-for-errors" id="getting-a-backtrace-for-errors">Getting a backtrace for errors</a></h2>
<p>If you want to get a backtrace to the point where the compiler emits
an error message, you can pass the <code>-Z treat-err-as-bug=n</code>, which
will make the compiler skip <code>n</code> errors or <code>delay_span_bug</code> calls and then
panic on the next one. If you leave off <code>=n</code>, the compiler will assume <code>0</code> for
<code>n</code> and thus panic on the first error it encounters.</p>
<p>This can also help when debugging <code>delay_span_bug</code> calls - it will make
the first <code>delay_span_bug</code> call panic, which will give you a useful backtrace.</p>
<p>For example:</p>
<pre><code class="language-bash">$ cat error.rs
fn main() {
    1 + ();
}
</code></pre>
<pre><code class="language-bash">$ ./build/x86_64-unknown-linux-gnu/stage1/bin/rustc error.rs
error[E0277]: the trait bound `{integer}: std::ops::Add&lt;()&gt;` is not satisfied
 --&gt; error.rs:2:7
  |
2 |     1 + ();
  |       ^ no implementation for `{integer} + ()`
  |
  = help: the trait `std::ops::Add&lt;()&gt;` is not implemented for `{integer}`

error: aborting due to previous error

$ # Now, where does the error above come from?
$ RUST_BACKTRACE=1 \
    ./build/x86_64-unknown-linux-gnu/stage1/bin/rustc \
    error.rs \
    -Z treat-err-as-bug
error[E0277]: the trait bound `{integer}: std::ops::Add&lt;()&gt;` is not satisfied
 --&gt; error.rs:2:7
  |
2 |     1 + ();
  |       ^ no implementation for `{integer} + ()`
  |
  = help: the trait `std::ops::Add&lt;()&gt;` is not implemented for `{integer}`

error: internal compiler error: unexpected panic

note: the compiler unexpectedly panicked. this is a bug.

note: we would appreciate a bug report: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports

note: rustc 1.24.0-dev running on x86_64-unknown-linux-gnu

note: run with `RUST_BACKTRACE=1` for a backtrace

thread 'rustc' panicked at 'encountered error with `-Z treat_err_as_bug',
/home/user/rust/src/librustc_errors/lib.rs:411:12
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose
backtrace.
stack backtrace:
  (~~~ IRRELEVANT PART OF BACKTRACE REMOVED BY ME ~~~)
   7: rustc::traits::error_reporting::&lt;impl rustc::infer::InferCtxt&lt;'a, 'tcx&gt;&gt;
             ::report_selection_error
             at /home/user/rust/src/librustc/traits/error_reporting.rs:823
   8: rustc::traits::error_reporting::&lt;impl rustc::infer::InferCtxt&lt;'a, 'tcx&gt;&gt;
             ::report_fulfillment_errors
             at /home/user/rust/src/librustc/traits/error_reporting.rs:160
             at /home/user/rust/src/librustc/traits/error_reporting.rs:112
   9: rustc_typeck::check::FnCtxt::select_obligations_where_possible
             at /home/user/rust/src/librustc_typeck/check/mod.rs:2192
  (~~~ IRRELEVANT PART OF BACKTRACE REMOVED BY ME ~~~)
  36: rustc_driver::run_compiler
             at /home/user/rust/src/librustc_driver/lib.rs:253
$ # Cool, now I have a backtrace for the error
</code></pre>
<h2><a class="header" href="#getting-logging-output" id="getting-logging-output">Getting logging output</a></h2>
<p>These crates are used in compiler for logging:</p>
<ul>
<li><a href="https://docs.rs/log/0.4.6/log/index.html">log</a></li>
<li><a href="https://docs.rs/env_logger/0.4.3/env_logger/">env-logger</a>: check the link to see the full <code>RUSTC_LOG</code> syntax</li>
</ul>
<p>The compiler has a lot of <code>debug!</code> calls, which print out logging information
at many points. These are very useful to at least narrow down the location of
a bug if not to find it entirely, or just to orient yourself as to why the
compiler is doing a particular thing.</p>
<p>To see the logs, you need to set the <code>RUSTC_LOG</code> environment variable to
your log filter, e.g. to get the logs for a specific module, you can run the
compiler as <code>RUSTC_LOG=module::path rustc my-file.rs</code>. All <code>debug!</code> output will
then appear in standard error.</p>
<p><strong>Note that unless you use a very strict filter, the logger will emit a lot of
output, so use the most specific module(s) you can (comma-separated if
multiple)</strong>. It's typically a good idea to pipe standard error to a file and
look at the log output with a text editor.</p>
<p>So to put it together.</p>
<pre><code class="language-bash"># This puts the output of all debug calls in `librustc/traits` into
# standard error, which might fill your console backscroll.
$ RUSTC_LOG=rustc::traits rustc +local my-file.rs

# This puts the output of all debug calls in `librustc/traits` in
# `traits-log`, so you can then see it with a text editor.
$ RUSTC_LOG=rustc::traits rustc +local my-file.rs 2&gt;traits-log

# Not recommended. This will show the output of all `debug!` calls
# in the Rust compiler, and there are a *lot* of them, so it will be
# hard to find anything.
$ RUSTC_LOG=debug rustc +local my-file.rs 2&gt;all-log

# This will show the output of all `info!` calls in `rustc_trans`.
#
# There's an `info!` statement in `trans_instance` that outputs
# every function that is translated. This is useful to find out
# which function triggers an LLVM assertion, and this is an `info!`
# log rather than a `debug!` log so it will work on the official
# compilers.
$ RUSTC_LOG=rustc_trans=info rustc +local my-file.rs
</code></pre>
<h3><a class="header" href="#how-to-keep-or-remove-debug-and-trace-calls-from-the-resulting-binary" id="how-to-keep-or-remove-debug-and-trace-calls-from-the-resulting-binary">How to keep or remove <code>debug!</code> and <code>trace!</code> calls from the resulting binary</a></h3>
<p>While calls to <code>error!</code>, <code>warn!</code> and <code>info!</code> are included in every build of the compiler,
calls to <code>debug!</code> and <code>trace!</code> are only included in the program if
<code>debug-assertions=yes</code> is turned on in config.toml (it is
turned off by default), so if you don't see <code>DEBUG</code> logs, especially
if you run the compiler with <code>RUSTC_LOG=rustc rustc some.rs</code> and only see
<code>INFO</code> logs, make sure that <code>debug-assertions=yes</code> is turned on in your
config.toml.</p>
<p>I also think that in some cases just setting it will not trigger a rebuild,
so if you changed it and you already have a compiler built, you might
want to call <code>x.py clean</code> to force one.</p>
<h3><a class="header" href="#logging-etiquette-and-conventions" id="logging-etiquette-and-conventions">Logging etiquette and conventions</a></h3>
<p>Because calls to <code>debug!</code> are removed by default, in most cases, don't worry
about adding &quot;unnecessary&quot; calls to <code>debug!</code> and leaving them in code you
commit - they won't slow down the performance of what we ship, and if they
helped you pinning down a bug, they will probably help someone else with a
different one.</p>
<p>A loosely followed convention is to use <code>debug!(&quot;foo(...)&quot;)</code> at the <em>start</em> of
a function <code>foo</code> and <code>debug!(&quot;foo: ...&quot;)</code> <em>within</em> the function. Another
loosely followed convention is to use the <code>{:?}</code> format specifier for debug
logs.</p>
<p>One thing to be <strong>careful</strong> of is <strong>expensive</strong> operations in logs.</p>
<p>If in the module <code>rustc::foo</code> you have a statement</p>
<pre><code class="language-Rust">debug!(&quot;{:?}&quot;, random_operation(tcx));
</code></pre>
<p>Then if someone runs a debug <code>rustc</code> with <code>RUSTC_LOG=rustc::bar</code>, then
<code>random_operation()</code> will run.</p>
<p>This means that you should not put anything too expensive or likely to crash
there - that would annoy anyone who wants to use logging for their own module.
No-one will know it until someone tries to use logging to find <em>another</em> bug.</p>
<h2><a class="header" href="#formatting-graphviz-output-dot-files" id="formatting-graphviz-output-dot-files">Formatting Graphviz output (.dot files)</a></h2>
<p>Some compiler options for debugging specific features yield graphviz graphs -
e.g. the <code>#[rustc_mir(borrowck_graphviz_postflow=&quot;suffix.dot&quot;)]</code> attribute
dumps various borrow-checker dataflow graphs.</p>
<p>These all produce <code>.dot</code> files. To view these files, install graphviz (e.g.
<code>apt-get install graphviz</code>) and then run the following commands:</p>
<pre><code class="language-bash">$ dot -T pdf maybe_init_suffix.dot &gt; maybe_init_suffix.pdf
$ firefox maybe_init_suffix.pdf # Or your favorite pdf viewer
</code></pre>
<h2><a class="header" href="#narrowing-bisecting-regressions" id="narrowing-bisecting-regressions">Narrowing (Bisecting) Regressions</a></h2>
<p>The <a href="https://github.com/rust-lang-nursery/cargo-bisect-rustc">cargo-bisect-rustc</a> tool can be used as a quick and easy way to
find exactly which PR caused a change in <code>rustc</code> behavior. It automatically
downloads <code>rustc</code> PR artifacts and tests them against a project you provide
until it finds the regression. You can then look at the PR to get more context
on <em>why</em> it was changed.  See <a href="https://github.com/rust-lang-nursery/cargo-bisect-rustc/blob/master/TUTORIAL.md">this tutorial</a> on how to use
it.</p>
<h2><a class="header" href="#downloading-artifacts-from-rusts-ci" id="downloading-artifacts-from-rusts-ci">Downloading Artifacts from Rust's CI</a></h2>
<p>The <a href="https://github.com/kennytm/rustup-toolchain-install-master">rustup-toolchain-install-master</a> tool by kennytm can be used to
download the artifacts produced by Rust's CI for a specific SHA1 -- this
basically corresponds to the successful landing of some PR -- and then sets
them up for your local use. This also works for artifacts produced by <code>@bors try</code>. This is helpful when you want to examine the resulting build of a PR
without doing the build yourself.</p>
<h1><a class="header" href="#profiling-the-compiler" id="profiling-the-compiler">Profiling the compiler</a></h1>
<p>This discussion talks about how profile the compiler and find out
where it spends its time.  If you just want to get a general overview,
it is often a good idea to just add <code>-Zself-profile</code> option to the
rustc command line. This will break down time spent into various
categories.  But if you want a more detailed look, you probably want
to break out a custom profiler.</p>
<h1><a class="header" href="#profiling-with-perf" id="profiling-with-perf">Profiling with perf</a></h1>
<p>This is a guide for how to profile rustc with <a href="https://perf.wiki.kernel.org/index.php/Main_Page">perf</a>.</p>
<h2><a class="header" href="#initial-steps" id="initial-steps">Initial steps</a></h2>
<ul>
<li>Get a clean checkout of rust-lang/master, or whatever it is you want
to profile.</li>
<li>Set the following settings in your <code>config.toml</code>:
<ul>
<li><code>debuginfo-level = 1</code> - enables line debuginfo</li>
<li><code>use-jemalloc = false</code> - lets you do memory use profiling with valgrind</li>
<li>leave everything else the defaults</li>
</ul>
</li>
<li>Run <code>./x.py build</code> to get a full build</li>
<li>Make a rustup toolchain pointing to that result
<ul>
<li>see <a href="rustc-guide/profiling/../how-to-build-and-run.html#toolchain">the &quot;build and run&quot; section for instructions</a></li>
</ul>
</li>
</ul>
<h2><a class="header" href="#gathering-a-perf-profile" id="gathering-a-perf-profile">Gathering a perf profile</a></h2>
<p>perf is an excellent tool on linux that can be used to gather and
analyze all kinds of information. Mostly it is used to figure out
where a program spends its time. It can also be used for other sorts
of events, though, like cache misses and so forth.</p>
<h3><a class="header" href="#the-basics" id="the-basics">The basics</a></h3>
<p>The basic <code>perf</code> command is this:</p>
<pre><code class="language-bash">&gt; perf record -F99 --call-graph dwarf XXX
</code></pre>
<p>The <code>-F99</code> tells perf to sample at 99 Hz, which avoids generating too
much data for longer runs (why 99 Hz you ask? It is often chosen
because it is unlikely to be in lockstep with other periodic
activity). The <code>--call-graph dwarf</code> tells perf to get call-graph
information from debuginfo, which is accurate. The <code>XXX</code> is the
command you want to profile. So, for example, you might do:</p>
<pre><code class="language-bash">&gt; perf record -F99 --call-graph dwarf cargo +&lt;toolchain&gt; rustc
</code></pre>
<p>to run <code>cargo</code> -- here <code>&lt;toolchain&gt;</code> should be the name of the toolchain
you made in the beginning. But there are some things to be aware of:</p>
<ul>
<li>You probably don't want to profile the time spend building
dependencies. So something like <code>cargo build; cargo clean -p $C</code> may
be helpful (where <code>$C</code> is the crate name)
<ul>
<li>Though usually I just do <code>touch src/lib.rs</code> and rebuild instead. =)</li>
</ul>
</li>
<li>You probably don't want incremental messing about with your
profile. So something like <code>CARGO_INCREMENTAL=0</code> can be helpful.</li>
</ul>
<h3><a class="header" href="#gathering-a-perf-profile-from-a-perfrust-langorg-test" id="gathering-a-perf-profile-from-a-perfrust-langorg-test">Gathering a perf profile from a <code>perf.rust-lang.org</code> test</a></h3>
<p>Often we want to analyze a specific test from <code>perf.rust-lang.org</code>. To
do that, the first step is to clone
<a href="https://github.com/rust-lang-nursery/rustc-perf">the rustc-perf repository</a>:</p>
<pre><code class="language-bash">&gt; git clone https://github.com/rust-lang-nursery/rustc-perf
</code></pre>
<h4><a class="header" href="#doing-it-the-easy-way" id="doing-it-the-easy-way">Doing it the easy way</a></h4>
<p>Once you've cloned the repo, you can use the <code>collector</code> executable to
do profiling for you! You can find
<a href="https://github.com/rust-lang-nursery/rustc-perf/blob/master/collector/README.md#profiling">instructions in the rustc-perf readme</a>.</p>
<p>For example, to measure the clap-rs test, you might do:</p>
<pre><code class="language-bash">&gt; ./target/release/collector
    --output-repo /path/to/place/output
    profile perf-record
    --rustc /path/to/rustc/executable/from/your/build/directory
    --cargo `which cargo`
    --filter clap-rs
    --builds Check
</code></pre>
<p>You can also use that same command to use cachegrind or other profiling tools.</p>
<h4><a class="header" href="#doing-it-the-hard-way" id="doing-it-the-hard-way">Doing it the hard way</a></h4>
<p>If you prefer to run things manually, that is also possible. You first
need to find the source for the test you want. Sources for the tests
are found in <a href="https://github.com/rust-lang-nursery/rustc-perf/tree/master/collector/benchmarks">the <code>collector/benchmarks</code> directory</a>. So let's go
into the directory of a specific test; we'll use <code>clap-rs</code> as an
example:</p>
<pre><code class="language-bash">&gt; cd collector/benchmarks/clap-rs
</code></pre>
<p>In this case, let's say we want to profile the <code>cargo check</code>
performance. In that case, I would first run some basic commands to
build the dependencies:</p>
<pre><code class="language-bash"># Setup: first clean out any old results and build the dependencies:
&gt; cargo +&lt;toolchain&gt; clean
&gt; CARGO_INCREMENTAL=0 cargo +&lt;toolchain&gt; check
</code></pre>
<p>(Again, <code>&lt;toolchain&gt;</code> should be replaced with the name of the
toolchain we made in the first step.)</p>
<p>Next: we want record the execution time for <em>just</em> the clap-rs crate,
running cargo check. I tend to use <code>cargo rustc</code> for this, since it
also allows me to add explicit flags, which we'll do later on.</p>
<pre><code class="language-bash">&gt; touch src/lib.rs
&gt; CARGO_INCREMENTAL=0 perf record -F99 --call-graph dwarf cargo rustc --profile check --lib
</code></pre>
<p>Note that final command: it's a doozy! It uses the <code>cargo rustc</code>
command, which executes rustc with (potentially) additional options;
the <code>--profile check</code> and <code>--lib</code> options specify that we are doing a
<code>cargo check</code> execution, and that this is a library (not a binary).</p>
<p>At this point, we can use <code>perf</code> tooling to analyze the results. For example:</p>
<pre><code class="language-bash">&gt; perf report
</code></pre>
<p>will open up an interactive TUI program. In simple cases, that can be
helpful. For more detailed examination, the <a href="https://github.com/nikomatsakis/perf-focus"><code>perf-focus</code> tool</a>
can be helpful; it is covered below.</p>
<p><strong>A note of caution.</strong> Each of the rustc-perf tests is its own special
snowflake. In particular, some of them are not libraries, in which
case you would want to do <code>touch src/main.rs</code> and avoid passing
<code>--lib</code>. I'm not sure how best to tell which test is which to be
honest.</p>
<h3><a class="header" href="#gathering-nll-data" id="gathering-nll-data">Gathering NLL data</a></h3>
<p>If you want to profile an NLL run, you can just pass extra options to
the <code>cargo rustc</code> command, like so:</p>
<pre><code class="language-bash">&gt; touch src/lib.rs
&gt; CARGO_INCREMENTAL=0 perf record -F99 --call-graph dwarf cargo rustc --profile check --lib -- -Zborrowck=mir
</code></pre>
<h2><a class="header" href="#analyzing-a-perf-profile-with-perf-focus" id="analyzing-a-perf-profile-with-perf-focus">Analyzing a perf profile with <code>perf focus</code></a></h2>
<p>Once you've gathered a perf profile, we want to get some information
about it. For this, I personally use <a href="https://github.com/nikomatsakis/perf-focus">perf focus</a>. It's a kind of
simple but useful tool that lets you answer queries like:</p>
<ul>
<li>&quot;how much time was spent in function F&quot; (no matter where it was called from)</li>
<li>&quot;how much time was spent in function F when it was called from G&quot;</li>
<li>&quot;how much time was spent in function F <em>excluding</em> time spent in G&quot;</li>
<li>&quot;what functions does F call and how much time does it spend in them&quot;</li>
</ul>
<p>To understand how it works, you have to know just a bit about
perf. Basically, perf works by <em>sampling</em> your process on a regular
basis (or whenever some event occurs). For each sample, perf gathers a
backtrace. <code>perf focus</code> lets you write a regular expression that tests
which functions appear in that backtrace, and then tells you which
percentage of samples had a backtrace that met the regular
expression. It's probably easiest to explain by walking through how I
would analyze NLL performance.</p>
<h3><a class="header" href="#installing-perf-focus" id="installing-perf-focus">Installing <code>perf-focus</code></a></h3>
<p>You can install perf-focus using <code>cargo install</code>:</p>
<pre><code class="language-bash">&gt; cargo install perf-focus
</code></pre>
<h3><a class="header" href="#example-how-much-time-is-spent-in-mir-borrowck" id="example-how-much-time-is-spent-in-mir-borrowck">Example: How much time is spent in MIR borrowck?</a></h3>
<p>Let's say we've gathered the NLL data for a test. We'd like to know
how much time it is spending in the MIR borrow-checker. The &quot;main&quot;
function of the MIR borrowck is called <code>do_mir_borrowck</code>, so we can do
this command:</p>
<pre><code class="language-bash">&gt; perf focus '{do_mir_borrowck}'
Matcher    : {do_mir_borrowck}
Matches    : 228
Not Matches: 542
Percentage : 29%
</code></pre>
<p>The <code>'{do_mir_borrowck}'</code> argument is called the <strong>matcher</strong>. It
specifies the test to be applied on the backtrace. In this case, the
<code>{X}</code> indicates that there must be <em>some</em> function on the backtrace
that meets the regular expression <code>X</code>. In this case, that regex is
just the name of the function we want (in fact, it's a subset of the name;
the full name includes a bunch of other stuff, like the module
path). In this mode, perf-focus just prints out the percentage of
samples where <code>do_mir_borrowck</code> was on the stack: in this case, 29%.</p>
<p><strong>A note about c++filt.</strong> To get the data from <code>perf</code>, <code>perf focus</code>
currently executes <code>perf script</code> (perhaps there is a better
way...). I've sometimes found that <code>perf script</code> outputs C++ mangled
names. This is annoying. You can tell by running <code>perf script | head</code> yourself — if you see names like <code>5rustc6middle</code> instead of
<code>rustc::middle</code>, then you have the same problem. You can solve this
by doing:</p>
<pre><code class="language-bash">&gt; perf script | c++filt | perf focus --from-stdin ...
</code></pre>
<p>This will pipe the output from <code>perf script</code> through <code>c++filt</code> and
should mostly convert those names into a more friendly format. The
<code>--from-stdin</code> flag to <code>perf focus</code> tells it to get its data from
stdin, rather than executing <code>perf focus</code>. We should make this more
convenient (at worst, maybe add a <code>c++filt</code> option to <code>perf focus</code>, or
just always use it — it's pretty harmless).</p>
<h3><a class="header" href="#example-how-much-time-does-mir-borrowck-spend-solving-traits" id="example-how-much-time-does-mir-borrowck-spend-solving-traits">Example: How much time does MIR borrowck spend solving traits?</a></h3>
<p>Perhaps we'd like to know how much time MIR borrowck spends in the
trait checker. We can ask this using a more complex regex:</p>
<pre><code class="language-bash">&gt; perf focus '{do_mir_borrowck}..{^rustc::traits}'
Matcher    : {do_mir_borrowck},..{^rustc::traits}
Matches    : 12
Not Matches: 1311
Percentage : 0%
</code></pre>
<p>Here we used the <code>..</code> operator to ask &quot;how often do we have
<code>do_mir_borrowck</code> on the stack and then, later, some function whose
name begins with <code>rusc::traits</code>?&quot; (basically, code in that module). It
turns out the answer is &quot;almost never&quot; — only 12 samples fit that
description (if you ever see <em>no</em> samples, that often indicates your
query is messed up).</p>
<p>If you're curious, you can find out exactly which samples by using the
<code>--print-match</code> option. This will print out the full backtrace for
each sample. The <code>|</code> at the front of the line indicates the part that
the regular expression matched.</p>
<h3><a class="header" href="#example-where-does-mir-borrowck-spend-its-time" id="example-where-does-mir-borrowck-spend-its-time">Example: Where does MIR borrowck spend its time?</a></h3>
<p>Often we want to do a more &quot;explorational&quot; queries. Like, we know that
MIR borrowck is 29% of the time, but where does that time get spent?
For that, the <code>--tree-callees</code> option is often the best tool. You
usually also want to give <code>--tree-min-percent</code> or
<code>--tree-max-depth</code>. The result looks like this:</p>
<pre><code class="language-bash">&gt; perf focus '{do_mir_borrowck}' --tree-callees --tree-min-percent 3
Matcher    : {do_mir_borrowck}
Matches    : 577
Not Matches: 746
Percentage : 43%

Tree
| matched `{do_mir_borrowck}` (43% total, 0% self)
: | rustc_mir::borrow_check::nll::compute_regions (20% total, 0% self)
: : | rustc_mir::borrow_check::nll::type_check::type_check_internal (13% total, 0% self)
: : : | core::ops::function::FnOnce::call_once (5% total, 0% self)
: : : : | rustc_mir::borrow_check::nll::type_check::liveness::generate (5% total, 3% self)
: : : | &lt;rustc_mir::borrow_check::nll::type_check::TypeVerifier&lt;'a, 'b, 'tcx&gt; as rustc::mir::visit::Visitor&lt;'tcx&gt;&gt;::visit_mir (3% total, 0% self)
: | rustc::mir::visit::Visitor::visit_mir (8% total, 6% self)
: | &lt;rustc_mir::borrow_check::MirBorrowckCtxt&lt;'cx, 'tcx&gt; as rustc_mir::dataflow::DataflowResultsConsumer&lt;'cx, 'tcx&gt;&gt;::visit_statement_entry (5% total, 0% self)
: | rustc_mir::dataflow::do_dataflow (3% total, 0% self)
</code></pre>
<p>What happens with <code>--tree-callees</code> is that</p>
<ul>
<li>we find each sample matching the regular expression</li>
<li>we look at the code that is occurs <em>after</em> the regex match and try
to build up a call tree</li>
</ul>
<p>The <code>--tree-min-percent 3</code> option says &quot;only show me things that take
more than 3% of the time. Without this, the tree often gets really
noisy and includes random stuff like the innards of
malloc. <code>--tree-max-depth</code> can be useful too, it just limits how many
levels we print.</p>
<p>For each line, we display the percent of time in that function
altogether (&quot;total&quot;) and the percent of time spent in <strong>just that
function and not some callee of that function</strong> (self). Usually
&quot;total&quot; is the more interesting number, but not always.</p>
<h3><a class="header" href="#relative-percentages" id="relative-percentages">Relative percentages</a></h3>
<p>By default, all in perf-focus are relative to the <strong>total program
execution</strong>. This is useful to help you keep perspective — often as
we drill down to find hot spots, we can lose sight of the fact that,
in terms of overall program execution, this &quot;hot spot&quot; is actually not
important. It also ensures that percentages between different queries
are easily compared against one another.</p>
<p>That said, sometimes it's useful to get relative percentages, so <code>perf focus</code> offers a <code>--relative</code> option. In this case, the percentages are
listed only for samples that match (vs all samples). So for example we
could get our percentages relative to the borrowck itself
like so:</p>
<pre><code class="language-bash">&gt; perf focus '{do_mir_borrowck}' --tree-callees --relative --tree-max-depth 1 --tree-min-percent 5
Matcher    : {do_mir_borrowck}
Matches    : 577
Not Matches: 746
Percentage : 100%

Tree
| matched `{do_mir_borrowck}` (100% total, 0% self)
: | rustc_mir::borrow_check::nll::compute_regions (47% total, 0% self) [...]
: | rustc::mir::visit::Visitor::visit_mir (19% total, 15% self) [...]
: | &lt;rustc_mir::borrow_check::MirBorrowckCtxt&lt;'cx, 'tcx&gt; as rustc_mir::dataflow::DataflowResultsConsumer&lt;'cx, 'tcx&gt;&gt;::visit_statement_entry (13% total, 0% self) [...]
: | rustc_mir::dataflow::do_dataflow (8% total, 1% self) [...]
</code></pre>
<p>Here you see that <code>compute_regions</code> came up as &quot;47% total&quot; — that
means that 47% of <code>do_mir_borrowck</code> is spent in that function. Before,
we saw 20% — that's because <code>do_mir_borrowck</code> itself is only 43% of
the total time (and <code>.47 * .43 = .20</code>).</p>
<p>This file offers some tips on the coding conventions for rustc.  This
chapter covers <a href="rustc-guide/conventions.html#formatting">formatting</a>, <a href="rustc-guide/conventions.html#cc">coding for correctness</a>,
<a href="rustc-guide/conventions.html#cio">using crates from crates.io</a>, and some tips on
<a href="rustc-guide/conventions.html#er">structuring your PR for easy review</a>.</p>
<p><a name="formatting"></a></p>
<h1><a class="header" href="#formatting-and-the-tidy-script" id="formatting-and-the-tidy-script">Formatting and the tidy script</a></h1>
<p>rustc is slowly moving towards the <a href="https://github.com/rust-lang-nursery/fmt-rfcs">Rust standard coding style</a>;
at the moment, however, it follows a rather more <em>chaotic</em> style.  We
do have some mandatory formatting conventions, which are automatically
enforced by a script we affectionately call the &quot;tidy&quot; script.  The
tidy script runs automatically when you do <code>./x.py test</code> and can be run
in isolation with <code>./x.py test src/tools/tidy</code>.</p>
<p><a name="copyright"></a></p>
<h3><a class="header" href="#copyright-notice" id="copyright-notice">Copyright notice</a></h3>
<p>In the past, files begin with a copyright and license notice. Please <strong>omit</strong>
this notice for new files licensed under the standard terms (dual
MIT/Apache-2.0).</p>
<p>All of the copyright notices should be gone by now, but if you come across one
in the rust-lang/rust repo, feel free to open a PR to remove it.</p>
<h2><a class="header" href="#line-length" id="line-length">Line length</a></h2>
<p>Lines should be at most 100 characters. It's even better if you can
keep things to 80.</p>
<p><strong>Ignoring the line length limit.</strong> Sometimes – in particular for
tests – it can be necessary to exempt yourself from this limit. In
that case, you can add a comment towards the top of the file (after
the copyright notice) like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// ignore-tidy-linelength
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#tabs-vs-spaces" id="tabs-vs-spaces">Tabs vs spaces</a></h2>
<p>Prefer 4-space indent.</p>
<p><a name="cc"></a></p>
<h1><a class="header" href="#coding-for-correctness" id="coding-for-correctness">Coding for correctness</a></h1>
<p>Beyond formatting, there are a few other tips that are worth
following.</p>
<h2><a class="header" href="#prefer-exhaustive-matches" id="prefer-exhaustive-matches">Prefer exhaustive matches</a></h2>
<p>Using <code>_</code> in a match is convenient, but it means that when new
variants are added to the enum, they may not get handled correctly.
Ask yourself: if a new variant were added to this enum, what's the
chance that it would want to use the <code>_</code> code, versus having some
other treatment?  Unless the answer is &quot;low&quot;, then prefer an
exhaustive match. (The same advice applies to <code>if let</code> and <code>while let</code>, which are effectively tests for a single variant.)</p>
<h2><a class="header" href="#use-todo-comments-for-things-you-dont-want-to-forget" id="use-todo-comments-for-things-you-dont-want-to-forget">Use &quot;TODO&quot; comments for things you don't want to forget</a></h2>
<p>As a useful tool to yourself, you can insert a <code>// TODO</code> comment
for something that you want to get back to before you land your PR:</p>
<pre><code class="language-rust ignore">fn do_something() {
    if something_else {
        unimplemented!(); // TODO write this
    }
}
</code></pre>
<p>The tidy script will report an error for a <code>// TODO</code> comment, so this
code would not be able to land until the TODO is fixed (or removed).</p>
<p>This can also be useful in a PR as a way to signal from one commit that you are
leaving a bug that a later commit will fix:</p>
<pre><code class="language-rust ignore">if foo {
    return true; // TODO wrong, but will be fixed in a later commit
}
</code></pre>
<p><a name="cio"></a></p>
<h1><a class="header" href="#using-crates-from-cratesio" id="using-crates-from-cratesio">Using crates from crates.io</a></h1>
<p>It is allowed to use crates from crates.io, though external
dependencies should not be added gratuitously. All such crates must
have a suitably permissive license. There is an automatic check which
inspects the Cargo metadata to ensure this.</p>
<p><a name="er"></a></p>
<h1><a class="header" href="#how-to-structure-your-pr" id="how-to-structure-your-pr">How to structure your PR</a></h1>
<p>How you prepare the commits in your PR can make a big difference for the
reviewer.  Here are some tips.</p>
<p><strong>Isolate &quot;pure refactorings&quot; into their own commit.</strong> For example, if
you rename a method, then put that rename into its own commit, along
with the renames of all the uses.</p>
<p><strong>More commits is usually better.</strong> If you are doing a large change,
it's almost always better to break it up into smaller steps that can
be independently understood. The one thing to be aware of is that if
you introduce some code following one strategy, then change it
dramatically (versus adding to it) in a later commit, that
'back-and-forth' can be confusing.</p>
<p><strong>If you run rustfmt and the file was not already formatted, isolate
that into its own commit.</strong> This is really the same as the previous
rule, but it's worth highlighting. It's ok to rustfmt files, but since
we do not currently run rustfmt all the time, that can introduce a lot
of noise into your commit. Please isolate that into its own
commit. This also makes rebases a lot less painful, since rustfmt
tends to cause a lot of merge conflicts, and having those isolated
into their own commit makes them easier to resolve.</p>
<p><strong>No merges.</strong> We do not allow merge commits into our history, other
than those by bors. If you get a merge conflict, rebase instead via a
command like <code>git rebase -i rust-lang/master</code> (presuming you use the
name <code>rust-lang</code> for your remote).</p>
<p><strong>Individual commits do not have to build (but it's nice).</strong> We do not
require that every intermediate commit successfully builds – we only
expect to be able to bisect at a PR level. However, if you <em>can</em> make
individual commits build, that is always helpful.</p>
<h1><a class="header" href="#naming-conventions" id="naming-conventions">Naming conventions</a></h1>
<p>Apart from normal Rust style/naming conventions, there are also some specific
to the compiler.</p>
<ul>
<li>
<p><code>cx</code> tends to be short for &quot;context&quot; and is often used as a suffix. For
example, <code>tcx</code> is a common name for the <a href="rustc-guide/./ty.html">Typing Context</a>.</p>
</li>
<li>
<p><a href="rustc-guide/./ty.html"><code>'tcx</code></a> is used as the lifetime name for the Typing Context.</p>
</li>
<li>
<p>Because <code>crate</code> is a keyword, if you need a variable to represent something
crate-related, often the spelling is changed to <code>krate</code>.</p>
</li>
</ul>
<h1><a class="header" href="#cratesio-dependencies" id="cratesio-dependencies">crates.io Dependencies</a></h1>
<p>The rust compiler supports building with some dependencies from <code>crates.io</code>.
For example, <code>log</code> and <code>env_logger</code> come from <code>crates.io</code>.</p>
<p>In general, you should avoid adding dependencies to the compiler for several
reasons:</p>
<ul>
<li>The dependency may not be high quality or well-maintained, whereas we want
the compiler to be high-quality.</li>
<li>The dependency may not be using a compatible license.</li>
<li>The dependency may have transitive dependencies that have one of the above
problems.</li>
</ul>
<p>TODO: what is the vetting process?</p>
<h2><a class="header" href="#whitelist" id="whitelist">Whitelist</a></h2>
<p>The <code>tidy</code> tool has a <a href="https://github.com/rust-lang/rust/blob/659994627234ce7d95a1a52ad8756ce661059adf/src/tools/tidy/src/deps.rs#L56">whitelist</a> of crates that are allowed. To add a
dependency that is not already in the compiler, you will need to add it to this
whitelist.</p>
<h1><a class="header" href="#emitting-errors-and-other-diagnostics" id="emitting-errors-and-other-diagnostics">Emitting Errors and other Diagnostics</a></h1>
<p>A lot of effort has been put into making <code>rustc</code> have great error messages.
This chapter is about how to emit compile errors and lints from the compiler.</p>
<h2><a class="header" href="#span" id="span"><code>Span</code></a></h2>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.Span.html"><code>Span</code></a> is the primary data structure in <code>rustc</code> used to represent a
location in the code being compiled. <code>Span</code>s are attached to most constructs in
HIR and MIR, allowing for more informative error reporting.</p>
<p>A <code>Span</code> can be looked up in a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.SourceMap.html"><code>SourceMap</code></a> to get a &quot;snippet&quot;
useful for displaying errors with <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.SourceMap.html#method.span_to_snippet"><code>span_to_snippet</code></a> and other
similar methods on the <code>SourceMap</code>.</p>
<h2><a class="header" href="#error-messages" id="error-messages">Error messages</a></h2>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/index.html"><code>rustc_errors</code></a> crate defines most of the utilities used for
reporting errors.</p>
<p><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html"><code>Session</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/struct.ParseSess.html"><code>ParseSess</code></a> have
methods (or fields with methods) that allow reporting errors. These methods
usually have names like <code>span_err</code> or <code>struct_span_err</code> or <code>span_warn</code>, etc...
There are lots of them; they emit different types of &quot;errors&quot;, such as
warnings, errors, fatal errors, suggestions, etc.</p>
<p>In general, there are two class of such methods: ones that emit an error
directly and ones that allow finer control over what to emit. For example,
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.span_err"><code>span_err</code></a> emits the given error message at the given <code>Span</code>, but
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.struct_span_err"><code>struct_span_err</code></a> instead returns a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html"><code>DiagnosticBuilder</code></a>.</p>
<p><code>DiagnosticBuilder</code> allows you to add related notes and suggestions to an error
before emitting it by calling the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html#method.emit"><code>emit</code></a> method. (Failing to either
emit or <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.Diagnostic.html#method.cancel">cancel</a> a <code>DiagnosticBuilder</code> will result in an ICE.) See the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/diagnostic_builder/struct.DiagnosticBuilder.html">docs</a> for more info on what you can do.</p>
<pre><code class="language-rust ignore">// Get a DiagnosticBuilder. This does _not_ emit an error yet.
let mut err = sess.struct_span_err(sp, &quot;oh no! this is an error!&quot;);

// In some cases, you might need to check if `sp` is generated by a macro to
// avoid printing weird errors about macro-generated code.

if let Ok(snippet) = sess.source_map().span_to_snippet(sp) {
    // Use the snippet to generate a suggested fix
    err.span_suggestion(suggestion_sp, &quot;try using a qux here&quot;, format!(&quot;qux {}&quot;, snip));
} else {
    // If we weren't able to generate a snippet, then emit a &quot;help&quot; message
    // instead of a concrete &quot;suggestion&quot;. In practice this is unlikely to be
    // reached.
    err.span_help(suggestion_sp, &quot;you could use a qux here instead&quot;);
}

// emit the error
err.emit();
</code></pre>
<h2><a class="header" href="#suggestions" id="suggestions">Suggestions</a></h2>
<p>In addition to telling the user exactly <em>why</em> their code is wrong, it's
oftentimes furthermore possible to tell them how to fix it. To this end,
<code>DiagnosticBuilder</code> offers a structured suggestions API, which formats code
suggestions pleasingly in the terminal, or (when the <code>--error-format json</code> flag
is passed) as JSON for consumption by tools, most notably the <a href="https://github.com/rust-lang/rls">Rust Language
Server</a> and <a href="https://github.com/rust-lang-nursery/rustfix"><code>rustfix</code></a>.</p>
<p>Not all suggestions should be applied mechanically. Use the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.DiagnosticBuilder.html#method.span_suggestion"><code>span_suggestion</code></a> method of <code>DiagnosticBuilder</code> to
make a suggestion. The last argument provides a hint to tools whether
the suggestion is mechanically applicable or not.</p>
<p>For example, to make our <code>qux</code> suggestion machine-applicable, we would do:</p>
<pre><code class="language-rust ignore">let mut err = sess.struct_span_err(sp, &quot;oh no! this is an error!&quot;);

if let Ok(snippet) = sess.source_map().span_to_snippet(sp) {
    err.span_suggestion(
        suggestion_sp,
        &quot;try using a qux here&quot;,
        format!(&quot;qux {}&quot;, snip),
        Applicability::MachineApplicable,
    );
} else {
    err.span_help(suggestion_sp, &quot;you could use a qux here instead&quot;);
}

err.emit();
</code></pre>
<p>This might emit an error like</p>
<pre><code class="language-console">$ rustc mycode.rs
error[E0999]: oh no! this is an error!
 --&gt; mycode.rs:3:5
  |
3 |     sad()
  |     ^ help: try using a qux here: `qux sad()`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0999`.
</code></pre>
<p>In some cases, like when the suggestion spans multiple lines or when there are
multiple suggestions, the suggestions are displayed on their own:</p>
<pre><code class="language-console">error[E0999]: oh no! this is an error!
 --&gt; mycode.rs:3:5
  |
3 |     sad()
  |     ^
help: try using a qux here:
  |
3 |     qux sad()
  |     ^^^

error: aborting due to previous error

For more information about this error, try `rustc --explain E0999`.
</code></pre>
<p>The possible values of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/enum.Applicability.html"><code>Applicability</code></a> are:</p>
<ul>
<li><code>MachineApplicable</code>: Can be applied mechanically.</li>
<li><code>HasPlaceholders</code>: Cannot be applied mechanically because it has placeholder
text in the suggestions. For example, &quot;Try adding a type: `let x:
&lt;type&gt;`&quot;.</li>
<li><code>MaybeIncorrect</code>: Cannot be applied mechanically because the suggestion may
or may not be a good one.</li>
<li><code>Unspecified</code>: Cannot be applied mechanically because we don't know which
of the above cases it falls into.</li>
</ul>
<h2><a class="header" href="#lints" id="lints">Lints</a></h2>
<p>The compiler linting infrastructure is defined in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/index.html"><code>rustc::lint</code></a>
module.</p>
<h3><a class="header" href="#declaring-a-lint" id="declaring-a-lint">Declaring a lint</a></h3>
<p>The built-in compiler lints are defined in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html"><code>rustc_lint</code></a>
crate.</p>
<p>Each lint is defined as a <code>struct</code> that implements the <code>LintPass</code> <code>trait</code>. The
trait implementation allows you to check certain syntactic constructs the
linter walks the source code. You can then choose to emit lints in a very
similar way to compile errors. Finally, you register the lint to actually get
it to be run by the compiler by using the <code>declare_lint!</code> macro.</p>
<p>For example, the following lint checks for uses
of <code>while true { ... }</code> and suggests using <code>loop { ... }</code> instead.</p>
<pre><code class="language-rust ignore">// Declare a lint called `WHILE_TRUE`
declare_lint! {
    WHILE_TRUE,

    // warn-by-default
    Warn,

    // This string is the lint description
    &quot;suggest using `loop { }` instead of `while true { }`&quot;
}

// Define a struct and `impl LintPass` for it.
#[derive(Copy, Clone)]
pub struct WhileTrue;

impl LintPass for WhileTrue {
    fn get_lints(&amp;self) -&gt; LintArray {
        lint_array!(WHILE_TRUE)
    }
}

// LateLintPass has lots of methods. We only override the definition of
// `check_expr` for this lint because that's all we need, but you could
// override other methods for your own lint. See the rustc docs for a full
// list of methods.
impl&lt;'a, 'tcx&gt; LateLintPass&lt;'a, 'tcx&gt; for WhileTrue {
    fn check_expr(&amp;mut self, cx: &amp;LateContext, e: &amp;hir::Expr) {
        if let hir::ExprWhile(ref cond, ..) = e.node {
            if let hir::ExprLit(ref lit) = cond.node {
                if let ast::LitKind::Bool(true) = lit.node {
                    if lit.span.ctxt() == SyntaxContext::empty() {
                        let msg = &quot;denote infinite loops with `loop { ... }`&quot;;
                        let condition_span = cx.tcx.sess.source_map().def_span(e.span);
                        let mut err = cx.struct_span_lint(WHILE_TRUE, condition_span, msg);
                        err.span_suggestion_short(condition_span, &quot;use `loop`&quot;, &quot;loop&quot;.to_owned());
                        err.emit();
                    }
                }
            }
        }
    }
}
</code></pre>
<h3><a class="header" href="#edition-gated-lints" id="edition-gated-lints">Edition-gated Lints</a></h3>
<p>Sometimes we want to change the behavior of a lint in a new edition. To do this,
we just add the transition to our invocation of <code>declare_lint!</code>:</p>
<pre><code class="language-rust ignore">declare_lint! {
    pub ANONYMOUS_PARAMETERS,
    Allow,
    &quot;detects anonymous parameters&quot;,
    Edition::Edition2018 =&gt; Warn,
}
</code></pre>
<p>This makes the <code>ANONYMOUS_PARAMETERS</code> lint allow-by-default in the 2015 edition
but warn-by-default in the 2018 edition.</p>
<p>Lints that represent an incompatibility (i.e. error) in the upcoming edition
should also be registered as <code>FutureIncompatibilityLint</code>s in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.register_builtins.html"><code>register_builtins</code></a> function in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html"><code>rustc_lint::lib</code></a>.</p>
<h3><a class="header" href="#lint-groups" id="lint-groups">Lint Groups</a></h3>
<p>Lints can be turned on in groups. These groups are declared in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/fn.register_builtins.html"><code>register_builtins</code></a> function in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_lint/index.html"><code>rustc_lint::lib</code></a>. The
<code>add_lint_group!</code> macro is used to declare a new group.</p>
<p>For example,</p>
<pre><code class="language-rust ignore">    add_lint_group!(sess,
                    &quot;nonstandard_style&quot;,
                    NON_CAMEL_CASE_TYPES,
                    NON_SNAKE_CASE,
                    NON_UPPER_CASE_GLOBALS);
</code></pre>
<p>This defines the <code>nonstandard_style</code> group which turns on the listed lints. A
user can turn on these lints with a <code>!#[warn(nonstandard_style)]</code> attribute in
the source code, or by passing <code>-W nonstandard-style</code> on the command line.</p>
<h3><a class="header" href="#linting-early-in-the-compiler" id="linting-early-in-the-compiler">Linting early in the compiler</a></h3>
<p>On occasion, you may need to define a lint that runs before the linting system
has been initialized (e.g. during parsing or macro expansion). This is
problematic because we need to have computed lint levels to know whether we
should emit a warning or an error or nothing at all.</p>
<p>To solve this problem, we buffer the lints until the linting system is
processed. <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html#method.buffer_lint"><code>Session</code></a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/struct.ParseSess.html#method.buffer_lint"><code>ParseSess</code></a> both have
<code>buffer_lint</code> methods that allow you to buffer a lint for later. The linting
system automatically takes care of handling buffered lints later.</p>
<p>Thus, to define a lint that runs early in the compilation, one defines a lint
like normal but invokes the lint with <code>buffer_lint</code>.</p>
<h4><a class="header" href="#linting-even-earlier-in-the-compiler" id="linting-even-earlier-in-the-compiler">Linting even earlier in the compiler</a></h4>
<p>The parser (<code>libsyntax</code>) is interesting in that it cannot have dependencies on
any of the other <code>librustc*</code> crates. In particular, it cannot depend on
<code>librustc::lint</code> or <code>librustc_lint</code>, where all of the compiler linting
infrastructure is defined. That's troublesome!</p>
<p>To solve this, <code>libsyntax</code> defines its own buffered lint type, which
<code>ParseSess::buffer_lint</code> uses. After macro expansion, these buffered lints are
then dumped into the <code>Session::buffered_lints</code> used by the rest of the compiler.</p>
<p>Usage for buffered lints in <code>libsyntax</code> is pretty much the same as the rest of
the compiler with one exception because we cannot import the <code>LintId</code>s for
lints we want to emit. Instead, the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/early_buffered_lints/enum.BufferedEarlyLintId.html"><code>BufferedEarlyLintId</code></a> type is used. If you
are defining a new lint, you will want to add an entry to this enum. Then, add
an appropriate mapping to the body of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/lint/struct.Lint.html#method.from_parser_lint_id"><code>Lint::from_parser_lint_id</code></a>.</p>
<h2><a class="header" href="#json-diagnostic-output" id="json-diagnostic-output">JSON diagnostic output</a></h2>
<p>The compiler accepts an <code>--error-format json</code> flag to output
diagnostics as JSON objects (for the benefit of tools such as <code>cargo fix</code> or the RLS). It looks like this—</p>
<pre><code class="language-console">$ rustc json_error_demo.rs --error-format json
{&quot;message&quot;:&quot;cannot add `&amp;str` to `{integer}`&quot;,&quot;code&quot;:{&quot;code&quot;:&quot;E0277&quot;,&quot;explanation&quot;:&quot;\nYou tried to use a type which doesn't implement some trait in a place which\nexpected that trait. Erroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&amp;self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func&lt;T: Foo&gt;(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&amp;self);\n}\n\nfn some_func&lt;T: Foo&gt;(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&amp;self) {}\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func&lt;T&gt;(foo: T) {\n    println!(\&quot;{:?}\&quot;, foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function: Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function: It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func&lt;T: fmt::Debug&gt;(foo: T) {\n    println!(\&quot;{:?}\&quot;, foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n&quot;},&quot;level&quot;:&quot;error&quot;,&quot;spans&quot;:[{&quot;file_name&quot;:&quot;json_error_demo.rs&quot;,&quot;byte_start&quot;:50,&quot;byte_end&quot;:51,&quot;line_start&quot;:4,&quot;line_end&quot;:4,&quot;column_start&quot;:7,&quot;column_end&quot;:8,&quot;is_primary&quot;:true,&quot;text&quot;:[{&quot;text&quot;:&quot;    a + b&quot;,&quot;highlight_start&quot;:7,&quot;highlight_end&quot;:8}],&quot;label&quot;:&quot;no implementation for `{integer} + &amp;str`&quot;,&quot;suggested_replacement&quot;:null,&quot;suggestion_applicability&quot;:null,&quot;expansion&quot;:null}],&quot;children&quot;:[{&quot;message&quot;:&quot;the trait `std::ops::Add&lt;&amp;str&gt;` is not implemented for `{integer}`&quot;,&quot;code&quot;:null,&quot;level&quot;:&quot;help&quot;,&quot;spans&quot;:[],&quot;children&quot;:[],&quot;rendered&quot;:null}],&quot;rendered&quot;:&quot;error[E0277]: cannot add `&amp;str` to `{integer}`\n --&gt; json_error_demo.rs:4:7\n  |\n4 |     a + b\n  |       ^ no implementation for `{integer} + &amp;str`\n  |\n  = help: the trait `std::ops::Add&lt;&amp;str&gt;` is not implemented for `{integer}`\n\n&quot;}
{&quot;message&quot;:&quot;aborting due to previous error&quot;,&quot;code&quot;:null,&quot;level&quot;:&quot;error&quot;,&quot;spans&quot;:[],&quot;children&quot;:[],&quot;rendered&quot;:&quot;error: aborting due to previous error\n\n&quot;}
{&quot;message&quot;:&quot;For more information about this error, try `rustc --explain E0277`.&quot;,&quot;code&quot;:null,&quot;level&quot;:&quot;&quot;,&quot;spans&quot;:[],&quot;children&quot;:[],&quot;rendered&quot;:&quot;For more information about this error, try `rustc --explain E0277`.\n&quot;}
</code></pre>
<p>Note that the output is a series of lines, each of which is a JSON
object, but the series of lines taken together is, unfortunately, not
valid JSON, thwarting tools and tricks (such as <a href="https://docs.python.org/3/library/json.html#module-json.tool">piping to <code>python3 -m json.tool</code></a>)
that require such. (One speculates that this was intentional for LSP
performance purposes, so that each line/object can be sent to RLS as
it is flushed?)</p>
<p>Also note the &quot;rendered&quot; field, which contains the &quot;human&quot; output as a
string; this was introduced so that UI tests could both make use of
the structured JSON and see the &quot;human&quot; output (well, <em>sans</em> colors)
without having to compile everything twice.</p>
<p>The JSON emitter currently lives in libsyntax/json.rs. (But arguably
it should live in librustc_errors along with the &quot;human&quot; emitter? It's
not obvious to the present author why it wasn't moved from libsyntax
to librustc_errors at the same <a href="https://github.com/rust-lang/rust/commit/6ae3502134">time the &quot;human&quot; emitter was
moved</a>.)</p>
<p>The JSON emitter defines <a href="https://github.com/rust-lang/rust/blob/b2c6b8c29f13f8d1f242da89e587960b95337819/src/libsyntax/json.rs#L85-L99">its own <code>Diagnostic</code>
struct</a>
(and sub-structs) for the JSON serialization. Don't confuse this with
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.Diagnostic.html"><code>errors::Diagnostic</code></a>!</p>
<h1><a class="header" href="#part-2-how-rustc-works" id="part-2-how-rustc-works">Part 2: How rustc works</a></h1>
<p>This part of the guide describes how the compiler works. It goes through
everything from high-level structure of the compiler to how each stage of
compilation works.</p>
<p>This section should be friendly to both readers interested in the end-to-end
process of compilation <em>and</em> readers interested in learning about a specific
system they wish to contribute to. If anything is unclear, feel free to file
an issue on the <a href="https://github.com/rust-lang/rustc-guide">rustc-guide repo</a>
or contact the compiler team, as detailed in <a href="rustc-guide/./compiler-team.html">this chapter from Part
1</a>.</p>
<h1><a class="header" href="#high-level-overview-of-the-compiler-source" id="high-level-overview-of-the-compiler-source">High-level overview of the compiler source</a></h1>
<h2><a class="header" href="#crate-structure" id="crate-structure">Crate structure</a></h2>
<p>The main Rust repository consists of a <code>src</code> directory, under which
there live many crates. These crates contain the sources for the
standard library and the compiler.  This document, of course, focuses
on the latter.</p>
<p>Rustc consists of a number of crates, including <code>syntax</code>,
<code>rustc</code>, <code>rustc_back</code>, <code>rustc_codegen</code>, <code>rustc_driver</code>, and
many more. The source for each crate can be found in a directory
like <code>src/libXXX</code>, where <code>XXX</code> is the crate name.</p>
<p>(N.B. The names and divisions of these crates are not set in
stone and may change over time. For the time being, we tend towards a
finer-grained division to help with compilation time, though as incremental
compilation improves, that may change.)</p>
<p>The dependency structure of these crates is roughly a diamond:</p>
<pre><code class="language-text">                  rustc_driver
                /      |       \
              /        |         \
            /          |           \
          /            v             \
rustc_codegen  rustc_borrowck   ...  rustc_metadata
          \            |            /
            \          |          /
              \        |        /
                \      v      /
                    rustc
                       |
                       v
                    syntax
                    /    \
                  /       \
           syntax_pos  syntax_ext
</code></pre>
<p>The <code>rustc_driver</code> crate, at the top of this lattice, is effectively
the &quot;main&quot; function for the rust compiler. It doesn't have much &quot;real
code&quot;, but instead ties together all of the code defined in the other
crates and defines the overall flow of execution. (As we transition
more and more to the <a href="rustc-guide/query.html">query model</a>, however, the
&quot;flow&quot; of compilation is becoming less centrally defined.)</p>
<p>At the other extreme, the <code>rustc</code> crate defines the common and
pervasive data structures that all the rest of the compiler uses
(e.g. how to represent types, traits, and the program itself). It
also contains some amount of the compiler itself, although that is
relatively limited.</p>
<p>Finally, all the crates in the bulge in the middle define the bulk of
the compiler – they all depend on <code>rustc</code>, so that they can make use
of the various types defined there, and they export public routines
that <code>rustc_driver</code> will invoke as needed (more and more, what these
crates export are &quot;query definitions&quot;, but those are covered later
on).</p>
<p>Below <code>rustc</code> lie various crates that make up the parser and error
reporting mechanism. For historical reasons, these crates do not have
the <code>rustc_</code> prefix, but they are really just as much an internal part
of the compiler and not intended to be stable (though they do wind up
getting used by some crates in the wild; a practice we hope to
gradually phase out).</p>
<p>Each crate has a <code>README.md</code> file that describes, at a high-level,
what it contains, and tries to give some kind of explanation (some
better than others).</p>
<h2><a class="header" href="#the-main-stages-of-compilation" id="the-main-stages-of-compilation">The main stages of compilation</a></h2>
<p>The Rust compiler is in a bit of transition right now. It used to be a
purely &quot;pass-based&quot; compiler, where we ran a number of passes over the
entire program, and each did a particular check of transformation. We
are gradually replacing this pass-based code with an alternative setup
based on on-demand <strong>queries</strong>. In the query-model, we work backwards,
executing a <em>query</em> that expresses our ultimate goal (e.g. &quot;compile
this crate&quot;). This query in turn may make other queries (e.g. &quot;get me
a list of all modules in the crate&quot;). Those queries make other queries
that ultimately bottom out in the base operations, like parsing the
input, running the type-checker, and so forth. This on-demand model
permits us to do exciting things like only do the minimal amount of
work needed to type-check a single function. It also helps with
incremental compilation. (For details on defining queries, check out
the <a href="rustc-guide/query.html">query model</a>.)</p>
<p>Regardless of the general setup, the basic operations that the
compiler must perform are the same. The only thing that changes is
whether these operations are invoked front-to-back, or on demand.  In
order to compile a Rust crate, these are the general steps that we
take:</p>
<ol>
<li><strong>Parsing input</strong>
<ul>
<li>this processes the <code>.rs</code> files and produces the AST
(&quot;abstract syntax tree&quot;)</li>
<li>the AST is defined in <code>src/libsyntax/ast.rs</code>. It is intended to match the lexical
syntax of the Rust language quite closely.</li>
</ul>
</li>
<li><strong>Name resolution, macro expansion, and configuration</strong>
<ul>
<li>once parsing is complete, we process the AST recursively, resolving
paths and expanding macros. This same process also processes <code>#[cfg]</code>
nodes, and hence may strip things out of the AST as well.</li>
</ul>
</li>
<li><strong>Lowering to HIR</strong>
<ul>
<li>Once name resolution completes, we convert the AST into the HIR,
or &quot;<a href="rustc-guide/hir.html">high-level intermediate representation</a>&quot;. The HIR is defined in
<code>src/librustc/hir/</code>; that module also includes the <a href="rustc-guide/lowering.html">lowering</a> code.</li>
<li>The HIR is a lightly desugared variant of the AST. It is more processed
than the AST and more suitable for the analyses that follow.
It is <strong>not</strong> required to match the syntax of the Rust language.</li>
<li>As a simple example, in the <strong>AST</strong>, we preserve the parentheses
that the user wrote, so <code>((1 + 2) + 3)</code> and <code>1 + 2 + 3</code> parse
into distinct trees, even though they are equivalent. In the
HIR, however, parentheses nodes are removed, and those two
expressions are represented in the same way.</li>
</ul>
</li>
<li><strong>Type-checking and subsequent analyses</strong>
<ul>
<li>An important step in processing the HIR is to perform type
checking. This process assigns types to every HIR expression,
for example, and also is responsible for resolving some
&quot;type-dependent&quot; paths, such as field accesses (<code>x.f</code> – we
can't know what field <code>f</code> is being accessed until we know the
type of <code>x</code>) and associated type references (<code>T::Item</code> – we
can't know what type <code>Item</code> is until we know what <code>T</code> is).</li>
<li>Type checking creates &quot;side-tables&quot; (<code>TypeckTables</code>) that include
the types of expressions, the way to resolve methods, and so forth.</li>
<li>After type-checking, we can do other analyses, such as privacy checking.</li>
</ul>
</li>
<li><strong>Lowering to MIR and post-processing</strong>
<ul>
<li>Once type-checking is done, we can lower the HIR into MIR (&quot;middle IR&quot;),
which is a <strong>very</strong> desugared version of Rust, well suited to borrowck
but also to certain high-level optimizations.</li>
</ul>
</li>
<li><strong>Translation to LLVM and LLVM optimizations</strong>
<ul>
<li>From MIR, we can produce LLVM IR.</li>
<li>LLVM then runs its various optimizations, which produces a number of
<code>.o</code> files (one for each &quot;codegen unit&quot;).</li>
</ul>
</li>
<li><strong>Linking</strong>
<ul>
<li>Finally, those <code>.o</code> files are linked together.</li>
</ul>
</li>
</ol>
<h1><a class="header" href="#the-rustc-driver-and-interface" id="the-rustc-driver-and-interface">The Rustc Driver and Interface</a></h1>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/"><code>rustc_driver</code></a> is essentially <code>rustc</code>'s <code>main()</code> function. It acts as
the glue for running the various phases of the compiler in the correct order,
using the interface defined in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/index.html"><code>rustc_interface</code></a> crate.</p>
<p>The <code>rustc_interface</code> crate provides external users with an (unstable) API
for running code at particular times during the compilation process, allowing
third parties to effectively use <code>rustc</code>'s internals as a library for
analysing a crate or emulating the compiler in-process (e.g. the RLS or rustdoc).</p>
<p>For those using <code>rustc</code> as a library, the <code>interface::run_compiler()</code> function is the main
entrypoint to the compiler. It takes a configuration for the compiler and a closure that
takes a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Compiler.html"><code>Compiler</code></a>. <code>run_compiler</code> creates a <code>Compiler</code> from the configuration and passes
it to the closure. Inside the closure, you can use the <code>Compiler</code> to drive queries to compile
a crate and get the results. This is what the <code>rustc_driver</code> does too.</p>
<p>You can see what queries are currently available through the rustdocs for <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Compiler.html"><code>Compiler</code></a>.
You can see an example of how to use them by looking at the <code>rustc_driver</code> implementation,
specifically the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/fn.run_compiler.html"><code>rustc_driver::run_compiler</code> function</a> (not to be confused with
<code>interface::run_compiler</code>). The <code>rustc_driver::run_compiler</code> function takes a bunch of
command-line args and some other configurations and drives the compilation to completion.</p>
<p><code>rustc_driver::run_compiler</code> also takes a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/trait.Callbacks.html"><code>Callbacks</code></a>. In the past, when
the <code>rustc_driver::run_compiler</code> was the primary way to use the compiler as a
library, these callbacks were used to have some custom code run after different
phases of the compilation. If you read <a href="rustc-guide/appendix/stupid-stats.html">Appendix A</a>, you may notice the use of the
types <code>CompilerCalls</code> and <code>CompileController</code>, which no longer exist. <code>Callbacks</code>
replaces this functionality.</p>
<blockquote>
<p><strong>Warning:</strong> By its very nature, the internal compiler APIs are always going
to be unstable. That said, we do try not to break things unnecessarily.</p>
</blockquote>
<h2><a class="header" href="#a-note-on-lifetimes" id="a-note-on-lifetimes">A Note On Lifetimes</a></h2>
<p>The Rust compiler is a fairly large program containing lots of big data
structures (e.g. the AST, HIR, and the type system) and as such, arenas and
references are heavily relied upon to minimize unnecessary memory use. This
manifests itself in the way people can plug into the compiler, preferring a
&quot;push&quot;-style API (callbacks) instead of the more Rust-ic &quot;pull&quot; style (think
the <code>Iterator</code> trait).</p>
<p>Thread-local storage and interning are used a lot through the compiler to reduce
duplication while also preventing a lot of the ergonomic issues due to many
pervasive lifetimes. The <code>rustc::ty::tls</code> module is used to access these
thread-locals, although you should rarely need to touch it.</p>
<h1><a class="header" href="#the-walking-tour-of-rustdoc" id="the-walking-tour-of-rustdoc">The walking tour of rustdoc</a></h1>
<p>Rustdoc actually uses the rustc internals directly. It lives in-tree with the
compiler and standard library. This chapter is about how it works.</p>
<p>Rustdoc is implemented entirely within the crate <a href="https://github.com/rust-lang/rust/tree/master/src/librustdoc"><code>librustdoc</code></a>. It runs
the compiler up to the point where we have an internal representation of a
crate (HIR) and the ability to run some queries about the types of items. <a href="rustc-guide/./hir.html">HIR</a>
and <a href="rustc-guide/./query.html">queries</a> are discussed in the linked chapters.</p>
<p><code>librustdoc</code> performs two major steps after that to render a set of
documentation:</p>
<ul>
<li>&quot;Clean&quot; the AST into a form that's more suited to creating documentation (and
slightly more resistant to churn in the compiler).</li>
<li>Use this cleaned AST to render a crate's documentation, one page at a time.</li>
</ul>
<p>Naturally, there's more than just this, and those descriptions simplify out
lots of details, but that's the high-level overview.</p>
<p>(Side note: <code>librustdoc</code> is a library crate! The <code>rustdoc</code> binary is created
using the project in <a href="https://github.com/rust-lang/rust/tree/master/src/tools/rustdoc"><code>src/tools/rustdoc</code></a>. Note that literally all that
does is call the <code>main()</code> that's in this crate's <code>lib.rs</code>, though.)</p>
<h2><a class="header" href="#cheat-sheet" id="cheat-sheet">Cheat sheet</a></h2>
<ul>
<li>Use <code>./x.py build --stage 1 src/libstd src/tools/rustdoc</code> to make a usable
rustdoc you can run on other projects.
<ul>
<li>Add <code>src/libtest</code> to be able to use <code>rustdoc --test</code>.</li>
<li>If you've used <code>rustup toolchain link local /path/to/build/$TARGET/stage1</code>
previously, then after the previous build command, <code>cargo +local doc</code> will
Just Work.</li>
</ul>
</li>
<li>Use <code>./x.py doc --stage 1 src/libstd</code> to use this rustdoc to generate the
standard library docs.
<ul>
<li>The completed docs will be available in <code>build/$TARGET/doc/std</code>, though the
bundle is meant to be used as though you would copy out the <code>doc</code> folder to
a web server, since that's where the CSS/JS and landing page are.</li>
</ul>
</li>
<li>Most of the HTML printing code is in <code>html/format.rs</code> and <code>html/render.rs</code>.
It's in a bunch of <code>fmt::Display</code> implementations and supplementary
functions.</li>
<li>The types that got <code>Display</code> impls above are defined in <code>clean/mod.rs</code>, right
next to the custom <code>Clean</code> trait used to process them out of the rustc HIR.</li>
<li>The bits specific to using rustdoc as a test harness are in <code>test.rs</code>.</li>
<li>The Markdown renderer is loaded up in <code>html/markdown.rs</code>, including functions
for extracting doctests from a given block of Markdown.</li>
<li>The tests on rustdoc <em>output</em> are located in <code>src/test/rustdoc</code>, where
they're handled by the test runner of rustbuild and the supplementary script
<code>src/etc/htmldocck.py</code>.</li>
<li>Tests on search index generation are located in <code>src/test/rustdoc-js</code>, as a
series of JavaScript files that encode queries on the standard library search
index and expected results.</li>
</ul>
<h2><a class="header" href="#from-crate-to-clean" id="from-crate-to-clean">From crate to clean</a></h2>
<p>In <code>core.rs</code> are two central items: the <code>DocContext</code> struct, and the <code>run_core</code>
function. The latter is where rustdoc calls out to rustc to compile a crate to
the point where rustdoc can take over. The former is a state container used
when crawling through a crate to gather its documentation.</p>
<p>The main process of crate crawling is done in <code>clean/mod.rs</code> through several
implementations of the <code>Clean</code> trait defined within. This is a conversion
trait, which defines one method:</p>
<pre><code class="language-rust ignore">pub trait Clean&lt;T&gt; {
    fn clean(&amp;self, cx: &amp;DocContext) -&gt; T;
}
</code></pre>
<p><code>clean/mod.rs</code> also defines the types for the &quot;cleaned&quot; AST used later on to
render documentation pages. Each usually accompanies an implementation of
<code>Clean</code> that takes some AST or HIR type from rustc and converts it into the
appropriate &quot;cleaned&quot; type. &quot;Big&quot; items like modules or associated items may
have some extra processing in its <code>Clean</code> implementation, but for the most part
these impls are straightforward conversions. The &quot;entry point&quot; to this module
is the <code>impl Clean&lt;Crate&gt; for visit_ast::RustdocVisitor</code>, which is called by
<code>run_core</code> above.</p>
<p>You see, I actually lied a little earlier: There's another AST transformation
that happens before the events in <code>clean/mod.rs</code>.  In <code>visit_ast.rs</code> is the
type <code>RustdocVisitor</code>, which <em>actually</em> crawls a <code>hir::Crate</code> to get the first
intermediate representation, defined in <code>doctree.rs</code>. This pass is mainly to
get a few intermediate wrappers around the HIR types and to process visibility
and inlining. This is where <code>#[doc(inline)]</code>, <code>#[doc(no_inline)]</code>, and
<code>#[doc(hidden)]</code> are processed, as well as the logic for whether a <code>pub use</code>
should get the full page or a &quot;Reexport&quot; line in the module page.</p>
<p>The other major thing that happens in <code>clean/mod.rs</code> is the collection of doc
comments and <code>#[doc=&quot;&quot;]</code> attributes into a separate field of the Attributes
struct, present on anything that gets hand-written documentation. This makes it
easier to collect this documentation later in the process.</p>
<p>The primary output of this process is a <code>clean::Crate</code> with a tree of Items
which describe the publicly-documentable items in the target crate.</p>
<h3><a class="header" href="#hot-potato" id="hot-potato">Hot potato</a></h3>
<p>Before moving on to the next major step, a few important &quot;passes&quot; occur over
the documentation.  These do things like combine the separate &quot;attributes&quot; into
a single string and strip leading whitespace to make the document easier on the
markdown parser, or drop items that are not public or deliberately hidden with
<code>#[doc(hidden)]</code>. These are all implemented in the <code>passes/</code> directory, one
file per pass. By default, all of these passes are run on a crate, but the ones
regarding dropping private/hidden items can be bypassed by passing
<code>--document-private-items</code> to rustdoc. Note that unlike the previous set of AST
transformations, the passes happen on the <em>cleaned</em> crate.</p>
<p>(Strictly speaking, you can fine-tune the passes run and even add your own, but
<a href="https://github.com/rust-lang/rust/issues/44136">we're trying to deprecate that</a>. If you need finer-grain control over
these passes, please let us know!)</p>
<p>Here is current (as of this writing) list of passes:</p>
<ul>
<li><code>propagate-doc-cfg</code> - propagates <code>#[doc(cfg(...))]</code> to child items.</li>
<li><code>collapse-docs</code> concatenates all document attributes into one document
attribute. This is necessary because each line of a doc comment is given as a
separate doc attribute, and this will combine them into a single string with
line breaks between each attribute.</li>
<li><code>unindent-comments</code> removes excess indentation on comments in order for
markdown to like it. This is necessary because the convention for writing
documentation is to provide a space between the <code>///</code> or <code>//!</code> marker and the
text, and stripping that leading space will make the text easier to parse by
the Markdown parser. (In the past, the markdown parser used was not
Commonmark- compliant, which caused annoyances with extra whitespace but this
seems to be less of an issue today.)</li>
<li><code>strip-priv-imports</code> strips all private import statements (<code>use</code>, <code>extern crate</code>) from a crate. This is necessary because rustdoc will handle <em>public</em>
imports by either inlining the item's documentation to the module or creating
a &quot;Reexports&quot; section with the import in it. The pass ensures that all of
these imports are actually relevant to documentation.</li>
<li><code>strip-hidden</code> and <code>strip-private</code> strip all <code>doc(hidden)</code> and private items
from the output. <code>strip-private</code> implies <code>strip-priv-imports</code>. Basically, the
goal is to remove items that are not relevant for public documentation.</li>
</ul>
<h2><a class="header" href="#from-clean-to-crate" id="from-clean-to-crate">From clean to crate</a></h2>
<p>This is where the &quot;second phase&quot; in rustdoc begins. This phase primarily lives
in the <code>html/</code> folder, and it all starts with <code>run()</code> in <code>html/render.rs</code>. This
code is responsible for setting up the <code>Context</code>, <code>SharedContext</code>, and <code>Cache</code>
which are used during rendering, copying out the static files which live in
every rendered set of documentation (things like the fonts, CSS, and JavaScript
that live in <code>html/static/</code>), creating the search index, and printing out the
source code rendering, before beginning the process of rendering all the
documentation for the crate.</p>
<p>Several functions implemented directly on <code>Context</code> take the <code>clean::Crate</code> and
set up some state between rendering items or recursing on a module's child
items. From here the &quot;page rendering&quot; begins, via an enormous <code>write!()</code> call
in <code>html/layout.rs</code>. The parts that actually generate HTML from the items and
documentation occurs within a series of <code>std::fmt::Display</code> implementations and
functions that pass around a <code>&amp;mut std::fmt::Formatter</code>. The top-level
implementation that writes out the page body is the <code>impl&lt;'a&gt; fmt::Display for Item&lt;'a&gt;</code> in <code>html/render.rs</code>, which switches out to one of several <code>item_*</code>
functions based on the kind of <code>Item</code> being rendered.</p>
<p>Depending on what kind of rendering code you're looking for, you'll probably
find it either in <code>html/render.rs</code> for major items like &quot;what sections should I
print for a struct page&quot; or <code>html/format.rs</code> for smaller component pieces like
&quot;how should I print a where clause as part of some other item&quot;.</p>
<p>Whenever rustdoc comes across an item that should print hand-written
documentation alongside, it calls out to <code>html/markdown.rs</code> which interfaces
with the Markdown parser. This is exposed as a series of types that wrap a
string of Markdown, and implement <code>fmt::Display</code> to emit HTML text. It takes
special care to enable certain features like footnotes and tables and add
syntax highlighting to Rust code blocks (via <code>html/highlight.rs</code>) before
running the Markdown parser. There's also a function in here
(<code>find_testable_code</code>) that specifically scans for Rust code blocks so the
test-runner code can find all the doctests in the crate.</p>
<h3><a class="header" href="#from-soup-to-nuts" id="from-soup-to-nuts">From soup to nuts</a></h3>
<p>(alternate title: <a href="https://www.youtube.com/watch?v=hOLAGYmUQV0">&quot;An unbroken thread that stretches from those first <code>Cell</code>s
to us&quot;</a>)</p>
<p>It's important to note that the AST cleaning can ask the compiler for
information (crucially, <code>DocContext</code> contains a <code>TyCtxt</code>), but page rendering
cannot. The <code>clean::Crate</code> created within <code>run_core</code> is passed outside the
compiler context before being handed to <code>html::render::run</code>. This means that a
lot of the &quot;supplementary data&quot; that isn't immediately available inside an
item's definition, like which trait is the <code>Deref</code> trait used by the language,
needs to be collected during cleaning, stored in the <code>DocContext</code>, and passed
along to the <code>SharedContext</code> during HTML rendering.  This manifests as a bunch
of shared state, context variables, and <code>RefCell</code>s.</p>
<p>Also of note is that some items that come from &quot;asking the compiler&quot; don't go
directly into the <code>DocContext</code> - for example, when loading items from a foreign
crate, rustdoc will ask about trait implementations and generate new <code>Item</code>s
for the impls based on that information. This goes directly into the returned
<code>Crate</code> rather than roundabout through the <code>DocContext</code>. This way, these
implementations can be collected alongside the others, right before rendering
the HTML.</p>
<h2><a class="header" href="#other-tricks-up-its-sleeve" id="other-tricks-up-its-sleeve">Other tricks up its sleeve</a></h2>
<p>All this describes the process for generating HTML documentation from a Rust
crate, but there are couple other major modes that rustdoc runs in. It can also
be run on a standalone Markdown file, or it can run doctests on Rust code or
standalone Markdown files. For the former, it shortcuts straight to
<code>html/markdown.rs</code>, optionally including a mode which inserts a Table of
Contents to the output HTML.</p>
<p>For the latter, rustdoc runs a similar partial-compilation to get relevant
documentation in <code>test.rs</code>, but instead of going through the full clean and
render process, it runs a much simpler crate walk to grab <em>just</em> the
hand-written documentation. Combined with the aforementioned
&quot;<code>find_testable_code</code>&quot; in <code>html/markdown.rs</code>, it builds up a collection of
tests to run before handing them off to the libtest test runner. One notable
location in <code>test.rs</code> is the function <code>make_test</code>, which is where hand-written
doctests get transformed into something that can be executed.</p>
<p>Some extra reading about <code>make_test</code> can be found
<a href="https://quietmisdreavus.net/code/2018/02/23/how-the-doctests-get-made/">here</a>.</p>
<h2><a class="header" href="#dotting-is-and-crossing-ts" id="dotting-is-and-crossing-ts">Dotting i's and crossing t's</a></h2>
<p>So that's rustdoc's code in a nutshell, but there's more things in the repo
that deal with it. Since we have the full <code>compiletest</code> suite at hand, there's
a set of tests in <code>src/test/rustdoc</code> that make sure the final HTML is what we
expect in various situations. These tests also use a supplementary script,
<code>src/etc/htmldocck.py</code>, that allows it to look through the final HTML using
XPath notation to get a precise look at the output. The full description of all
the commands available to rustdoc tests is in <code>htmldocck.py</code>.</p>
<p>In addition, there are separate tests for the search index and rustdoc's
ability to query it. The files in <code>src/test/rustdoc-js</code> each contain a
different search query and the expected results, broken out by search tab.
These files are processed by a script in <code>src/tools/rustdoc-js</code> and the Node.js
runtime. These tests don't have as thorough of a writeup, but a broad example
that features results in all tabs can be found in <code>basic.js</code>. The basic idea is
that you match a given <code>QUERY</code> with a set of <code>EXPECTED</code> results, complete with
the full item path of each item.</p>
<h1><a class="header" href="#queries-demand-driven-compilation" id="queries-demand-driven-compilation">Queries: demand-driven compilation</a></h1>
<p>As described in <a href="rustc-guide/high-level-overview.html">the high-level overview of the compiler</a>, the
Rust compiler is current transitioning from a traditional &quot;pass-based&quot;
setup to a &quot;demand-driven&quot; system. <strong>The Compiler Query System is the
key to our new demand-driven organization.</strong> The idea is pretty
simple. You have various queries that compute things about the input
– for example, there is a query called <code>type_of(def_id)</code> that, given
the def-id of some item, will compute the type of that item and return
it to you.</p>
<p>Query execution is <strong>memoized</strong> – so the first time you invoke a
query, it will go do the computation, but the next time, the result is
returned from a hashtable. Moreover, query execution fits nicely into
<strong>incremental computation</strong>; the idea is roughly that, when you do a
query, the result <strong>may</strong> be returned to you by loading stored data
from disk (but that's a separate topic we won't discuss further here).</p>
<p>The overall vision is that, eventually, the entire compiler
control-flow will be query driven. There will effectively be one
top-level query (&quot;compile&quot;) that will run compilation on a crate; this
will in turn demand information about that crate, starting from the
<em>end</em>.  For example:</p>
<ul>
<li>This &quot;compile&quot; query might demand to get a list of codegen-units
(i.e. modules that need to be compiled by LLVM).</li>
<li>But computing the list of codegen-units would invoke some subquery
that returns the list of all modules defined in the Rust source.</li>
<li>That query in turn would invoke something asking for the HIR.</li>
<li>This keeps going further and further back until we wind up doing the
actual parsing.</li>
</ul>
<p>However, that vision is not fully realized. Still, big chunks of the
compiler (for example, generating MIR) work exactly like this.</p>
<h3><a class="header" href="#the-query-evaluation-model-in-detail" id="the-query-evaluation-model-in-detail">The Query Evaluation Model in Detail</a></h3>
<p>The <a href="rustc-guide/queries/query-evaluation-model-in-detail.html">Query Evaluation Model in Detail</a> chapter gives a more
in-depth description of what queries are and how they work.
If you intend to write a query of your own, this is a good read.</p>
<h3><a class="header" href="#invoking-queries" id="invoking-queries">Invoking queries</a></h3>
<p>To invoke a query is simple. The tcx (&quot;type context&quot;) offers a method
for each defined query. So, for example, to invoke the <code>type_of</code>
query, you would just do this:</p>
<pre><code class="language-rust ignore">let ty = tcx.type_of(some_def_id);
</code></pre>
<h3><a class="header" href="#how-the-compiler-executes-a-query" id="how-the-compiler-executes-a-query">How the compiler executes a query</a></h3>
<p>So you may be wondering what happens when you invoke a query
method. The answer is that, for each query, the compiler maintains a
cache – if your query has already been executed, then, the answer is
simple: we clone the return value out of the cache and return it
(therefore, you should try to ensure that the return types of queries
are cheaply cloneable; insert a <code>Rc</code> if necessary).</p>
<h4><a class="header" href="#providers" id="providers">Providers</a></h4>
<p>If, however, the query is <em>not</em> in the cache, then the compiler will
try to find a suitable <strong>provider</strong>. A provider is a function that has
been defined and linked into the compiler somewhere that contains the
code to compute the result of the query.</p>
<p><strong>Providers are defined per-crate.</strong> The compiler maintains,
internally, a table of providers for every crate, at least
conceptually. Right now, there are really two sets: the providers for
queries about the <strong>local crate</strong> (that is, the one being compiled)
and providers for queries about <strong>external crates</strong> (that is,
dependencies of the local crate). Note that what determines the crate
that a query is targeting is not the <em>kind</em> of query, but the <em>key</em>.
For example, when you invoke <code>tcx.type_of(def_id)</code>, that could be a
local query or an external query, depending on what crate the <code>def_id</code>
is referring to (see the <code>self::keys::Key</code> trait for more information
on how that works).</p>
<p>Providers always have the same signature:</p>
<pre><code class="language-rust ignore">fn provider&lt;'tcx&gt;(
    tcx: TyCtxt&lt;'tcx&gt;,
    key: QUERY_KEY,
) -&gt; QUERY_RESULT {
    ...
}
</code></pre>
<p>Providers take two arguments: the <code>tcx</code> and the query key.
They return the result of the query.</p>
<h4><a class="header" href="#how-providers-are-setup" id="how-providers-are-setup">How providers are setup</a></h4>
<p>When the tcx is created, it is given the providers by its creator using
the <code>Providers</code> struct. This struct is generated by the macros here, but it
is basically a big list of function pointers:</p>
<pre><code class="language-rust ignore">struct Providers {
    type_of: for&lt;'tcx&gt; fn(TyCtxt&lt;'tcx&gt;, DefId) -&gt; Ty&lt;'tcx&gt;,
    ...
}
</code></pre>
<p>At present, we have one copy of the struct for local crates, and one
for external crates, though the plan is that we may eventually have
one per crate.</p>
<p>These <code>Provider</code> structs are ultimately created and populated by
<code>librustc_driver</code>, but it does this by distributing the work
throughout the other <code>rustc_*</code> crates. This is done by invoking
various <code>provide</code> functions. These functions tend to look something
like this:</p>
<pre><code class="language-rust ignore">pub fn provide(providers: &amp;mut Providers) {
    *providers = Providers {
        type_of,
        ..*providers
    };
}
</code></pre>
<p>That is, they take an <code>&amp;mut Providers</code> and mutate it in place. Usually
we use the formulation above just because it looks nice, but you could
as well do <code>providers.type_of = type_of</code>, which would be equivalent.
(Here, <code>type_of</code> would be a top-level function, defined as we saw
before.) So, if we want to add a provider for some other query,
let's call it <code>fubar</code>, into the crate above, we might modify the <code>provide()</code>
function like so:</p>
<pre><code class="language-rust ignore">pub fn provide(providers: &amp;mut Providers) {
    *providers = Providers {
        type_of,
        fubar,
        ..*providers
    };
}

fn fubar&lt;'tcx&gt;(tcx: TyCtxt&lt;'tcx&gt;, key: DefId) -&gt; Fubar&lt;'tcx&gt; { ... }
</code></pre>
<p>N.B. Most of the <code>rustc_*</code> crates only provide <strong>local
providers</strong>. Almost all <strong>extern providers</strong> wind up going through the
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_metadata"><code>rustc_metadata</code> crate</a>, which loads the information from the
crate metadata. But in some cases there are crates that provide queries for
<em>both</em> local and external crates, in which case they define both a
<code>provide</code> and a <code>provide_extern</code> function that <code>rustc_driver</code> can
invoke.</p>
<h3><a class="header" href="#adding-a-new-kind-of-query" id="adding-a-new-kind-of-query">Adding a new kind of query</a></h3>
<p>So suppose you want to add a new kind of query, how do you do so?
Well, defining a query takes place in two steps:</p>
<ol>
<li>first, you have to specify the query name and arguments; and then,</li>
<li>you have to supply query providers where needed.</li>
</ol>
<p>To specify the query name and arguments, you simply add an entry to
the big macro invocation in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/query/index.html"><code>src/librustc/query/mod.rs</code></a>, which looks something like:</p>
<pre><code class="language-rust ignore">rustc_queries! {
    Other {
        /// Records the type of every item.
        query type_of(key: DefId) -&gt; Ty&lt;'tcx&gt; {
            cache { key.is_local() }
        }
    }

    ...
}
</code></pre>
<p>Queries are grouped into categories (<code>Other</code>, <code>Codegen</code>, <code>TypeChecking</code>, etc.).
Each group contains one or more queries. Each query definition is broken up like
this:</p>
<pre><code class="language-rust ignore">query type_of(key: DefId) -&gt; Ty&lt;'tcx&gt; { ... }
^^    ^^^^^^^      ^^^^^     ^^^^^^^^   ^^^
|     |            |         |          |
|     |            |         |          query modifiers
|     |            |         result type of query
|     |            query key type
|     name of query
query keyword
</code></pre>
<p>Let's go over them one by one:</p>
<ul>
<li><strong>Query keyword:</strong> indicates a start of a query definition.</li>
<li><strong>Name of query:</strong> the name of the query method
(<code>tcx.type_of(..)</code>). Also used as the name of a struct
(<code>ty::queries::type_of</code>) that will be generated to represent
this query.</li>
<li><strong>Query key type:</strong> the type of the argument to this query.
This type must implement the <code>ty::query::keys::Key</code> trait, which
defines (for example) how to map it to a crate, and so forth.</li>
<li><strong>Result type of query:</strong> the type produced by this query. This type
should (a) not use <code>RefCell</code> or other interior mutability and (b) be
cheaply cloneable. Interning or using <code>Rc</code> or <code>Arc</code> is recommended for
non-trivial data types.
<ul>
<li>The one exception to those rules is the <code>ty::steal::Steal</code> type,
which is used to cheaply modify MIR in place. See the definition
of <code>Steal</code> for more details. New uses of <code>Steal</code> should <strong>not</strong> be
added without alerting <code>@rust-lang/compiler</code>.</li>
</ul>
</li>
<li><strong>Query modifiers:</strong> various flags and options that customize how the
query is processed.</li>
</ul>
<p>So, to add a query:</p>
<ul>
<li>Add an entry to <code>rustc_queries!</code> using the format above.</li>
<li>Link the provider by modifying the appropriate <code>provide</code> method;
or add a new one if needed and ensure that <code>rustc_driver</code> is invoking it.</li>
</ul>
<h4><a class="header" href="#query-structs-and-descriptions" id="query-structs-and-descriptions">Query structs and descriptions</a></h4>
<p>For each kind, the <code>rustc_queries</code> macro will generate a &quot;query struct&quot;
named after the query. This struct is a kind of a place-holder
describing the query. Each such struct implements the
<code>self::config::QueryConfig</code> trait, which has associated types for the
key/value of that particular query. Basically the code generated looks something
like this:</p>
<pre><code class="language-rust ignore">// Dummy struct representing a particular kind of query:
pub struct type_of&lt;'tcx&gt; { data: PhantomData&lt;&amp;'tcx ()&gt; }

impl&lt;'tcx&gt; QueryConfig for type_of&lt;'tcx&gt; {
  type Key = DefId;
  type Value = Ty&lt;'tcx&gt;;

  const NAME: QueryName = QueryName::type_of;
  const CATEGORY: ProfileCategory = ProfileCategory::Other;
}
</code></pre>
<p>There is an additional trait that you may wish to implement called
<code>self::config::QueryDescription</code>. This trait is used during cycle
errors to give a &quot;human readable&quot; name for the query, so that we can
summarize what was happening when the cycle occurred. Implementing
this trait is optional if the query key is <code>DefId</code>, but if you <em>don't</em>
implement it, you get a pretty generic error (&quot;processing <code>foo</code>...&quot;).
You can put new impls into the <code>config</code> module. They look something like this:</p>
<pre><code class="language-rust ignore">impl&lt;'tcx&gt; QueryDescription for queries::type_of&lt;'tcx&gt; {
    fn describe(tcx: TyCtxt, key: DefId) -&gt; String {
        format!(&quot;computing the type of `{}`&quot;, tcx.def_path_str(key))
    }
}
</code></pre>
<p>Another option is to add <code>desc</code> modifier:</p>
<pre><code class="language-rust ignore">rustc_queries! {
    Other {
        /// Records the type of every item.
        query type_of(key: DefId) -&gt; Ty&lt;'tcx&gt; {
            desc { |tcx| &quot;computing the type of `{}`&quot;, tcx.def_path_str(key) }
        }
    }
}
</code></pre>
<p><code>rustc_queries</code> macro will generate an appropriate <code>impl</code> automatically.</p>
<h1><a class="header" href="#the-query-evaluation-model-in-detail-1" id="the-query-evaluation-model-in-detail-1">The Query Evaluation Model in Detail</a></h1>
<p>This chapter provides a deeper dive into the abstract model queries are built on.
It does not go into implementation details but tries to explain
the underlying logic. The examples here, therefore, have been stripped down and
simplified and don't directly reflect the compilers internal APIs.</p>
<h2><a class="header" href="#what-is-a-query" id="what-is-a-query">What is a query?</a></h2>
<p>Abstractly we view the compiler's knowledge about a given crate as a &quot;database&quot;
and queries are the way of asking the compiler questions about it, i.e.
we &quot;query&quot; the compiler's &quot;database&quot; for facts.</p>
<p>However, there's something special to this compiler database: It starts out empty
and is filled on-demand when queries are executed. Consequently, a query must
know how to compute its result if the database does not contain it yet. For
doing so, it can access other queries and certain input values that the database
is pre-filled with on creation.</p>
<p>A query thus consists of the following things:</p>
<ul>
<li>A name that identifies the query</li>
<li>A &quot;key&quot; that specifies what we want to look up</li>
<li>A result type that specifies what kind of result it yields</li>
<li>A &quot;provider&quot; which is a function that specifies how the result is to be
computed if it isn't already present in the database.</li>
</ul>
<p>As an example, the name of the <code>type_of</code> query is <code>type_of</code>, its query key is a
<code>DefId</code> identifying the item we want to know the type of, the result type is
<code>Ty&lt;'tcx&gt;</code>, and the provider is a function that, given the query key and access
to the rest of the database, can compute the type of the item identified by the
key.</p>
<p>So in some sense a query is just a function that maps the query key to the
corresponding result. However, we have to apply some restrictions in order for
this to be sound:</p>
<ul>
<li>The key and result must be immutable values.</li>
<li>The provider function must be a pure function, that is, for the same key it
must always yield the same result.</li>
<li>The only parameters a provider function takes are the key and a reference to
the &quot;query context&quot; (which provides access to rest of the &quot;database&quot;).</li>
</ul>
<p>The database is built up lazily by invoking queries. The query providers will
invoke other queries, for which the result is either already cached or computed
by calling another query provider. These query provider invocations
conceptually form a directed acyclic graph (DAG) at the leaves of which are
input values that are already known when the query context is created.</p>
<h2><a class="header" href="#cachingmemoization" id="cachingmemoization">Caching/Memoization</a></h2>
<p>Results of query invocations are &quot;memoized&quot; which means that the query context
will cache the result in an internal table and, when the query is invoked with
the same query key again, will return the result from the cache instead of
running the provider again.</p>
<p>This caching is crucial for making the query engine efficient. Without
memoization the system would still be sound (that is, it would yield the same
results) but the same computations would be done over and over again.</p>
<p>Memoization is one of the main reasons why query providers have to be pure
functions. If calling a provider function could yield different results for
each invocation (because it accesses some global mutable state) then we could
not memoize the result.</p>
<h2><a class="header" href="#input-data" id="input-data">Input data</a></h2>
<p>When the query context is created, it is still empty: No queries have been
executed, no results are cached. But the context already provides access to
&quot;input&quot; data, i.e. pieces of immutable data that where computed before the
context was created and that queries can access to do their computations.
Currently this input data consists mainly of the HIR map and the command-line
options the compiler was invoked with. In the future, inputs will just consist
of command-line options and a list of source files -- the HIR map will itself
be provided by a query which processes these source files.</p>
<p>Without inputs, queries would live in a void without anything to compute their
result from (remember, query providers only have access to other queries and
the context but not any other outside state or information).</p>
<p>For a query provider, input data and results of other queries look exactly the
same: It just tells the context &quot;give me the value of X&quot;. Because input data
is immutable, the provider can rely on it being the same across
different query invocations, just as is the case for query results.</p>
<h2><a class="header" href="#an-example-execution-trace-of-some-queries" id="an-example-execution-trace-of-some-queries">An example execution trace of some queries</a></h2>
<p>How does this DAG of query invocations come into existence? At some point
the compiler driver will create the, as yet empty, query context. It will then,
from outside of the query system, invoke the queries it needs to perform its
task. This looks something like the following:</p>
<pre><code class="language-rust ignore">fn compile_crate() {
    let cli_options = ...;
    let hir_map = ...;

    // Create the query context `tcx`
    let tcx = TyCtxt::new(cli_options, hir_map);

    // Do type checking by invoking the type check query
    tcx.type_check_crate();
}
</code></pre>
<p>The <code>type_check_crate</code> query provider would look something like the following:</p>
<pre><code class="language-rust ignore">fn type_check_crate_provider(tcx, _key: ()) {
    let list_of_items = tcx.hir_map.list_of_items();

    for item_def_id in list_of_hir_items {
        tcx.type_check_item(item_def_id);
    }
}
</code></pre>
<p>We see that the <code>type_check_crate</code> query accesses input data
(<code>tcx.hir_map.list_of_items()</code>) and invokes other queries
(<code>type_check_item</code>). The <code>type_check_item</code>
invocations will themselves access input data and/or invoke other queries,
so that in the end the DAG of query invocations will be built up backwards
from the node that was initially executed:</p>
<pre><code class="language-ignore">         (2)                                                 (1)
  list_of_all_hir_items &lt;----------------------------- type_check_crate()
                                                               |
    (5)             (4)                  (3)                   |
  Hir(foo) &lt;--- type_of(foo) &lt;--- type_check_item(foo) &lt;-------+
                                      |                        |
                    +-----------------+                        |
                    |                                          |
    (7)             v  (6)                  (8)                |
  Hir(bar) &lt;--- type_of(bar) &lt;--- type_check_item(bar) &lt;-------+

// (x) denotes invocation order
</code></pre>
<p>We also see that often a query result can be read from the cache:
<code>type_of(bar)</code> was computed for <code>type_check_item(foo)</code> so when
<code>type_check_item(bar)</code> needs it, it is already in the cache.</p>
<p>Query results stay cached in the query context as long as the context lives.
So if the compiler driver invoked another query later on, the above graph
would still exist and already executed queries would not have to be re-done.</p>
<h2><a class="header" href="#cycles" id="cycles">Cycles</a></h2>
<p>Earlier we stated that query invocations form a DAG. However, it would be easy
form a cyclic graph by, for example, having a query provider like the following:</p>
<pre><code class="language-rust ignore">fn cyclic_query_provider(tcx, key) -&gt; u32 {
  // Invoke the same query with the same key again
  tcx.cyclic_query(key)
}
</code></pre>
<p>Since query providers are regular functions, this would behave much as expected:
Evaluation would get stuck in an infinite recursion. A query like this would not
be very useful either. However, sometimes certain kinds of invalid user input
can result in queries being called in a cyclic way. The query engine includes
a check for cyclic invocations and, because cycles are an irrecoverable error,
will abort execution with a &quot;cycle error&quot; messages that tries to be human
readable.</p>
<p>At some point the compiler had a notion of &quot;cycle recovery&quot;, that is, one could
&quot;try&quot; to execute a query and if it ended up causing a cycle, proceed in some
other fashion. However, this was later removed because it is not entirely
clear what the theoretical consequences of this are, especially regarding
incremental compilation.</p>
<h2><a class="header" href="#steal-queries" id="steal-queries">&quot;Steal&quot; Queries</a></h2>
<p>Some queries have their result wrapped in a <code>Steal&lt;T&gt;</code> struct. These queries
behave exactly the same as regular with one exception: Their result is expected
to be &quot;stolen&quot; out of the cache at some point, meaning some other part of the
program is taking ownership of it and the result cannot be accessed anymore.</p>
<p>This stealing mechanism exists purely as a performance optimization because some
result values are too costly to clone (e.g. the MIR of a function). It seems
like result stealing would violate the condition that query results must be
immutable (after all we are moving the result value out of the cache) but it is
OK as long as the mutation is not observable. This is achieved by two things:</p>
<ul>
<li>Before a result is stolen, we make sure to eagerly run all queries that
might ever need to read that result. This has to be done manually by calling
those queries.</li>
<li>Whenever a query tries to access a stolen result, we make the compiler ICE so
that such a condition cannot go unnoticed.</li>
</ul>
<p>This is not an ideal setup because of the manual intervention needed, so it
should be used sparingly and only when it is well known which queries might
access a given result. In practice, however, stealing has not turned out to be
much of a maintenance burden.</p>
<p>To summarize: &quot;Steal queries&quot; break some of the rules in a controlled way.
There are checks in place that make sure that nothing can go silently wrong.</p>
<h2><a class="header" href="#parallel-query-execution" id="parallel-query-execution">Parallel Query Execution</a></h2>
<p>The query model has some properties that make it actually feasible to evaluate
multiple queries in parallel without too much of an effort:</p>
<ul>
<li>All data a query provider can access is accessed via the query context, so
the query context can take care of synchronizing access.</li>
<li>Query results are required to be immutable so they can safely be used by
different threads concurrently.</li>
</ul>
<p>The nightly compiler already implements parallel query evaluation as follows:</p>
<p>When a query <code>foo</code> is evaluated, the cache table for <code>foo</code> is locked.</p>
<ul>
<li>If there already is a result, we can clone it,release the lock and
we are done.</li>
<li>If there is no cache entry and no other active query invocation computing the
same result, we mark the key as being &quot;in progress&quot;, release the lock and
start evaluating.</li>
<li>If there <em>is</em> another query invocation for the same key in progress, we
release the lock, and just block the thread until the other invocation has
computed the result we are waiting for. This cannot deadlock because, as
mentioned before, query invocations form a DAG. Some thread will always make
progress.</li>
</ul>
<h1><a class="header" href="#incremental-compilation-1" id="incremental-compilation-1">Incremental compilation</a></h1>
<p>The incremental compilation scheme is, in essence, a surprisingly
simple extension to the overall query system. We'll start by describing
a slightly simplified variant of the real thing – the &quot;basic algorithm&quot; –
and then describe some possible improvements.</p>
<h2><a class="header" href="#the-basic-algorithm" id="the-basic-algorithm">The basic algorithm</a></h2>
<p>The basic algorithm is
called the <strong>red-green</strong> algorithm<sup class="footnote-reference"><a href="#salsa">1</a></sup>. The high-level idea is
that, after each run of the compiler, we will save the results of all
the queries that we do, as well as the <strong>query DAG</strong>. The
<strong>query DAG</strong> is a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a> that indexes which queries executed which
other queries. So, for example, there would be an edge from a query Q1
to another query Q2 if computing Q1 required computing Q2 (note that
because queries cannot depend on themselves, this results in a DAG and
not a general graph).</p>
<p>On the next run of the compiler, then, we can sometimes reuse these
query results to avoid re-executing a query. We do this by assigning
every query a <strong>color</strong>:</p>
<ul>
<li>If a query is colored <strong>red</strong>, that means that its result during
this compilation has <strong>changed</strong> from the previous compilation.</li>
<li>If a query is colored <strong>green</strong>, that means that its result is
the <strong>same</strong> as the previous compilation.</li>
</ul>
<p>There are two key insights here:</p>
<ul>
<li>First, if all the inputs to query Q are colored green, then the
query Q <strong>must</strong> result in the same value as last time and hence
need not be re-executed (or else the compiler is not deterministic).</li>
<li>Second, even if some inputs to a query changes, it may be that it
<strong>still</strong> produces the same result as the previous compilation. In
particular, the query may only use part of its input.
<ul>
<li>Therefore, after executing a query, we always check whether it
produced the same result as the previous time. <strong>If it did,</strong> we
can still mark the query as green, and hence avoid re-executing
dependent queries.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#the-try-mark-green-algorithm" id="the-try-mark-green-algorithm">The try-mark-green algorithm</a></h3>
<p>At the core of incremental compilation is an algorithm called
&quot;try-mark-green&quot;. It has the job of determining the color of a given
query Q (which must not have yet been executed). In cases where Q has
red inputs, determining Q's color may involve re-executing Q so that
we can compare its output, but if all of Q's inputs are green, then we
can conclude that Q must be green without re-executing it or inspecting
its value at all. In the compiler, this allows us to avoid
deserializing the result from disk when we don't need it, and in fact
enables us to sometimes skip <em>serializing</em> the result as well
(see the refinements section below).</p>
<p>Try-mark-green works as follows:</p>
<ul>
<li>First check if the query Q was executed during the previous compilation.
<ul>
<li>If not, we can just re-execute the query as normal, and assign it the
color of red.</li>
</ul>
</li>
<li>If yes, then load the 'dependent queries' of Q.</li>
<li>If there is a saved result, then we load the <code>reads(Q)</code> vector from the
query DAG. The &quot;reads&quot; is the set of queries that Q executed during
its execution.
<ul>
<li>For each query R in <code>reads(Q)</code>, we recursively demand the color
of R using try-mark-green.
<ul>
<li>Note: it is important that we visit each node in <code>reads(Q)</code> in same order
as they occurred in the original compilation. See <a href="rustc-guide/queries/incremental-compilation.html#dag">the section on the
query DAG below</a>.</li>
<li>If <strong>any</strong> of the nodes in <code>reads(Q)</code> wind up colored <strong>red</strong>, then Q is
dirty.
<ul>
<li>We re-execute Q and compare the hash of its result to the hash of the
result from the previous compilation.</li>
<li>If the hash has not changed, we can mark Q as <strong>green</strong> and return.</li>
</ul>
</li>
<li>Otherwise, <strong>all</strong> of the nodes in <code>reads(Q)</code> must be <strong>green</strong>. In that
case, we can color Q as <strong>green</strong> and return.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a name="dag"></a></p>
<h3><a class="header" href="#the-query-dag" id="the-query-dag">The query DAG</a></h3>
<p>The query DAG code is stored in
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph"><code>src/librustc/dep_graph</code></a>. Construction of the DAG is done
by instrumenting the query execution.</p>
<p>One key point is that the query DAG also tracks ordering; that is, for
each query Q, we not only track the queries that Q reads, we track the
<strong>order</strong> in which they were read.  This allows try-mark-green to walk
those queries back in the same order. This is important because once a
subquery comes back as red, we can no longer be sure that Q will continue
along the same path as before. That is, imagine a query like this:</p>
<pre><code class="language-rust ignore">fn main_query(tcx) {
    if tcx.subquery1() {
        tcx.subquery2()
    } else {
        tcx.subquery3()
    }
}
</code></pre>
<p>Now imagine that in the first compilation, <code>main_query</code> starts by
executing <code>subquery1</code>, and this returns true. In that case, the next
query <code>main_query</code> executes will be <code>subquery2</code>, and <code>subquery3</code> will
not be executed at all.</p>
<p>But now imagine that in the <strong>next</strong> compilation, the input has
changed such that <code>subquery1</code> returns <strong>false</strong>. In this case, <code>subquery2</code>
would never execute. If try-mark-green were to visit <code>reads(main_query)</code> out
of order, however, it might visit <code>subquery2</code> before <code>subquery1</code>, and hence
execute it.
This can lead to ICEs and other problems in the compiler.</p>
<h2><a class="header" href="#improvements-to-the-basic-algorithm" id="improvements-to-the-basic-algorithm">Improvements to the basic algorithm</a></h2>
<p>In the description of the basic algorithm, we said that at the end of
compilation we would save the results of all the queries that were
performed.  In practice, this can be quite wasteful – many of those
results are very cheap to recompute, and serializing and deserializing
them is not a particular win. In practice, what we would do is to save
<strong>the hashes</strong> of all the subqueries that we performed. Then, in select cases,
we <strong>also</strong> save the results.</p>
<p>This is why the incremental algorithm separates computing the
<strong>color</strong> of a node, which often does not require its value, from
computing the <strong>result</strong> of a node. Computing the result is done via a simple
algorithm like so:</p>
<ul>
<li>Check if a saved result for Q is available. If so, compute the color of Q.
If Q is green, deserialize and return the saved result.</li>
<li>Otherwise, execute Q.
<ul>
<li>We can then compare the hash of the result and color Q as green if
it did not change.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#resources" id="resources">Resources</a></h2>
<p>The initial design document can be found at https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md, which expands on the memoization details, provides more high-level overview and motivation for this system.</p>
<h1><a class="header" href="#footnotes" id="footnotes">Footnotes</a></h1>
<div class="footnote-definition" id="salsa"><sup class="footnote-definition-label">1</sup>
<p>I have long wanted to rename it to the Salsa algorithm, but it never caught on. -@nikomatsakis</p>
</div>
<h1><a class="header" href="#incremental-compilation-in-detail" id="incremental-compilation-in-detail">Incremental Compilation In Detail</a></h1>
<p>The incremental compilation scheme is, in essence, a surprisingly
simple extension to the overall query system. It relies on the fact that:</p>
<ol>
<li>queries are pure functions -- given the same inputs, a query will always
yield the same result, and</li>
<li>the query model structures compilation in an acyclic graph that makes
dependencies between individual computations explicit.</li>
</ol>
<p>This chapter will explain how we can use these properties for making things
incremental and then goes on to discuss version implementation issues.</p>
<h1><a class="header" href="#a-basic-algorithm-for-incremental-query-evaluation" id="a-basic-algorithm-for-incremental-query-evaluation">A Basic Algorithm For Incremental Query Evaluation</a></h1>
<p>As explained in the <a href="rustc-guide/queries/./query-evaluation-model-in-detail.html">query evaluation model primer</a>, query
invocations form a directed-acyclic graph. Here's the example from the
previous chapter again:</p>
<pre><code class="language-ignore">  list_of_all_hir_items &lt;----------------------------- type_check_crate()
                                                               |
                                                               |
  Hir(foo) &lt;--- type_of(foo) &lt;--- type_check_item(foo) &lt;-------+
                                      |                        |
                    +-----------------+                        |
                    |                                          |
                    v                                          |
  Hir(bar) &lt;--- type_of(bar) &lt;--- type_check_item(bar) &lt;-------+
</code></pre>
<p>Since every access from one query to another has to go through the query
context, we can record these accesses and thus actually build this dependency
graph in memory. With dependency tracking enabled, when compilation is done,
we know which queries were invoked (the nodes of the graph) and for each
invocation, which other queries or input has gone into computing the query's
result (the edges of the graph).</p>
<p>Now suppose, we change the source code of our program so that
HIR of <code>bar</code> looks different than before. Our goal is to only recompute
those queries that are actually affected by the change while just re-using
the cached results of all the other queries. Given the dependency graph we can
do exactly that. For a given query invocation, the graph tells us exactly
what data has gone into computing its results, we just have to follow the
edges until we reach something that has changed. If we don't encounter
anything that has changed, we know that the query still would evaluate to
the same result we already have in our cache.</p>
<p>Taking the <code>type_of(foo)</code> invocation from above as example, we can check
whether the cached result is still valid by following the edges to its
inputs. The only edge leads to <code>Hir(foo)</code>, an input that has not been affected
by the change. So we know that the cached result for <code>type_of(foo)</code> is still
valid.</p>
<p>The story is a bit different for <code>type_check_item(foo)</code>: We again walk the
edges and already know that <code>type_of(foo)</code> is fine. Then we get to
<code>type_of(bar)</code> which we have not checked yet, so we walk the edges of
<code>type_of(bar)</code> and encounter <code>Hir(bar)</code> which <em>has</em> changed. Consequently
the result of <code>type_of(bar)</code> might yield a different same result than what we
have in the cache and, transitively, the result of <code>type_check_item(foo)</code>
might have changed too. We thus re-run <code>type_check_item(foo)</code>, which in
turn will re-run <code>type_of(bar)</code>, which will yield an up-to-date result
because it reads the up-to-date version of <code>Hir(bar)</code>.</p>
<h1><a class="header" href="#the-problem-with-the-basic-algorithm-false-positives" id="the-problem-with-the-basic-algorithm-false-positives">The Problem With The Basic Algorithm: False Positives</a></h1>
<p>If you read the previous paragraph carefully, you'll notice that it says that
<code>type_of(bar)</code> <em>might</em> have changed because one of its inputs has changed.
There's also the possibility that it might still yield exactly the same
result <em>even though</em> its input has changed. Consider an example with a
simple query that just computes the sign of an integer:</p>
<pre><code class="language-ignore">  IntValue(x) &lt;---- sign_of(x) &lt;--- some_other_query(x)
</code></pre>
<p>Let's say that <code>IntValue(x)</code> starts out as <code>1000</code> and then is set to <code>2000</code>.
Even though <code>IntValue(x)</code> is different in the two cases, <code>sign_of(x)</code> yields
the result <code>+</code> in both cases.</p>
<p>If we follow the basic algorithm, however, <code>some_other_query(x)</code> would have to
(unnecessarily) be re-evaluated because it transitively depends on a changed
input. Change detection yields a &quot;false positive&quot; in this case because it has
to conservatively assume that <code>some_other_query(x)</code> might be affected by that
changed input.</p>
<p>Unfortunately it turns out that the actual queries in the compiler are full
of examples like this and small changes to the input often potentially affect
very large parts of the output binaries. As a consequence, we had to make the
change detection system smarter and more accurate.</p>
<h1><a class="header" href="#improving-accuracy-the-red-green-algorithm" id="improving-accuracy-the-red-green-algorithm">Improving Accuracy: The red-green Algorithm</a></h1>
<p>The &quot;false positives&quot; problem can be solved by interleaving change detection
and query re-evaluation. Instead of walking the graph all the way to the
inputs when trying to find out if some cached result is still valid, we can
check if a result has <em>actually</em> changed after we were forced to re-evaluate
it.</p>
<p>We call this algorithm, for better or worse, the red-green algorithm because nodes
in the dependency graph are assigned the color green if we were able to prove
that its cached result is still valid and the color red if the result has
turned out to be different after re-evaluating it.</p>
<p>The meat of red-green change tracking is implemented in the try-mark-green
algorithm, that, you've guessed it, tries to mark a given node as green:</p>
<pre><code class="language-rust ignore">fn try_mark_green(tcx, current_node) -&gt; bool {

    // Fetch the inputs to `current_node`, i.e. get the nodes that the direct
    // edges from `node` lead to.
    let dependencies = tcx.dep_graph.get_dependencies_of(current_node);

    // Now check all the inputs for changes
    for dependency in dependencies {

        match tcx.dep_graph.get_node_color(dependency) {
            Green =&gt; {
                // This input has already been checked before and it has not
                // changed; so we can go on to check the next one
            }
            Red =&gt; {
                // We found an input that has changed. We cannot mark
                // `current_node` as green without re-running the
                // corresponding query.
                return false
            }
            Unknown =&gt; {
                // This is the first time we are look at this node. Let's try
                // to mark it green by calling try_mark_green() recursively.
                if try_mark_green(tcx, dependency) {
                    // We successfully marked the input as green, on to the
                    // next.
                } else {
                    // We could *not* mark the input as green. This means we
                    // don't know if its value has changed. In order to find
                    // out, we re-run the corresponding query now!
                    tcx.run_query_for(dependency);

                    // Fetch and check the node color again. Running the query
                    // has forced it to either red (if it yielded a different
                    // result than we have in the cache) or green (if it
                    // yielded the same result).
                    match tcx.dep_graph.get_node_color(dependency) {
                        Red =&gt; {
                            // The input turned out to be red, so we cannot
                            // mark `current_node` as green.
                            return false
                        }
                        Green =&gt; {
                            // Re-running the query paid off! The result is the
                            // same as before, so this particular input does
                            // not invalidate `current_node`.
                        }
                        Unknown =&gt; {
                            // There is no way a node has no color after
                            // re-running the query.
                            panic!(&quot;unreachable&quot;)
                        }
                    }
                }
            }
        }
    }

    // If we have gotten through the entire loop, it means that all inputs
    // have turned out to be green. If all inputs are unchanged, it means
    // that the query result corresponding to `current_node` cannot have
    // changed either.
    tcx.dep_graph.mark_green(current_node);

    true
}

// Note: The actual implementation can be found in
//       src/librustc/dep_graph/graph.rs
</code></pre>
<p>By using red-green marking we can avoid the devastating cumulative effect of
having false positives during change detection. Whenever a query is executed
in incremental mode, we first check if its already green. If not, we run
<code>try_mark_green()</code> on it. If it still isn't green after that, then we actually
invoke the query provider to re-compute the result.</p>
<h1><a class="header" href="#the-real-world-how-persistence-makes-everything-complicated" id="the-real-world-how-persistence-makes-everything-complicated">The Real World: How Persistence Makes Everything Complicated</a></h1>
<p>The sections above described the underlying algorithm for incremental
compilation but because the compiler process exits after being finished and
takes the query context with its result cache with it into oblivion, we have
persist data to disk, so the next compilation session can make use of it.
This comes with a whole new set of implementation challenges:</p>
<ul>
<li>The query results cache is stored to disk, so they are not readily available
for change comparison.</li>
<li>A subsequent compilation session will start off with new version of the code
that has arbitrary changes applied to it. All kinds of IDs and indices that
are generated from a global, sequential counter (e.g. <code>NodeId</code>, <code>DefId</code>, etc)
might have shifted, making the persisted results on disk not immediately
usable anymore because the same numeric IDs and indices might refer to
completely new things in the new compilation session.</li>
<li>Persisting things to disk comes at a cost, so not every tiny piece of
information should be actually cached in between compilation sessions.
Fixed-sized, plain-old-data is preferred to complex things that need to run
branching code during (de-)serialization.</li>
</ul>
<p>The following sections describe how the compiler currently solves these issues.</p>
<h2><a class="header" href="#a-question-of-stability-bridging-the-gap-between-compilation-sessions" id="a-question-of-stability-bridging-the-gap-between-compilation-sessions">A Question Of Stability: Bridging The Gap Between Compilation Sessions</a></h2>
<p>As noted before, various IDs (like <code>DefId</code>) are generated by the compiler in a
way that depends on the contents of the source code being compiled. ID assignment
is usually deterministic, that is, if the exact same code is compiled twice,
the same things will end up with the same IDs. However, if something
changes, e.g. a function is added in the middle of a file, there is no
guarantee that anything will have the same ID as it had before.</p>
<p>As a consequence we cannot represent the data in our on-disk cache the same
way it is represented in memory. For example, if we just stored a piece
of type information like <code>TyKind::FnDef(DefId, &amp;'tcx Substs&lt;'tcx&gt;)</code> (as we do
in memory) and then the contained <code>DefId</code> points to a different function in
a new compilation session we'd be in trouble.</p>
<p>The solution to this problem is to find &quot;stable&quot; forms for IDs which remain
valid in between compilation sessions. For the most important case, <code>DefId</code>s,
these are the so-called <code>DefPath</code>s. Each <code>DefId</code> has a
corresponding <code>DefPath</code> but in place of a numeric ID, a <code>DefPath</code> is based on
the path to the identified item, e.g. <code>std::collections::HashMap</code>. The
advantage of an ID like this is that it is not affected by unrelated changes.
For example, one can add a new function to <code>std::collections</code> but
<code>std::collections::HashMap</code> would still be <code>std::collections::HashMap</code>. A
<code>DefPath</code> is &quot;stable&quot; across changes made to the source code while a <code>DefId</code>
isn't.</p>
<p>There is also the <code>DefPathHash</code> which is just a 128-bit hash value of the
<code>DefPath</code>. The two contain the same information and we mostly use the
<code>DefPathHash</code> because it simpler to handle, being <code>Copy</code> and self-contained.</p>
<p>This principle of stable identifiers is used to make the data in the on-disk
cache resilient to source code changes. Instead of storing a <code>DefId</code>, we store
the <code>DefPathHash</code> and when we deserialize something from the cache, we map the
<code>DefPathHash</code> to the corresponding <code>DefId</code> in the <em>current</em> compilation session
(which is just a simple hash table lookup).</p>
<p>The <code>HirId</code>, used for identifying HIR components that don't have their own
<code>DefId</code>, is another such stable ID. It is (conceptually) a pair of a <code>DefPath</code>
and a <code>LocalId</code>, where the <code>LocalId</code> identifies something (e.g. a <code>hir::Expr</code>)
locally within its &quot;owner&quot; (e.g. a <code>hir::Item</code>). If the owner is moved around,
the <code>LocalId</code>s within it are still the same.</p>
<h2><a class="header" href="#checking-query-results-for-changes-stablehash-and-fingerprints" id="checking-query-results-for-changes-stablehash-and-fingerprints">Checking Query Results For Changes: StableHash And Fingerprints</a></h2>
<p>In order to do red-green-marking we often need to check if the result of a
query has changed compared to the result it had during the previous
compilation session. There are two performance problems with this though:</p>
<ul>
<li>We'd like to avoid having to load the previous result from disk just for
doing the comparison. We already computed the new result and will use that.
Also loading a result from disk will &quot;pollute&quot; the interners with data that
is unlikely to ever be used.</li>
<li>We don't want to store each and every result in the on-disk cache. For
example, it would be wasted effort to persist things to disk that are
already available in upstream crates.</li>
</ul>
<p>The compiler avoids these problems by using so-called <code>Fingerprint</code>s. Each time
a new query result is computed, the query engine will compute a 128 bit hash
value of the result. We call this hash value &quot;the <code>Fingerprint</code> of the query
result&quot;. The hashing is (and has to be) done &quot;in a stable way&quot;. This means
that whenever something is hashed that might change in between compilation
sessions (e.g. a <code>DefId</code>), we instead hash its stable equivalent
(e.g. the corresponding <code>DefPath</code>). That's what the whole <code>StableHash</code>
infrastructure is for. This way <code>Fingerprint</code>s computed in two
different compilation sessions are still comparable.</p>
<p>The next step is to store these fingerprints along with the dependency graph.
This is cheap since fingerprints are just bytes to be copied. It's also cheap to
load the entire set of fingerprints together with the dependency graph.</p>
<p>Now, when red-green-marking reaches the point where it needs to check if a
result has changed, it can just compare the (already loaded) previous
fingerprint to the fingerprint of the new result.</p>
<p>This approach works rather well but it's not without flaws:</p>
<ul>
<li>
<p>There is a small possibility of hash collisions. That is, two different
results could have the same fingerprint and the system would erroneously
assume that the result hasn't changed, leading to a missed update.</p>
<p>We mitigate this risk by using a high-quality hash function and a 128 bit
wide hash value. Due to these measures the practical risk of a hash
collision is negligible.</p>
</li>
<li>
<p>Computing fingerprints is quite costly. It is the main reason why incremental
compilation can be slower than non-incremental compilation. We are forced to
use a good and thus expensive hash function, and we have to map things to
their stable equivalents while doing the hashing.</p>
</li>
</ul>
<p>In the future we might want to explore different approaches to this problem.
For now it's <code>StableHash</code> and <code>Fingerprint</code>.</p>
<h2><a class="header" href="#a-tale-of-two-depgraphs-the-old-and-the-new" id="a-tale-of-two-depgraphs-the-old-and-the-new">A Tale Of Two DepGraphs: The Old And The New</a></h2>
<p>The initial description of dependency tracking glosses over a few details
that quickly become a head scratcher when actually trying to implement things.
In particular it's easy to overlook that we are actually dealing with <em>two</em>
dependency graphs: The one we built during the previous compilation session and
the one that we are building for the current compilation session.</p>
<p>When a compilation session starts, the compiler loads the previous dependency
graph into memory as an immutable piece of data. Then, when a query is invoked,
it will first try to mark the corresponding node in the graph as green. This
means really that we are trying to mark the node in the <em>previous</em> dep-graph
as green that corresponds to the query key in the <em>current</em> session. How do we
do this mapping between current query key and previous <code>DepNode</code>? The answer
is again <code>Fingerprint</code>s: Nodes in the dependency graph are identified by a
fingerprint of the query key. Since fingerprints are stable across compilation
sessions, computing one in the current session allows us to find a node
in the dependency graph from the previous session. If we don't find a node with
the given fingerprint, it means that the query key refers to something that
did not yet exist in the previous session.</p>
<p>So, having found the dep-node in the previous dependency graph, we can look
up its dependencies (also dep-nodes in the previous graph) and continue with
the rest of the try-mark-green algorithm. The next interesting thing happens
when we successfully marked the node as green. At that point we copy the node
and the edges to its dependencies from the old graph into the new graph. We
have to do this because the new dep-graph cannot not acquire the
node and edges via the regular dependency tracking. The tracking system can
only record edges while actually running a query -- but running the query,
although we have the result already cached, is exactly what we want to avoid.</p>
<p>Once the compilation session has finished, all the unchanged parts have been
copied over from the old into the new dependency graph, while the changed parts
have been added to the new graph by the tracking system. At this point, the
new graph is serialized out to disk, alongside the query result cache, and can
act as the previous dep-graph in a subsequent compilation session.</p>
<h2><a class="header" href="#didnt-you-forget-something-cache-promotion" id="didnt-you-forget-something-cache-promotion">Didn't You Forget Something?: Cache Promotion</a></h2>
<p>TODO</p>
<h1><a class="header" href="#the-future-shortcomings-of-the-current-system-and-possible-solutions" id="the-future-shortcomings-of-the-current-system-and-possible-solutions">The Future: Shortcomings Of The Current System and Possible Solutions</a></h1>
<p>TODO</p>
<h1><a class="header" href="#debugging-and-testing-dependencies" id="debugging-and-testing-dependencies">Debugging and Testing Dependencies</a></h1>
<h2><a class="header" href="#testing-the-dependency-graph" id="testing-the-dependency-graph">Testing the dependency graph</a></h2>
<p>There are various ways to write tests against the dependency graph.
The simplest mechanisms are the <code>#[rustc_if_this_changed]</code> and
<code>#[rustc_then_this_would_need]</code> annotations. These are used in compile-fail
tests to test whether the expected set of paths exist in the dependency graph.
As an example, see <code>src/test/compile-fail/dep-graph-caller-callee.rs</code>.</p>
<p>The idea is that you can annotate a test like:</p>
<pre><code class="language-rust ignore">#[rustc_if_this_changed]
fn foo() { }

#[rustc_then_this_would_need(TypeckTables)] //~ ERROR OK
fn bar() { foo(); }

#[rustc_then_this_would_need(TypeckTables)] //~ ERROR no path
fn baz() { }
</code></pre>
<p>This will check whether there is a path in the dependency graph from <code>Hir(foo)</code>
to <code>TypeckTables(bar)</code>. An error is reported for each
<code>#[rustc_then_this_would_need]</code> annotation that indicates whether a path
exists. <code>//~ ERROR</code> annotations can then be used to test if a path is found (as
demonstrated above).</p>
<h2><a class="header" href="#debugging-the-dependency-graph" id="debugging-the-dependency-graph">Debugging the dependency graph</a></h2>
<h3><a class="header" href="#dumping-the-graph" id="dumping-the-graph">Dumping the graph</a></h3>
<p>The compiler is also capable of dumping the dependency graph for your
debugging pleasure. To do so, pass the <code>-Z dump-dep-graph</code> flag. The
graph will be dumped to <code>dep_graph.{txt,dot}</code> in the current
directory.  You can override the filename with the <code>RUST_DEP_GRAPH</code>
environment variable.</p>
<p>Frequently, though, the full dep graph is quite overwhelming and not
particularly helpful. Therefore, the compiler also allows you to filter
the graph. You can filter in three ways:</p>
<ol>
<li>All edges originating in a particular set of nodes (usually a single node).</li>
<li>All edges reaching a particular set of nodes.</li>
<li>All edges that lie between given start and end nodes.</li>
</ol>
<p>To filter, use the <code>RUST_DEP_GRAPH_FILTER</code> environment variable, which should
look like one of the following:</p>
<pre><code class="language-text">source_filter     // nodes originating from source_filter
-&gt; target_filter  // nodes that can reach target_filter
source_filter -&gt; target_filter // nodes in between source_filter and target_filter
</code></pre>
<p><code>source_filter</code> and <code>target_filter</code> are a <code>&amp;</code>-separated list of strings.
A node is considered to match a filter if all of those strings appear in its
label. So, for example:</p>
<pre><code class="language-text">RUST_DEP_GRAPH_FILTER='-&gt; TypeckTables'
</code></pre>
<p>would select the predecessors of all <code>TypeckTables</code> nodes. Usually though you
want the <code>TypeckTables</code> node for some particular fn, so you might write:</p>
<pre><code class="language-text">RUST_DEP_GRAPH_FILTER='-&gt; TypeckTables &amp; bar'
</code></pre>
<p>This will select only the predecessors of <code>TypeckTables</code> nodes for functions
with <code>bar</code> in their name.</p>
<p>Perhaps you are finding that when you change <code>foo</code> you need to re-type-check
<code>bar</code>, but you don't think you should have to. In that case, you might do:</p>
<pre><code class="language-text">RUST_DEP_GRAPH_FILTER='Hir &amp; foo -&gt; TypeckTables &amp; bar'
</code></pre>
<p>This will dump out all the nodes that lead from <code>Hir(foo)</code> to
<code>TypeckTables(bar)</code>, from which you can (hopefully) see the source
of the erroneous edge.</p>
<h3><a class="header" href="#tracking-down-incorrect-edges" id="tracking-down-incorrect-edges">Tracking down incorrect edges</a></h3>
<p>Sometimes, after you dump the dependency graph, you will find some
path that should not exist, but you will not be quite sure how it came
to be. <strong>When the compiler is built with debug assertions,</strong> it can
help you track that down. Simply set the <code>RUST_FORBID_DEP_GRAPH_EDGE</code>
environment variable to a filter. Every edge created in the dep-graph
will be tested against that filter – if it matches, a <code>bug!</code> is
reported, so you can easily see the backtrace (<code>RUST_BACKTRACE=1</code>).</p>
<p>The syntax for these filters is the same as described in the previous
section. However, note that this filter is applied to every <strong>edge</strong>
and doesn't handle longer paths in the graph, unlike the previous
section.</p>
<p>Example:</p>
<p>You find that there is a path from the <code>Hir</code> of <code>foo</code> to the type
check of <code>bar</code> and you don't think there should be. You dump the
dep-graph as described in the previous section and open <code>dep-graph.txt</code>
to see something like:</p>
<pre><code class="language-text">Hir(foo) -&gt; Collect(bar)
Collect(bar) -&gt; TypeckTables(bar)
</code></pre>
<p>That first edge looks suspicious to you. So you set
<code>RUST_FORBID_DEP_GRAPH_EDGE</code> to <code>Hir&amp;foo -&gt; Collect&amp;bar</code>, re-run, and
then observe the backtrace. Voila, bug fixed!</p>
<h1><a class="header" href="#the-parser" id="the-parser">The Parser</a></h1>
<p>The parser is responsible for converting raw Rust source code into a structured
form which is easier for the compiler to work with, usually called an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree"><em>Abstract
Syntax Tree</em></a>. An AST mirrors the structure of a Rust program in memory,
using a <code>Span</code> to link a particular AST node back to its source text.</p>
<p>The bulk of the parser lives in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/index.html">libsyntax</a> crate.</p>
<p>Like most parsers, the parsing process is composed of two main steps,</p>
<ul>
<li>lexical analysis – turn a stream of characters into a stream of token trees</li>
<li>parsing – turn the token trees into an AST</li>
</ul>
<p>The <code>syntax</code> crate contains several main players,</p>
<ul>
<li>a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.SourceMap.html"><code>SourceMap</code></a> for mapping AST nodes to their source code</li>
<li>the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/index.html">ast module</a> contains types corresponding to each AST node</li>
<li>a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/lexer/struct.StringReader.html"><code>StringReader</code></a> for lexing source code into tokens</li>
<li>the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/index.html">parser module</a> and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/parser/struct.Parser.html"><code>Parser</code></a> struct are in charge of actually parsing
tokens into AST nodes,</li>
<li>and a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/visit/index.html">visit module</a> for walking the AST and inspecting or mutating the AST
nodes.</li>
</ul>
<p>The main entrypoint to the parser is via the various <code>parse_*</code> functions in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/index.html">parser module</a>. They let you do things like turn a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.SourceFile.html"><code>SourceFile</code></a>
(e.g. the source in a single file) into a token stream, create a parser from
the token stream, and then execute the parser to get a <code>Crate</code> (the root AST
node).</p>
<p>To minimise the amount of copying that is done, both the <code>StringReader</code> and
<code>Parser</code> have lifetimes which bind them to the parent <code>ParseSess</code>. This contains
all the information needed while parsing, as well as the <code>SourceMap</code> itself.</p>
<h3><a class="header" href="#the-test-attribute" id="the-test-attribute">The <code>#[test]</code> attribute</a></h3>
<p>Today, rust programmers rely on a built in attribute called <code>#[test]</code>. All
you have to do is mark a function as a test and include some asserts like so:</p>
<pre><code class="language-rust ignore">#[test]
fn my_test() {
  assert!(2+2 == 4);
}
</code></pre>
<p>When this program is compiled using <code>rustc --test</code> or <code>cargo test</code>, it will
produce an executable that can run this, and any other test function. This
method of testing allows tests to live alongside code in an organic way. You
can even put tests inside private modules:</p>
<pre><code class="language-rust ignore">mod my_priv_mod {
  fn my_priv_func() -&gt; bool {}

  #[test]
  fn test_priv_func() {
    assert!(my_priv_func());
  }
}
</code></pre>
<p>Private items can thus be easily tested without worrying about how to expose
the them to any sort of external testing apparatus. This is key to the
ergonomics of testing in Rust. Semantically, however, it's rather odd.
How does any sort of <code>main</code> function invoke these tests if they're not visible?
What exactly is <code>rustc --test</code> doing?</p>
<p><code>#[test]</code> is implemented as a syntactic transformation inside the compiler's
<a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax"><code>libsyntax</code> crate</a>. Essentially, it's a fancy macro, that
rewrites the crate in 3 steps:</p>
<h4><a class="header" href="#step-1-re-exporting" id="step-1-re-exporting">Step 1: Re-Exporting</a></h4>
<p>As mentioned earlier, tests can exist inside private modules, so we need a
way of exposing them to the main function, without breaking any existing
code. To that end, <code>libsyntax</code> will create local modules called
<code>__test_reexports</code> that recursively reexport tests. This expansion translates
the above example into:</p>
<pre><code class="language-rust ignore">mod my_priv_mod {
  fn my_priv_func() -&gt; bool {}

  pub fn test_priv_func() {
    assert!(my_priv_func());
  }

  pub mod __test_reexports {
    pub use super::test_priv_func;
  }
}
</code></pre>
<p>Now, our test can be accessed as
<code>my_priv_mod::__test_reexports::test_priv_func</code>. For deeper module
structures, <code>__test_reexports</code> will reexport modules that contain tests, so a
test at <code>a::b::my_test</code> becomes
<code>a::__test_reexports::b::__test_reexports::my_test</code>. While this process seems
pretty safe, what happens if there is an existing <code>__test_reexports</code> module?
The answer: nothing.</p>
<p>To explain, we need to understand <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Ident.html">how the AST represents
identifiers</a>. The name of every function, variable, module, etc. is
not stored as a string, but rather as an opaque <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Ident.html">Symbol</a> which is
essentially an ID number for each identifier. The compiler keeps a separate
hashtable that allows us to recover the human-readable name of a Symbol when
necessary (such as when printing a syntax error). When the compiler generates
the <code>__test_reexports</code> module, it generates a new Symbol for the identifier,
so while the compiler-generated <code>__test_reexports</code> may share a name with your
hand-written one, it will not share a Symbol. This technique prevents name
collision during code generation and is the foundation of Rust's macro
hygiene.</p>
<h4><a class="header" href="#step-2-harness-generation" id="step-2-harness-generation">Step 2: Harness Generation</a></h4>
<p>Now that our tests are accessible from the root of our crate, we need to do
something with them. <code>libsyntax</code> generates a module like so:</p>
<pre><code class="language-rust ignore">#[main]
pub fn main() {
  extern crate test;
  test::test_main_static(&amp;[&amp;path::to::test1, /*...*/]);
}
</code></pre>
<p>where <code>path::to::test1</code> is a constant of type <code>test::TestDescAndFn</code>.</p>
<p>While this transformation is simple, it gives us a lot of insight into how
tests are actually run. The tests are aggregated into an array and passed to
a test runner called <code>test_main_static</code>. We'll come back to exactly what
<code>TestDescAndFn</code> is, but for now, the key takeaway is that there is a crate
called <a href="https://doc.rust-lang.org/test/index.html"><code>test</code></a> that is part of Rust core, that implements all of the
runtime for testing. <code>test</code>'s interface is unstable, so the only stable way
to interact with it is through the <code>#[test]</code> macro.</p>
<h4><a class="header" href="#step-3-test-object-generation" id="step-3-test-object-generation">Step 3: Test Object Generation</a></h4>
<p>If you've written tests in Rust before, you may be familiar with some of the
optional attributes available on test functions. For example, a test can be
annotated with <code>#[should_panic]</code> if we expect the test to cause a panic. It
looks something like this:</p>
<pre><code class="language-rust ignore">#[test]
#[should_panic]
fn foo() {
  panic!(&quot;intentional&quot;);
}
</code></pre>
<p>This means our tests are more than just simple functions, they have
configuration information as well. <code>test</code> encodes this configuration data
into a struct called <a href="https://doc.rust-lang.org/test/struct.TestDesc.html"><code>TestDesc</code></a>. For each test function in a
crate, <code>libsyntax</code> will parse its attributes and generate a <code>TestDesc</code>
instance. It then combines the <code>TestDesc</code> and test function into the
predictably named <code>TestDescAndFn</code> struct, that <code>test_main_static</code> operates
on. For a given test, the generated <code>TestDescAndFn</code> instance looks like so:</p>
<pre><code class="language-rust ignore">self::test::TestDescAndFn{
  desc: self::test::TestDesc{
    name: self::test::StaticTestName(&quot;foo&quot;),
    ignore: false,
    should_panic: self::test::ShouldPanic::Yes,
    allow_fail: false,
  },
  testfn: self::test::StaticTestFn(||
    self::test::assert_test_result(::crate::__test_reexports::foo())),
}
</code></pre>
<p>Once we've constructed an array of these test objects, they're passed to the
test runner via the harness generated in step 2.</p>
<h3><a class="header" href="#inspecting-the-generated-code" id="inspecting-the-generated-code">Inspecting the generated code</a></h3>
<p>On nightly rust, there's an unstable flag called <code>unpretty</code> that you can use
to print out the module source after macro expansion:</p>
<pre><code class="language-bash">$ rustc my_mod.rs -Z unpretty=hir
</code></pre>
<h1><a class="header" href="#macro-expansion" id="macro-expansion">Macro expansion</a></h1>
<p>Macro expansion happens during parsing. <code>rustc</code> has two parsers, in fact: the
normal Rust parser, and the macro parser. During the parsing phase, the normal
Rust parser will set aside the contents of macros and their invocations. Later,
before name resolution, macros are expanded using these portions of the code.
The macro parser, in turn, may call the normal Rust parser when it needs to
bind a metavariable (e.g.  <code>$my_expr</code>) while parsing the contents of a macro
invocation. The code for macro expansion is in
<a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax/ext/tt"><code>src/libsyntax/ext/tt/</code></a>. This chapter aims to explain how macro
expansion works.</p>
<h3><a class="header" href="#example" id="example">Example</a></h3>
<p>It's helpful to have an example to refer to. For the remainder of this chapter,
whenever we refer to the &quot;example <em>definition</em>&quot;, we mean the following:</p>
<pre><code class="language-rust ignore">macro_rules! printer {
    (print $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
    }
    (print twice $mvar:ident) =&gt; {
        println!(&quot;{}&quot;, $mvar);
        println!(&quot;{}&quot;, $mvar);
    }
}
</code></pre>
<p><code>$mvar</code> is called a <em>metavariable</em>. Unlike normal variables, rather than
binding to a value in a computation, a metavariable binds <em>at compile time</em> to
a tree of <em>tokens</em>.  A <em>token</em> is a single &quot;unit&quot; of the grammar, such as an
identifier (e.g. <code>foo</code>) or punctuation (e.g. <code>=&gt;</code>). There are also other
special tokens, such as <code>EOF</code>, which indicates that there are no more tokens.
Token trees resulting from paired parentheses-like characters (<code>(</code>...<code>)</code>,
<code>[</code>...<code>]</code>, and <code>{</code>...<code>}</code>) – they include the open and close and all the tokens
in between (we do require that parentheses-like characters be balanced). Having
macro expansion operate on token streams rather than the raw bytes of a source
file abstracts away a lot of complexity. The macro expander (and much of the
rest of the compiler) doesn't really care that much about the exact line and
column of some syntactic construct in the code; it cares about what constructs
are used in the code. Using tokens allows us to care about <em>what</em> without
worrying about <em>where</em>. For more information about tokens, see the
<a href="rustc-guide/./the-parser.html">Parsing</a> chapter of this book.</p>
<p>Whenever we refer to the &quot;example <em>invocation</em>&quot;, we mean the following snippet:</p>
<pre><code class="language-rust ignore">printer!(print foo); // Assume `foo` is a variable defined somewhere else...
</code></pre>
<p>The process of expanding the macro invocation into the syntax tree
<code>println!(&quot;{}&quot;, foo)</code> and then expanding that into a call to <code>Display::fmt</code> is
called <em>macro expansion</em>, and it is the topic of this chapter.</p>
<h3><a class="header" href="#the-macro-parser" id="the-macro-parser">The macro parser</a></h3>
<p>There are two parts to macro expansion: parsing the definition and parsing the
invocations. Interestingly, both are done by the macro parser.</p>
<p>Basically, the macro parser is like an NFA-based regex parser. It uses an
algorithm similar in spirit to the <a href="https://en.wikipedia.org/wiki/Earley_parser">Earley parsing
algorithm</a>. The macro parser is
defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_parser/"><code>src/libsyntax/ext/tt/macro_parser.rs</code></a>.</p>
<p>The interface of the macro parser is as follows (this is slightly simplified):</p>
<pre><code class="language-rust ignore">fn parse(
    sess: ParserSession,
    tts: TokenStream,
    ms: &amp;[TokenTree]
) -&gt; NamedParseResult
</code></pre>
<p>In this interface:</p>
<ul>
<li><code>sess</code> is a &quot;parsing session&quot;, which keeps track of some metadata. Most
notably, this is used to keep track of errors that are generated so they can
be reported to the user.</li>
<li><code>tts</code> is a stream of tokens. The macro parser's job is to consume the raw
stream of tokens and output a binding of metavariables to corresponding token
trees.</li>
<li><code>ms</code> a <em>matcher</em>. This is a sequence of token trees that we want to match
<code>tts</code> against.</li>
</ul>
<p>In the analogy of a regex parser, <code>tts</code> is the input and we are matching it
against the pattern <code>ms</code>. Using our examples, <code>tts</code> could be the stream of
tokens containing the inside of the example invocation <code>print foo</code>, while <code>ms</code>
might be the sequence of token (trees) <code>print $mvar:ident</code>.</p>
<p>The output of the parser is a <code>NamedParseResult</code>, which indicates which of
three cases has occurred:</p>
<ul>
<li>Success: <code>tts</code> matches the given matcher <code>ms</code>, and we have produced a binding
from metavariables to the corresponding token trees.</li>
<li>Failure: <code>tts</code> does not match <code>ms</code>. This results in an error message such as
&quot;No rule expected token <em>blah</em>&quot;.</li>
<li>Error: some fatal error has occurred <em>in the parser</em>. For example, this
happens if there are more than one pattern match, since that indicates
the macro is ambiguous.</li>
</ul>
<p>The full interface is defined <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_parser/fn.parse.html">here</a>.</p>
<p>The macro parser does pretty much exactly the same as a normal regex parser with
one exception: in order to parse different types of metavariables, such as
<code>ident</code>, <code>block</code>, <code>expr</code>, etc., the macro parser must sometimes call back to the
normal Rust parser.</p>
<p>As mentioned above, both definitions and invocations of macros are parsed using
the macro parser. This is extremely non-intuitive and self-referential. The code
to parse macro <em>definitions</em> is in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_rules/"><code>src/libsyntax/ext/tt/macro_rules.rs</code></a>. It defines the pattern for
matching for a macro definition as <code>$( $lhs:tt =&gt; $rhs:tt );+</code>. In other words,
a <code>macro_rules</code> definition should have in its body at least one occurrence of a
token tree followed by <code>=&gt;</code> followed by another token tree. When the compiler
comes to a <code>macro_rules</code> definition, it uses this pattern to match the two token
trees per rule in the definition of the macro <em>using the macro parser itself</em>.
In our example definition, the metavariable <code>$lhs</code> would match the patterns of
both arms: <code>(print $mvar:ident)</code> and <code>(print twice $mvar:ident)</code>.  And <code>$rhs</code>
would match the bodies of both arms: <code>{ println!(&quot;{}&quot;, $mvar); }</code> and <code>{ println!(&quot;{}&quot;, $mvar); println!(&quot;{}&quot;, $mvar); }</code>. The parser would keep this
knowledge around for when it needs to expand a macro invocation.</p>
<p>When the compiler comes to a macro invocation, it parses that invocation using
the same NFA-based macro parser that is described above. However, the matcher
used is the first token tree (<code>$lhs</code>) extracted from the arms of the macro
<em>definition</em>. Using our example, we would try to match the token stream <code>print foo</code> from the invocation against the matchers <code>print $mvar:ident</code> and <code>print twice $mvar:ident</code> that we previously extracted from the definition.  The
algorithm is exactly the same, but when the macro parser comes to a place in the
current matcher where it needs to match a <em>non-terminal</em> (e.g. <code>$mvar:ident</code>),
it calls back to the normal Rust parser to get the contents of that
non-terminal. In this case, the Rust parser would look for an <code>ident</code> token,
which it finds (<code>foo</code>) and returns to the macro parser. Then, the macro parser
proceeds in parsing as normal. Also, note that exactly one of the matchers from
the various arms should match the invocation; if there is more than one match,
the parse is ambiguous, while if there are no matches at all, there is a syntax
error.</p>
<p>For more information about the macro parser's implementation, see the comments
in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ext/tt/macro_parser/"><code>src/libsyntax/ext/tt/macro_parser.rs</code></a>.</p>
<h3><a class="header" href="#hygiene" id="hygiene">Hygiene</a></h3>
<p>If you have ever used C/C++ preprocessor macros, you know that there are some
annoying and hard-to-debug gotchas! For example, consider the following C code:</p>
<pre><code class="language-c">#define DEFINE_FOO struct Bar {int x;}; struct Foo {Bar bar;};

// Then, somewhere else
struct Bar {
    ...
};

DEFINE_FOO
</code></pre>
<p>Most people avoid writing C like this – and for good reason: it doesn't
compile. The <code>struct Bar</code> defined by the macro clashes names with the <code>struct Bar</code> defined in the code. Consider also the following example:</p>
<pre><code class="language-c">#define DO_FOO(x) {\
    int y = 0;\
    foo(x, y);\
    }

// Then elsewhere
int y = 22;
DO_FOO(y);
</code></pre>
<p>Do you see the problem? We wanted to generate a call <code>foo(22, 0)</code>, but instead
we got <code>foo(0, 0)</code> because the macro defined its own <code>y</code>!</p>
<p>These are both examples of <em>macro hygiene</em> issues. <em>Hygiene</em> relates to how to
handle names defined <em>within a macro</em>. In particular, a hygienic macro system
prevents errors due to names introduced within a macro. Rust macros are hygienic
in that they do not allow one to write the sorts of bugs above.</p>
<p>At a high level, hygiene within the rust compiler is accomplished by keeping
track of the context where a name is introduced and used. We can then
disambiguate names based on that context. Future iterations of the macro system
will allow greater control to the macro author to use that context. For example,
a macro author may want to introduce a new name to the context where the macro
was called. Alternately, the macro author may be defining a variable for use
only within the macro (i.e. it should not be visible outside the macro).</p>
<p>In rustc, this &quot;context&quot; is tracked via <code>Span</code>s.</p>
<p>TODO: what is call-site hygiene? what is def-site hygiene?</p>
<p>TODO</p>
<h3><a class="header" href="#procedural-macros-1" id="procedural-macros-1">Procedural Macros</a></h3>
<p>TODO</p>
<h3><a class="header" href="#custom-derive-1" id="custom-derive-1">Custom Derive</a></h3>
<p>TODO</p>
<p>TODO: maybe something about macros 2.0?</p>
<h1><a class="header" href="#name-resolution" id="name-resolution">Name resolution</a></h1>
<p>The name resolution is a two-phase process. In the first phase, which runs
during macro expansion, we build a tree of modules and resolve imports. Macro
expansion and name resolution communicate with each other via the <code>Resolver</code>
trait, defined in <code>libsyntax</code>.</p>
<p>The input to the second phase is the syntax tree, produced by parsing input
files and expanding macros. This phase produces links from all the names in the
source to relevant places where the name was introduced. It also generates
helpful error messages, like typo suggestions, traits to import or lints about
unused items.</p>
<p>A successful run of the second phase (<code>Resolver::resolve_crate</code>) creates kind
of an index the rest of the compilation may use to ask about the present names
(through the <code>hir::lowering::Resolver</code> interface).</p>
<p>The name resolution lives in the <code>librustc_resolve</code> crate, with the meat in
<code>lib.rs</code> and some helpers or symbol-type specific logic in the other modules.</p>
<h2><a class="header" href="#namespaces" id="namespaces">Namespaces</a></h2>
<p>Different kind of symbols live in different namespaces ‒ eg. types don't
clash with variables. This usually doesn't happen, because variables start with
lower-case letter while types with upper case one, but this is only a
convention. This is legal Rust code that'll compile (with warnings):</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>type x = u32;
let x: x = 1;
let y: x = 2; // See? x is still a type here.
<span class="boring">}
</span></code></pre></pre>
<p>To cope with this, and with slightly different scoping rules for these
namespaces, the resolver keeps them separated and builds separate structures for
them.</p>
<p>In other words, when the code talks about namespaces, it doesn't mean the module
hierarchy, it's types vs. values vs. macros.</p>
<h2><a class="header" href="#scopes-and-ribs" id="scopes-and-ribs">Scopes and ribs</a></h2>
<p>A name is visible only in certain area in the source code. This forms a
hierarchical structure, but not necessarily a simple one ‒ if one scope is
part of another, it doesn't mean the name visible in the outer one is also
visible in the inner one, or that it refers to the same thing.</p>
<p>To cope with that, the compiler introduces the concept of Ribs. This is
abstraction of a scope. Every time the set of visible names potentially changes,
a new rib is pushed onto a stack. The places where this can happen includes for
example:</p>
<ul>
<li>The obvious places ‒ curly braces enclosing a block, function boundaries,
modules.</li>
<li>Introducing a let binding ‒ this can shadow another binding with the same
name.</li>
<li>Macro expansion border ‒ to cope with macro hygiene.</li>
</ul>
<p>When searching for a name, the stack of ribs is traversed from the innermost
outwards. This helps to find the closest meaning of the name (the one not
shadowed by anything else). The transition to outer rib may also change the
rules what names are usable ‒ if there are nested functions (not closures),
the inner one can't access parameters and local bindings of the outer one,
even though they should be visible by ordinary scoping rules. An example:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn do_something&lt;T: Default&gt;(val: T) { // &lt;- New rib in both types and values (1)
    // `val` is accessible, as is the helper function
    // `T` is accessible
    let helper = || { // New rib on `helper` (2) and another on the block (3)
        // `val` is accessible here
    }; // End of (3)
    // `val` is accessible, `helper` variable shadows `helper` function
    fn helper() { // &lt;- New rib in both types and values (4)
        // `val` is not accessible here, (4) is not transparent for locals)
        // `T` is not accessible here
    } // End of (4)
    let val = T::default(); // New rib (5)
    // `val` is the variable, not the parameter here
} // End of (5), (2) and (1)
<span class="boring">}
</span></code></pre></pre>
<p>Because the rules for different namespaces are a bit different, each namespace
has its own independent rib stack that is constructed in parallel to the others.
In addition, there's also a rib stack for local labels (eg. names of loops or
blocks), which isn't a full namespace in its own right.</p>
<h2><a class="header" href="#overall-strategy" id="overall-strategy">Overall strategy</a></h2>
<p>To perform the name resolution of the whole crate, the syntax tree is traversed
top-down and every encountered name is resolved. This works for most kinds of
names, because at the point of use of a name it is already introduced in the Rib
hierarchy.</p>
<p>There are some exceptions to this. Items are bit tricky, because they can be
used even before encountered ‒ therefore every block needs to be first scanned
for items to fill in its Rib.</p>
<p>Other, even more problematic ones, are imports which need recursive fixed-point
resolution and macros, that need to be resolved and expanded before the rest of
the code can be processed.</p>
<p>Therefore, the resolution is performed in multiple stages.</p>
<h2><a class="header" href="#todo" id="todo">TODO:</a></h2>
<p>This is a result of the first pass of learning the code. It is definitely
incomplete and not detailed enough. It also might be inaccurate in places.
Still, it probably provides useful first guidepost to what happens in there.</p>
<ul>
<li>What exactly does it link to and how is that published and consumed by
following stages of compilation?</li>
<li>Who calls it and how it is actually used.</li>
<li>Is it a pass and then the result is only used, or can it be computed
incrementally (eg. for RLS)?</li>
<li>The overall strategy description is a bit vague.</li>
<li>Where does the name <code>Rib</code> come from?</li>
<li>Does this thing have its own tests, or is it tested only as part of some e2e
testing?</li>
</ul>
<h1><a class="header" href="#the-hir" id="the-hir">The HIR</a></h1>
<p>The HIR – &quot;High-Level Intermediate Representation&quot; – is the primary IR used
in most of rustc. It is a compiler-friendly representation of the abstract
syntax tree (AST) that is generated after parsing, macro expansion, and name
resolution (see <a href="rustc-guide/./lowering.html">Lowering</a> for how the HIR is created).
Many parts of HIR resemble Rust surface syntax quite closely, with
the exception that some of Rust's expression forms have been desugared away.
For example, <code>for</code> loops are converted into a <code>loop</code> and do not appear in
the HIR. This makes HIR more amenable to analysis than a normal AST.</p>
<p>This chapter covers the main concepts of the HIR.</p>
<p>You can view the HIR representation of your code by passing the
<code>-Zunpretty=hir-tree</code> flag to rustc:</p>
<pre><code class="language-bash">&gt; cargo rustc -- -Zunpretty=hir-tree
</code></pre>
<h3><a class="header" href="#out-of-band-storage-and-the-crate-type" id="out-of-band-storage-and-the-crate-type">Out-of-band storage and the <code>Crate</code> type</a></h3>
<p>The top-level data-structure in the HIR is the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.Crate.html"><code>Crate</code></a>, which stores
the contents of the crate currently being compiled (we only ever
construct HIR for the current crate). Whereas in the AST the crate
data structure basically just contains the root module, the HIR
<code>Crate</code> structure contains a number of maps and other things that
serve to organize the content of the crate for easier access.</p>
<p>For example, the contents of individual items (e.g. modules,
functions, traits, impls, etc) in the HIR are not immediately
accessible in the parents. So, for example, if there is a module item
<code>foo</code> containing a function <code>bar()</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod foo {
    fn bar() { }
}
<span class="boring">}
</span></code></pre></pre>
<p>then in the HIR the representation of module <code>foo</code> (the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.Mod.html"><code>Mod</code></a>
struct) would only have the <strong><code>ItemId</code></strong> <code>I</code> of <code>bar()</code>. To get the
details of the function <code>bar()</code>, we would lookup <code>I</code> in the
<code>items</code> map.</p>
<p>One nice result from this representation is that one can iterate
over all items in the crate by iterating over the key-value pairs
in these maps (without the need to trawl through the whole HIR).
There are similar maps for things like trait items and impl items,
as well as &quot;bodies&quot; (explained below).</p>
<p>The other reason to set up the representation this way is for better
integration with incremental compilation. This way, if you gain access
to an <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.Item.html"><code>&amp;hir::Item</code></a> (e.g. for the mod <code>foo</code>), you do not immediately
gain access to the contents of the function <code>bar()</code>. Instead, you only
gain access to the <strong>id</strong> for <code>bar()</code>, and you must invoke some
function to lookup the contents of <code>bar()</code> given its id; this gives
the compiler a chance to observe that you accessed the data for
<code>bar()</code>, and then record the dependency.</p>
<p><a name="hir-id"></a></p>
<h3><a class="header" href="#identifiers-in-the-hir" id="identifiers-in-the-hir">Identifiers in the HIR</a></h3>
<p>Most of the code that has to deal with things in HIR tends not to
carry around references into the HIR, but rather to carry around
<em>identifier numbers</em> (or just &quot;ids&quot;). Right now, you will find four
sorts of identifiers in active use:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/def_id/struct.DefId.html"><code>DefId</code></a>, which primarily names &quot;definitions&quot; or top-level items.
<ul>
<li>You can think of a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/def_id/struct.DefId.html"><code>DefId</code></a> as being shorthand for a very explicit
and complete path, like <code>std::collections::HashMap</code>. However,
these paths are able to name things that are not nameable in
normal Rust (e.g. impls), and they also include extra information
about the crate (such as its version number, as two versions of
the same crate can co-exist).</li>
<li>A <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/def_id/struct.DefId.html"><code>DefId</code></a> really consists of two parts, a <code>CrateNum</code> (which
identifies the crate) and a <code>DefIndex</code> (which indexes into a list
of items that is maintained per crate).</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.HirId.html"><code>HirId</code></a>, which combines the index of a particular item with an
offset within that item.
<ul>
<li>the key point of a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.HirId.html"><code>HirId</code></a> is that it is <em>relative</em> to some item
(which is named via a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/def_id/struct.DefId.html"><code>DefId</code></a>).</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.BodyId.html"><code>BodyId</code></a>, this is an identifier that refers to a specific
body (definition of a function or constant) in the crate. It is currently
effectively a &quot;newtype'd&quot; <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.HirId.html"><code>HirId</code></a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.NodeId.html"><code>NodeId</code></a>, which is an absolute id that identifies a single node in the HIR
tree.
<ul>
<li>While these are still in common use, <strong>they are being slowly phased out</strong>.</li>
<li>Since they are absolute within the crate, adding a new node anywhere in the
tree causes the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.NodeId.html"><code>NodeId</code></a>s of all subsequent code in the crate to change.
This is terrible for incremental compilation, as you can perhaps imagine.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="#the-hir-map" id="the-hir-map">The HIR Map</a></h3>
<p>Most of the time when you are working with the HIR, you will do so via
the <strong>HIR Map</strong>, accessible in the tcx via <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/context/struct.GlobalCtxt.html#structfield.hir_map"><code>tcx.hir_map</code></a> (and defined in
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/map/index.html"><code>hir::map</code></a> module). The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/map/struct.Map.html">HIR map</a> contains a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/map/struct.Map.html#methods">number of methods</a> to
convert between IDs of various kinds and to lookup data associated
with an HIR node.</p>
<p>For example, if you have a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/def_id/struct.DefId.html"><code>DefId</code></a>, and you would like to convert it
to a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.NodeId.html"><code>NodeId</code></a>, you can use
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/map/struct.Map.html#method.as_local_node_id"><code>tcx.hir.as_local_node_id(def_id)</code></a>. This returns
an <code>Option&lt;NodeId&gt;</code> – this will be <code>None</code> if the def-id refers to
something outside of the current crate (since then it has no HIR
node), but otherwise returns <code>Some(n)</code> where <code>n</code> is the node-id of the
definition.</p>
<p>Similarly, you can use <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/map/struct.Map.html#method.find"><code>tcx.hir.find(n)</code></a> to lookup the node for a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.NodeId.html"><code>NodeId</code></a>. This returns a <code>Option&lt;Node&lt;'tcx&gt;&gt;</code>, where <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/enum.Node.html"><code>Node</code></a> is an enum
defined in the map; by matching on this you can find out what sort of
node the node-id referred to and also get a pointer to the data
itself. Often, you know what sort of node <code>n</code> is – e.g. if you know
that <code>n</code> must be some HIR expression, you can do
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/map/struct.Map.html#method.expect_expr"><code>tcx.hir.expect_expr(n)</code></a>, which will extract and return the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.Expr.html"><code>&amp;hir::Expr</code></a>, panicking if <code>n</code> is not in fact an expression.</p>
<p>Finally, you can use the HIR map to find the parents of nodes, via
calls like <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/map/struct.Map.html#method.get_parent_node"><code>tcx.hir.get_parent_node(n)</code></a>.</p>
<h3><a class="header" href="#hir-bodies" id="hir-bodies">HIR Bodies</a></h3>
<p>A <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.Body.html"><code>hir::Body</code></a> represents some kind of executable code, such as the body
of a function/closure or the definition of a constant. Bodies are
associated with an <strong>owner</strong>, which is typically some kind of item
(e.g. an <code>fn()</code> or <code>const</code>), but could also be a closure expression
(e.g. <code>|x, y| x + y</code>). You can use the HIR map to find the body
associated with a given def-id (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/map/struct.Map.html#method.maybe_body_owned_by"><code>maybe_body_owned_by</code></a>) or to find
the owner of a body (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/map/struct.Map.html#method.body_owner_def_id"><code>body_owner_def_id</code></a>).</p>
<h1><a class="header" href="#lowering" id="lowering">Lowering</a></h1>
<p>The lowering step converts AST to <a href="rustc-guide/hir.html">HIR</a>.
This means many structures are removed if they are irrelevant
for type analysis or similar syntax agnostic analyses. Examples
of such structures include but are not limited to</p>
<ul>
<li>Parenthesis
<ul>
<li>Removed without replacement, the tree structure makes order explicit</li>
</ul>
</li>
<li><code>for</code> loops and <code>while (let)</code> loops
<ul>
<li>Converted to <code>loop</code> + <code>match</code> and some <code>let</code> bindings</li>
</ul>
</li>
<li><code>if let</code>
<ul>
<li>Converted to <code>match</code></li>
</ul>
</li>
<li>Universal <code>impl Trait</code>
<ul>
<li>Converted to generic arguments
(but with some flags, to know that the user didn't write them)</li>
</ul>
</li>
<li>Existential <code>impl Trait</code>
<ul>
<li>Converted to a virtual <code>existential type</code> declaration</li>
</ul>
</li>
</ul>
<p>Lowering needs to uphold several invariants in order to not trigger the
sanity checks in <code>src/librustc/hir/map/hir_id_validator.rs</code>:</p>
<ol>
<li>A <code>HirId</code> must be used if created. So if you use the <code>lower_node_id</code>,
you <em>must</em> use the resulting <code>NodeId</code> or <code>HirId</code> (either is fine, since
any <code>NodeId</code>s in the <code>HIR</code> are checked for existing <code>HirId</code>s)</li>
<li>Lowering a <code>HirId</code> must be done in the scope of the <em>owning</em> item.
This means you need to use <code>with_hir_id_owner</code> if you are creating parts
of an item other than the one being currently lowered. This happens for
example during the lowering of existential <code>impl Trait</code></li>
<li>A <code>NodeId</code> that will be placed into a HIR structure must be lowered,
even if its <code>HirId</code> is unused. Calling
<code>let _ = self.lower_node_id(node_id);</code> is perfectly legitimate.</li>
<li>If you are creating new nodes that didn't exist in the <code>AST</code>, you <em>must</em>
create new ids for them. This is done by calling the <code>next_id</code> method,
which produces both a new <code>NodeId</code> as well as automatically lowering it
for you so you also get the <code>HirId</code>.</li>
</ol>
<p>If you are creating new <code>DefId</code>s, since each <code>DefId</code> needs to have a
corresponding <code>NodeId</code>, it is advisable to add these <code>NodeId</code>s to the
<code>AST</code> so you don't have to generate new ones during lowering. This has
the advantage of creating a way to find the <code>DefId</code> of something via its
<code>NodeId</code>. If lowering needs this <code>DefId</code> in multiple places, you can't
generate a new <code>NodeId</code> in all those places because you'd also get a new
<code>DefId</code> then. With a <code>NodeId</code> from the <code>AST</code> this is not an issue.</p>
<p>Having the <code>NodeId</code> also allows the <code>DefCollector</code> to generate the <code>DefId</code>s
instead of lowering having to do it on the fly. Centralizing the <code>DefId</code>
generation in one place makes it easier to refactor and reason about.</p>
<h1><a class="header" href="#hir-debugging" id="hir-debugging">HIR Debugging</a></h1>
<p>The <code>-Zunpretty=hir-tree</code> flag will dump out the HIR.</p>
<p>If you are trying to correlate <code>NodeId</code>s or <code>DefId</code>s with source code, the
<code>--pretty expanded,identified</code> flag may be useful.</p>
<p>TODO: anything else?</p>
<h1><a class="header" href="#closure-expansion-in-rustc" id="closure-expansion-in-rustc">Closure Expansion in rustc</a></h1>
<p>This section describes how rustc handles closures. Closures in Rust are
effectively &quot;desugared&quot; into structs that contain the values they use (or
references to the values they use) from their creator's stack frame. rustc has
the job of figuring out which values a closure uses and how, so it can decide
whether to capture a given variable by shared reference, mutable reference, or
by move. rustc also has to figure out which the closure traits (<a href="https://doc.rust-lang.org/std/ops/trait.Fn.html"><code>Fn</code></a>,
<a href="https://doc.rust-lang.org/std/ops/trait.FnMut.html"><code>FnMut</code></a>, or <a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a>) a closure is capable of
implementing.</p>
<p>Let's start with a few examples:</p>
<h3><a class="header" href="#example-1" id="example-1">Example 1</a></h3>
<p>To start, let's take a look at how the closure in the following example is desugared:</p>
<pre><pre class="playpen"><code class="language-rust">fn closure(f: impl Fn()) {
    f();
}

fn main() {
    let x: i32 = 10;
    closure(|| println!(&quot;Hi {}&quot;, x));  // The closure just reads x.
    println!(&quot;Value of x after return {}&quot;, x);
}
</code></pre></pre>
<p>Let's say the above is the content of a file called <code>immut.rs</code>. If we compile
<code>immut.rs</code> using the following command. The <a href="rustc-guide/./mir/passes.html"><code>-Zdump-mir=all</code></a> flag will cause
<code>rustc</code> to generate and dump the <a href="rustc-guide/./mir/index.html">MIR</a> to a directory called <code>mir_dump</code>.</p>
<pre><code class="language-console">&gt; rustc +stage1 immut.rs -Zdump-mir=all
</code></pre>
<p>After we run this command, we will see a newly generated directory in our
current working directory called <code>mir_dump</code>, which will contain several files.
If we look at file <code>rustc.main.-------.mir_map.0.mir</code>, we will find, among
other things, it also contains this line:</p>
<pre><code class="language-rust ignore">_4 = &amp;_1;
_3 = [closure@immut.rs:7:13: 7:36] { x: move _4 };
</code></pre>
<p>Note that in the MIR examples in this chapter, <code>_1</code> is <code>x</code>.</p>
<p>Here in first line <code>_4 = &amp;_1;</code>, the <code>mir_dump</code> tells us that <code>x</code> was borrowed
as an immutable reference.  This is what we would hope as our closure just
reads <code>x</code>.</p>
<h3><a class="header" href="#example-2" id="example-2">Example 2</a></h3>
<p>Here is another example:</p>
<pre><pre class="playpen"><code class="language-rust">fn closure(mut f: impl FnMut()) {
    f();
}

fn main() {
    let mut x: i32 = 10;
    closure(|| {
        x += 10;  // The closure mutates the value of x
        println!(&quot;Hi {}&quot;, x)
    });
    println!(&quot;Value of x after return {}&quot;, x);
}
</code></pre></pre>
<pre><code class="language-rust ignore">_4 = &amp;mut _1;
_3 = [closure@mut.rs:7:13: 10:6] { x: move _4 };
</code></pre>
<p>This time along, in the line <code>_4 = &amp;mut _1;</code>, we see that the borrow is changed to mutable borrow.
Fair enough! The closure increments <code>x</code> by 10.</p>
<h3><a class="header" href="#example-3" id="example-3">Example 3</a></h3>
<p>One more example:</p>
<pre><pre class="playpen"><code class="language-rust">fn closure(f: impl FnOnce()) {
    f();
}

fn main() {
    let x = vec![21];
    closure(|| {
        drop(x);  // Makes x unusable after the fact.
    });
    // println!(&quot;Value of x after return {:?}&quot;, x);
}
</code></pre></pre>
<pre><code class="language-rust ignore">_6 = [closure@move.rs:7:13: 9:6] { x: move _1 }; // bb16[3]: scope 1 at move.rs:7:13: 9:6
</code></pre>
<p>Here, <code>x</code> is directly moved into the closure and the access to it will not be permitted after the
closure.</p>
<h2><a class="header" href="#inferences-in-the-compiler" id="inferences-in-the-compiler">Inferences in the compiler</a></h2>
<p>Now let's dive into rustc code and see how all these inferences are done by the compiler.</p>
<p>Let's start with defining a term that we will be using quite a bit in the rest of the discussion -
<em>upvar</em>. An <strong>upvar</strong> is a variable that is local to the function where the closure is defined. So,
in the above examples, <strong>x</strong> will be an upvar to the closure. They are also sometimes referred to as
the <em>free variables</em> meaning they are not bound to the context of the closure.
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/query/queries/struct.upvars.html"><code>src/librustc/ty/query/mod.rs</code></a> defines a query called <em>upvars</em> for this purpose.</p>
<p>Other than lazy invocation, one other thing that the distinguishes a closure from a
normal function is that it can use the upvars. It borrows these upvars from its surrounding
context; therfore the compiler has to determine the upvar's borrow type. The compiler starts with
assigning an immutable borrow type and lowers the restriction (that is, changes it from
<strong>immutable</strong> to <strong>mutable</strong> to <strong>move</strong>) as needed, based on the usage. In the Example 1 above, the
closure only uses the variable for printing but does not modify it in any way and therefore, in the
<code>mir_dump</code>, we find the borrow type for the upvar <code>x</code> to be immutable.  In example 2, however, the
closure modifies <code>x</code> and increments it by some value.  Because of this mutation, the compiler, which
started off assigning <code>x</code> as an immutable reference type, has to adjust it as a mutable reference.
Likewise in the third example, the closure drops the vector and therefore this requires the variable
<code>x</code> to be moved into the closure. Depending on the borrow kind, the closure has to implement the
appropriate trait: <code>Fn</code> trait for immutable borrow, <code>FnMut</code> for mutable borrow,
and <code>FnOnce</code> for move semantics.</p>
<p>Most of the code related to the closure is in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/upvar/index.html"><code>src/librustc_typeck/check/upvar.rs</code></a> file and the data structures are
declared in the file <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/index.html"><code>src/librustc/ty/mod.rs</code></a>.</p>
<p>Before we go any further, let's discuss how we can examine the flow of coontrol through the rustc
codebase. For closures specifically, set the <code>RUST_LOG</code> env variable as below and collect the
output in a file:</p>
<pre><code class="language-console">&gt; RUST_LOG=rustc_typeck::check::upvar rustc +stage1 -Zdump-mir=all \
    &lt;.rs file to compile&gt; 2&gt; &lt;file where the output will be dumped&gt;
</code></pre>
<p>This uses the stage1 compiler and enables <code>debug!</code> logging for the
<code>rustc_typeck::check::upvar</code> module.</p>
<p>The other option is to step through the code using lldb or gdb.</p>
<ol>
<li><code>rust-lldb build/x86_64-apple-darwin/stage1/bin/rustc test.rs</code></li>
<li>In lldb:
<ol>
<li><code>b upvar.rs:134</code>  // Setting the breakpoint on a certain line in the upvar.rs file`</li>
<li><code>r</code>  // Run the program until it hits the breakpoint</li>
</ol>
</li>
</ol>
<p>Let's start with <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/upvar/index.html"><code>upvar.rs</code></a>. This file has something called
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/middle/expr_use_visitor/struct.ExprUseVisitor.html"><code>euv::ExprUseVisitor</code></a> which walks the source of the closure and
invokes a callbackfor each upvar that is borrowed, mutated, or moved.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut x = vec![21];
    let _cl = || {
        let y = x[0];  // 1.
        x[0] += 1;  // 2.
    };
}
</code></pre></pre>
<p>In the above example, our visitor will be called twice, for the lines marked 1 and 2, once for a
shared borrow and another one for a mutable borrow. It will also tell us what was borrowed.</p>
<p>The callbacks are defined by implementing the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/middle/expr_use_visitor/trait.Delegate.html"><code>Delegate</code></a> trait. The
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/upvar/struct.InferBorrowKind.html"><code>InferBorrowKind</code></a> type implements <code>Delegate</code> and keeps a map that
records for each upvar which mode of borrow was required. The modes of borrow
can be <code>ByValue</code> (moved) or <code>ByRef</code> (borrowed). For <code>ByRef</code> borrows, it can be
<code>shared</code>, <code>shallow</code>, <code>unique</code> or <code>mut</code> as defined in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/index.html"><code>src/librustc/mir/mod.rs</code></a>.</p>
<p><code>Delegate</code> defines a few different methods (the different callbacks):
<strong>consume</strong>: for <em>move</em> of a variable, <strong>borrow</strong> for a <em>borrow</em> of some kind
(shared or mutable), and <strong>mutate</strong> when we see an <em>assignment</em> of something.</p>
<p>All of these callbacks have a common argument <em>cmt</em> which stands for Category,
Mutability and Type and is defined in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/middle/mem_categorization/index.html"><code>src/librustc/middle/mem_categorization.rs</code></a>. Borrowing from the code
comments, &quot;<code>cmt</code> is a complete categorization of a value indicating where it
originated and how it is located, as well as the mutability of the memory in
which the value is stored&quot;. Based on the callback (consume, borrow etc.), we
will call the relevant <em>adjust_upvar_borrow_kind_for_<something></em> and pass the
<code>cmt</code> along. Once the borrow type is adjusted, we store it in the table, which
basically says what borrows were made for each closure.</p>
<pre><code class="language-rust ignore">self.tables
    .borrow_mut()
    .upvar_capture_map
    .extend(delegate.adjust_upvar_captures);
</code></pre>
<h1><a class="header" href="#the-ty-module-representing-types" id="the-ty-module-representing-types">The <code>ty</code> module: representing types</a></h1>
<p>The <code>ty</code> module defines how the Rust compiler represents types
internally. It also defines the <em>typing context</em> (<code>tcx</code> or <code>TyCtxt</code>),
which is the central data structure in the compiler.</p>
<h2><a class="header" href="#the-tcx-and-how-it-uses-lifetimes" id="the-tcx-and-how-it-uses-lifetimes">The tcx and how it uses lifetimes</a></h2>
<p>The <code>tcx</code> (&quot;typing context&quot;) is the central data structure in the
compiler. It is the context that you use to perform all manner of
queries. The struct <code>TyCtxt</code> defines a reference to this shared context:</p>
<pre><code class="language-rust ignore">tcx: TyCtxt&lt;'tcx&gt;
//          ----
//          |
//          arena lifetime
</code></pre>
<p>As you can see, the <code>TyCtxt</code> type takes a lifetime parameter.
During Rust compilation, we allocate most of our memory in
<strong>arenas</strong>, which are basically pools of memory that get freed all at
once. When you see a reference with a lifetime like <code>'tcx</code>,
you know that it refers to arena-allocated data (or data that lives as
long as the arenas, anyhow).</p>
<h3><a class="header" href="#allocating-and-working-with-types" id="allocating-and-working-with-types">Allocating and working with types</a></h3>
<p>Rust types are represented using the <code>Ty&lt;'tcx&gt;</code> defined in the <code>ty</code>
module (not to be confused with the <code>Ty</code> struct from <a href="rustc-guide/./hir.html">the HIR</a>). This
is in fact a simple type alias for a reference with <code>'tcx</code> lifetime:</p>
<pre><code class="language-rust ignore">pub type Ty&lt;'tcx&gt; = &amp;'tcx TyS&lt;'tcx&gt;;
</code></pre>
<p>You can basically ignore the <code>TyS</code> struct – you will basically never
access it explicitly. We always pass it by reference using the
<code>Ty&lt;'tcx&gt;</code> alias – the only exception I think is to define inherent
methods on types. Instances of <code>TyS</code> are only ever allocated in one of
the rustc arenas (never e.g. on the stack).</p>
<p>One common operation on types is to <strong>match</strong> and see what kinds of
types they are. This is done by doing <code>match ty.sty</code>, sort of like this:</p>
<pre><code class="language-rust ignore">fn test_type&lt;'tcx&gt;(ty: Ty&lt;'tcx&gt;) {
    match ty.sty {
        ty::TyArray(elem_ty, len) =&gt; { ... }
        ...
    }
}
</code></pre>
<p>The <code>sty</code> field (the origin of this name is unclear to me; perhaps
structural type?) is of type <code>TyKind&lt;'tcx&gt;</code>, which is an enum
defining all of the different kinds of types in the compiler.</p>
<blockquote>
<p>N.B. inspecting the <code>sty</code> field on types during type inference can be
risky, as there may be inference variables and other things to
consider, or sometimes types are not yet known that will become
known later.).</p>
</blockquote>
<p>To allocate a new type, you can use the various <code>mk_</code> methods defined
on the <code>tcx</code>. These have names that correpond mostly to the various kinds
of type variants. For example:</p>
<pre><code class="language-rust ignore">let array_ty = tcx.mk_array(elem_ty, len * 2);
</code></pre>
<p>These methods all return a <code>Ty&lt;'tcx&gt;</code> – note that the lifetime you
get back is the lifetime of the innermost arena that this <code>tcx</code> has
access to. In fact, types are always canonicalized and interned (so we
never allocate exactly the same type twice) and are always allocated
in the outermost arena where they can be (so, if they do not contain
any inference variables or other &quot;temporary&quot; types, they will be
allocated in the global arena). However, the lifetime <code>'tcx</code> is always
a safe approximation, so that is what you get back.</p>
<blockquote>
<p>NB. Because types are interned, it is possible to compare them for
equality efficiently using <code>==</code> – however, this is almost never what
you want to do unless you happen to be hashing and looking for
duplicates. This is because often in Rust there are multiple ways to
represent the same type, particularly once inference is involved. If
you are going to be testing for type equality, you probably need to
start looking into the inference code to do it right.</p>
</blockquote>
<p>You can also find various common types in the <code>tcx</code> itself by accessing
<code>tcx.types.bool</code>, <code>tcx.types.char</code>, etc (see <code>CommonTypes</code> for more).</p>
<h3><a class="header" href="#beyond-types-other-kinds-of-arena-allocated-data-structures" id="beyond-types-other-kinds-of-arena-allocated-data-structures">Beyond types: other kinds of arena-allocated data structures</a></h3>
<p>In addition to types, there are a number of other arena-allocated data
structures that you can allocate, and which are found in this
module. Here are a few examples:</p>
<ul>
<li><a href="rustc-guide/./kinds.html#subst"><code>Substs</code></a>, allocated with <code>mk_substs</code> – this will intern a slice of
types, often used to specify the values to be substituted for generics
(e.g. <code>HashMap&lt;i32, u32&gt;</code> would be represented as a slice
<code>&amp;'tcx [tcx.types.i32, tcx.types.u32]</code>).</li>
<li><code>TraitRef</code>, typically passed by value – a <strong>trait reference</strong>
consists of a reference to a trait along with its various type
parameters (including <code>Self</code>), like <code>i32: Display</code> (here, the def-id
would reference the <code>Display</code> trait, and the substs would contain
<code>i32</code>).</li>
<li><code>Predicate</code> defines something the trait system has to prove (see <code>traits</code>
module).</li>
</ul>
<h3><a class="header" href="#import-conventions" id="import-conventions">Import conventions</a></h3>
<p>Although there is no hard and fast rule, the <code>ty</code> module tends to be used like
so:</p>
<pre><code class="language-rust ignore">use ty::{self, Ty, TyCtxt};
</code></pre>
<p>In particular, since they are so common, the <code>Ty</code> and <code>TyCtxt</code> types
are imported directly. Other types are often referenced with an
explicit <code>ty::</code> prefix (e.g. <code>ty::TraitRef&lt;'tcx&gt;</code>). But some modules
choose to import a larger or smaller set of names explicitly.</p>
<h1><a class="header" href="#kinds" id="kinds">Kinds</a></h1>
<p>A <code>ty::subst::Kind&lt;'tcx&gt;</code> represents some entity in the type system: a type
(<code>Ty&lt;'tcx&gt;</code>), lifetime (<code>ty::Region&lt;'tcx&gt;</code>) or constant (<code>ty::Const&lt;'tcx&gt;</code>).
<code>Kind</code> is used to perform substitutions of generic parameters for concrete
arguments, such as when calling a function with generic parameters explicitly
with type arguments. Substitutions are represented using the
<a href="rustc-guide/kinds.html#subst"><code>Subst</code> type</a> as described below.</p>
<h2><a class="header" href="#subst" id="subst"><code>Subst</code></a></h2>
<p><code>ty::subst::Subst&lt;'tcx&gt;</code> is intuitively simply a slice of <code>Kind&lt;'tcx&gt;</code>s,
acting as an ordered list of substitutions from generic parameters to
concrete arguments (such as types, lifetimes and consts).</p>
<p>For example, given a <code>HashMap&lt;K, V&gt;</code> with two type parameters, <code>K</code> and <code>V</code>, an
instantiation of the parameters, for example <code>HashMap&lt;i32, u32&gt;</code>, would be
represented by the substitution <code>&amp;'tcx [tcx.types.i32, tcx.types.u32]</code>.</p>
<p><code>Subst</code> provides various convenience methods to instantiant substitutions
given item definitions, which should generally be used rather than explicitly
constructing such substitution slices.</p>
<h2><a class="header" href="#kind" id="kind"><code>Kind</code></a></h2>
<p>The actual <code>Kind</code> struct is optimised for space, storing the type, lifetime or
const as an interned pointer containing a tag identifying its kind (in the
lowest 2 bits). Unless you are working with the <code>Subst</code> implementation
specifically, you should generally not have to deal with <code>Kind</code> and instead
make use of the safe <a href="rustc-guide/kinds.html#unpackedkind"><code>UnpackedKind</code></a> abstraction.</p>
<h2><a class="header" href="#unpackedkind" id="unpackedkind"><code>UnpackedKind</code></a></h2>
<p>As <code>Kind</code> itself is not type-safe, the <code>UnpackedKind</code> enum provides a more
convenient and safe interface for dealing with kinds. An <code>UnpackedKind</code> can
be converted to a raw <code>Kind</code> using <code>Kind::from()</code> (or simply <code>.into()</code> when
the context is clear). As mentioned earlier, substition lists store raw
<code>Kind</code>s, so before dealing with them, it is preferable to convert them to
<code>UnpackedKind</code>s first. This is done by calling the <code>.unpack()</code> method.</p>
<pre><code class="language-rust ignore">// An example of unpacking and packing a kind.
fn deal_with_kind&lt;'tcx&gt;(kind: Kind&lt;'tcx&gt;) -&gt; Kind&lt;'tcx&gt; {
    // Unpack a raw `Kind` to deal with it safely.
    let new_kind: UnpackedKind&lt;'tcx&gt; = match kind.unpack() {
        UnpackedKind::Type(ty) =&gt; { /* ... */ }
        UnpackedKind::Lifetime(lt) =&gt; { /* ... */ }
        UnpackedKind::Const(ct) =&gt; { /* ... */ }
    };
    // Pack the `UnpackedKind` to store it in a substitution list.
    new_kind.into()
}
</code></pre>
<h1><a class="header" href="#type-inference" id="type-inference">Type inference</a></h1>
<p>Type inference is the process of automatic detection of the type of an
expression.</p>
<p>It is what allows Rust to work with fewer or no type annotations,
making things easier for users:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut things = vec![];
    things.push(&quot;thing&quot;);
}
</code></pre></pre>
<p>Here, the type of <code>things</code> is <em>inferred</em> to be <code>Vec&lt;&amp;str&gt;</code> because of the value
we push into <code>things</code>.</p>
<p>The type inference is based on the standard Hindley-Milner (HM) type inference
algorithm, but extended in various way to accommodate subtyping, region
inference, and higher-ranked types.</p>
<h2><a class="header" href="#a-note-on-terminology" id="a-note-on-terminology">A note on terminology</a></h2>
<p>We use the notation <code>?T</code> to refer to inference variables, also called
existential variables.</p>
<p>We use the terms &quot;region&quot; and &quot;lifetime&quot; interchangeably. Both refer to
the <code>'a</code> in <code>&amp;'a T</code>.</p>
<p>The term &quot;bound region&quot; refers to a region that is bound in a function
signature, such as the <code>'a</code> in <code>for&lt;'a&gt; fn(&amp;'a u32)</code>. A region is
&quot;free&quot; if it is not bound.</p>
<h2><a class="header" href="#creating-an-inference-context" id="creating-an-inference-context">Creating an inference context</a></h2>
<p>You create and &quot;enter&quot; an inference context by doing something like
the following:</p>
<pre><code class="language-rust ignore">tcx.infer_ctxt().enter(|infcx| {
    // Use the inference context `infcx` here.
})
</code></pre>
<p>Each inference context creates a short-lived type arena to store the
fresh types and things that it will create, as described in the
<a href="rustc-guide/ty.html">chapter on the <code>ty</code> module</a>. This arena is created by the <code>enter</code>
function and disposed of after it returns.</p>
<p>Within the closure, <code>infcx</code> has the type <code>InferCtxt&lt;'cx, 'tcx&gt;</code> for some
fresh <code>'cx</code>, while <code>'tcx</code> is the same as outside the inference context.
(Again, see the <a href="rustc-guide/ty.html"><code>ty</code> chapter</a> for more details on this setup.)</p>
<p>The <code>tcx.infer_ctxt</code> method actually returns a builder, which means
there are some kinds of configuration you can do before the <code>infcx</code> is
created. See <code>InferCtxtBuilder</code> for more information.</p>
<p><a name="vars"></a></p>
<h2><a class="header" href="#inference-variables" id="inference-variables">Inference variables</a></h2>
<p>The main purpose of the inference context is to house a bunch of
<strong>inference variables</strong> – these represent types or regions whose precise
value is not yet known, but will be uncovered as we perform type-checking.</p>
<p>If you're familiar with the basic ideas of unification from H-M type
systems, or logic languages like Prolog, this is the same concept. If
you're not, you might want to read a tutorial on how H-M type
inference works, or perhaps this blog post on
<a href="http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/">unification in the Chalk project</a>.</p>
<p>All told, the inference context stores four kinds of inference variables as of
this writing:</p>
<ul>
<li>Type variables, which come in three varieties:
<ul>
<li>General type variables (the most common). These can be unified with any
type.</li>
<li>Integral type variables, which can only be unified with an integral type,
and arise from an integer literal expression like <code>22</code>.</li>
<li>Float type variables, which can only be unified with a float type, and
arise from a float literal expression like <code>22.0</code>.</li>
</ul>
</li>
<li>Region variables, which represent lifetimes, and arise all over the place.</li>
</ul>
<p>All the type variables work in much the same way: you can create a new
type variable, and what you get is <code>Ty&lt;'tcx&gt;</code> representing an
unresolved type <code>?T</code>. Then later you can apply the various operations
that the inferencer supports, such as equality or subtyping, and it
will possibly <strong>instantiate</strong> (or <strong>bind</strong>) that <code>?T</code> to a specific
value as a result.</p>
<p>The region variables work somewhat differently, and are described
below in a separate section.</p>
<h2><a class="header" href="#enforcing-equality--subtyping" id="enforcing-equality--subtyping">Enforcing equality / subtyping</a></h2>
<p>The most basic operations you can perform in the type inferencer is
<strong>equality</strong>, which forces two types <code>T</code> and <code>U</code> to be the same. The
recommended way to add an equality constraint is to use the <code>at</code>
method, roughly like so:</p>
<pre><code class="language-rust ignore">infcx.at(...).eq(t, u);
</code></pre>
<p>The first <code>at()</code> call provides a bit of context, i.e. why you are
doing this unification, and in what environment, and the <code>eq</code> method
performs the actual equality constraint.</p>
<p>When you equate things, you force them to be precisely equal. Equating
returns an <code>InferResult</code> – if it returns <code>Err(err)</code>, then equating
failed, and the enclosing <code>TypeError</code> will tell you what went wrong.</p>
<p>The success case is perhaps more interesting. The &quot;primary&quot; return
type of <code>eq</code> is <code>()</code> – that is, when it succeeds, it doesn't return a
value of any particular interest. Rather, it is executed for its
side-effects of constraining type variables and so forth. However, the
actual return type is not <code>()</code>, but rather <code>InferOk&lt;()&gt;</code>. The
<code>InferOk</code> type is used to carry extra trait obligations – your job is
to ensure that these are fulfilled (typically by enrolling them in a
fulfillment context). See the <a href="rustc-guide/traits/resolution.html">trait chapter</a> for more background on that.</p>
<p>You can similarly enforce subtyping through <code>infcx.at(..).sub(..)</code>. The same
basic concepts as above apply.</p>
<h2><a class="header" href="#trying-equality" id="trying-equality">&quot;Trying&quot; equality</a></h2>
<p>Sometimes you would like to know if it is <em>possible</em> to equate two
types without error.  You can test that with <code>infcx.can_eq</code> (or
<code>infcx.can_sub</code> for subtyping). If this returns <code>Ok</code>, then equality
is possible – but in all cases, any side-effects are reversed.</p>
<p>Be aware, though, that the success or failure of these methods is always
<strong>modulo regions</strong>. That is, two types <code>&amp;'a u32</code> and <code>&amp;'b u32</code> will
return <code>Ok</code> for <code>can_eq</code>, even if <code>'a != 'b</code>.  This falls out from the
&quot;two-phase&quot; nature of how we solve region constraints.</p>
<h2><a class="header" href="#snapshots" id="snapshots">Snapshots</a></h2>
<p>As described in the previous section on <code>can_eq</code>, often it is useful
to be able to do a series of operations and then roll back their
side-effects. This is done for various reasons: one of them is to be
able to backtrack, trying out multiple possibilities before settling
on which path to take. Another is in order to ensure that a series of
smaller changes take place atomically or not at all.</p>
<p>To allow for this, the inference context supports a <code>snapshot</code> method.
When you call it, it will start recording changes that occur from the
operations you perform. When you are done, you can either invoke
<code>rollback_to</code>, which will undo those changes, or else <code>confirm</code>, which
will make the permanent. Snapshots can be nested as long as you follow
a stack-like discipline.</p>
<p>Rather than use snapshots directly, it is often helpful to use the
methods like <code>commit_if_ok</code> or <code>probe</code> that encapsulate higher-level
patterns.</p>
<h2><a class="header" href="#subtyping-obligations" id="subtyping-obligations">Subtyping obligations</a></h2>
<p>One thing worth discussing is subtyping obligations. When you force
two types to be a subtype, like <code>?T &lt;: i32</code>, we can often convert those
into equality constraints. This follows from Rust's rather limited notion
of subtyping: so, in the above case, <code>?T &lt;: i32</code> is equivalent to <code>?T = i32</code>.</p>
<p>However, in some cases we have to be more careful. For example, when
regions are involved. So if you have <code>?T &lt;: &amp;'a i32</code>, what we would do
is to first &quot;generalize&quot; <code>&amp;'a i32</code> into a type with a region variable:
<code>&amp;'?b i32</code>, and then unify <code>?T</code> with that (<code>?T = &amp;'?b i32</code>). We then
relate this new variable with the original bound:</p>
<pre><code class="language-text">&amp;'?b i32 &lt;: &amp;'a i32
</code></pre>
<p>This will result in a region constraint (see below) of <code>'?b: 'a</code>.</p>
<p>One final interesting case is relating two unbound type variables,
like <code>?T &lt;: ?U</code>.  In that case, we can't make progress, so we enqueue
an obligation <code>Subtype(?T, ?U)</code> and return it via the <code>InferOk</code>
mechanism. You'll have to try again when more details about <code>?T</code> or
<code>?U</code> are known.</p>
<h2><a class="header" href="#region-constraints" id="region-constraints">Region constraints</a></h2>
<p>Regions are inferenced somewhat differently from types. Rather than
eagerly unifying things, we simply collect constraints as we go, but
make (almost) no attempt to solve regions. These constraints have the
form of an &quot;outlives&quot; constraint:</p>
<pre><code class="language-text">'a: 'b
</code></pre>
<p>Actually the code tends to view them as a subregion relation, but it's the same
idea:</p>
<pre><code class="language-text">'b &lt;= 'a
</code></pre>
<p>(There are various other kinds of constraints, such as &quot;verifys&quot;; see
the <code>region_constraints</code> module for details.)</p>
<p>There is one case where we do some amount of eager unification. If you have an
equality constraint between two regions</p>
<pre><code class="language-text">'a = 'b
</code></pre>
<p>we will record that fact in a unification table. You can then use
<code>opportunistic_resolve_var</code> to convert <code>'b</code> to <code>'a</code> (or vice
versa). This is sometimes needed to ensure termination of fixed-point
algorithms.</p>
<h2><a class="header" href="#extracting-region-constraints" id="extracting-region-constraints">Extracting region constraints</a></h2>
<p>Ultimately, region constraints are only solved at the very end of
type-checking, once all other constraints are known. There are two
ways to solve region constraints right now: lexical and
non-lexical. Eventually there will only be one.</p>
<p>To solve <strong>lexical</strong> region constraints, you invoke
<code>resolve_regions_and_report_errors</code>.  This &quot;closes&quot; the region
constraint process and invoke the <code>lexical_region_resolve</code> code. Once
this is done, any further attempt to equate or create a subtyping
relationship will yield an ICE.</p>
<p>Non-lexical region constraints are not handled within the inference
context. Instead, the NLL solver (actually, the MIR type-checker)
invokes <code>take_and_reset_region_constraints</code> periodically. This
extracts all of the outlives constraints from the region solver, but
leaves the set of variables intact. This is used to get <em>just</em> the
region constraints that resulted from some particular point in the
program, since the NLL solver needs to know not just <em>what</em> regions
were subregions but <em>where</em>. Finally, the NLL solver invokes
<code>take_region_var_origins</code>, which &quot;closes&quot; the region constraint
process in the same way as normal solving.</p>
<h2><a class="header" href="#lexical-region-resolution" id="lexical-region-resolution">Lexical region resolution</a></h2>
<p>Lexical region resolution is done by initially assigning each region
variable to an empty value. We then process each outlives constraint
repeatedly, growing region variables until a fixed-point is reached.
Region variables can be grown using a least-upper-bound relation on
the region lattice in a fairly straightforward fashion.</p>
<h1><a class="header" href="#trait-resolution-old-style" id="trait-resolution-old-style">Trait resolution (old-style)</a></h1>
<p>This chapter describes the general process of <em>trait resolution</em> and points out
some non-obvious things.</p>
<p><strong>Note:</strong> This chapter (and its subchapters) describe how the trait
solver <strong>currently</strong> works. However, we are in the process of
designing a new trait solver. If you'd prefer to read about <em>that</em>,
see <a href="rustc-guide/traits/./index.html"><em>this</em> traits chapter</a>.</p>
<h2><a class="header" href="#major-concepts" id="major-concepts">Major concepts</a></h2>
<p>Trait resolution is the process of pairing up an impl with each
reference to a trait. So, for example, if there is a generic function like:</p>
<pre><code class="language-rust ignore">fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; { ... }
</code></pre>
<p>and then a call to that function:</p>
<pre><code class="language-rust ignore">let v: Vec&lt;isize&gt; = clone_slice(&amp;[1, 2, 3])
</code></pre>
<p>it is the job of trait resolution to figure out whether there exists an impl of
(in this case) <code>isize : Clone</code>.</p>
<p>Note that in some cases, like generic functions, we may not be able to
find a specific impl, but we can figure out that the caller must
provide an impl. For example, consider the body of <code>clone_slice</code>:</p>
<pre><code class="language-rust ignore">fn clone_slice&lt;T:Clone&gt;(x: &amp;[T]) -&gt; Vec&lt;T&gt; {
    let mut v = Vec::new();
    for e in &amp;x {
        v.push((*e).clone()); // (*)
    }
}
</code></pre>
<p>The line marked <code>(*)</code> is only legal if <code>T</code> (the type of <code>*e</code>)
implements the <code>Clone</code> trait. Naturally, since we don't know what <code>T</code>
is, we can't find the specific impl; but based on the bound <code>T:Clone</code>,
we can say that there exists an impl which the caller must provide.</p>
<p>We use the term <em>obligation</em> to refer to a trait reference in need of
an impl. Basically, the trait resolution system resolves an obligation
by proving that an appropriate impl does exist.</p>
<p>During type checking, we do not store the results of trait selection.
We simply wish to verify that trait selection will succeed. Then
later, at trans time, when we have all concrete types available, we
can repeat the trait selection to choose an actual implementation, which
will then be generated in the output binary.</p>
<h2><a class="header" href="#overview-1" id="overview-1">Overview</a></h2>
<p>Trait resolution consists of three major parts:</p>
<ul>
<li>
<p><strong>Selection</strong>: Deciding how to resolve a specific obligation. For
example, selection might decide that a specific obligation can be
resolved by employing an impl which matches the <code>Self</code> type, or by using a
parameter bound (e.g. <code>T: Trait</code>). In the case of an impl, selecting one
obligation can create <em>nested obligations</em> because of where clauses
on the impl itself. It may also require evaluating those nested
obligations to resolve ambiguities.</p>
</li>
<li>
<p><strong>Fulfillment</strong>: The fulfillment code is what tracks that obligations
are completely fulfilled. Basically it is a worklist of obligations
to be selected: once selection is successful, the obligation is
removed from the worklist and any nested obligations are enqueued.</p>
</li>
<li>
<p><strong>Coherence</strong>: The coherence checks are intended to ensure that there
are never overlapping impls, where two impls could be used with
equal precedence.</p>
</li>
</ul>
<h2><a class="header" href="#selection" id="selection">Selection</a></h2>
<p>Selection is the process of deciding whether an obligation can be
resolved and, if so, how it is to be resolved (via impl, where clause, etc).
The main interface is the <code>select()</code> function, which takes an obligation
and returns a <code>SelectionResult</code>. There are three possible outcomes:</p>
<ul>
<li>
<p><code>Ok(Some(selection))</code> – yes, the obligation can be resolved, and
<code>selection</code> indicates how. If the impl was resolved via an impl,
then <code>selection</code> may also indicate nested obligations that are required
by the impl.</p>
</li>
<li>
<p><code>Ok(None)</code> – we are not yet sure whether the obligation can be
resolved or not. This happens most commonly when the obligation
contains unbound type variables.</p>
</li>
<li>
<p><code>Err(err)</code> – the obligation definitely cannot be resolved due to a
type error or because there are no impls that could possibly apply.</p>
</li>
</ul>
<p>The basic algorithm for selection is broken into two big phases:
candidate assembly and confirmation.</p>
<p>Note that because of how lifetime inference works, it is not possible to
give back immediate feedback as to whether a unification or subtype
relationship between lifetimes holds or not. Therefore, lifetime
matching is <em>not</em> considered during selection. This is reflected in
the fact that subregion assignment is infallible. This may yield
lifetime constraints that will later be found to be in error (in
contrast, the non-lifetime-constraints have already been checked
during selection and can never cause an error, though naturally they
may lead to other errors downstream).</p>
<h3><a class="header" href="#candidate-assembly" id="candidate-assembly">Candidate assembly</a></h3>
<p>Searches for impls/where-clauses/etc that might
possibly be used to satisfy the obligation. Each of those is called
a candidate. To avoid ambiguity, we want to find exactly one
candidate that is definitively applicable. In some cases, we may not
know whether an impl/where-clause applies or not – this occurs when
the obligation contains unbound inference variables.</p>
<p>The subroutines that decide whether a particular impl/where-clause/etc
applies to a particular obligation are collectively referred to as the
process of <em>matching</em>. At the moment, this amounts to
unifying the <code>Self</code> types, but in the future we may also recursively
consider some of the nested obligations, in the case of an impl.</p>
<p><strong>TODO</strong>: what does &quot;unifying the <code>Self</code> types&quot; mean? The <code>Self</code> of the
obligation with that of an impl?</p>
<p>The basic idea for candidate assembly is to do a first pass in which
we identify all possible candidates. During this pass, all that we do
is try and unify the type parameters. (In particular, we ignore any
nested where clauses.) Presuming that this unification succeeds, the
impl is added as a candidate.</p>
<p>Once this first pass is done, we can examine the set of candidates. If
it is a singleton set, then we are done: this is the only impl in
scope that could possibly apply. Otherwise, we can winnow down the set
of candidates by using where clauses and other conditions. If this
reduced set yields a single, unambiguous entry, we're good to go,
otherwise the result is considered ambiguous.</p>
<h4><a class="header" href="#the-basic-process-inferring-based-on-the-impls-we-see" id="the-basic-process-inferring-based-on-the-impls-we-see">The basic process: Inferring based on the impls we see</a></h4>
<p>This process is easier if we work through some examples. Consider
the following trait:</p>
<pre><code class="language-rust ignore">trait Convert&lt;Target&gt; {
    fn convert(&amp;self) -&gt; Target;
}
</code></pre>
<p>This trait just has one method. It's about as simple as it gets. It
converts from the (implicit) <code>Self</code> type to the <code>Target</code> type. If we
wanted to permit conversion between <code>isize</code> and <code>usize</code>, we might
implement <code>Convert</code> like so:</p>
<pre><code class="language-rust ignore">impl Convert&lt;usize&gt; for isize { ... } // isize -&gt; usize
impl Convert&lt;isize&gt; for usize { ... } // usize -&gt; isize
</code></pre>
<p>Now imagine there is some code like the following:</p>
<pre><code class="language-rust ignore">let x: isize = ...;
let y = x.convert();
</code></pre>
<p>The call to convert will generate a trait reference <code>Convert&lt;$Y&gt; for isize</code>, where <code>$Y</code> is the type variable representing the type of
<code>y</code>. Of the two impls we can see, the only one that matches is
<code>Convert&lt;usize&gt; for isize</code>. Therefore, we can
select this impl, which will cause the type of <code>$Y</code> to be unified to
<code>usize</code>. (Note that while assembling candidates, we do the initial
unifications in a transaction, so that they don't affect one another.)</p>
<p><strong>TODO</strong>: The example says we can &quot;select&quot; the impl, but this section is
talking specifically about candidate assembly. Does this mean we can sometimes
skip confirmation? Or is this poor wording?
<strong>TODO</strong>: Is the unification of <code>$Y</code> part of trait resolution or type
inference? Or is this not the same type of &quot;inference variable&quot; as in type
inference?</p>
<h4><a class="header" href="#winnowing-resolving-ambiguities" id="winnowing-resolving-ambiguities">Winnowing: Resolving ambiguities</a></h4>
<p>But what happens if there are multiple impls where all the types
unify? Consider this example:</p>
<pre><code class="language-rust ignore">trait Get {
    fn get(&amp;self) -&gt; Self;
}

impl&lt;T:Copy&gt; Get for T {
    fn get(&amp;self) -&gt; T { *self }
}

impl&lt;T:Get&gt; Get for Box&lt;T&gt; {
    fn get(&amp;self) -&gt; Box&lt;T&gt; { Box::new(get_it(&amp;**self)) }
}
</code></pre>
<p>What happens when we invoke <code>get_it(&amp;Box::new(1_u16))</code>, for example? In this
case, the <code>Self</code> type is <code>Box&lt;u16&gt;</code> – that unifies with both impls,
because the first applies to all types <code>T</code>, and the second to all
<code>Box&lt;T&gt;</code>. In order for this to be unambiguous, the compiler does a <em>winnowing</em>
pass that considers <code>where</code> clauses
and attempts to remove candidates. In this case, the first impl only
applies if <code>Box&lt;u16&gt; : Copy</code>, which doesn't hold. After winnowing,
then, we are left with just one candidate, so we can proceed.</p>
<h4><a class="header" href="#where-clauses-1" id="where-clauses-1"><code>where</code> clauses</a></h4>
<p>Besides an impl, the other major way to resolve an obligation is via a
where clause. The selection process is always given a <a href="rustc-guide/traits/../param_env.html">parameter
environment</a> which contains a list of where clauses, which are
basically obligations that we can assume are satisfiable. We will iterate
over that list and check whether our current obligation can be found
in that list. If so, it is considered satisfied. More precisely, we
want to check whether there is a where-clause obligation that is for
the same trait (or some subtrait) and which can match against the obligation.</p>
<p>Consider this simple example:</p>
<pre><code class="language-rust ignore">trait A1 {
    fn do_a1(&amp;self);
}
trait A2 : A1 { ... }

trait B {
    fn do_b(&amp;self);
}

fn foo&lt;X:A2+B&gt;(x: X) {
    x.do_a1(); // (*)
    x.do_b();  // (#)
}
</code></pre>
<p>In the body of <code>foo</code>, clearly we can use methods of <code>A1</code>, <code>A2</code>, or <code>B</code>
on variable <code>x</code>. The line marked <code>(*)</code> will incur an obligation <code>X: A1</code>,
while the line marked <code>(#)</code> will incur an obligation <code>X: B</code>. Meanwhile,
the parameter environment will contain two where-clauses: <code>X : A2</code> and <code>X : B</code>.
For each obligation, then, we search this list of where-clauses. The
obligation <code>X: B</code> trivially matches against the where-clause <code>X: B</code>.
To resolve an obligation <code>X:A1</code>, we would note that <code>X:A2</code> implies that <code>X:A1</code>.</p>
<h3><a class="header" href="#confirmation" id="confirmation">Confirmation</a></h3>
<p><em>Confirmation</em> unifies the output type parameters of the trait with the
values found in the obligation, possibly yielding a type error.</p>
<p>Suppose we have the following variation of the <code>Convert</code> example in the
previous section:</p>
<pre><code class="language-rust ignore">trait Convert&lt;Target&gt; {
    fn convert(&amp;self) -&gt; Target;
}

impl Convert&lt;usize&gt; for isize { ... } // isize -&gt; usize
impl Convert&lt;isize&gt; for usize { ... } // usize -&gt; isize

let x: isize = ...;
let y: char = x.convert(); // NOTE: `y: char` now!
</code></pre>
<p>Confirmation is where an error would be reported because the impl specified
that <code>Target</code> would be <code>usize</code>, but the obligation reported <code>char</code>. Hence the
result of selection would be an error.</p>
<p>Note that the candidate impl is chosen based on the <code>Self</code> type, but
confirmation is done based on (in this case) the <code>Target</code> type parameter.</p>
<h3><a class="header" href="#selection-during-translation" id="selection-during-translation">Selection during translation</a></h3>
<p>As mentioned above, during type checking, we do not store the results of trait
selection. At trans time, we repeat the trait selection to choose a particular
impl for each method call. In this second selection, we do not consider any
where-clauses to be in scope because we know that each resolution will resolve
to a particular impl.</p>
<p>One interesting twist has to do with nested obligations. In general, in trans,
we only need to do a &quot;shallow&quot; selection for an obligation. That is, we wish to
identify which impl applies, but we do not (yet) need to decide how to select
any nested obligations. Nonetheless, we <em>do</em> currently do a complete resolution,
and that is because it can sometimes inform the results of type inference.
That is, we do not have the full substitutions in terms of the type variables
of the impl available to us, so we must run trait selection to figure
everything out.</p>
<p><strong>TODO</strong>: is this still talking about trans?</p>
<p>Here is an example:</p>
<pre><code class="language-rust ignore">trait Foo { ... }
impl&lt;U, T:Bar&lt;U&gt;&gt; Foo for Vec&lt;T&gt; { ... }

impl Bar&lt;usize&gt; for isize { ... }
</code></pre>
<p>After one shallow round of selection for an obligation like <code>Vec&lt;isize&gt; : Foo</code>, we would know which impl we want, and we would know that
<code>T=isize</code>, but we do not know the type of <code>U</code>.  We must select the
nested obligation <code>isize : Bar&lt;U&gt;</code> to find out that <code>U=usize</code>.</p>
<p>It would be good to only do <em>just as much</em> nested resolution as
necessary. Currently, though, we just do a full resolution.</p>
<h1><a class="header" href="#higher-ranked-trait-bounds" id="higher-ranked-trait-bounds">Higher-ranked trait bounds</a></h1>
<p>One of the more subtle concepts in trait resolution is <em>higher-ranked trait
bounds</em>. An example of such a bound is <code>for&lt;'a&gt; MyTrait&lt;&amp;'a isize&gt;</code>.
Let's walk through how selection on higher-ranked trait references
works.</p>
<h2><a class="header" href="#basic-matching-and-placeholder-leaks" id="basic-matching-and-placeholder-leaks">Basic matching and placeholder leaks</a></h2>
<p>Suppose we have a trait <code>Foo</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;X&gt; {
    fn foo(&amp;self, x: X) { }
}
<span class="boring">}
</span></code></pre></pre>
<p>Let's say we have a function <code>want_hrtb</code> that wants a type which
implements <code>Foo&lt;&amp;'a isize&gt;</code> for any <code>'a</code>:</p>
<pre><code class="language-rust ignore">fn want_hrtb&lt;T&gt;() where T : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt; { ... }
</code></pre>
<p>Now we have a struct <code>AnyInt</code> that implements <code>Foo&lt;&amp;'a isize&gt;</code> for any
<code>'a</code>:</p>
<pre><code class="language-rust ignore">struct AnyInt;
impl&lt;'a&gt; Foo&lt;&amp;'a isize&gt; for AnyInt { }
</code></pre>
<p>And the question is, does <code>AnyInt : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code>? We want the
answer to be yes. The algorithm for figuring it out is closely related
to the subtyping for higher-ranked types (which is described <a href="https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked/README.md">here</a>
and also in a <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/">paper by SPJ</a>. If you wish to understand higher-ranked
subtyping, we recommend you read the paper). There are a few parts:</p>
<ol>
<li>Replace bound regions in the obligation with placeholders.</li>
<li>Match the impl against the <a href="rustc-guide/traits/../appendix/glossary.html#appendix-c-glossary">placeholder</a> obligation.</li>
<li>Check for <em>placeholder leaks</em>.</li>
</ol>
<p>So let's work through our example.</p>
<ol>
<li>
<p>The first thing we would do is to
replace the bound region in the obligation with a placeholder, yielding 
<code>AnyInt : Foo&lt;&amp;'0 isize&gt;</code> (here <code>'0</code> represents placeholder region #0). 
Note that we now have no quantifiers;
in terms of the compiler type, this changes from a <code>ty::PolyTraitRef</code>
to a <code>TraitRef</code>. We would then create the <code>TraitRef</code> from the impl,
using fresh variables for it's bound regions (and thus getting
<code>Foo&lt;&amp;'$a isize&gt;</code>, where <code>'$a</code> is the inference variable for <code>'a</code>).</p>
</li>
<li>
<p>Next
we relate the two trait refs, yielding a graph with the constraint
that <code>'0 == '$a</code>.</p>
</li>
<li>
<p>Finally, we check for placeholder &quot;leaks&quot; – a
leak is basically any attempt to relate a placeholder region to another
placeholder region, or to any region that pre-existed the impl match.
The leak check is done by searching from the placeholder region to find
the set of regions that it is related to in any way. This is called
the &quot;taint&quot; set. To pass the check, that set must consist <em>solely</em> of
itself and region variables from the impl. If the taint set includes
any other region, then the match is a failure. In this case, the taint
set for <code>'0</code> is <code>{'0, '$a}</code>, and hence the check will succeed.</p>
</li>
</ol>
<p>Let's consider a failure case. Imagine we also have a struct</p>
<pre><code class="language-rust ignore">struct StaticInt;
impl Foo&lt;&amp;'static isize&gt; for StaticInt;
</code></pre>
<p>We want the obligation <code>StaticInt : for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code> to be
considered unsatisfied. The check begins just as before. <code>'a</code> is
replaced with a placeholder <code>'0</code> and the impl trait reference is instantiated to
<code>Foo&lt;&amp;'static isize&gt;</code>. When we relate those two, we get a constraint
like <code>'static == '0</code>. This means that the taint set for <code>'0</code> is <code>{'0, 'static}</code>, which fails the leak check.</p>
<p><strong>TODO</strong>: This is because <code>'static</code> is not a region variable but is in the
taint set, right?</p>
<h2><a class="header" href="#higher-ranked-trait-obligations" id="higher-ranked-trait-obligations">Higher-ranked trait obligations</a></h2>
<p>Once the basic matching is done, we get to another interesting topic:
how to deal with impl obligations. I'll work through a simple example
here. Imagine we have the traits <code>Foo</code> and <code>Bar</code> and an associated impl:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Foo&lt;X&gt; {
    fn foo(&amp;self, x: X) { }
}

trait Bar&lt;X&gt; {
    fn bar(&amp;self, x: X) { }
}

impl&lt;X,F&gt; Foo&lt;X&gt; for F
    where F : Bar&lt;X&gt;
{
}
<span class="boring">}
</span></code></pre></pre>
<p>Now let's say we have a obligation <code>Baz: for&lt;'a&gt; Foo&lt;&amp;'a isize&gt;</code> and we match
this impl. What obligation is generated as a result? We want to get
<code>Baz: for&lt;'a&gt; Bar&lt;&amp;'a isize&gt;</code>, but how does that happen?</p>
<p>After the matching, we are in a position where we have a placeholder
substitution like <code>X =&gt; &amp;'0 isize</code>. If we apply this substitution to the
impl obligations, we get <code>F : Bar&lt;&amp;'0 isize&gt;</code>. Obviously this is not
directly usable because the placeholder region <code>'0</code> cannot leak out of
our computation.</p>
<p>What we do is to create an inverse mapping from the taint set of <code>'0</code>
back to the original bound region (<code>'a</code>, here) that <code>'0</code> resulted
from. (This is done in <code>higher_ranked::plug_leaks</code>). We know that the
leak check passed, so this taint set consists solely of the placeholder
region itself plus various intermediate region variables. We then walk
the trait-reference and convert every region in that taint set back to
a late-bound region, so in this case we'd wind up with
<code>Baz: for&lt;'a&gt; Bar&lt;&amp;'a isize&gt;</code>.</p>
<h1><a class="header" href="#caching-and-subtle-considerations-therewith" id="caching-and-subtle-considerations-therewith">Caching and subtle considerations therewith</a></h1>
<p>In general, we attempt to cache the results of trait selection.  This
is a somewhat complex process. Part of the reason for this is that we
want to be able to cache results even when all the types in the trait
reference are not fully known. In that case, it may happen that the
trait selection process is also influencing type variables, so we have
to be able to not only cache the <em>result</em> of the selection process,
but <em>replay</em> its effects on the type variables.</p>
<h2><a class="header" href="#an-example" id="an-example">An example</a></h2>
<p>The high-level idea of how the cache works is that we first replace
all unbound inference variables with placeholder versions. Therefore,
if we had a trait reference <code>usize : Foo&lt;$t&gt;</code>, where <code>$t</code> is an unbound
inference variable, we might replace it with <code>usize : Foo&lt;$0&gt;</code>, where
<code>$0</code> is a placeholder type. We would then look this up in the cache.</p>
<p>If we found a hit, the hit would tell us the immediate next step to
take in the selection process (e.g. apply impl #22, or apply where
clause <code>X : Foo&lt;Y&gt;</code>).</p>
<p>On the other hand, if there is no hit, we need to go through the <a href="rustc-guide/traits/./resolution.html#selection">selection
process</a> from scratch. Suppose, we come to the conclusion that the only
possible impl is this one, with def-id 22:</p>
<pre><code class="language-rust ignore">impl Foo&lt;isize&gt; for usize { ... } // Impl #22
</code></pre>
<p>We would then record in the cache <code>usize : Foo&lt;$0&gt; =&gt; ImplCandidate(22)</code>. Next
we would <a href="rustc-guide/traits/./resolution.html#confirmation">confirm</a> <code>ImplCandidate(22)</code>, which would (as a side-effect) unify
<code>$t</code> with <code>isize</code>.</p>
<p>Now, at some later time, we might come along and see a <code>usize : Foo&lt;$u&gt;</code>. When replaced with a placeholder, this would yield <code>usize : Foo&lt;$0&gt;</code>, just as
before, and hence the cache lookup would succeed, yielding
<code>ImplCandidate(22)</code>. We would confirm <code>ImplCandidate(22)</code> which would
(as a side-effect) unify <code>$u</code> with <code>isize</code>.</p>
<h2><a class="header" href="#where-clauses-and-the-local-vs-global-cache" id="where-clauses-and-the-local-vs-global-cache">Where clauses and the local vs global cache</a></h2>
<p>One subtle interaction is that the results of trait lookup will vary
depending on what where clauses are in scope. Therefore, we actually
have <em>two</em> caches, a local and a global cache. The local cache is
attached to the <a href="rustc-guide/traits/../param_env.html"><code>ParamEnv</code></a>, and the global cache attached to the
<a href="rustc-guide/traits/../ty.html"><code>tcx</code></a>. We use the local cache whenever the result might depend on the
where clauses that are in scope. The determination of which cache to
use is done by the method <code>pick_candidate_cache</code> in <code>select.rs</code>. At
the moment, we use a very simple, conservative rule: if there are any
where-clauses in scope, then we use the local cache.  We used to try
and draw finer-grained distinctions, but that led to a serious of
annoying and weird bugs like <a href="https://github.com/rust-lang/rust/issues/22019">#22019</a> and <a href="https://github.com/rust-lang/rust/issues/18290">#18290</a>. This simple rule seems
to be pretty clearly safe and also still retains a very high hit rate
(~95% when compiling rustc).</p>
<p><strong>TODO</strong>: it looks like <code>pick_candidate_cache</code> no longer exists. In
general, is this section still accurate at all?</p>
<h1><a class="header" href="#specialization" id="specialization">Specialization</a></h1>
<p><strong>TODO</strong>: where does Chalk fit in? Should we mention/discuss it here?</p>
<p>Defined in the <code>specialize</code> module.</p>
<p>The basic strategy is to build up a <em>specialization graph</em> during
coherence checking (recall that coherence checking looks for overlapping
impls). Insertion into the graph locates the right place
to put an impl in the specialization hierarchy; if there is no right
place (due to partial overlap but no containment), you get an overlap
error. Specialization is consulted when selecting an impl (of course),
and the graph is consulted when propagating defaults down the
specialization hierarchy.</p>
<p>You might expect that the specialization graph would be used during
selection – i.e. when actually performing specialization. This is
not done for two reasons:</p>
<ul>
<li>
<p>It's merely an optimization: given a set of candidates that apply,
we can determine the most specialized one by comparing them directly
for specialization, rather than consulting the graph. Given that we
also cache the results of selection, the benefit of this
optimization is questionable.</p>
</li>
<li>
<p>To build the specialization graph in the first place, we need to use
selection (because we need to determine whether one impl specializes
another). Dealing with this reentrancy would require some additional
mode switch for selection. Given that there seems to be no strong
reason to use the graph anyway, we stick with a simpler approach in
selection, and use the graph only for propagating default
implementations.</p>
</li>
</ul>
<p>Trait impl selection can succeed even when multiple impls can apply,
as long as they are part of the same specialization family. In that
case, it returns a <em>single</em> impl on success – this is the most
specialized impl <em>known</em> to apply. However, if there are any inference
variables in play, the returned impl may not be the actual impl we
will use at trans time. Thus, we take special care to avoid projecting
associated types unless either (1) the associated type does not use
<code>default</code> and thus cannot be overridden or (2) all input types are
known concretely.</p>
<h2><a class="header" href="#additional-resources" id="additional-resources">Additional Resources</a></h2>
<p><a href="https://www.youtube.com/watch?v=rZqS4bLPL24">This talk</a> by @sunjay may be useful. Keep in mind that the talk only
gives a broad overview of the problem and the solution (it was presented about
halfway through @sunjay's work). Also, it was given in June 2018, and some
things may have changed by the time you watch it.</p>
<h1><a class="header" href="#trait-solving-new-style" id="trait-solving-new-style">Trait solving (new-style)</a></h1>
<blockquote>
<p>🚧 This chapter describes &quot;new-style&quot; trait solving. This is still in the
<a href="https://github.com/rust-lang/rust/issues/48416">process of being implemented</a>; this chapter serves as a kind of
in-progress design document. If you would prefer to read about how the
current trait solver works, check out
<a href="rustc-guide/traits/./resolution.html">this other chapter</a>. 🚧</p>
<p>By the way, if you would like to help in hacking on the new solver, you will
find instructions for getting involved in the
<a href="https://github.com/rust-lang/rust/issues/48416">Traits Working Group tracking issue</a>!</p>
</blockquote>
<p>The new-style trait solver is based on the work done in <a href="https://github.com/rust-lang-nursery/chalk">chalk</a>. Chalk
recasts Rust's trait system explicitly in terms of logic programming. It does
this by &quot;lowering&quot; Rust code into a kind of logic program we can then execute
queries against.</p>
<p>You can read more about chalk itself in the
<a href="rustc-guide/traits/./chalk-overview.html">Overview of Chalk</a> section.</p>
<p>Trait solving in rustc is based around a few key ideas:</p>
<ul>
<li><a href="rustc-guide/traits/./lowering-to-logic.html">Lowering to logic</a>, which expresses
Rust traits in terms of standard logical terms.
<ul>
<li>The <a href="rustc-guide/traits/./goals-and-clauses.html">goals and clauses</a> chapter
describes the precise form of rules we use, and
<a href="rustc-guide/traits/./lowering-rules.html">lowering rules</a> gives the complete set of
lowering rules in a more reference-like form.</li>
<li><a href="rustc-guide/traits/./associated-types.html">Lazy normalization</a>, which is the
technique we use to accommodate associated types when figuring out
whether types are equal.</li>
<li><a href="rustc-guide/traits/./regions.html">Region constraints</a>, which are accumulated
during trait solving but mostly ignored. This means that trait
solving effectively ignores the precise regions involved, always –
but we still remember the constraints on them so that those
constraints can be checked by the type checker.</li>
</ul>
</li>
<li><a href="rustc-guide/traits/./canonical-queries.html">Canonical queries</a>, which allow us
to solve trait problems (like &quot;is <code>Foo</code> implemented for the type
<code>Bar</code>?&quot;) once, and then apply that same result independently in many
different inference contexts.</li>
</ul>
<blockquote>
<p>This is not a complete list of topics. See the sidebar for more.</p>
</blockquote>
<h2><a class="header" href="#ongoing-work" id="ongoing-work">Ongoing work</a></h2>
<p>The design of the new-style trait solving currently happens in two places:</p>
<p><strong>chalk</strong>. The <a href="https://github.com/rust-lang-nursery/chalk">chalk</a> repository is where we experiment with new ideas
and designs for the trait system. It primarily consists of two parts:</p>
<ul>
<li>a unit testing framework
for the correctness and feasibility of the logical rules defining the
new-style trait system.</li>
<li>the <a href="https://github.com/rust-lang-nursery/chalk/tree/master/chalk-engine"><code>chalk_engine</code></a> crate, which
defines the new-style trait solver used both in the unit testing framework
and in rustc.</li>
</ul>
<p><strong>rustc</strong>. Once we are happy with the logical rules, we proceed to
implementing them in rustc. This mainly happens in
<a href="https://github.com/rust-lang/rust/tree/master/src/librustc_traits"><code>librustc_traits</code></a>.</p>
<h1><a class="header" href="#lowering-to-logic" id="lowering-to-logic">Lowering to logic</a></h1>
<p>The key observation here is that the Rust trait system is basically a
kind of logic, and it can be mapped onto standard logical inference
rules. We can then look for solutions to those inference rules in a
very similar fashion to how e.g. a <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a> solver works. It turns out
that we can't <em>quite</em> use Prolog rules (also called Horn clauses) but
rather need a somewhat more expressive variant.</p>
<h2><a class="header" href="#rust-traits-and-logic" id="rust-traits-and-logic">Rust traits and logic</a></h2>
<p>One of the first observations is that the Rust trait system is
basically a kind of logic. As such, we can map our struct, trait, and
impl declarations into logical inference rules. For the most part,
these are basically Horn clauses, though we'll see that to capture the
full richness of Rust – and in particular to support generic
programming – we have to go a bit further than standard Horn clauses.</p>
<p>To see how this mapping works, let's start with an example. Imagine
we declare a trait and a few impls, like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Clone { }
impl Clone for usize { }
impl&lt;T&gt; Clone for Vec&lt;T&gt; where T: Clone { }
<span class="boring">}
</span></code></pre></pre>
<p>We could map these declarations to some Horn clauses, written in a
Prolog-like notation, as follows:</p>
<pre><code class="language-text">Clone(usize).
Clone(Vec&lt;?T&gt;) :- Clone(?T).

// The notation `A :- B` means &quot;A is true if B is true&quot;.
// Or, put another way, B implies A.
</code></pre>
<p>In Prolog terms, we might say that <code>Clone(Foo)</code> – where <code>Foo</code> is some
Rust type – is a <em>predicate</em> that represents the idea that the type
<code>Foo</code> implements <code>Clone</code>. These rules are <strong>program clauses</strong>; they
state the conditions under which that predicate can be proven (i.e.,
considered true). So the first rule just says &quot;Clone is implemented
for <code>usize</code>&quot;. The next rule says &quot;for any type <code>?T</code>, Clone is
implemented for <code>Vec&lt;?T&gt;</code> if clone is implemented for <code>?T</code>&quot;. So
e.g. if we wanted to prove that <code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code>, we would do
so by applying the rules recursively:</p>
<ul>
<li><code>Clone(Vec&lt;Vec&lt;usize&gt;&gt;)</code> is provable if:
<ul>
<li><code>Clone(Vec&lt;usize&gt;)</code> is provable if:
<ul>
<li><code>Clone(usize)</code> is provable. (Which it is, so we're all good.)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>But now suppose we tried to prove that <code>Clone(Vec&lt;Bar&gt;)</code>. This would
fail (after all, I didn't give an impl of <code>Clone</code> for <code>Bar</code>):</p>
<ul>
<li><code>Clone(Vec&lt;Bar&gt;)</code> is provable if:
<ul>
<li><code>Clone(Bar)</code> is provable. (But it is not, as there are no applicable rules.)</li>
</ul>
</li>
</ul>
<p>We can easily extend the example above to cover generic traits with
more than one input type. So imagine the <code>Eq&lt;T&gt;</code> trait, which declares
that <code>Self</code> is equatable with a value of type <code>T</code>:</p>
<pre><code class="language-rust ignore">trait Eq&lt;T&gt; { ... }
impl Eq&lt;usize&gt; for usize { }
impl&lt;T: Eq&lt;U&gt;&gt; Eq&lt;Vec&lt;U&gt;&gt; for Vec&lt;T&gt; { }
</code></pre>
<p>That could be mapped as follows:</p>
<pre><code class="language-text">Eq(usize, usize).
Eq(Vec&lt;?T&gt;, Vec&lt;?U&gt;) :- Eq(?T, ?U).
</code></pre>
<p>So far so good.</p>
<h2><a class="header" href="#type-checking-normal-functions" id="type-checking-normal-functions">Type-checking normal functions</a></h2>
<p>OK, now that we have defined some logical rules that are able to
express when traits are implemented and to handle associated types,
let's turn our focus a bit towards <strong>type-checking</strong>. Type-checking is
interesting because it is what gives us the goals that we need to
prove. That is, everything we've seen so far has been about how we
derive the rules by which we can prove goals from the traits and impls
in the program; but we are also interested in how to derive the goals
that we need to prove, and those come from type-checking.</p>
<p>Consider type-checking the function <code>foo()</code> here:</p>
<pre><code class="language-rust ignore">fn foo() { bar::&lt;usize&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>This function is very simple, of course: all it does is to call
<code>bar::&lt;usize&gt;()</code>. Now, looking at the definition of <code>bar()</code>, we can see
that it has one where-clause <code>U: Eq&lt;U&gt;</code>. So, that means that <code>foo()</code> will
have to prove that <code>usize: Eq&lt;usize&gt;</code> in order to show that it can call <code>bar()</code>
with <code>usize</code> as the type argument.</p>
<p>If we wanted, we could write a Prolog predicate that defines the
conditions under which <code>bar()</code> can be called. We'll say that those
conditions are called being &quot;well-formed&quot;:</p>
<pre><code class="language-text">barWellFormed(?U) :- Eq(?U, ?U).
</code></pre>
<p>Then we can say that <code>foo()</code> type-checks if the reference to
<code>bar::&lt;usize&gt;</code> (that is, <code>bar()</code> applied to the type <code>usize</code>) is
well-formed:</p>
<pre><code class="language-text">fooTypeChecks :- barWellFormed(usize).
</code></pre>
<p>If we try to prove the goal <code>fooTypeChecks</code>, it will succeed:</p>
<ul>
<li><code>fooTypeChecks</code> is provable if:
<ul>
<li><code>barWellFormed(usize)</code>, which is provable if:
<ul>
<li><code>Eq(usize, usize)</code>, which is provable because of an impl.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Ok, so far so good. Let's move on to type-checking a more complex function.</p>
<h2><a class="header" href="#type-checking-generic-functions-beyond-horn-clauses" id="type-checking-generic-functions-beyond-horn-clauses">Type-checking generic functions: beyond Horn clauses</a></h2>
<p>In the last section, we used standard Prolog horn-clauses (augmented with Rust's
notion of type equality) to type-check some simple Rust functions. But that only
works when we are type-checking non-generic functions. If we want to type-check
a generic function, it turns out we need a stronger notion of goal than what Prolog
can provide. To see what I'm talking about, let's revamp our previous
example to make <code>foo</code> generic:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Eq&lt;T&gt;&gt;() { bar::&lt;T&gt;() }
fn bar&lt;U: Eq&lt;U&gt;&gt;() { }
</code></pre>
<p>To type-check the body of <code>foo</code>, we need to be able to hold the type
<code>T</code> &quot;abstract&quot;.  That is, we need to check that the body of <code>foo</code> is
type-safe <em>for all types <code>T</code></em>, not just for some specific type. We might express
this like so:</p>
<pre><code class="language-text">fooTypeChecks :-
  // for all types T...
  forall&lt;T&gt; {
    // ...if we assume that Eq(T, T) is provable...
    if (Eq(T, T)) {
      // ...then we can prove that `barWellFormed(T)` holds.
      barWellFormed(T)
    }
  }.
</code></pre>
<p>This notation I'm using here is the notation I've been using in my
prototype implementation; it's similar to standard mathematical
notation but a bit Rustified. Anyway, the problem is that standard
Horn clauses don't allow universal quantification (<code>forall</code>) or
implication (<code>if</code>) in goals (though many Prolog engines do support
them, as an extension). For this reason, we need to accept something
called &quot;first-order hereditary harrop&quot; (FOHH) clauses – this long
name basically means &quot;standard Horn clauses with <code>forall</code> and <code>if</code> in
the body&quot;. But it's nice to know the proper name, because there is a
lot of work describing how to efficiently handle FOHH clauses; see for
example Gopalan Nadathur's excellent
<a href="rustc-guide/traits/./bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
in <a href="rustc-guide/traits/./bibliography.html">the bibliography</a>.</p>
<p>It turns out that supporting FOHH is not really all that hard. And
once we are able to do that, we can easily describe the type-checking
rule for generic functions like <code>foo</code> in our logic.</p>
<h2><a class="header" href="#source" id="source">Source</a></h2>
<p>This page is a lightly adapted version of a
<a href="http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">blog post by Nicholas Matsakis</a>.</p>
<h1><a class="header" href="#goals-and-clauses" id="goals-and-clauses">Goals and clauses</a></h1>
<p>In logic programming terms, a <strong>goal</strong> is something that you must
prove and a <strong>clause</strong> is something that you know is true. As
described in the <a href="rustc-guide/traits/./lowering-to-logic.html">lowering to logic</a>
chapter, Rust's trait solver is based on an extension of hereditary
harrop (HH) clauses, which extend traditional Prolog Horn clauses with
a few new superpowers.</p>
<h2><a class="header" href="#goals-and-clauses-meta-structure" id="goals-and-clauses-meta-structure">Goals and clauses meta structure</a></h2>
<p>In Rust's solver, <strong>goals</strong> and <strong>clauses</strong> have the following forms
(note that the two definitions reference one another):</p>
<pre><code class="language-text">Goal = DomainGoal           // defined in the section below
        | Goal &amp;&amp; Goal
        | Goal || Goal
        | exists&lt;K&gt; { Goal }   // existential quantification
        | forall&lt;K&gt; { Goal }   // universal quantification
        | if (Clause) { Goal } // implication
        | true                 // something that's trivially true
        | ambiguous            // something that's never provable

Clause = DomainGoal
        | Clause :- Goal     // if can prove Goal, then Clause is true
        | Clause &amp;&amp; Clause
        | forall&lt;K&gt; { Clause }

K = &lt;type&gt;     // a &quot;kind&quot;
    | &lt;lifetime&gt;
</code></pre>
<p>The proof procedure for these sorts of goals is actually quite
straightforward.  Essentially, it's a form of depth-first search. The
paper
<a href="rustc-guide/traits/./bibliography.html#pphhf">&quot;A Proof Procedure for the Logic of Hereditary Harrop Formulas&quot;</a>
gives the details.</p>
<p>In terms of code, these types are defined in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc/traits/mod.rs"><code>librustc/traits/mod.rs</code></a> in rustc, and in
<a href="https://github.com/rust-lang-nursery/chalk/blob/master/chalk-ir/src/lib.rs"><code>chalk-ir/src/lib.rs</code></a> in chalk.</p>
<p><a name="domain-goals"></a></p>
<h2><a class="header" href="#domain-goals" id="domain-goals">Domain goals</a></h2>
<p><em>Domain goals</em> are the atoms of the trait logic. As can be seen in the
definitions given above, general goals basically consist in a combination of
domain goals.</p>
<p>Moreover, flattenning a bit the definition of clauses given previously, one can
see that clauses are always of the form:</p>
<pre><code class="language-text">forall&lt;K1, ..., Kn&gt; { DomainGoal :- Goal }
</code></pre>
<p>hence domain goals are in fact clauses' LHS. That is, at the most granular level,
domain goals are what the trait solver will end up trying to prove.</p>
<p><a name="trait-ref"></a></p>
<p>To define the set of domain goals in our system, we need to first
introduce a few simple formulations. A <strong>trait reference</strong> consists of
the name of a trait along with a suitable set of inputs P0..Pn:</p>
<pre><code class="language-text">TraitRef = P0: TraitName&lt;P1..Pn&gt;
</code></pre>
<p>So, for example, <code>u32: Display</code> is a trait reference, as is <code>Vec&lt;T&gt;: IntoIterator</code>. Note that Rust surface syntax also permits some extra
things, like associated type bindings (<code>Vec&lt;T&gt;: IntoIterator&lt;Item = T&gt;</code>), that are not part of a trait reference.</p>
<p><a name="projection"></a></p>
<p>A <strong>projection</strong> consists of an associated item reference along with
its inputs P0..Pm:</p>
<pre><code class="language-text">Projection = &lt;P0 as TraitName&lt;P1..Pn&gt;&gt;::AssocItem&lt;Pn+1..Pm&gt;
</code></pre>
<p>Given these, we can define a <code>DomainGoal</code> as follows:</p>
<pre><code class="language-text">DomainGoal = Holds(WhereClause)
            | FromEnv(TraitRef)
            | FromEnv(Type)
            | WellFormed(TraitRef)
            | WellFormed(Type)
            | Normalize(Projection -&gt; Type)

WhereClause = Implemented(TraitRef)
            | ProjectionEq(Projection = Type)
            | Outlives(Type: Region)
            | Outlives(Region: Region)
</code></pre>
<p><code>WhereClause</code> refers to a <code>where</code> clause that a Rust user would actually be able
to write in a Rust program. This abstraction exists only as a convenience as we
sometimes want to only deal with domain goals that are effectively writable in
Rust.</p>
<p>Let's break down each one of these, one-by-one.</p>
<h4><a class="header" href="#implementedtraitref" id="implementedtraitref">Implemented(TraitRef)</a></h4>
<p>e.g. <code>Implemented(i32: Copy)</code></p>
<p>True if the given trait is implemented for the given input types and lifetimes.</p>
<h4><a class="header" href="#projectioneqprojection--type" id="projectioneqprojection--type">ProjectionEq(Projection = Type)</a></h4>
<p>e.g. <code>ProjectionEq&lt;T as Iterator&gt;::Item = u8</code></p>
<p>The given associated type <code>Projection</code> is equal to <code>Type</code>; this can be proved
with either normalization or using placeholder associated types. See
<a href="rustc-guide/traits/./associated-types.html">the section on associated types</a>.</p>
<h4><a class="header" href="#normalizeprojection---type" id="normalizeprojection---type">Normalize(Projection -&gt; Type)</a></h4>
<p>e.g. <code>ProjectionEq&lt;T as Iterator&gt;::Item -&gt; u8</code></p>
<p>The given associated type <code>Projection</code> can be <a href="rustc-guide/traits/./associated-types.html#normalize">normalized</a> to <code>Type</code>.</p>
<p>As discussed in <a href="rustc-guide/traits/./associated-types.html">the section on associated
types</a>, <code>Normalize</code> implies <code>ProjectionEq</code>,
but not vice versa. In general, proving <code>Normalize(&lt;T as Trait&gt;::Item -&gt; U)</code>
also requires proving <code>Implemented(T: Trait)</code>.</p>
<h4><a class="header" href="#fromenvtraitref" id="fromenvtraitref">FromEnv(TraitRef)</a></h4>
<p>e.g. <code>FromEnv(Self: Add&lt;i32&gt;)</code></p>
<p>True if the inner <code>TraitRef</code> is <em>assumed</em> to be true,
that is, if it can be derived from the in-scope where clauses.</p>
<p>For example, given the following function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn loud_clone&lt;T: Clone&gt;(stuff: &amp;T) -&gt; T {
    println!(&quot;cloning!&quot;);
    stuff.clone()
}
<span class="boring">}
</span></code></pre></pre>
<p>Inside the body of our function, we would have <code>FromEnv(T: Clone)</code>. In-scope
where clauses nest, so a function body inside an impl body inherits the
impl body's where clauses, too.</p>
<p>This and the next rule are used to implement <a href="rustc-guide/traits/./lowering-rules.html#implied-bounds">implied bounds</a>. As we'll see
in the section on lowering, <code>FromEnv(TraitRef)</code> implies <code>Implemented(TraitRef)</code>,
but not vice versa. This distinction is crucial to implied bounds.</p>
<h4><a class="header" href="#fromenvtype" id="fromenvtype">FromEnv(Type)</a></h4>
<p>e.g. <code>FromEnv(HashSet&lt;K&gt;)</code></p>
<p>True if the inner <code>Type</code> is <em>assumed</em> to be well-formed, that is, if it is an
input type of a function or an impl.</p>
<p>For example, given the following code:</p>
<pre><code class="language-rust ignore">struct HashSet&lt;K&gt; where K: Hash { ... }

fn loud_insert&lt;K&gt;(set: &amp;mut HashSet&lt;K&gt;, item: K) {
    println!(&quot;inserting!&quot;);
    set.insert(item);
}
</code></pre>
<p><code>HashSet&lt;K&gt;</code> is an input type of the <code>loud_insert</code> function. Hence, we assume it
to be well-formed, so we would have <code>FromEnv(HashSet&lt;K&gt;)</code> inside the body of our
function. As we'll see in the section on lowering, <code>FromEnv(HashSet&lt;K&gt;)</code> implies
<code>Implemented(K: Hash)</code> because the
<code>HashSet</code> declaration was written with a <code>K: Hash</code> where clause. Hence, we don't
need to repeat that bound on the <code>loud_insert</code> function: we rather automatically
assume that it is true.</p>
<h4><a class="header" href="#wellformeditem" id="wellformeditem">WellFormed(Item)</a></h4>
<p>These goals imply that the given item is <em>well-formed</em>.</p>
<p>We can talk about different types of items being well-formed:</p>
<ul>
<li>
<p><em>Types</em>, like <code>WellFormed(Vec&lt;i32&gt;)</code>, which is true in Rust, or
<code>WellFormed(Vec&lt;str&gt;)</code>, which is not (because <code>str</code> is not <code>Sized</code>.)</p>
</li>
<li>
<p><em>TraitRefs</em>, like <code>WellFormed(Vec&lt;i32&gt;: Clone)</code>.</p>
</li>
</ul>
<p>Well-formedness is important to <a href="rustc-guide/traits/./lowering-rules.html#implied-bounds">implied bounds</a>. In particular, the reason
it is okay to assume <code>FromEnv(T: Clone)</code> in the <code>loud_clone</code> example is that we
<em>also</em> verify <code>WellFormed(T: Clone)</code> for each call site of <code>loud_clone</code>.
Similarly, it is okay to assume <code>FromEnv(HashSet&lt;K&gt;)</code> in the <code>loud_insert</code>
example because we will verify <code>WellFormed(HashSet&lt;K&gt;)</code> for each call site of
<code>loud_insert</code>. </p>
<h4><a class="header" href="#outlivestype-region-outlivesregion-region" id="outlivestype-region-outlivesregion-region">Outlives(Type: Region), Outlives(Region: Region)</a></h4>
<p>e.g. <code>Outlives(&amp;'a str: 'b)</code>, <code>Outlives('a: 'static)</code></p>
<p>True if the given type or region on the left outlives the right-hand region.</p>
<p><a name="coinductive"></a></p>
<h2><a class="header" href="#coinductive-goals" id="coinductive-goals">Coinductive goals</a></h2>
<p>Most goals in our system are &quot;inductive&quot;. In an inductive goal,
circular reasoning is disallowed. Consider this example clause:</p>
<pre><code class="language-text">    Implemented(Foo: Bar) :-
        Implemented(Foo: Bar).
</code></pre>
<p>Considered inductively, this clause is useless: if we are trying to
prove <code>Implemented(Foo: Bar)</code>, we would then recursively have to prove
<code>Implemented(Foo: Bar)</code>, and that cycle would continue ad infinitum
(the trait solver will terminate here, it would just consider that
<code>Implemented(Foo: Bar)</code> is not known to be true).</p>
<p>However, some goals are <em>co-inductive</em>. Simply put, this means that
cycles are OK. So, if <code>Bar</code> were a co-inductive trait, then the rule
above would be perfectly valid, and it would indicate that
<code>Implemented(Foo: Bar)</code> is true.</p>
<p><em>Auto traits</em> are one example in Rust where co-inductive goals are used.
Consider the <code>Send</code> trait, and imagine that we have this struct:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Foo {
    next: Option&lt;Box&lt;Foo&gt;&gt;
}
<span class="boring">}
</span></code></pre></pre>
<p>The default rules for auto traits say that <code>Foo</code> is <code>Send</code> if the
types of its fields are <code>Send</code>. Therefore, we would have a rule like</p>
<pre><code class="language-text">Implemented(Foo: Send) :-
    Implemented(Option&lt;Box&lt;Foo&gt;&gt;: Send).
</code></pre>
<p>As you can probably imagine, proving that <code>Option&lt;Box&lt;Foo&gt;&gt;: Send</code> is
going to wind up circularly requiring us to prove that <code>Foo: Send</code>
again. So this would be an example where we wind up in a cycle – but
that's ok, we <em>do</em> consider <code>Foo: Send</code> to hold, even though it
references itself.</p>
<p>In general, co-inductive traits are used in Rust trait solving when we
want to enumerate a fixed set of possibilities. In the case of auto
traits, we are enumerating the set of reachable types from a given
starting point (i.e., <code>Foo</code> can reach values of type
<code>Option&lt;Box&lt;Foo&gt;&gt;</code>, which implies it can reach values of type
<code>Box&lt;Foo&gt;</code>, and then of type <code>Foo</code>, and then the cycle is complete).</p>
<p>In addition to auto traits, <code>WellFormed</code> predicates are co-inductive.
These are used to achieve a similar &quot;enumerate all the cases&quot; pattern,
as described in the section on <a href="rustc-guide/traits/./lowering-rules.html#implied-bounds">implied bounds</a>.</p>
<h2><a class="header" href="#incomplete-chapter" id="incomplete-chapter">Incomplete chapter</a></h2>
<p>Some topics yet to be written:</p>
<ul>
<li>Elaborate on the proof procedure</li>
<li>SLG solving – introduce negative reasoning</li>
</ul>
<h1><a class="header" href="#equality-and-associated-types" id="equality-and-associated-types">Equality and associated types</a></h1>
<p>This section covers how the trait system handles equality between
associated types. The full system consists of several moving parts,
which we will introduce one by one:</p>
<ul>
<li>Projection and the <code>Normalize</code> predicate</li>
<li>Placeholder associated type projections</li>
<li>The <code>ProjectionEq</code> predicate</li>
<li>Integration with unification</li>
</ul>
<h2><a class="header" href="#associated-type-projection-and-normalization" id="associated-type-projection-and-normalization">Associated type projection and normalization</a></h2>
<p>When a trait defines an associated type (e.g.,
<a href="https://doc.rust-lang.org/nightly/core/iter/trait.IntoIterator.html#associatedtype.Item">the <code>Item</code> type in the <code>IntoIterator</code> trait</a>), that
type can be referenced by the user using an <strong>associated type
projection</strong> like <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code>.</p>
<blockquote>
<p>Often, people will use the shorthand syntax <code>T::Item</code>. Presently, that
syntax is expanded during <a href="rustc-guide/traits/../type-checking.html">&quot;type collection&quot;</a> into the
explicit form, though that is something we may want to change in the future.</p>
</blockquote>
<p><a name="normalize"></a></p>
<p>In some cases, associated type projections can be <strong>normalized</strong> –
that is, simplified – based on the types given in an impl. So, to
continue with our example, the impl of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code>
declares (among other things) that <code>Item = T</code>:</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; IntoIterator for Option&lt;T&gt; {
  type Item = T;
  ...
}
</code></pre>
<p>This means we can normalize the projection <code>&lt;Option&lt;u32&gt; as IntoIterator&gt;::Item</code> to just <code>u32</code>.</p>
<p>In this case, the projection was a &quot;monomorphic&quot; one – that is, it
did not have any type parameters.  Monomorphic projections are special
because they can <strong>always</strong> be fully normalized.</p>
<p>Often, we can normalize other associated type projections as well. For
example, <code>&lt;Option&lt;?T&gt; as IntoIterator&gt;::Item</code>, where <code>?T</code> is an inference
variable, can be normalized to just <code>?T</code>.</p>
<p>In our logic, normalization is defined by a predicate
<code>Normalize</code>. The <code>Normalize</code> clauses arise only from
impls. For example, the <code>impl</code> of <code>IntoIterator</code> for <code>Option&lt;T&gt;</code> that
we saw above would be lowered to a program clause like so:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    Normalize(&lt;Option&lt;T&gt; as IntoIterator&gt;::Item -&gt; T) :-
        Implemented(Option&lt;T&gt;: IntoIterator)
}
</code></pre>
<p>where in this case, the one <code>Implemented</code> condition is always true.</p>
<blockquote>
<p>Since we do not permit quantification over traits, this is really more like
a family of program clauses, one for each associated type.</p>
</blockquote>
<p>We could apply that rule to normalize either of the examples that
we've seen so far.</p>
<h2><a class="header" href="#placeholder-associated-types" id="placeholder-associated-types">Placeholder associated types</a></h2>
<p>Sometimes however we want to work with associated types that cannot be
normalized. For example, consider this function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: IntoIterator&gt;(...) { ... }
</code></pre>
<p>In this context, how would we normalize the type <code>T::Item</code>?</p>
<p>Without knowing what <code>T</code> is, we can't really do so. To represent this case,
we introduce a type called a <strong>placeholder associated type projection</strong>. This
is written like so: <code>(IntoIterator::Item)&lt;T&gt;</code>.</p>
<p>You may note that it looks a lot like a regular type (e.g., <code>Option&lt;T&gt;</code>),
except that the &quot;name&quot; of the type is <code>(IntoIterator::Item)</code>. This is not an
accident: placeholder associated type projections work just like ordinary
types like <code>Vec&lt;T&gt;</code> when it comes to unification. That is, they are only
considered equal if (a) they are both references to the same associated type,
like <code>IntoIterator::Item</code> and (b) their type arguments are equal.</p>
<p>Placeholder associated types are never written directly by the user.
They are used internally by the trait system only, as we will see
shortly.</p>
<p>In rustc, they correspond to the <code>TyKind::UnnormalizedProjectionTy</code> enum
variant, declared in <a href="https://github.com/rust-lang/rust/blob/master/src/librustc/ty/sty.rs"><code>librustc/ty/sty.rs</code></a>. In chalk, we use an
<code>ApplicationTy</code> with a name living in a special namespace dedicated to
placeholder associated types (see the <code>TypeName</code> enum declared in
<a href="https://github.com/rust-lang-nursery/chalk/blob/master/chalk-ir/src/lib.rs"><code>chalk-ir/src/lib.rs</code></a>).</p>
<h2><a class="header" href="#projection-equality" id="projection-equality">Projection equality</a></h2>
<p>So far we have seen two ways to answer the question of &quot;When can we
consider an associated type projection equal to another type?&quot;:</p>
<ul>
<li>the <code>Normalize</code> predicate could be used to transform projections when we
knew which impl applied;</li>
<li><strong>placeholder</strong> associated types can be used when we don't. This is also
known as <strong>lazy normalization</strong>.</li>
</ul>
<p>We now introduce the <code>ProjectionEq</code> predicate to bring those two cases
together. The <code>ProjectionEq</code> predicate looks like so:</p>
<pre><code class="language-text">ProjectionEq(&lt;T as IntoIterator&gt;::Item = U)
</code></pre>
<p>and we will see that it can be proven <em>either</em> via normalization or
via the placeholder type. As part of lowering an associated type declaration from
some trait, we create two program clauses for <code>ProjectionEq</code>:</p>
<pre><code class="language-text">forall&lt;T, U&gt; {
    ProjectionEq(&lt;T as IntoIterator&gt;::Item = U) :-
        Normalize(&lt;T as IntoIterator&gt;::Item -&gt; U)
}

forall&lt;T&gt; {
    ProjectionEq(&lt;T as IntoIterator&gt;::Item = (IntoIterator::Item)&lt;T&gt;)
}
</code></pre>
<p>These are the only two <code>ProjectionEq</code> program clauses we ever make for
any given associated item.</p>
<h2><a class="header" href="#integration-with-unification" id="integration-with-unification">Integration with unification</a></h2>
<p>Now we are ready to discuss how associated type equality integrates
with unification. As described in the
<a href="rustc-guide/traits/../type-inference.html">type inference</a> section, unification is
basically a procedure with a signature like this:</p>
<pre><code class="language-text">Unify(A, B) = Result&lt;(Subgoals, RegionConstraints), NoSolution&gt;
</code></pre>
<p>In other words, we try to unify two things A and B. That procedure
might just fail, in which case we get back <code>Err(NoSolution)</code>. This
would happen, for example, if we tried to unify <code>u32</code> and <code>i32</code>.</p>
<p>The key point is that, on success, unification can also give back to
us a set of subgoals that still remain to be proven. (It can also give
back region constraints, but those are not relevant here).</p>
<p>Whenever unification encounters a non-placeholder associated type
projection P being equated with some other type T, it always succeeds,
but it produces a subgoal <code>ProjectionEq(P = T)</code> that is propagated
back up. Thus it falls to the ordinary workings of the trait system
to process that constraint.</p>
<blockquote>
<p>If we unify two projections P1 and P2, then unification produces a
variable X and asks us to prove that <code>ProjectionEq(P1 = X)</code> and
<code>ProjectionEq(P2 = X)</code>. (That used to be needed in an older system to
prevent cycles; I rather doubt it still is. -nmatsakis)</p>
</blockquote>
<h1><a class="header" href="#implied-bounds" id="implied-bounds">Implied Bounds</a></h1>
<p>Implied bounds remove the need to repeat where clauses written on
a type declaration or a trait declaration. For example, say we have the
following type declaration:</p>
<pre><code class="language-rust ignore">struct HashSet&lt;K: Hash&gt; {
    ...
}
</code></pre>
<p>then everywhere we use <code>HashSet&lt;K&gt;</code> as an &quot;input&quot; type, that is appearing in
the receiver type of an <code>impl</code> or in the arguments of a function, we don't
want to have to repeat the <code>where K: Hash</code> bound, as in:</p>
<pre><code class="language-rust ignore">// I don't want to have to repeat `where K: Hash` here.
impl&lt;K&gt; HashSet&lt;K&gt; {
    ...
}

// Same here.
fn loud_insert&lt;K&gt;(set: &amp;mut HashSet&lt;K&gt;, item: K) {
    println!(&quot;inserting!&quot;);
    set.insert(item);
}
</code></pre>
<p>Note that in the <code>loud_insert</code> example, <code>HashSet&lt;K&gt;</code> is not the type
of the <code>set</code> argument of <code>loud_insert</code>, it only <em>appears</em> in the
argument type <code>&amp;mut HashSet&lt;K&gt;</code>: we care about every type appearing
in the function's header (the header is the signature without the return type),
not only types of the function's arguments.</p>
<p>The rationale for applying implied bounds to input types is that, for example,
in order to call the <code>loud_insert</code> function above, the programmer must have
<em>produced</em> the type <code>HashSet&lt;K&gt;</code> already, hence the compiler already verified
that <code>HashSet&lt;K&gt;</code> was well-formed, i.e. that <code>K</code> effectively implemented
<code>Hash</code>, as in the following example:</p>
<pre><code class="language-rust ignore">fn main() {
    // I am producing a value of type `HashSet&lt;i32&gt;`.
    // If `i32` was not `Hash`, the compiler would report an error here.
    let set: HashSet&lt;i32&gt; = HashSet::new();
    loud_insert(&amp;mut set, 5);
}
</code></pre>
<p>Hence, we don't want to repeat where clauses for input types because that would
sort of duplicate the work of the programmer, having to verify that their types
are well-formed both when calling the function and when using them in the
arguments of their function. The same reasoning applies when using an <code>impl</code>.</p>
<p>Similarly, given the following trait declaration:</p>
<pre><code class="language-rust ignore">trait Copy where Self: Clone { // desugared version of `Copy: Clone`
    ...
}
</code></pre>
<p>then everywhere we bound over <code>SomeType: Copy</code>, we would like to be able to
use the fact that <code>SomeType: Clone</code> without having to write it explicitly,
as in:</p>
<pre><code class="language-rust ignore">fn loud_clone&lt;T: Clone&gt;(x: T) {
    println!(&quot;cloning!&quot;);
    x.clone();
}

fn fun_with_copy&lt;T: Copy&gt;(x: T) {
    println!(&quot;will clone a `Copy` type soon...&quot;);

    // I'm using `loud_clone&lt;T: Clone&gt;` with `T: Copy`, I know this
    // implies `T: Clone` so I don't want to have to write it explicitly.
    loud_clone(x);
}
</code></pre>
<p>The rationale for implied bounds for traits is that if a type implements
<code>Copy</code>, that is, if there exists an <code>impl Copy</code> for that type, there <em>ought</em>
to exist an <code>impl Clone</code> for that type, otherwise the compiler would have
reported an error in the first place. So again, if we were forced to repeat the
additionnal <code>where SomeType: Clone</code> everywhere whereas we already know that
<code>SomeType: Copy</code> hold, we would kind of duplicate the verification work.</p>
<p>Implied bounds are not yet completely enforced in rustc, at the moment it only
works for outlive requirements, super trait bounds, and bounds on associated
types. The full RFC can be found <a href="https://github.com/rust-lang/rfcs/blob/master/text/2089-implied-bounds.md">here</a>. We'll give here a brief view
of how implied bounds work and why we chose to implement it that way. The
complete set of lowering rules can be found in the corresponding
<a href="rustc-guide/traits/./lowering-rules.html">chapter</a>.</p>
<h2><a class="header" href="#implied-bounds-and-lowering-rules" id="implied-bounds-and-lowering-rules">Implied bounds and lowering rules</a></h2>
<p>Now we need to express implied bounds in terms of logical rules. We will start
with exposing a naive way to do it. Suppose that we have the following traits:</p>
<pre><code class="language-rust ignore">trait Foo {
    ...
}

trait Bar where Self: Foo { } {
    ...
}
</code></pre>
<p>So we would like to say that if a type implements <code>Bar</code>, then necessarily
it must also implement <code>Foo</code>. We might think that a clause like this would
work:</p>
<pre><code class="language-text">forall&lt;Type&gt; {
    Implemented(Type: Foo) :- Implemented(Type: Bar).
}
</code></pre>
<p>Now suppose that we just write this impl:</p>
<pre><code class="language-rust ignore">struct X;

impl Bar for X { }
</code></pre>
<p>Clearly this should not be allowed: indeed, we wrote a <code>Bar</code> impl for <code>X</code>, but
the <code>Bar</code> trait requires that we also implement <code>Foo</code> for <code>X</code>, which we never
did. In terms of what the compiler does, this would look like this:</p>
<pre><code class="language-rust ignore">struct X;

impl Bar for X {
    // We are in a `Bar` impl for the type `X`.
    // There is a `where Self: Foo` bound on the `Bar` trait declaration.
    // Hence I need to prove that `X` also implements `Foo` for that impl
    // to be legal.
}
</code></pre>
<p>So the compiler would try to prove <code>Implemented(X: Foo)</code>. Of course it will
not find any <code>impl Foo for X</code> since we did not write any. However, it
will see our implied bound clause:</p>
<pre><code class="language-text">forall&lt;Type&gt; {
    Implemented(Type: Foo) :- Implemented(Type: Bar).
}
</code></pre>
<p>so that it may be able to prove <code>Implemented(X: Foo)</code> if <code>Implemented(X: Bar)</code>
holds. And it turns out that <code>Implemented(X: Bar)</code> does hold since we wrote
a <code>Bar</code> impl for <code>X</code>! Hence the compiler will accept the <code>Bar</code> impl while it
should not.</p>
<h2><a class="header" href="#implied-bounds-coming-from-the-environment" id="implied-bounds-coming-from-the-environment">Implied bounds coming from the environment</a></h2>
<p>So the naive approach does not work. What we need to do is to somehow decouple
implied bounds from impls. Suppose we know that a type <code>SomeType&lt;...&gt;</code>
implements <code>Bar</code> and we want to deduce that <code>SomeType&lt;...&gt;</code> must also implement
<code>Foo</code>.</p>
<p>There are two possibilities: first, we have enough information about
<code>SomeType&lt;...&gt;</code> to see that there exists a <code>Bar</code> impl in the program which
covers <code>SomeType&lt;...&gt;</code>, for example a plain <code>impl&lt;...&gt; Bar for SomeType&lt;...&gt;</code>.
Then if the compiler has done its job correctly, there <em>must</em> exist a <code>Foo</code>
impl which covers <code>SomeType&lt;...&gt;</code>, e.g. another plain
<code>impl&lt;...&gt; Foo for SomeType&lt;...&gt;</code>. In that case then, we can just use this
impl and we do not need implied bounds at all.</p>
<p>Second possibility: we do not know enough about <code>SomeType&lt;...&gt;</code> in order to
find a <code>Bar</code> impl which covers it, for example if <code>SomeType&lt;...&gt;</code> is just
a type parameter in a function:</p>
<pre><code class="language-rust ignore">fn foo&lt;T: Bar&gt;() {
    // We'd like to deduce `Implemented(T: Foo)`.
}
</code></pre>
<p>That is, the information that <code>T</code> implements <code>Bar</code> here comes from the
<em>environment</em>. The environment is the set of things that we assume to be true
when we type check some Rust declaration. In that case, what we assume is that
<code>T: Bar</code>. Then at that point, we might authorize ourselves to have some kind
of  &quot;local&quot; implied bound reasoning which would say
<code>Implemented(T: Foo) :- Implemented(T: Bar)</code>. This reasoning would
only be done within our <code>foo</code> function in order to avoid the earlier
problem where we had a global clause.</p>
<p>We can apply these local reasonings everywhere we can have an environment
-- i.e. when we can write where clauses -- that is, inside impls,
trait declarations, and type declarations.</p>
<h2><a class="header" href="#computing-implied-bounds-with-fromenv" id="computing-implied-bounds-with-fromenv">Computing implied bounds with <code>FromEnv</code></a></h2>
<p>The previous subsection showed that it was only useful to compute implied
bounds for facts coming from the environment.
We talked about &quot;local&quot; rules, but there are multiple possible strategies to
indeed implement the locality of implied bounds.</p>
<p>In rustc, the current strategy is to <em>elaborate</em> bounds: that is, each time
we have a fact in the environment, we recursively derive all the other things
that are implied by this fact until we reach a fixed point. For example, if
we have the following declarations:</p>
<pre><code class="language-rust ignore">trait A { }
trait B where Self: A { }
trait C where Self: B { }

fn foo&lt;T: C&gt;() {
    ...
}
</code></pre>
<p>then inside the <code>foo</code> function, we start with an environment containing only
<code>Implemented(T: C)</code>. Then because of implied bounds for the <code>C</code> trait, we
elaborate <code>Implemented(T: B)</code> and add it to our environment. Because of
implied bounds for the <code>B</code> trait, we elaborate <code>Implemented(T: A)</code>and add it
to our environment as well. We cannot elaborate anything else, so we conclude
that our final environment consists of <code>Implemented(T: A + B + C)</code>.</p>
<p>In the new-style trait system, we like to encode as many things as possible
with logical rules. So rather than &quot;elaborating&quot;, we have a set of <em>global</em>
program clauses defined like so:</p>
<pre><code class="language-text">forall&lt;T&gt; { Implemented(T: A) :- FromEnv(T: A). }

forall&lt;T&gt; { Implemented(T: B) :- FromEnv(T: B). }
forall&lt;T&gt; { FromEnv(T: A) :- FromEnv(T: B). }

forall&lt;T&gt; { Implemented(T: C) :- FromEnv(T: C). }
forall&lt;T&gt; { FromEnv(T: C) :- FromEnv(T: C). }
</code></pre>
<p>So these clauses are defined globally (that is, they are available from
everywhere in the program) but they cannot be used because the hypothesis
is always of the form <code>FromEnv(...)</code> which is a bit special. Indeed, as
indicated by the name, <code>FromEnv(...)</code> facts can <strong>only</strong> come from the
environment.
How it works is that in the <code>foo</code> function, instead of having an environment
containing <code>Implemented(T: C)</code>, we replace this environment with
<code>FromEnv(T: C)</code>. From here and thanks to the above clauses, we see that we
are able to reach any of <code>Implemented(T: A)</code>, <code>Implemented(T: B)</code> or
<code>Implemented(T: C)</code>, which is what we wanted.</p>
<h2><a class="header" href="#implied-bounds-and-well-formedness-checking" id="implied-bounds-and-well-formedness-checking">Implied bounds and well-formedness checking</a></h2>
<p>Implied bounds are tightly related with well-formedness checking.
Well-formedness checking is the process of checking that the impls the
programmer wrote are legal, what we referred to earlier as &quot;the compiler doing
its job correctly&quot;.</p>
<p>We already saw examples of illegal and legal impls:</p>
<pre><code class="language-rust ignore">trait Foo { }
trait Bar where Self: Foo { }

struct X;
struct Y;

impl Bar for X {
    // This impl is not legal: the `Bar` trait requires that we also
    // implement `Foo`, and we didn't.
}

impl Foo for Y {
    // This impl is legal: there is nothing to check as there are no where
    // clauses on the `Foo` trait.
}

impl Bar for Y {
    // This impl is legal: we have a `Foo` impl for `Y`.
}
</code></pre>
<p>We must define what &quot;legal&quot; and &quot;illegal&quot; mean. For this, we introduce another
predicate: <code>WellFormed(Type: Trait)</code>. We say that the trait reference
<code>Type: Trait</code> is well-formed if <code>Type</code> meets the bounds written on the
<code>Trait</code> declaration. For each impl we write, assuming that the where clauses
declared on the impl hold, the compiler tries to prove that the corresponding
trait reference is well-formed. The impl is legal if the compiler manages to do
so.</p>
<p>Coming to the definition of <code>WellFormed(Type: Trait)</code>, it would be tempting
to define it as:</p>
<pre><code class="language-rust ignore">trait Trait where WC1, WC2, ..., WCn {
    ...
}
</code></pre>
<pre><code class="language-text">forall&lt;Type&gt; {
    WellFormed(Type: Trait) :- WC1 &amp;&amp; WC2 &amp;&amp; .. &amp;&amp; WCn.
}
</code></pre>
<p>and indeed this was basically what was done in rustc until it was noticed that
this mixed badly with implied bounds. The key thing is that implied bounds
allows someone to derive all bounds implied by a fact in the environment, and
this <em>transitively</em> as we've seen with the <code>A + B + C</code> traits example.
However, the <code>WellFormed</code> predicate as defined above only checks that the
<em>direct</em> superbounds hold. That is, if we come back to our <code>A + B + C</code>
example:</p>
<pre><code class="language-rust ignore">trait A { }
// No where clauses, always well-formed.
// forall&lt;Type&gt; { WellFormed(Type: A). }

trait B where Self: A { }
// We only check the direct superbound `Self: A`.
// forall&lt;Type&gt; { WellFormed(Type: B) :- Implemented(Type: A). }

trait C where Self: B { }
// We only check the direct superbound `Self: B`. We do not check
// the `Self: A` implied bound  coming from the `Self: B` superbound.
// forall&lt;Type&gt; { WellFormed(Type: C) :- Implemented(Type: B). }
</code></pre>
<p>There is an asymmetry between the recursive power of implied bounds and
the shallow checking of <code>WellFormed</code>. It turns out that this asymmetry
can be <a href="https://github.com/rust-lang/rust/pull/43786">exploited</a>. Indeed, suppose that we define the following
traits:</p>
<pre><code class="language-rust ignore">trait Partial where Self: Copy { }
// WellFormed(Self: Partial) :- Implemented(Self: Copy).

trait Complete where Self: Partial { }
// WellFormed(Self: Complete) :- Implemented(Self: Partial).

impl&lt;T&gt; Partial for T where T: Complete { }

impl&lt;T&gt; Complete for T { }
</code></pre>
<p>For the <code>Partial</code> impl, what the compiler must prove is:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    if (T: Complete) { // assume that the where clauses hold
        WellFormed(T: Partial) // show that the trait reference is well-formed
    }
}
</code></pre>
<p>Proving <code>WellFormed(T: Partial)</code> amounts to proving <code>Implemented(T: Copy)</code>.
However, we have <code>Implemented(T: Complete)</code> in our environment: thanks to
implied bounds, we can deduce <code>Implemented(T: Partial)</code>. Using implied bounds
one level deeper, we can deduce <code>Implemented(T: Copy)</code>. Finally, the <code>Partial</code>
impl is legal.</p>
<p>For the <code>Complete</code> impl, what the compiler must prove is:</p>
<pre><code class="language-text">forall&lt;T&gt; {
    WellFormed(T: Complete) // show that the trait reference is well-formed
}
</code></pre>
<p>Proving <code>WellFormed(T: Complete)</code> amounts to proving <code>Implemented(T: Partial)</code>.
We see that the <code>impl Partial for T</code> applies if we can prove
<code>Implemented(T: Complete)</code>, and it turns out we can prove this fact since our
<code>impl&lt;T&gt; Complete for T</code> is a blanket impl without any where clauses.</p>
<p>So both impls are legal and the compiler accepts the program. Moreover, thanks
to the <code>Complete</code> blanket impl, all types implement <code>Complete</code>. So we could
now use this impl like so:</p>
<pre><code class="language-rust ignore">fn eat&lt;T&gt;(x: T) { }

fn copy_everything&lt;T: Complete&gt;(x: T) {
    eat(x);
    eat(x);
}

fn main() {
    let not_copiable = vec![1, 2, 3, 4];
    copy_everything(not_copiable);
}
</code></pre>
<p>In this program, we use the fact that <code>Vec&lt;i32&gt;</code> implements <code>Complete</code>, as any
other type. Hence we can call <code>copy_everything</code> with an argument of type
<code>Vec&lt;i32&gt;</code>. Inside the <code>copy_everything</code> function, we have the
<code>Implemented(T: Complete)</code> bound in our environment. Thanks to implied bounds,
we can deduce <code>Implemented(T: Partial)</code>. Using implied bounds again, we deduce
<code>Implemented(T: Copy)</code> and we can indeed call the <code>eat</code> function which moves
the argument twice since its argument is <code>Copy</code>. Problem: the <code>T</code> type was
in fact <code>Vec&lt;i32&gt;</code> which is not copy at all, hence we will double-free the
underlying vec storage so we have a memory unsoundness in safe Rust.</p>
<p>Of course, disregarding the asymmetry between <code>WellFormed</code> and implied bounds,
this bug was possible only because we had some kind of self-referencing impls.
But self-referencing impls are very useful in practice and are not the real
culprits in this affair.</p>
<h2><a class="header" href="#co-inductiveness-of-wellformed" id="co-inductiveness-of-wellformed">Co-inductiveness of <code>WellFormed</code></a></h2>
<p>So the solution is to fix this asymmetry between <code>WellFormed</code> and implied
bounds. For that, we need for the <code>WellFormed</code> predicate to not only require
that the direct superbounds hold, but also all the bounds transitively implied
by the superbounds. What we can do is to have the following rules for the
<code>WellFormed</code> predicate:</p>
<pre><code class="language-rust ignore">trait A { }
// WellFormed(Self: A) :- Implemented(Self: A).

trait B where Self: A { }
// WellFormed(Self: B) :- Implemented(Self: B) &amp;&amp; WellFormed(Self: A).

trait C where Self: B { }
// WellFormed(Self: C) :- Implemented(Self: C) &amp;&amp; WellFormed(Self: B).
</code></pre>
<p>Notice that we are now also requiring <code>Implemented(Self: Trait)</code> for
<code>WellFormed(Self: Trait)</code> to be true: this is to simplify the process of
traversing all the implied bounds transitively. This does not change anything
when checking whether impls are legal, because since we assume
that the where clauses hold inside the impl, we know that the corresponding
trait reference do hold. Thanks to this setup, you can see that we indeed
require to prove the set of all bounds transitively implied by the where
clauses.</p>
<p>However there is still a catch. Suppose that we have the following trait
definition:</p>
<pre><code class="language-rust ignore">trait Foo where &lt;Self as Foo&gt;::Item: Foo {
    type Item;
}
</code></pre>
<p>so this definition is a bit more involved than the ones we've seen already
because it defines an associated item. However, the well-formedness rule
would not be more complicated:</p>
<pre><code class="language-text">WellFormed(Self: Foo) :-
    Implemented(Self: Foo) &amp;&amp;
    WellFormed(&lt;Self as Foo&gt;::Item: Foo).
</code></pre>
<p>Now we would like to write the following impl:</p>
<pre><code class="language-rust ignore">impl Foo for i32 {
    type Item = i32;
}
</code></pre>
<p>The <code>Foo</code> trait definition and the <code>impl Foo for i32</code> are perfectly valid
Rust: we're kind of recursively using our <code>Foo</code> impl in order to show that
the associated value indeed implements <code>Foo</code>, but that's ok. But if we
translate this to our well-formedness setting, the compiler proof process
inside the <code>Foo</code> impl is the following: it starts with proving that the
well-formedness goal <code>WellFormed(i32: Foo)</code> is true. In order to do that,
it must prove the following goals: <code>Implemented(i32: Foo)</code> and
<code>WellFormed(&lt;i32 as Foo&gt;::Item: Foo)</code>. <code>Implemented(i32: Foo)</code> holds because
there is our impl and there are no where clauses on it so it's always true.
However, because of the associated type value we used,
<code>WellFormed(&lt;i32 as Foo&gt;::Item: Foo)</code> simplifies to just
<code>WellFormed(i32: Foo)</code>. So in order to prove its original goal
<code>WellFormed(i32: Foo)</code>, the compiler needs to prove <code>WellFormed(i32: Foo)</code>:
this clearly is a cycle and cycles are usually rejected by the trait solver,
unless...  if the <code>WellFormed</code> predicate was made to be co-inductive.</p>
<p>A co-inductive predicate, as discussed in the chapter on
<a href="rustc-guide/traits/./goals-and-clauses.html#coinductive-goals">goals and clauses</a>, are predicates
for which the
trait solver accepts cycles. In our setting, this would be a valid thing to do:
indeed, the <code>WellFormed</code> predicate just serves as a way of enumerating all
the implied bounds. Hence, it's like a fixed point algorithm: it tries to grow
the set of implied bounds until there is nothing more to add. Here, a cycle
in the chain of <code>WellFormed</code> predicates just means that there is no more bounds
to add in that direction, so we can just accept this cycle and focus on other
directions. It's easy to prove that under these co-inductive semantics, we
are effectively visiting all the transitive implied bounds, and only these.</p>
<h2><a class="header" href="#implied-bounds-on-types" id="implied-bounds-on-types">Implied bounds on types</a></h2>
<p>We mainly talked about implied bounds for traits because this was the most
subtle regarding implementation. Implied bounds on types are simpler,
especially because if we assume that a type is well-formed, we don't use that
fact to deduce that other types are well-formed, we only use it to deduce
that e.g. some trait bounds hold.</p>
<p>For types, we just use rules like these ones:</p>
<pre><code class="language-rust ignore">struct Type&lt;...&gt; where WC1, ..., WCn {
    ...
}
</code></pre>
<pre><code class="language-text">forall&lt;...&gt; {
    WellFormed(Type&lt;...&gt;) :- WC1, ..., WCn.
}

forall&lt;...&gt; {
    FromEnv(WC1) :- FromEnv(Type&lt;...&gt;).
    ...
    FromEnv(WCn) :- FromEnv(Type&lt;...&gt;).
}
</code></pre>
<p>We can see that we have this asymmetry between well-formedness check,
which only verifies that the direct superbounds hold, and implied bounds which
gives access to all bounds transitively implied by the where clauses. In that
case this is ok because as we said, we don't use <code>FromEnv(Type&lt;...&gt;)</code> to deduce
other <code>FromEnv(OtherType&lt;...&gt;)</code> things, nor do we use <code>FromEnv(Type: Trait)</code> to
deduce <code>FromEnv(OtherType&lt;...&gt;)</code> things. So in that sense type definitions are
&quot;less recursive&quot; than traits, and we saw in a previous subsection that
it was the combination of asymmetry and recursive trait / impls that led to
unsoundness. As such, the <code>WellFormed(Type&lt;...&gt;)</code> predicate does not need
to be co-inductive.</p>
<p>This asymmetry optimization is useful because in a real Rust program, we have
to check the well-formedness of types very often (e.g. for each type which
appears in the body of a function).</p>
<h1><a class="header" href="#region-constraints-1" id="region-constraints-1">Region constraints</a></h1>
<p><em>To be written.</em></p>
<p>Chalk does not have the concept of region constraints, and as of this
writing, work on rustc was not far enough to worry about them.</p>
<p>In the meantime, you can read about region constraints in the
<a href="rustc-guide/traits/../type-inference.html#region-constraints">type inference</a> section.</p>
<h1><a class="header" href="#the-lowering-module-in-rustc" id="the-lowering-module-in-rustc">The lowering module in rustc</a></h1>
<p>The program clauses described in the
<a href="rustc-guide/traits/./lowering-rules.html">lowering rules</a> section are actually
created in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_traits/lowering/"><code>rustc_traits::lowering</code></a> module.</p>
<h2><a class="header" href="#the-program_clauses_for-query" id="the-program_clauses_for-query">The <code>program_clauses_for</code> query</a></h2>
<p>The main entry point is the <code>program_clauses_for</code> <a href="rustc-guide/traits/../query.html">query</a>, which –
given a def-id – produces a set of Chalk program clauses. These
queries are tested using a
<a href="rustc-guide/traits/lowering-module.html#unit-tests">dedicated unit-testing mechanism, described below</a>.  The
query is invoked on a <code>DefId</code> that identifies something like a trait,
an impl, or an associated item definition. It then produces and
returns a vector of program clauses.</p>
<p><a name="unit-tests"></a></p>
<h2><a class="header" href="#unit-tests-1" id="unit-tests-1">Unit tests</a></h2>
<p>Unit tests are located in <a href="https://github.com/rust-lang/rust/tree/master/src/test/ui/chalkify"><code>src/test/ui/chalkify</code></a>. A good
example test is <a href="https://github.com/rust-lang/rust/tree/master/src/test/ui/chalkify/lower_impl.rs">the <code>lower_impl</code> test</a>. At the time of
this writing, it looked like this:</p>
<pre><code class="language-rust ignore">#![feature(rustc_attrs)]

trait Foo { }

#[rustc_dump_program_clauses] //~ ERROR program clause dump
impl&lt;T: 'static&gt; Foo for T where T: Iterator&lt;Item = i32&gt; { }

fn main() {
    println!(&quot;hello&quot;);
}
</code></pre>
<p>The <code>#[rustc_dump_program_clauses]</code> annotation can be attached to
anything with a def-id.  (It requires the <code>rustc_attrs</code> feature.) The
compiler will then invoke the <code>program_clauses_for</code> query on that
item, and emit compiler errors that dump the clauses produced. These
errors just exist for unit-testing, as we can then leverage the
standard <a href="rustc-guide/traits/../tests/adding.html#guide-to-the-ui-tests">ui test</a> mechanisms to check them. In this case, there is a
<code>//~ ERROR program clause dump</code> annotation which is always the same for
<code>#[rustc_dump_program_clauses]</code>, but <a href="https://github.com/rust-lang/rust/tree/master/src/test/ui/chalkify/lower_impl.stderr">the stderr file</a> contains
the full details:</p>
<pre><code class="language-text">error: program clause dump
  --&gt; $DIR/lower_impl.rs:5:1
   |
LL | #[rustc_dump_program_clauses]
   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
   = note: forall&lt;T&gt; { Implemented(T: Foo) :- ProjectionEq(&lt;T as std::iter::Iterator&gt;::Item == i32), TypeOutlives(T: 'static), Implemented(T: std::iter::Iterator), Implemented(T: std::marker::Sized). }
</code></pre>
<h1><a class="header" href="#lowering-rules" id="lowering-rules">Lowering rules</a></h1>
<p>This section gives the complete lowering rules for Rust traits into
<a href="rustc-guide/traits/./goals-and-clauses.html">program clauses</a>. It is a kind of reference. These rules
reference the <a href="rustc-guide/traits/./goals-and-clauses.html#domain-goals">domain goals</a> defined in an earlier section.</p>
<h2><a class="header" href="#notation" id="notation">Notation</a></h2>
<p>The nonterminal <code>Pi</code> is used to mean some generic <em>parameter</em>, either a
named lifetime like <code>'a</code> or a type parameter like <code>A</code>.</p>
<p>The nonterminal <code>Ai</code> is used to mean some generic <em>argument</em>, which
might be a lifetime like <code>'a</code> or a type like <code>Vec&lt;A&gt;</code>.</p>
<p>When defining the lowering rules, we will give goals and clauses in
the <a href="rustc-guide/traits/./goals-and-clauses.html">notation given in this section</a>.
We sometimes insert &quot;macros&quot; like <code>LowerWhereClause!</code> into these
definitions; these macros reference other sections within this chapter.</p>
<h2><a class="header" href="#rule-names-and-cross-references" id="rule-names-and-cross-references">Rule names and cross-references</a></h2>
<p>Each of these lowering rules is given a name, documented with a
comment like so:</p>
<pre><code>// Rule Foo-Bar-Baz
</code></pre>
<p>The reference implementation of these rules is to be found in
<a href="https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/clauses.rs"><code>chalk/chalk-solve/src/clauses.rs</code></a>. They are also ported in
rustc in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_traits"><code>librustc_traits</code></a> crate.</p>
<h2><a class="header" href="#lowering-where-clauses" id="lowering-where-clauses">Lowering where clauses</a></h2>
<p>When used in a goal position, where clauses can be mapped directly to
the <code>Holds</code> variant of <a href="rustc-guide/traits/./goals-and-clauses.html#domain-goals">domain goals</a>, as follows:</p>
<ul>
<li><code>A0: Foo&lt;A1..An&gt;</code> maps to <code>Implemented(A0: Foo&lt;A1..An&gt;)</code></li>
<li><code>T: 'r</code> maps to <code>Outlives(T, 'r)</code></li>
<li><code>'a: 'b</code> maps to <code>Outlives('a, 'b)</code></li>
<li><code>A0: Foo&lt;A1..An, Item = T&gt;</code> is a bit special and expands to two distinct
goals, namely <code>Implemented(A0: Foo&lt;A1..An&gt;)</code> and
<code>ProjectionEq(&lt;A0 as Foo&lt;A1..An&gt;&gt;::Item = T)</code></li>
</ul>
<p>In the rules below, we will use <code>WC</code> to indicate where clauses that
appear in Rust syntax; we will then use the same <code>WC</code> to indicate
where those where clauses appear as goals in the program clauses that
we are producing. In that case, the mapping above is used to convert
from the Rust syntax into goals.</p>
<h3><a class="header" href="#transforming-the-lowered-where-clauses" id="transforming-the-lowered-where-clauses">Transforming the lowered where clauses</a></h3>
<p>In addition, in the rules below, we sometimes do some transformations
on the lowered where clauses, as defined here:</p>
<ul>
<li><code>FromEnv(WC)</code> – this indicates that:
<ul>
<li><code>Implemented(TraitRef)</code> becomes <code>FromEnv(TraitRef)</code></li>
<li>other where-clauses are left intact</li>
</ul>
</li>
<li><code>WellFormed(WC)</code> – this indicates that:
<ul>
<li><code>Implemented(TraitRef)</code> becomes <code>WellFormed(TraitRef)</code></li>
<li>other where-clauses are left intact</li>
</ul>
</li>
</ul>
<p><em>TODO</em>: I suspect that we want to alter the outlives relations too,
but Chalk isn't modeling those right now.</p>
<h2><a class="header" href="#lowering-traits" id="lowering-traits">Lowering traits</a></h2>
<p>Given a trait definition</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1..Pn&gt; // P0 == Self
where WC
{
    // trait items
}
</code></pre>
<p>we will produce a number of declarations. This section is focused on
the program clauses for the trait header (i.e., the stuff outside the
<code>{}</code>); the <a href="rustc-guide/traits/lowering-rules.html#trait-items">section on trait items</a> covers the stuff
inside the <code>{}</code>.</p>
<h3><a class="header" href="#trait-header" id="trait-header">Trait header</a></h3>
<p>From the trait itself we mostly make &quot;meta&quot; rules that setup the
relationships between different kinds of domain goals.  The first such
rule from the trait header creates the mapping between the <code>FromEnv</code>
and <code>Implemented</code> predicates:</p>
<pre><code class="language-text">// Rule Implemented-From-Env
forall&lt;Self, P1..Pn&gt; {
  Implemented(Self: Trait&lt;P1..Pn&gt;) :- FromEnv(Self: Trait&lt;P1..Pn&gt;)
}
</code></pre>
<p><a name="implied-bounds"></a></p>
<h4><a class="header" href="#implied-bounds-1" id="implied-bounds-1">Implied bounds</a></h4>
<p>The next few clauses have to do with implied bounds (see also
<a href="https://rust-lang.github.io/rfcs/2089-implied-bounds.html">RFC 2089</a> and the <a href="rustc-guide/traits/./implied-bounds.html">implied bounds</a> chapter for a more in depth
cover). For each trait, we produce two clauses:</p>
<pre><code class="language-text">// Rule Implied-Bound-From-Trait
//
// For each where clause WC:
forall&lt;Self, P1..Pn&gt; {
  FromEnv(WC) :- FromEnv(Self: Trait&lt;P1..Pn)
}
</code></pre>
<p>This clause says that if we are assuming that the trait holds, then we can also
assume that its where-clauses hold. It's perhaps useful to see an example:</p>
<pre><code class="language-rust ignore">trait Eq: PartialEq { ... }
</code></pre>
<p>In this case, the <code>PartialEq</code> supertrait is equivalent to a <code>where Self: PartialEq</code> where clause, in our simplified model. The program
clause above therefore states that if we can prove <code>FromEnv(T: Eq)</code> –
e.g., if we are in some function with <code>T: Eq</code> in its where clauses –
then we also know that <code>FromEnv(T: PartialEq)</code>. Thus the set of things
that follow from the environment are not only the <strong>direct where
clauses</strong> but also things that follow from them.</p>
<p>The next rule is related; it defines what it means for a trait reference
to be <strong>well-formed</strong>:</p>
<pre><code class="language-text">// Rule WellFormed-TraitRef
forall&lt;Self, P1..Pn&gt; {
  WellFormed(Self: Trait&lt;P1..Pn&gt;) :- Implemented(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WellFormed(WC)
}
</code></pre>
<p>This <code>WellFormed</code> rule states that <code>T: Trait</code> is well-formed if (a)
<code>T: Trait</code> is implemented and (b) all the where-clauses declared on
<code>Trait</code> are well-formed (and hence they are implemented). Remember
that the <code>WellFormed</code> predicate is
<a href="rustc-guide/traits/./goals-and-clauses.html#coinductive">coinductive</a>; in this
case, it is serving as a kind of &quot;carrier&quot; that allows us to enumerate
all the where clauses that are transitively implied by <code>T: Trait</code>.</p>
<p>An example:</p>
<pre><code class="language-rust ignore">trait Foo: A + Bar { }
trait Bar: B + Foo { }
trait A { }
trait B { }
</code></pre>
<p>Here, the transitive set of implications for <code>T: Foo</code> are <code>T: A</code>, <code>T: Bar</code>, and
<code>T: B</code>.  And indeed if we were to try to prove <code>WellFormed(T: Foo)</code>, we would
have to prove each one of those:</p>
<ul>
<li><code>WellFormed(T: Foo)</code>
<ul>
<li><code>Implemented(T: Foo)</code></li>
<li><code>WellFormed(T: A)</code>
<ul>
<li><code>Implemented(T: A)</code></li>
</ul>
</li>
<li><code>WellFormed(T: Bar)</code>
<ul>
<li><code>Implemented(T: Bar)</code></li>
<li><code>WellFormed(T: B)</code>
<ul>
<li><code>Implemented(T: Bar)</code></li>
</ul>
</li>
<li><code>WellFormed(T: Foo)</code> -- cycle, true coinductively</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This <code>WellFormed</code> predicate is only used when proving that impls are
well-formed – basically, for each impl of some trait ref <code>TraitRef</code>,
we must show that <code>WellFormed(TraitRef)</code>. This in turn justifies the
implied bounds rules that allow us to extend the set of <code>FromEnv</code>
items.</p>
<h2><a class="header" href="#lowering-type-definitions" id="lowering-type-definitions">Lowering type definitions</a></h2>
<p>We also want to have some rules which define when a type is well-formed.
For example, given this type:</p>
<pre><code class="language-rust ignore">struct Set&lt;K&gt; where K: Hash { ... }
</code></pre>
<p>then <code>Set&lt;i32&gt;</code> is well-formed because <code>i32</code> implements <code>Hash</code>, but
<code>Set&lt;NotHash&gt;</code> would not be well-formed. Basically, a type is well-formed
if its parameters verify the where clauses written on the type definition.</p>
<p>Hence, for every type definition:</p>
<pre><code class="language-rust ignore">struct Type&lt;P1..Pn&gt; where WC { ... }
</code></pre>
<p>we produce the following rule:</p>
<pre><code class="language-text">// Rule WellFormed-Type
forall&lt;P1..Pn&gt; {
  WellFormed(Type&lt;P1..Pn&gt;) :- WC
}
</code></pre>
<p>Note that we use <code>struct</code> for defining a type, but this should be understood
as a general type definition (it could be e.g. a generic <code>enum</code>).</p>
<p>Conversely, we define rules which say that if we assume that a type is
well-formed, we can also assume that its where clauses hold. That is,
we produce the following family of rules:</p>
<pre><code class="language-text">// Rule Implied-Bound-From-Type
//
// For each where clause `WC`
forall&lt;P1..Pn&gt; {
  FromEnv(WC) :- FromEnv(Type&lt;P1..Pn&gt;)
}
</code></pre>
<p>As for the implied bounds RFC, functions will <em>assume</em> that their arguments
are well-formed. For example, suppose we have the following bit of code:</p>
<pre><code class="language-rust ignore">trait Hash: Eq { }
struct Set&lt;K: Hash&gt; { ... }

fn foo&lt;K&gt;(collection: Set&lt;K&gt;, x: K, y: K) {
    // `x` and `y` can be equalized even if we did not explicitly write
    // `where K: Eq`
    if x == y {
        ...
    }
}
</code></pre>
<p>In the <code>foo</code> function, we assume that <code>Set&lt;K&gt;</code> is well-formed, i.e. we have
<code>FromEnv(Set&lt;K&gt;)</code> in our environment. Because of the previous rule, we get
<code>FromEnv(K: Hash)</code> without needing an explicit where clause. And because
of the <code>Hash</code> trait definition, there also exists a rule which says:</p>
<pre><code class="language-text">forall&lt;K&gt; {
  FromEnv(K: Eq) :- FromEnv(K: Hash)
}
</code></pre>
<p>which means that we finally get <code>FromEnv(K: Eq)</code> and then can compare <code>x</code>
and <code>y</code> without needing an explicit where clause.</p>
<p><a name="trait-items"></a></p>
<h2><a class="header" href="#lowering-trait-items" id="lowering-trait-items">Lowering trait items</a></h2>
<h3><a class="header" href="#associated-type-declarations" id="associated-type-declarations">Associated type declarations</a></h3>
<p>Given a trait that declares a (possibly generic) associated type:</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1..Pn&gt; // P0 == Self
where WC
{
    type AssocType&lt;Pn+1..Pm&gt;: Bounds where WC1;
}
</code></pre>
<p>We will produce a number of program clauses. The first two define
the rules by which <code>ProjectionEq</code> can succeed; these two clauses are discussed
in detail in the <a href="rustc-guide/traits/./associated-types.html">section on associated types</a>,
but reproduced here for reference:</p>
<pre><code class="language-text">// Rule ProjectionEq-Normalize
//
// ProjectionEq can succeed by normalizing:
forall&lt;Self, P1..Pn, Pn+1..Pm, U&gt; {
  ProjectionEq(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; = U) :-
      Normalize(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; U)
}
</code></pre>
<pre><code class="language-text">// Rule ProjectionEq-Placeholder
//
// ProjectionEq can succeed through the placeholder associated type,
// see &quot;associated type&quot; chapter for more:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
  ProjectionEq(
    &lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; =
    (Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;
  )
}
</code></pre>
<p>The next rule covers implied bounds for the projection. In particular,
the <code>Bounds</code> declared on the associated type must have been proven to hold
to show that the impl is well-formed, and hence we can rely on them
elsewhere.</p>
<pre><code class="language-text">// Rule Implied-Bound-From-AssocTy
//
// For each `Bound` in `Bounds`:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(&lt;Self as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt;&gt;: Bound) :-
      FromEnv(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WC1
}
</code></pre>
<p>Next, we define the requirements for an instantiation of our associated
type to be well-formed...</p>
<pre><code class="language-text">// Rule WellFormed-AssocTy
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    WellFormed((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;) :-
      Implemented(Self: Trait&lt;P1..Pn&gt;) &amp;&amp; WC1
}
</code></pre>
<p>...along with the reverse implications, when we can assume that it is
well-formed.</p>
<pre><code class="language-text">// Rule Implied-WC-From-AssocTy
//
// For each where clause WC1:
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(WC1) :- FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)
}
</code></pre>
<pre><code class="language-text">// Rule Implied-Trait-From-AssocTy
forall&lt;Self, P1..Pn, Pn+1..Pm&gt; {
    FromEnv(Self: Trait&lt;P1..Pn&gt;) :-
      FromEnv((Trait::AssocType)&lt;Self, P1..Pn, Pn+1..Pm&gt;)
}
</code></pre>
<h3><a class="header" href="#lowering-function-and-constant-declarations" id="lowering-function-and-constant-declarations">Lowering function and constant declarations</a></h3>
<p>Chalk didn't model functions and constants, but I would eventually like to
treat them exactly like normalization. See <a href="rustc-guide/traits/lowering-rules.html#constant-vals">the section on function/constant
values below</a> for more details.</p>
<h2><a class="header" href="#lowering-impls" id="lowering-impls">Lowering impls</a></h2>
<p>Given an impl of a trait:</p>
<pre><code class="language-rust ignore">impl&lt;P0..Pn&gt; Trait&lt;A1..An&gt; for A0
where WC
{
    // zero or more impl items
}
</code></pre>
<p>Let <code>TraitRef</code> be the trait reference <code>A0: Trait&lt;A1..An&gt;</code>. Then we
will create the following rules:</p>
<pre><code class="language-text">// Rule Implemented-From-Impl
forall&lt;P0..Pn&gt; {
  Implemented(TraitRef) :- WC
}
</code></pre>
<p>In addition, we will lower all of the <em>impl items</em>.</p>
<h2><a class="header" href="#lowering-impl-items" id="lowering-impl-items">Lowering impl items</a></h2>
<h3><a class="header" href="#associated-type-values" id="associated-type-values">Associated type values</a></h3>
<p>Given an impl that contains:</p>
<pre><code class="language-rust ignore">impl&lt;P0..Pn&gt; Trait&lt;P1..Pn&gt; for P0
where WC_impl
{
    type AssocType&lt;Pn+1..Pm&gt; = T;
}
</code></pre>
<p>and our where clause <code>WC1</code> on the trait associated type from above, we
produce the following rule:</p>
<pre><code class="language-text">// Rule Normalize-From-Impl
forall&lt;P0..Pm&gt; {
  forall&lt;Pn+1..Pm&gt; {
    Normalize(&lt;P0 as Trait&lt;P1..Pn&gt;&gt;::AssocType&lt;Pn+1..Pm&gt; -&gt; T) :-
      Implemented(P0 as Trait) &amp;&amp; WC1
  }
}
</code></pre>
<p>Note that <code>WC_impl</code> and <code>WC1</code> both encode where-clauses that the impl can
rely on. (<code>WC_impl</code> is not used here, because it is implied by
<code>Implemented(P0 as Trait)</code>.)</p>
<p><a name="constant-vals"></a></p>
<h3><a class="header" href="#function-and-constant-values" id="function-and-constant-values">Function and constant values</a></h3>
<p>Chalk didn't model functions and constants, but I would eventually
like to treat them exactly like normalization. This presumably
involves adding a new kind of parameter (constant), and then having a
<code>NormalizeValue</code> domain goal. This is <em>to be written</em> because the
details are a bit up in the air.</p>
<h1><a class="header" href="#well-formedness-checking" id="well-formedness-checking">Well-formedness checking</a></h1>
<p>WF checking has the job of checking that the various declarations in a Rust
program are well-formed. This is the basis for implied bounds, and partly for
that reason, this checking can be surprisingly subtle! For example, we
have to be sure that each impl proves the WF conditions declared on
the trait.</p>
<p>For each declaration in a Rust program, we will generate a logical goal and try
to prove it using the lowered rules we described in the
<a href="rustc-guide/traits/./lowering-rules.html">lowering rules</a> chapter. If we are able to prove it, we
say that the construct is well-formed. If not, we report an error to the user.</p>
<p>Well-formedness checking happens in the <a href="https://github.com/rust-lang/chalk/blob/master/chalk-solve/src/wf.rs"><code>chalk/chalk-solve/src/wf.rs</code></a>
module in chalk. After you have read this chapter, you may find useful to see
an extended set of examples in the <a href="https://github.com/rust-lang/chalk/blob/master/src/test/wf.rs"><code>chalk/src/test/wf.rs</code></a> submodule.</p>
<p>The new-style WF checking has not been implemented in rustc yet.</p>
<p>We give here a complete reference of the generated goals for each Rust
declaration.</p>
<p>In addition to the notations introduced in the chapter about
lowering rules, we'll introduce another notation: when checking WF of a
declaration, we'll often have to prove that all types that appear are
well-formed, except type parameters that we always assume to be WF. Hence,
we'll use the following notation: for a type <code>SomeType&lt;...&gt;</code>, we define
<code>InputTypes(SomeType&lt;...&gt;)</code> to be the set of all non-parameter types appearing
in <code>SomeType&lt;...&gt;</code>, including <code>SomeType&lt;...&gt;</code> itself.</p>
<p>Examples:</p>
<ul>
<li><code>InputTypes((u32, f32)) = [u32, f32, (u32, f32)]</code></li>
<li><code>InputTypes(Box&lt;T&gt;) = [Box&lt;T&gt;]</code> (assuming that <code>T</code> is a type parameter)</li>
<li><code>InputTypes(Box&lt;Box&lt;T&gt;&gt;) = [Box&lt;T&gt;, Box&lt;Box&lt;T&gt;&gt;]</code></li>
</ul>
<p>We also extend the <code>InputTypes</code> notation to where clauses in the natural way.
So, for example <code>InputTypes(A0: Trait&lt;A1,...,An&gt;)</code> is the union of
<code>InputTypes(A0)</code>, <code>InputTypes(A1)</code>, ..., <code>InputTypes(An)</code>.</p>
<h1><a class="header" href="#type-definitions" id="type-definitions">Type definitions</a></h1>
<p>Given a general type definition:</p>
<pre><code class="language-rust ignore">struct Type&lt;P...&gt; where WC_type {
    field1: A1,
    ...
    fieldn: An,
}
</code></pre>
<p>we generate the following goal, which represents its well-formedness condition:</p>
<pre><code class="language-text">forall&lt;P...&gt; {
    if (FromEnv(WC_type)) {
        WellFormed(InputTypes(WC_type)) &amp;&amp;
            WellFormed(InputTypes(A1)) &amp;&amp;
            ...
            WellFormed(InputTypes(An))
    }
}
</code></pre>
<p>which in English states: assuming that the where clauses defined on the type
hold, prove that every type appearing in the type definition is well-formed.</p>
<p>Some examples:</p>
<pre><code class="language-rust ignore">struct OnlyClone&lt;T&gt; where T: Clone {
    clonable: T,
}
// The only types appearing are type parameters: we have nothing to check,
// the type definition is well-formed.
</code></pre>
<pre><code class="language-rust ignore">struct Foo&lt;T&gt; where T: Clone {
    foo: OnlyClone&lt;T&gt;,
}
// The only non-parameter type which appears in this definition is
// `OnlyClone&lt;T&gt;`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Clone)) {
//          WellFormed(OnlyClone&lt;T&gt;)
//     }
// }
// ```
// which is provable.
</code></pre>
<pre><code class="language-rust ignore">struct Bar&lt;T&gt; where &lt;T as Iterator&gt;::Item: Debug {
    bar: i32,
}
// The only non-parameter types which appear in this definition are
// `&lt;T as Iterator&gt;::Item` and `i32`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(&lt;T as Iterator&gt;::Item: Debug)) {
//          WellFormed(&lt;T as Iterator&gt;::Item) &amp;&amp;
//               WellFormed(i32)
//     }
// }
// ```
// which is not provable since `WellFormed(&lt;T as Iterator&gt;::Item)` requires
// proving `Implemented(T: Iterator)`, and we are unable to prove that for an
// unknown `T`.
//
// Hence, this type definition is considered illegal. An additional
// `where T: Iterator` would make it legal.
</code></pre>
<h1><a class="header" href="#trait-definitions" id="trait-definitions">Trait definitions</a></h1>
<p>Given a general trait definition:</p>
<pre><code class="language-rust ignore">trait Trait&lt;P1...&gt; where WC_trait {
    type Assoc&lt;P2...&gt;: Bounds_assoc where WC_assoc;
}
</code></pre>
<p>we generate the following goal:</p>
<pre><code class="language-text">forall&lt;P1...&gt; {
    if (FromEnv(WC_trait)) {
        WellFormed(InputTypes(WC_trait)) &amp;&amp;

            forall&lt;P2...&gt; {
                if (FromEnv(WC_assoc)) {
                    WellFormed(InputTypes(Bounds_assoc)) &amp;&amp;
                        WellFormed(InputTypes(WC_assoc))
                }
            }
    }
}
</code></pre>
<p>There is not much to verify in a trait definition. We just want
to prove that the types appearing in the trait definition are well-formed,
under the assumption that the different where clauses hold.</p>
<p>Some examples:</p>
<pre><code class="language-rust ignore">trait Foo&lt;T&gt; where T: Iterator, &lt;T as Iterator&gt;::Item: Debug {
    ...
}
// The only non-parameter type which appears in this definition is
// `&lt;T as Iterator&gt;::Item`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Iterator), FromEnv(&lt;T as Iterator&gt;::Item: Debug)) {
//         WellFormed(&lt;T as Iterator&gt;::Item)
//     }
// }
// ```
// which is provable thanks to the `FromEnv(T: Iterator)` assumption.
</code></pre>
<pre><code class="language-rust ignore">trait Bar {
    type Assoc&lt;T&gt;: From&lt;&lt;T as Iterator&gt;::Item&gt;;
}
// The only non-parameter type which appears in this definition is
// `&lt;T as Iterator&gt;::Item`. The generated goal is the following:
// ```
// forall&lt;T&gt; {
//     WellFormed(&lt;T as Iterator&gt;::Item)
// }
// ```
// which is not provable, hence the trait definition is considered illegal.
</code></pre>
<pre><code class="language-rust ignore">trait Baz {
    type Assoc&lt;T&gt;: From&lt;&lt;T as Iterator&gt;::Item&gt; where T: Iterator;
}
// The generated goal is now:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Iterator)) {
//         WellFormed(&lt;T as Iterator&gt;::Item)
//     }
// }
// ```
// which is now provable.
</code></pre>
<h1><a class="header" href="#impls" id="impls">Impls</a></h1>
<p>Now we give ourselves a general impl for the trait defined above:</p>
<pre><code class="language-rust ignore">impl&lt;P1...&gt; Trait&lt;A1...&gt; for SomeType&lt;A2...&gt; where WC_impl {
    type Assoc&lt;P2...&gt; = SomeValue&lt;A3...&gt; where WC_assoc;
}
</code></pre>
<p>Note that here, <code>WC_assoc</code> are the same where clauses as those defined on the
associated type definition in the trait declaration, <em>except</em> that type
parameters from the trait are substituted with values provided by the impl
(see example below). You cannot add new where clauses. You may omit to write
the where clauses if you want to emphasize the fact that you are actually not
relying on them.</p>
<p>Some examples to illustrate that:</p>
<pre><code class="language-rust ignore">trait Foo&lt;T&gt; {
    type Assoc where T: Clone;
}

struct OnlyClone&lt;T: Clone&gt; { ... }

impl&lt;U&gt; Foo&lt;Option&lt;U&gt;&gt; for () {
    // We substitute type parameters from the trait by the ones provided
    // by the impl, that is instead of having a `T: Clone` where clause,
    // we have an `Option&lt;U&gt;: Clone` one.
    type Assoc = OnlyClone&lt;Option&lt;U&gt;&gt; where Option&lt;U&gt;: Clone;
}

impl&lt;T&gt; Foo&lt;T&gt; for i32 {
    // I'm not using the `T: Clone` where clause from the trait, so I can
    // omit it.
    type Assoc = u32;
}

impl&lt;T&gt; Foo&lt;T&gt; for f32 {
    type Assoc = OnlyClone&lt;Option&lt;T&gt;&gt; where Option&lt;T&gt;: Clone;
    //                                ^^^^^^^^^^^^^^^^^^^^^^
    //                                this where clause does not exist
    //                                on the original trait decl: illegal
}
</code></pre>
<blockquote>
<p>So in Rust, where clauses on associated types work <em>exactly</em> like where
clauses on trait methods: in an impl, we must substitute the parameters from
the traits with values provided by the impl, we may omit them if we don't
need them, but we cannot add new where clauses.</p>
</blockquote>
<p>Now let's see the generated goal for this general impl:</p>
<pre><code class="language-text">forall&lt;P1...&gt; {
    // Well-formedness of types appearing in the impl
    if (FromEnv(WC_impl), FromEnv(InputTypes(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;))) {
        WellFormed(InputTypes(WC_impl)) &amp;&amp;

            forall&lt;P2...&gt; {
                if (FromEnv(WC_assoc)) {
                        WellFormed(InputTypes(SomeValue&lt;A3...&gt;))
                }
            }
    }

    // Implied bounds checking
    if (FromEnv(WC_impl), FromEnv(InputTypes(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;))) {
        WellFormed(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;) &amp;&amp;

            forall&lt;P2...&gt; {
                if (FromEnv(WC_assoc)) {
                    WellFormed(SomeValue&lt;A3...&gt;: Bounds_assoc)
                }
            }
    }
}
</code></pre>
<p>Here is the most complex goal. As always, first, assuming that
the various where clauses hold, we prove that every type appearing in the impl
is well-formed, <em><strong>except</strong></em> types appearing in the impl header
<code>SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;</code>. Instead, we <em>assume</em> that those types are
well-formed
(hence the <code>if (FromEnv(InputTypes(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;)))</code>
conditions). This is
part of the implied bounds proposal, so that we can rely on the bounds
written on the definition of e.g. the <code>SomeType&lt;A2...&gt;</code> type (and that we don't
need to repeat those bounds).</p>
<blockquote>
<p>Note that we don't need to check well-formedness of types appearing in
<code>WC_assoc</code> because we already did that in the trait decl (they are just
repeated with some substitutions of values which we already assume to be
well-formed)</p>
</blockquote>
<p>Next, still assuming that the where clauses on the impl <code>WC_impl</code> hold and that
the input types of <code>SomeType&lt;A2...&gt;</code> are well-formed, we prove that
<code>WellFormed(SomeType&lt;A2...&gt;: Trait&lt;A1...&gt;)</code> hold. That is, we want to prove
that <code>SomeType&lt;A2...&gt;</code> verify all the where clauses that might transitively
be required by the <code>Trait</code> definition (see
<a href="rustc-guide/traits/./implied-bounds.html#co-inductiveness-of-wellformed">this subsection</a>).</p>
<p>Lastly, assuming in addition that the where clauses on the associated type
<code>WC_assoc</code> hold,
we prove that <code>WellFormed(SomeValue&lt;A3...&gt;: Bounds_assoc)</code> hold. Again, we are
not only proving <code>Implemented(SomeValue&lt;A3...&gt;: Bounds_assoc)</code>, but also
all the facts that might transitively come from <code>Bounds_assoc</code>. We must do this
because we allow the use of implied bounds on associated types: if we have
<code>FromEnv(SomeType: Trait)</code> in our environment, the lowering rules
chapter indicates that we are able to deduce
<code>FromEnv(&lt;SomeType as Trait&gt;::Assoc: Bounds_assoc)</code> without knowing what the
precise value of <code>&lt;SomeType as Trait&gt;::Assoc</code> is.</p>
<p>Some examples for the generated goal:</p>
<pre><code class="language-rust ignore">// Trait Program Clauses

// These are program clauses that come from the trait definitions below
// and that the trait solver can use for its reasonings. I'm just restating
// them here so that we have them in mind.

trait Copy { }
// This is a program clause that comes from the trait definition above
// and that the trait solver can use for its reasonings. I'm just restating
// it here (and also the few other ones coming just after) so that we have
// them in mind.
// `WellFormed(Self: Copy) :- Implemented(Self: Copy).`

trait Partial where Self: Copy { }
// ```
// WellFormed(Self: Partial) :-
//     Implemented(Self: Partial) &amp;&amp;
//     WellFormed(Self: Copy).
// ```

trait Complete where Self: Partial { }
// ```
// WellFormed(Self: Complete) :-
//     Implemented(Self: Complete) &amp;&amp;
//     WellFormed(Self: Partial).
// ```

// Impl WF Goals

impl&lt;T&gt; Partial for T where T: Complete { }
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Complete)) {
//         WellFormed(T: Partial)
//     }
// }
// ```
// Then proving `WellFormed(T: Partial)` amounts to proving
// `Implemented(T: Partial)` and `Implemented(T: Copy)`.
// Both those facts can be deduced from the `FromEnv(T: Complete)` in our
// environment: this impl is legal.

impl&lt;T&gt; Complete for T { }
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     WellFormed(T: Complete)
// }
// ```
// Then proving `WellFormed(T: Complete)` amounts to proving
// `Implemented(T: Complete)`, `Implemented(T: Partial)` and
// `Implemented(T: Copy)`.
//
// `Implemented(T: Complete)` can be proved thanks to the
// `impl&lt;T&gt; Complete for T` blanket impl.
//
// `Implemented(T: Partial)` can be proved thanks to the
// `impl&lt;T&gt; Partial for T where T: Complete` impl and because we know
// `T: Complete` holds.

// However, `Implemented(T: Copy)` cannot be proved: the impl is illegal.
// An additional `where T: Copy` bound would be sufficient to make that impl
// legal.
</code></pre>
<pre><code class="language-rust ignore">trait Bar { }

impl&lt;T&gt; Bar for T where &lt;T as Iterator&gt;::Item: Bar { }
// We have a non-parameter type appearing in the where clauses:
// `&lt;T as Iterator&gt;::Item`. The generated goal is:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(&lt;T as Iterator&gt;::Item: Bar)) {
//         WellFormed(T: Bar) &amp;&amp;
//             WellFormed(&lt;T as Iterator&gt;::Item: Bar)
//     }
// }
// ```
// And `WellFormed(&lt;T as Iterator&gt;::Item: Bar)` is not provable: we'd need
// an additional `where T: Iterator` for example.
</code></pre>
<pre><code class="language-rust ignore">trait Foo { }

trait Bar {
    type Item: Foo;
}

struct Stuff&lt;T&gt; { }

impl&lt;T&gt; Bar for Stuff&lt;T&gt; where T: Foo {
    type Item = T;
}
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     if (FromEnv(T: Foo)) {
//         WellFormed(T: Foo).
//     }
// }
// ```
// which is provable.
</code></pre>
<pre><code class="language-rust ignore">trait Debug { ... }
// `WellFormed(Self: Debug) :- Implemented(Self: Debug).`

struct Box&lt;T&gt; { ... }
impl&lt;T&gt; Debug for Box&lt;T&gt; where T: Debug { ... }

trait PointerFamily {
    type Pointer&lt;T&gt;: Debug where T: Debug;
}
// `WellFormed(Self: PointerFamily) :- Implemented(Self: PointerFamily).`

struct BoxFamily;

impl PointerFamily for BoxFamily {
    type Pointer&lt;T&gt; = Box&lt;T&gt; where T: Debug;
}
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     WellFormed(BoxFamily: PointerFamily) &amp;&amp;
//
//     if (FromEnv(T: Debug)) {
//         WellFormed(Box&lt;T&gt;: Debug) &amp;&amp;
//             WellFormed(Box&lt;T&gt;)
//     }
// }
// ```
// `WellFormed(BoxFamily: PointerFamily)` amounts to proving
// `Implemented(BoxFamily: PointerFamily)`, which is ok thanks to our impl.
//
// `WellFormed(Box&lt;T&gt;)` is always true (there are no where clauses on the
// `Box` type definition).
//
// Moreover, we have an `impl&lt;T: Debug&gt; Debug for Box&lt;T&gt;`, hence
// we can prove `WellFormed(Box&lt;T&gt;: Debug)` and the impl is indeed legal.
</code></pre>
<pre><code class="language-rust ignore">trait Foo {
    type Assoc&lt;T&gt;;
}

struct OnlyClone&lt;T: Clone&gt; { ... }

impl Foo for i32 {
    type Assoc&lt;T&gt; = OnlyClone&lt;T&gt;;
}
// The generated goal is:
// ```
// forall&lt;T&gt; {
//     WellFormed(i32: Foo) &amp;&amp;
//        WellFormed(OnlyClone&lt;T&gt;)
// }
// ```
// however `WellFormed(OnlyClone&lt;T&gt;)` is not provable because it requires
// `Implemented(T: Clone)`. It would be tempting to just add a `where T: Clone`
// bound inside the `impl Foo for i32` block, however we saw that it was
// illegal to add where clauses that didn't come from the trait definition.
</code></pre>
<h1><a class="header" href="#canonical-queries" id="canonical-queries">Canonical queries</a></h1>
<p>The &quot;start&quot; of the trait system is the <strong>canonical query</strong> (these are
both queries in the more general sense of the word – something you
would like to know the answer to – and in the
<a href="rustc-guide/traits/../query.html">rustc-specific sense</a>).  The idea is that the type
checker or other parts of the system, may in the course of doing their
thing want to know whether some trait is implemented for some type
(e.g., is <code>u32: Debug</code> true?). Or they may want to
<a href="rustc-guide/traits/./associated-types.html">normalize some associated type</a>.</p>
<p>This section covers queries at a fairly high level of abstraction. The
subsections look a bit more closely at how these ideas are implemented
in rustc.</p>
<h2><a class="header" href="#the-traditional-interactive-prolog-query" id="the-traditional-interactive-prolog-query">The traditional, interactive Prolog query</a></h2>
<p>In a traditional Prolog system, when you start a query, the solver
will run off and start supplying you with every possible answer it can
find. So given something like this:</p>
<pre><code class="language-text">?- Vec&lt;i32&gt;: AsRef&lt;?U&gt;
</code></pre>
<p>The solver might answer:</p>
<pre><code class="language-text">Vec&lt;i32&gt;: AsRef&lt;[i32]&gt;
    continue? (y/n)
</code></pre>
<p>This <code>continue</code> bit is interesting. The idea in Prolog is that the
solver is finding <strong>all possible</strong> instantiations of your query that
are true. In this case, if we instantiate <code>?U = [i32]</code>, then the query
is true (note that a traditional Prolog interface does not, directly,
tell us a value for <code>?U</code>, but we can infer one by unifying the
response with our original query – Rust's solver gives back a
substitution instead). If we were to hit <code>y</code>, the solver might then
give us another possible answer:</p>
<pre><code class="language-text">Vec&lt;i32&gt;: AsRef&lt;Vec&lt;i32&gt;&gt;
    continue? (y/n)
</code></pre>
<p>This answer derives from the fact that there is a reflexive impl
(<code>impl&lt;T&gt; AsRef&lt;T&gt; for T</code>) for <code>AsRef</code>. If were to hit <code>y</code> again,
then we might get back a negative response:</p>
<pre><code class="language-text">no
</code></pre>
<p>Naturally, in some cases, there may be no possible answers, and hence
the solver will just give me back <code>no</code> right away:</p>
<pre><code class="language-text">?- Box&lt;i32&gt;: Copy
    no
</code></pre>
<p>In some cases, there might be an infinite number of responses. So for
example if I gave this query, and I kept hitting <code>y</code>, then the solver
would never stop giving me back answers:</p>
<pre><code class="language-text">?- Vec&lt;?U&gt;: Clone
    Vec&lt;i32&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;i32&gt;&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;: Clone
        continue? (y/n)
    Vec&lt;Box&lt;Box&lt;Box&lt;i32&gt;&gt;&gt;&gt;: Clone
        continue? (y/n)
</code></pre>
<p>As you can imagine, the solver will gleefully keep adding another
layer of <code>Box</code> until we ask it to stop, or it runs out of memory.</p>
<p>Another interesting thing is that queries might still have variables
in them. For example:</p>
<pre><code class="language-text">?- Rc&lt;?T&gt;: Clone
</code></pre>
<p>might produce the answer:</p>
<pre><code class="language-text">Rc&lt;?T&gt;: Clone
    continue? (y/n)
</code></pre>
<p>After all, <code>Rc&lt;?T&gt;</code> is true <strong>no matter what type <code>?T</code> is</strong>.</p>
<p><a name="query-response"></a></p>
<h2><a class="header" href="#a-trait-query-in-rustc" id="a-trait-query-in-rustc">A trait query in rustc</a></h2>
<p>The trait queries in rustc work somewhat differently. Instead of
trying to enumerate <strong>all possible</strong> answers for you, they are looking
for an <strong>unambiguous</strong> answer. In particular, when they tell you the
value for a type variable, that means that this is the <strong>only possible
instantiation</strong> that you could use, given the current set of impls and
where-clauses, that would be provable. (Internally within the solver,
though, they can potentially enumerate all possible answers. See
<a href="rustc-guide/traits/./slg.html">the description of the SLG solver</a> for details.)</p>
<p>The response to a trait query in rustc is typically a
<code>Result&lt;QueryResult&lt;T&gt;, NoSolution&gt;</code> (where the <code>T</code> will vary a bit
depending on the query itself). The <code>Err(NoSolution)</code> case indicates
that the query was false and had no answers (e.g., <code>Box&lt;i32&gt;: Copy</code>).
Otherwise, the <code>QueryResult</code> gives back information about the possible answer(s)
we did find. It consists of four parts:</p>
<ul>
<li><strong>Certainty:</strong> tells you how sure we are of this answer. It can have two
values:
<ul>
<li><code>Proven</code> means that the result is known to be true.
<ul>
<li>This might be the result for trying to prove <code>Vec&lt;i32&gt;: Clone</code>,
say, or <code>Rc&lt;?T&gt;: Clone</code>.</li>
</ul>
</li>
<li><code>Ambiguous</code> means that there were things we could not yet prove to
be either true <em>or</em> false, typically because more type information
was needed. (We'll see an example shortly.)
<ul>
<li>This might be the result for trying to prove <code>Vec&lt;?T&gt;: Clone</code>.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Var values:</strong> Values for each of the unbound inference variables
(like <code>?T</code>) that appeared in your original query. (Remember that in Prolog,
we had to infer these.)
<ul>
<li>As we'll see in the example below, we can get back var values even
for <code>Ambiguous</code> cases.</li>
</ul>
</li>
<li><strong>Region constraints:</strong> these are relations that must hold between
the lifetimes that you supplied as inputs. We'll ignore these here,
but see the
<a href="rustc-guide/traits/./regions.html">section on handling regions in traits</a> for
more details.</li>
<li><strong>Value:</strong> The query result also comes with a value of type <code>T</code>. For
some specialized queries – like normalizing associated types –
this is used to carry back an extra result, but it's often just
<code>()</code>.</li>
</ul>
<h3><a class="header" href="#examples" id="examples">Examples</a></h3>
<p>Let's work through an example query to see what all the parts mean.
Consider <a href="https://doc.rust-lang.org/std/borrow/trait.Borrow.html">the <code>Borrow</code> trait</a>. This trait has a number of
impls; among them, there are these two (for clarity, I've written the
<code>Sized</code> bounds explicitly):</p>
<pre><code class="language-rust ignore">impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized
impl&lt;T&gt; Borrow&lt;[T]&gt; for Vec&lt;T&gt; where T: Sized
</code></pre>
<p><strong>Example 1.</strong> Imagine we are type-checking this (rather artificial)
bit of code:</p>
<pre><code class="language-rust ignore">fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }

fn main() {
    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;
    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;
    foo(t, u); // Example 1: requires `Vec&lt;?T&gt;: Borrow&lt;?U&gt;`
    ...
}
</code></pre>
<p>As the comments indicate, we first create two variables <code>t</code> and <code>u</code>;
<code>t</code> is an empty vector and <code>u</code> is a <code>None</code> option. Both of these
variables have unbound inference variables in their type: <code>?T</code>
represents the elements in the vector <code>t</code> and <code>?U</code> represents the
value stored in the option <code>u</code>.  Next, we invoke <code>foo</code>; comparing the
signature of <code>foo</code> to its arguments, we wind up with <code>A = Vec&lt;?T&gt;</code> and
<code>B = ?U</code>. Therefore, the where clause on <code>foo</code> requires that <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>. This is thus our first example trait query.</p>
<p>There are many possible solutions to the query <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>;
for example:</p>
<ul>
<li><code>?U = Vec&lt;?T&gt;</code>,</li>
<li><code>?U = [?T]</code>,</li>
<li><code>?T = u32, ?U = [u32]</code></li>
<li>and so forth.</li>
</ul>
<p>Therefore, the result we get back would be as follows (I'm going to
ignore region constraints and the &quot;value&quot;):</p>
<ul>
<li>Certainty: <code>Ambiguous</code> – we're not sure yet if this holds</li>
<li>Var values: <code>[?T = ?T, ?U = ?U]</code> – we learned nothing about the values of
the variables</li>
</ul>
<p>In short, the query result says that it is too soon to say much about
whether this trait is proven. During type-checking, this is not an
immediate error: instead, the type checker would hold on to this
requirement (<code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>) and wait. As we'll see in the next
example, it may happen that <code>?T</code> and <code>?U</code> wind up constrained from
other sources, in which case we can try the trait query again.</p>
<p><strong>Example 2.</strong> We can now extend our previous example a bit,
and assign a value to <code>u</code>:</p>
<pre><code class="language-rust ignore">fn foo&lt;A, B&gt;(a: A, vec_b: Option&lt;B&gt;) where A: Borrow&lt;B&gt; { }

fn main() {
    // What we saw before:
    let mut t: Vec&lt;_&gt; = vec![]; // Type: Vec&lt;?T&gt;
    let mut u: Option&lt;_&gt; = None; // Type: Option&lt;?U&gt;
    foo(t, u); // `Vec&lt;?T&gt;: Borrow&lt;?U&gt;` =&gt; ambiguous

    // New stuff:
    u = Some(vec![]); // ?U = Vec&lt;?V&gt;
}
</code></pre>
<p>As a result of this assignment, the type of <code>u</code> is forced to be
<code>Option&lt;Vec&lt;?V&gt;&gt;</code>, where <code>?V</code> represents the element type of the
vector. This in turn implies that <code>?U</code> is <a href="rustc-guide/traits/../type-checking.html">unified</a> to <code>Vec&lt;?V&gt;</code>.</p>
<p>Let's suppose that the type checker decides to revisit the
&quot;as-yet-unproven&quot; trait obligation we saw before, <code>Vec&lt;?T&gt;: Borrow&lt;?U&gt;</code>. <code>?U</code> is no longer an unbound inference variable; it now
has a value, <code>Vec&lt;?V&gt;</code>. So, if we &quot;refresh&quot; the query with that value, we get:</p>
<pre><code class="language-text">Vec&lt;?T&gt;: Borrow&lt;Vec&lt;?V&gt;&gt;
</code></pre>
<p>This time, there is only one impl that applies, the reflexive impl:</p>
<pre><code class="language-text">impl&lt;T&gt; Borrow&lt;T&gt; for T where T: ?Sized
</code></pre>
<p>Therefore, the trait checker will answer:</p>
<ul>
<li>Certainty: <code>Proven</code></li>
<li>Var values: <code>[?T = ?T, ?V = ?T]</code></li>
</ul>
<p>Here, it is saying that we have indeed proven that the obligation
holds, and we also know that <code>?T</code> and <code>?V</code> are the same type (but we
don't know what that type is yet!).</p>
<p>(In fact, as the function ends here, the type checker would give an
error at this point, since the element types of <code>t</code> and <code>u</code> are still
not yet known, even though they are known to be the same.)</p>
<h1><a class="header" href="#canonicalization" id="canonicalization">Canonicalization</a></h1>
<p>Canonicalization is the process of <strong>isolating</strong> an inference value
from its context. It is a key part of implementing
<a href="rustc-guide/traits/./canonical-queries.html">canonical queries</a>, and you may wish to read the parent chapter
to get more context.</p>
<p>Canonicalization is really based on a very simple concept: every
<a href="rustc-guide/traits/../type-inference.html#vars">inference variable</a> is always in one of
two states: either it is <strong>unbound</strong>, in which case we don't know yet
what type it is, or it is <strong>bound</strong>, in which case we do. So to
isolate some data-structure T that contains types/regions from its
environment, we just walk down and find the unbound variables that
appear in T; those variables get replaced with &quot;canonical variables&quot;,
starting from zero and numbered in a fixed order (left to right, for
the most part, but really it doesn't matter as long as it is
consistent).</p>
<p>So, for example, if we have the type <code>X = (?T, ?U)</code>, where <code>?T</code> and
<code>?U</code> are distinct, unbound inference variables, then the canonical
form of <code>X</code> would be <code>(?0, ?1)</code>, where <code>?0</code> and <code>?1</code> represent these
<strong>canonical placeholders</strong>. Note that the type <code>Y = (?U, ?T)</code> also
canonicalizes to <code>(?0, ?1)</code>. But the type <code>Z = (?T, ?T)</code> would
canonicalize to <code>(?0, ?0)</code> (as would <code>(?U, ?U)</code>). In other words, the
exact identity of the inference variables is not important – unless
they are repeated.</p>
<p>We use this to improve caching as well as to detect cycles and other
things during trait resolution. Roughly speaking, the idea is that if
two trait queries have the same canonical form, then they will get
the same answer. That answer will be expressed in terms of the
canonical variables (<code>?0</code>, <code>?1</code>), which we can then map back to the
original variables (<code>?T</code>, <code>?U</code>).</p>
<h2><a class="header" href="#canonicalizing-the-query" id="canonicalizing-the-query">Canonicalizing the query</a></h2>
<p>To see how it works, imagine that we are asking to solve the following
trait query: <code>?A: Foo&lt;'static, ?B&gt;</code>, where <code>?A</code> and <code>?B</code> are unbound.
This query contains two unbound variables, but it also contains the
lifetime <code>'static</code>. The trait system generally ignores all lifetimes
and treats them equally, so when canonicalizing, we will <em>also</em>
replace any <a href="rustc-guide/traits/../appendix/background.html#free-vs-bound">free lifetime</a> with a
canonical variable (Note that <code>'static</code> is actually a <em>free</em> lifetime 
variable here. We are not considering it in the typing context of the whole 
program but only in the context of this trait reference. Mathematically, we
are not quantifying over the whole program, but only this obligation).
Therefore, we get the following result:</p>
<pre><code class="language-text">?0: Foo&lt;'?1, ?2&gt;
</code></pre>
<p>Sometimes we write this differently, like so:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>This <code>for&lt;&gt;</code> gives some information about each of the canonical
variables within.  In this case, each <code>T</code> indicates a type variable,
so <code>?0</code> and <code>?2</code> are types; the <code>L</code> indicates a lifetime variable, so
<code>?1</code> is a lifetime. The <code>canonicalize</code> method <em>also</em> gives back a
<code>CanonicalVarValues</code> array OV with the &quot;original values&quot; for each
canonicalized variable:</p>
<pre><code class="language-text">[?A, 'static, ?B]
</code></pre>
<p>We'll need this vector OV later, when we process the query response.</p>
<h2><a class="header" href="#executing-the-query" id="executing-the-query">Executing the query</a></h2>
<p>Once we've constructed the canonical query, we can try to solve it.
To do so, we will wind up creating a fresh inference context and
<strong>instantiating</strong> the canonical query in that context. The idea is that
we create a substitution S from the canonical form containing a fresh
inference variable (of suitable kind) for each canonical variable.
So, for our example query:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>the substitution S might be:</p>
<pre><code class="language-text">S = [?A, '?B, ?C]
</code></pre>
<p>We can then replace the bound canonical variables (<code>?0</code>, etc) with
these inference variables, yielding the following fully instantiated
query:</p>
<pre><code class="language-text">?A: Foo&lt;'?B, ?C&gt;
</code></pre>
<p>Remember that substitution S though! We're going to need it later.</p>
<p>OK, now that we have a fresh inference context and an instantiated
query, we can go ahead and try to solve it. The trait solver itself is
explained in more detail in <a href="rustc-guide/traits/./slg.html">another section</a>, but
suffice to say that it will compute a <a href="rustc-guide/traits/./canonical-queries.html#query-response">certainty value</a> (<code>Proven</code> or
<code>Ambiguous</code>) and have side-effects on the inference variables we've
created. For example, if there were only one impl of <code>Foo</code>, like so:</p>
<pre><code class="language-rust ignore">impl&lt;'a, X&gt; Foo&lt;'a, X&gt; for Vec&lt;X&gt;
where X: 'a
{ ... }
</code></pre>
<p>then we might wind up with a certainty value of <code>Proven</code>, as well as
creating fresh inference variables <code>'?D</code> and <code>?E</code> (to represent the
parameters on the impl) and unifying as follows:</p>
<ul>
<li><code>'?B = '?D</code></li>
<li><code>?A = Vec&lt;?E&gt;</code></li>
<li><code>?C = ?E</code></li>
</ul>
<p>We would also accumulate the region constraint <code>?E: '?D</code>, due to the
where clause.</p>
<p>In order to create our final query result, we have to &quot;lift&quot; these
values out of the query's inference context and into something that
can be reapplied in our original inference context. We do that by
<strong>re-applying canonicalization</strong>, but to the <strong>query result</strong>.</p>
<h2><a class="header" href="#canonicalizing-the-query-result" id="canonicalizing-the-query-result">Canonicalizing the query result</a></h2>
<p>As discussed in <a href="rustc-guide/traits/./canonical-queries.html#query-response">the parent section</a>, most trait queries wind up
with a result that brings together a &quot;certainty value&quot; <code>certainty</code>, a
result substitution <code>var_values</code>, and some region constraints. To
create this, we wind up re-using the substitution S that we created
when first instantiating our query. To refresh your memory, we had a query</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>for which we made a substutition S:</p>
<pre><code class="language-text">S = [?A, '?B, ?C]
</code></pre>
<p>We then did some work which unified some of those variables with other things.
If we &quot;refresh&quot; S with the latest results, we get:</p>
<pre><code class="language-text">S = [Vec&lt;?E&gt;, '?D, ?E]
</code></pre>
<p>These are precisely the new values for the three input variables from
our original query. Note though that they include some new variables
(like <code>?E</code>). We can make those go away by canonicalizing again! We don't
just canonicalize S, though, we canonicalize the whole query response QR:</p>
<pre><code class="language-text">QR = {
    certainty: Proven,             // or whatever
    var_values: [Vec&lt;?E&gt;, '?D, ?E] // this is S
    region_constraints: [?E: '?D], // from the impl
    value: (),                     // for our purposes, just (), but
                                   // in some cases this might have
                                   // a type or other info
}
</code></pre>
<p>The result would be as follows:</p>
<pre><code class="language-text">Canonical(QR) = for&lt;T, L&gt; {
    certainty: Proven,
    var_values: [Vec&lt;?0&gt;, '?1, ?0]
    region_constraints: [?0: '?1],
    value: (),
}
</code></pre>
<p>(One subtle point: when we canonicalize the query <strong>result</strong>, we do not
use any special treatment for free lifetimes. Note that both
references to <code>'?D</code>, for example, were converted into the same
canonical variable (<code>?1</code>). This is in contrast to the original query,
where we canonicalized every free lifetime into a fresh canonical
variable.)</p>
<p>Now, this result must be reapplied in each context where needed.</p>
<h2><a class="header" href="#processing-the-canonicalized-query-result" id="processing-the-canonicalized-query-result">Processing the canonicalized query result</a></h2>
<p>In the previous section we produced a canonical query result. We now have
to apply that result in our original context. If you recall, way back in the
beginning, we were trying to prove this query:</p>
<pre><code class="language-text">?A: Foo&lt;'static, ?B&gt;
</code></pre>
<p>We canonicalized that into this:</p>
<pre><code class="language-text">for&lt;T,L,T&gt; { ?0: Foo&lt;'?1, ?2&gt; }
</code></pre>
<p>and now we got back a canonical response:</p>
<pre><code class="language-text">for&lt;T, L&gt; {
    certainty: Proven,
    var_values: [Vec&lt;?0&gt;, '?1, ?0]
    region_constraints: [?0: '?1],
    value: (),
}
</code></pre>
<p>We now want to apply that response to our context. Conceptually, how
we do that is to (a) instantiate each of the canonical variables in
the result with a fresh inference variable, (b) unify the values in
the result with the original values, and then (c) record the region
constraints for later. Doing step (a) would yield a result of</p>
<pre><code class="language-text">{
      certainty: Proven,
      var_values: [Vec&lt;?C&gt;, '?D, ?C]
                       ^^   ^^^ fresh inference variables
      region_constraints: [?C: '?D],
      value: (),
}
</code></pre>
<p>Step (b) would then unify:</p>
<pre><code class="language-text">?A with Vec&lt;?C&gt;
'static with '?D
?B with ?C
</code></pre>
<p>And finally the region constraint of <code>?C: 'static</code> would be recorded
for later verification.</p>
<p>(What we <em>actually</em> do is a mildly optimized variant of that: Rather
than eagerly instantiating all of the canonical values in the result
with variables, we instead walk the vector of values, looking for
cases where the value is just a canonical variable. In our example,
<code>values[2]</code> is <code>?C</code>, so that means we can deduce that <code>?C := ?B</code> and
<code>'?D := 'static</code>. This gives us a partial set of values. Anything for
which we do not find a value, we create an inference variable.)</p>
<h1><a class="header" href="#the-on-demand-slg-solver" id="the-on-demand-slg-solver">The On-Demand SLG solver</a></h1>
<p>Given a set of program clauses (provided by our <a href="rustc-guide/traits/./lowering-rules.html">lowering rules</a>)
and a query, we need to return the result of the query and the value of any
type variables we can determine. This is the job of the solver.</p>
<p>For example, <code>exists&lt;T&gt; { Vec&lt;T&gt;: FromIterator&lt;u32&gt; }</code> has one solution, so
its result is <code>Unique; substitution [?T := u32]</code>. A solution also comes with
a set of region constraints, which we'll ignore in this introduction.</p>
<h2><a class="header" href="#goals-of-the-solver" id="goals-of-the-solver">Goals of the Solver</a></h2>
<h3><a class="header" href="#on-demand" id="on-demand">On demand</a></h3>
<p>There are often many, or even infinitely many, solutions to a query. For
example, say we want to prove that <code>exists&lt;T&gt; { Vec&lt;T&gt;: Debug }</code> for <em>some</em>
type <code>?T</code>. Our solver should be capable of yielding one answer at a time, say
<code>?T = u32</code>, then <code>?T = i32</code>, and so on, rather than iterating over every type
in the type system. If we need more answers, we can request more until we are
done. This is similar to how Prolog works.</p>
<p><em>See also: <a href="rustc-guide/traits/./canonical-queries.html#the-traditional-interactive-prolog-query">The traditional, interactive Prolog query</a></em></p>
<h3><a class="header" href="#breadth-first" id="breadth-first">Breadth-first</a></h3>
<p><code>Vec&lt;?T&gt;: Debug</code> is true if <code>?T: Debug</code>. This leads to a cycle: <code>[Vec&lt;u32&gt;, Vec&lt;Vec&lt;u32&gt;&gt;, Vec&lt;Vec&lt;Vec&lt;u32&gt;&gt;&gt;]</code>, and so on all implement <code>Debug</code>. Our
solver ought to be breadth first and consider answers like <code>[Vec&lt;u32&gt;: Debug, Vec&lt;i32&gt;: Debug, ...]</code> before it recurses, or we may never find the answer
we're looking for.</p>
<h3><a class="header" href="#cachable" id="cachable">Cachable</a></h3>
<p>To speed up compilation, we need to cache results, including partial results
left over from past solver queries.</p>
<h2><a class="header" href="#description-of-how-it-works" id="description-of-how-it-works">Description of how it works</a></h2>
<p>The basis of the solver is the <a href="https://rust-lang.github.io/chalk/doc/chalk_engine/forest/struct.Forest.html"><code>Forest</code></a> type. A <em>forest</em> stores a
collection of <em>tables</em> as well as a <em>stack</em>. Each <em>table</em> represents
the stored results of a particular query that is being performed, as
well as the various <em>strands</em>, which are basically suspended
computations that may be used to find more answers. Tables are
interdependent: solving one query may require solving others.</p>
<h3><a class="header" href="#walkthrough" id="walkthrough">Walkthrough</a></h3>
<p>Perhaps the easiest way to explain how the solver works is to walk
through an example. Let's imagine that we have the following program:</p>
<pre><code class="language-rust ignore">trait Debug { }

struct u32 { }
impl Debug for u32 { }

struct Rc&lt;T&gt; { }
impl&lt;T: Debug&gt; Debug for Rc&lt;T&gt; { }

struct Vec&lt;T&gt; { }
impl&lt;T: Debug&gt; Debug for Vec&lt;T&gt; { }
</code></pre>
<p>Now imagine that we want to find answers for the query <code>exists&lt;T&gt; { Rc&lt;T&gt;: Debug }</code>. The first step would be to u-canonicalize this query; this is the
act of giving canonical names to all the unbound inference variables based on
the order of their left-most appearance, as well as canonicalizing the
universes of any universally bound names (e.g., the <code>T</code> in <code>forall&lt;T&gt; { ... }</code>). In this case, there are no universally bound names, but the canonical
form Q of the query might look something like:</p>
<pre><code class="language-text">Rc&lt;?0&gt;: Debug
</code></pre>
<p>where <code>?0</code> is a variable in the root universe U0. We would then go and
look for a table with this canonical query as the key: since the forest is
empty, this lookup will fail, and we will create a new table T0,
corresponding to the u-canonical goal Q.</p>
<p><strong>Ignoring negative reasoning and regions.</strong> To start, we'll ignore
the possibility of negative goals like <code>not { Foo }</code>. We'll phase them
in later, as they bring several complications.</p>
<p><strong>Creating a table.</strong> When we first create a table, we also initialize
it with a set of <em>initial strands</em>. A &quot;strand&quot; is kind of like a
&quot;thread&quot; for the solver: it contains a particular way to produce an
answer. The initial set of strands for a goal like <code>Rc&lt;?0&gt;: Debug</code>
(i.e., a &quot;domain goal&quot;) is determined by looking for <em>clauses</em> in the
environment. In Rust, these clauses derive from impls, but also from
where-clauses that are in scope. In the case of our example, there
would be three clauses, each coming from the program. Using a
Prolog-like notation, these look like:</p>
<pre><code class="language-text">(u32: Debug).
(Rc&lt;T&gt;: Debug) :- (T: Debug).
(Vec&lt;T&gt;: Debug) :- (T: Debug).
</code></pre>
<p>To create our initial strands, then, we will try to apply each of
these clauses to our goal of <code>Rc&lt;?0&gt;: Debug</code>. The first and third
clauses are inapplicable because <code>u32</code> and <code>Vec&lt;?0&gt;</code> cannot be unified
with <code>Rc&lt;?0&gt;</code>. The second clause, however, will work.</p>
<p><strong>What is a strand?</strong> Let's talk a bit more about what a strand <em>is</em>. In the code, a strand
is the combination of an inference table, an <em>X-clause</em>, and (possibly)
a selected subgoal from that X-clause. But what is an X-clause
(<a href="https://rust-lang.github.io/chalk/doc/chalk_engine/struct.ExClause.html"><code>ExClause</code></a>, in the code)? An X-clause pulls together a few things:</p>
<ul>
<li>The current state of the goal we are trying to prove;</li>
<li>A set of subgoals that have yet to be proven;</li>
<li>There are also a few things we're ignoring for now:
<ul>
<li>delayed literals, region constraints</li>
</ul>
</li>
</ul>
<p>The general form of an X-clause is written much like a Prolog clause,
but with somewhat different semantics. Since we're ignoring delayed
literals and region constraints, an X-clause just looks like this:</p>
<pre><code class="language-text">G :- L
</code></pre>
<p>where G is a goal and L is a set of subgoals that must be proven.
(The L stands for <em>literal</em> -- when we address negative reasoning, a
literal will be either a positive or negative subgoal.) The idea is
that if we are able to prove L then the goal G can be considered true.</p>
<p>In the case of our example, we would wind up creating one strand, with
an X-clause like so:</p>
<pre><code class="language-text">(Rc&lt;?T&gt;: Debug) :- (?T: Debug)
</code></pre>
<p>Here, the <code>?T</code> refers to one of the inference variables created in the
inference table that accompanies the strand. (I'll use named variables
to refer to inference variables, and numbered variables like <code>?0</code> to
refer to variables in a canonicalized goal; in the code, however, they
are both represented with an index.)</p>
<p>For each strand, we also optionally store a <em>selected subgoal</em>. This
is the subgoal after the turnstile (<code>:-</code>) that we are currently trying
to prove in this strand. Initially, when a strand is first created,
there is no selected subgoal.</p>
<p><strong>Activating a strand.</strong> Now that we have created the table T0 and
initialized it with strands, we have to actually try and produce an answer.
We do this by invoking the <a href="https://rust-lang.github.io/chalk/doc/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> operation on the table:
specifically, we say <code>ensure_root_answer(T0, A0)</code>, meaning &quot;ensure that there
is a 0th answer A0 to query T0&quot;.</p>
<p>Remember that tables store not only strands, but also a vector of cached
answers. The first thing that <a href="https://rust-lang.github.io/chalk/doc/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> does is to check whether
answer A0 is in this vector. If so, we can just return immediately. In this
case, the vector will be empty, and hence that does not apply (this becomes
important for cyclic checks later on).</p>
<p>When there is no cached answer, <a href="https://rust-lang.github.io/chalk/doc/chalk_engine/forest/struct.Forest.html#method.ensure_root_answer"><code>ensure_root_answer</code></a> will try to produce one.
It does this by selecting a strand from the set of active strands -- the
strands are stored in a <code>VecDeque</code> and hence processed in a round-robin
fashion. Right now, we have only one strand, storing the following X-clause
with no selected subgoal:</p>
<pre><code class="language-text">(Rc&lt;?T&gt;: Debug) :- (?T: Debug)
</code></pre>
<p>When we activate the strand, we see that we have no selected subgoal,
and so we first pick one of the subgoals to process. Here, there is only
one (<code>?T: Debug</code>), so that becomes the selected subgoal, changing
the state of the strand to:</p>
<pre><code class="language-text">(Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A0)
</code></pre>
<p>Here, we write <code>selected(L, An)</code> to indicate that (a) the literal <code>L</code>
is the selected subgoal and (b) which answer <code>An</code> we are looking for. We
start out looking for <code>A0</code>.</p>
<p><strong>Processing the selected subgoal.</strong> Next, we have to try and find an
answer to this selected goal. To do that, we will u-canonicalize it
and try to find an associated table. In this case, the u-canonical
form of the subgoal is <code>?0: Debug</code>: we don't have a table yet for
that, so we can create a new one, T1. As before, we'll initialize T1
with strands. In this case, there will be three strands, because all
the program clauses are potentially applicable. Those three strands
will be:</p>
<ul>
<li><code>(u32: Debug) :-</code>, derived from the program clause <code>(u32: Debug).</code>.
<ul>
<li>Note: This strand has no subgoals.</li>
</ul>
</li>
<li><code>(Vec&lt;?U&gt;: Debug) :- (?U: Debug)</code>, derived from the <code>Vec</code> impl.</li>
<li><code>(Rc&lt;?U&gt;: Debug) :- (?U: Debug)</code>, derived from the <code>Rc</code> impl.</li>
</ul>
<p>We can thus summarize the state of the whole forest at this point as
follows:</p>
<pre><code class="language-text">Table T0 [Rc&lt;?0&gt;: Debug]
  Strands:
    (Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A0)
  
Table T1 [?0: Debug]
  Strands:
    (u32: Debug) :-
    (Vec&lt;?U&gt;: Debug) :- (?U: Debug)
    (Rc&lt;?V&gt;: Debug) :- (?V: Debug)
</code></pre>
<p><strong>Delegation between tables.</strong> Now that the active strand from T0 has
created the table T1, it can try to extract an answer. It does this
via that same <code>ensure_answer</code> operation we saw before. In this case,
the strand would invoke <code>ensure_answer(T1, A0)</code>, since we will start
with the first answer. This will cause T1 to activate its first
strand, <code>u32: Debug :-</code>.</p>
<p>This strand is somewhat special: it has no subgoals at all. This means
that the goal is proven. We can therefore add <code>u32: Debug</code> to the set
of <em>answers</em> for our table, calling it answer A0 (it is the first
answer). The strand is then removed from the list of strands.</p>
<p>The state of table T1 is therefore:</p>
<pre><code class="language-text">Table T1 [?0: Debug]
  Answers:
    A0 = [?0 = u32]
  Strand:
    (Vec&lt;?U&gt;: Debug) :- (?U: Debug)
    (Rc&lt;?V&gt;: Debug) :- (?V: Debug)
</code></pre>
<p>Note that I am writing out the answer A0 as a substitution that can be
applied to the table goal; actually, in the code, the goals for each
X-clause are also represented as substitutions, but in this exposition
I've chosen to write them as full goals, following <a href="rustc-guide/traits/./bibliography.html#slg">NFTD</a>.</p>
<p>Since we now have an answer, <code>ensure_answer(T1, A0)</code> will return <code>Ok</code>
to the table T0, indicating that answer A0 is available. T0 now has
the job of incorporating that result into its active strand. It does
this in two ways. First, it creates a new strand that is looking for
the next possible answer of T1. Next, it incorpoates the answer from
A0 and removes the subgoal. The resulting state of table T0 is:</p>
<pre><code class="language-text">Table T0 [Rc&lt;?0&gt;: Debug]
  Strands:
    (Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A1)
    (Rc&lt;u32&gt;: Debug) :-
</code></pre>
<p>We then immediately activate the strand that incorporated the answer
(the <code>Rc&lt;u32&gt;: Debug</code> one). In this case, that strand has no further
subgoals, so it becomes an answer to the table T0. This answer can
then be returned up to our caller, and the whole forest goes quiescent
at this point (remember, we only do enough work to generate <em>one</em>
answer). The ending state of the forest at this point will be:</p>
<pre><code class="language-text">Table T0 [Rc&lt;?0&gt;: Debug]
  Answer:
    A0 = [?0 = u32]
  Strands:
    (Rc&lt;?T&gt;: Debug) :- selected(?T: Debug, A1)

Table T1 [?0: Debug]
  Answers:
    A0 = [?0 = u32]
  Strand:
    (Vec&lt;?U&gt;: Debug) :- (?U: Debug)
    (Rc&lt;?V&gt;: Debug) :- (?V: Debug)
</code></pre>
<p>Here you can see how the forest captures both the answers we have
created thus far <em>and</em> the strands that will let us try to produce
more answers later on.</p>
<h2><a class="header" href="#see-also-71" id="see-also-71">See also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/chalk/blob/239e4ae4e69b2785b5f99e0f2b41fc16b0b4e65e/chalk-engine/src/README.md">chalk_solve README</a>, which contains links to papers used and
acronyms referenced in the code</li>
<li>This section is a lightly adapted version of the blog post <a href="http://smallcultfollowing.com/babysteps/blog/2018/01/31/an-on-demand-slg-solver-for-chalk/">An on-demand
SLG solver for chalk</a></li>
<li><a href="http://aturon.github.io/blog/2017/04/24/negative-chalk/">Negative Reasoning in Chalk</a> explains the need
for negative reasoning, but not how the SLG solver does it</li>
</ul>
<h1><a class="header" href="#an-overview-of-chalk" id="an-overview-of-chalk">An Overview of Chalk</a></h1>
<blockquote>
<p>Chalk is under heavy development, so if any of these links are broken or if
any of the information is inconsistent with the code or outdated, please
<a href="https://github.com/rust-lang/rustc-guide/issues">open an issue</a> so we can fix it. If you are able to fix the
issue yourself, we would love your contribution!</p>
</blockquote>
<p><a href="https://github.com/rust-lang/chalk">Chalk</a> recasts Rust's trait system explicitly in terms of logic
programming by &quot;lowering&quot; Rust code into a kind of logic program we can then
execute queries against. (See <a href="rustc-guide/traits/./lowering-to-logic.html"><em>Lowering to Logic</em></a> and
<a href="rustc-guide/traits/./lowering-rules.html"><em>Lowering Rules</em></a>) Its goal is to be an executable, highly
readable specification of the Rust trait system.</p>
<p>There are many expected benefits from this work. It will consolidate our
existing, somewhat ad-hoc implementation into something far more principled and
expressive, which should behave better in corner cases, and be much easier to
extend.</p>
<h2><a class="header" href="#chalk-structure" id="chalk-structure">Chalk Structure</a></h2>
<p>Chalk has two main &quot;products&quot;. The first of these is the
<a href="https://rust-lang.github.io/chalk/doc/chalk_engine/index.html"><code>chalk_engine</code></a> crate, which defines the core <a href="rustc-guide/traits/./slg.html">SLG
solver</a>. This is the part rustc uses.</p>
<p>The rest of chalk can be considered an elaborate testing harness. Chalk is
capable of parsing Rust-like &quot;programs&quot;, lowering them to logic, and
performing queries on them.</p>
<p>Here's a sample session in the chalk repl, chalki. After feeding it our
program, we perform some queries on it.</p>
<pre><code class="language-rust ignore">?- program
Enter a program; press Ctrl-D when finished
| struct Foo { }
| struct Bar { }
| struct Vec&lt;T&gt; { }
| trait Clone { }
| impl&lt;T&gt; Clone for Vec&lt;T&gt; where T: Clone { }
| impl Clone for Foo { }

?- Vec&lt;Foo&gt;: Clone
Unique; substitution [], lifetime constraints []

?- Vec&lt;Bar&gt;: Clone
No possible solution.

?- exists&lt;T&gt; { Vec&lt;T&gt;: Clone }
Ambiguous; no inference guidance
</code></pre>
<p>You can see more examples of programs and queries in the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L115">unit
tests</a>.</p>
<p>Next we'll go through each stage required to produce the output above.</p>
<h3><a class="header" href="#parsing-a-hrefhttpsrust-langgithubiochalkdocchalk_parseindexhtmlchalk_parsea" id="parsing-a-hrefhttpsrust-langgithubiochalkdocchalk_parseindexhtmlchalk_parsea">Parsing (<a href="https://rust-lang.github.io/chalk/doc/chalk_parse/index.html">chalk_parse</a>)</a></h3>
<p>Chalk is designed to be incorporated with the Rust compiler, so the syntax and
concepts it deals with heavily borrow from Rust. It is convenient for the sake
of testing to be able to run chalk on its own, so chalk includes a parser for a
Rust-like syntax. This syntax is orthogonal to the Rust AST and grammar. It is
not intended to look exactly like it or support the exact same syntax.</p>
<p>The parser takes that syntax and produces an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a>.
You can find the <a href="http://rust-lang.github.io/chalk/doc/chalk_parse/ast/index.html">complete definition of the AST</a> in the source code.</p>
<p>The syntax contains things from Rust that we know and love, for example: traits,
impls, and struct definitions. Parsing is often the first &quot;phase&quot; of
transformation that a program goes through in order to become a format that
chalk can understand.</p>
<h3><a class="header" href="#rust-intermediate-representation-a-hrefhttpsrust-langgithubiochalkdocchalk_rust_irindexhtmlchalk_rust_ira" id="rust-intermediate-representation-a-hrefhttpsrust-langgithubiochalkdocchalk_rust_irindexhtmlchalk_rust_ira">Rust Intermediate Representation (<a href="https://rust-lang.github.io/chalk/doc/chalk_rust_ir/index.html">chalk_rust_ir</a>)</a></h3>
<p>After getting the AST we convert it to a more convenient intermediate
representation called <a href="https://rust-lang.github.io/chalk/doc/chalk_rust_ir/index.html"><code>chalk_rust_ir</code></a>. This is sort of
analogous to the <a href="rustc-guide/traits/../hir.html">HIR</a> in Rust. The process of converting to IR is called
<em>lowering</em>.</p>
<p>The <a href="http://rust-lang.github.io/chalk/doc/chalk/program/struct.Program.html"><code>chalk::program::Program</code></a> struct contains some &quot;rust things&quot;
but indexed and accessible in a different way. For example, if you have a
type like <code>Foo&lt;Bar&gt;</code>, we would represent <code>Foo</code> as a string in the AST but in
<code>chalk::program::Program</code>, we use numeric indices (<code>ItemId</code>).</p>
<p>The <a href="http://rust-lang.github.io/chalk/doc/chalk_rust_ir/">IR source code</a> contains the complete definition.</p>
<h3><a class="header" href="#chalk-intermediate-representation-a-hrefhttpsrust-langgithubiochalkdocchalk_irindexhtmlchalk_ira" id="chalk-intermediate-representation-a-hrefhttpsrust-langgithubiochalkdocchalk_irindexhtmlchalk_ira">Chalk Intermediate Representation (<a href="https://rust-lang.github.io/chalk/doc/chalk_ir/index.html">chalk_ir</a>)</a></h3>
<p>Once we have Rust IR it is time to convert it to &quot;program clauses&quot;. A
<a href="https://rust-lang.github.io/chalk/doc/chalk_ir/enum.ProgramClause.html"><code>ProgramClause</code></a> is essentially one of the following:</p>
<ul>
<li>A <a href="https://github.com/rust-lang/chalk/blob/master/GLOSSARY.md#clause">clause</a> of the form <code>consequence :- conditions</code> where <code>:-</code> is read as
&quot;if&quot; and <code>conditions = cond1 &amp;&amp; cond2 &amp;&amp; ...</code></li>
<li>A universally quantified clause of the form
<code>forall&lt;T&gt; { consequence :- conditions }</code>
<ul>
<li><code>forall&lt;T&gt; { ... }</code> is used to represent <a href="https://en.wikipedia.org/wiki/Universal_quantification">universal quantification</a>. See the
section on <a href="rustc-guide/traits/./lowering-to-logic.html#type-checking-generic-functions-beyond-horn-clauses">Lowering to logic</a> for more information.</li>
<li>A key thing to note about <code>forall</code> is that we don't allow you to &quot;quantify&quot;
over traits, only types and regions (lifetimes). That is, you can't make a
rule like <code>forall&lt;Trait&gt; { u32: Trait }</code> which would say &quot;<code>u32</code> implements
all traits&quot;. You can however say <code>forall&lt;T&gt; { T: Trait }</code> meaning &quot;<code>Trait</code>
is implemented by all types&quot;.</li>
<li><code>forall&lt;T&gt; { ... }</code> is represented in the code using the <a href="http://rust-lang.github.io/chalk/doc/chalk_ir/struct.Binders.html"><code>Binders&lt;T&gt;</code>
struct</a>.</li>
</ul>
</li>
</ul>
<p><em>See also: <a href="rustc-guide/traits/./goals-and-clauses.html">Goals and Clauses</a></em></p>
<p>This is where we encode the rules of the trait system into logic. For
example, if we have the following Rust:</p>
<pre><code class="language-rust ignore">impl&lt;T: Clone&gt; Clone for Vec&lt;T&gt; {}
</code></pre>
<p>We generate the following program clause:</p>
<pre><code class="language-rust ignore">forall&lt;T&gt; { (Vec&lt;T&gt;: Clone) :- (T: Clone) }
</code></pre>
<p>This rule dictates that <code>Vec&lt;T&gt;: Clone</code> is only satisfied if <code>T: Clone</code> is also
satisfied (i.e. &quot;provable&quot;).</p>
<p>Similar to <a href="http://rust-lang.github.io/chalk/doc/chalk/program/struct.Program.html"><code>chalk::program::Program</code></a> which has &quot;rust-like
things&quot;, chalk_ir defines <a href="http://rust-lang.github.io/chalk/doc/chalk/program_environment/struct.ProgramEnvironment.html"><code>ProgramEnvironment</code></a> which is &quot;pure logic&quot;.
The main field in that struct is <code>program_clauses</code>, which contains the
<a href="https://rust-lang.github.io/chalk/doc/chalk_ir/enum.ProgramClause.html"><code>ProgramClause</code></a>s generated by the rules module.</p>
<h3><a class="header" href="#rules-a-hrefhttpsrust-langgithubiochalkdocchalk_solveindexhtmlchalk_solvea" id="rules-a-hrefhttpsrust-langgithubiochalkdocchalk_solveindexhtmlchalk_solvea">Rules (<a href="https://rust-lang.github.io/chalk/doc/chalk_solve/index.html">chalk_solve</a>)</a></h3>
<p>The <code>chalk_solve</code> crate (<a href="https://rust-lang.github.io/chalk/doc/chalk_solve/index.html">source code</a>) defines the logic rules we
use for each item in the Rust IR. It works by iterating over every trait, impl,
etc. and emitting the rules that come from each one.</p>
<p><em>See also: <a href="rustc-guide/traits/./lowering-rules.html">Lowering Rules</a></em></p>
<h4><a class="header" href="#well-formedness-checks" id="well-formedness-checks">Well-formedness checks</a></h4>
<p>As part of lowering to logic, we also do some &quot;well formedness&quot; checks. See
the <a href="http://rust-lang.github.io/chalk/doc/chalk_solve/wf/index.html"><code>chalk_solve::wf</code> source code</a> for where those are done.</p>
<p><em>See also: <a href="rustc-guide/traits/./wf.html">Well-formedness checking</a></em></p>
<h4><a class="header" href="#coherence" id="coherence">Coherence</a></h4>
<p>The method <code>CoherenceSolver::specialization_priorities</code> in the <code>coherence</code> module
(<a href="http://rust-lang.github.io/chalk/doc/chalk_solve/coherence/index.html">source code</a>) checks &quot;coherence&quot;, which means that it
ensures that two impls of the same trait for the same type cannot exist.</p>
<h3><a class="header" href="#solver-a-hrefhttpsrust-langgithubiochalkdocchalk_solveindexhtmlchalk_solvea" id="solver-a-hrefhttpsrust-langgithubiochalkdocchalk_solveindexhtmlchalk_solvea">Solver (<a href="https://rust-lang.github.io/chalk/doc/chalk_solve/index.html">chalk_solve</a>)</a></h3>
<p>Finally, when we've collected all the program clauses we care about, we want
to perform queries on it. The component that finds the answer to these
queries is called the <em>solver</em>.</p>
<p><em>See also: <a href="rustc-guide/traits/./slg.html">The SLG Solver</a></em></p>
<h2><a class="header" href="#crates-3" id="crates-3">Crates</a></h2>
<p>Chalk's functionality is broken up into the following crates:</p>
<ul>
<li><a href="https://rust-lang.github.io/chalk/doc/chalk_engine/index.html"><strong>chalk_engine</strong></a>: Defines the core <a href="rustc-guide/traits/./slg.html">SLG solver</a>.</li>
<li><a href="https://rust-lang.github.io/chalk/doc/chalk_rust_ir/index.html"><strong>chalk_rust_ir</strong></a>, containing the &quot;HIR-like&quot; form of the AST</li>
<li><a href="https://rust-lang.github.io/chalk/doc/chalk_ir/index.html"><strong>chalk_ir</strong></a>: Defines chalk's internal representation of
types, lifetimes, and goals.</li>
<li><a href="https://rust-lang.github.io/chalk/doc/chalk_solve/index.html"><strong>chalk_solve</strong></a>: Combines <code>chalk_ir</code> and <code>chalk_engine</code>,
effectively, which implements logic rules converting <code>chalk_rust_ir</code> to
<code>chalk_ir</code>
<ul>
<li>Defines the <code>coherence</code> module, which implements coherence rules</li>
<li><a href="https://rust-lang.github.io/chalk/doc/chalk_engine/context/index.html"><code>chalk_engine::context</code></a> provides the necessary hooks.</li>
</ul>
</li>
<li><a href="https://rust-lang.github.io/chalk/doc/chalk_parse/index.html"><strong>chalk_parse</strong></a>: Defines the raw AST and a parser.</li>
<li><a href="https://rust-lang.github.io/chalk/doc/chalk/index.html"><strong>chalk</strong></a>: Brings everything together. Defines the following
modules:
<ul>
<li><code>chalk::lowering</code>, which converts AST to <code>chalk_rust_ir</code></li>
<li>Also includes <a href="https://rust-lang.github.io/chalk/doc/chalki/index.html">chalki</a>, chalk's REPL.</li>
</ul>
</li>
</ul>
<p><a href="https://github.com/rust-lang/chalk">Browse source code on GitHub</a></p>
<h2><a class="header" href="#testing-2" id="testing-2">Testing</a></h2>
<p>chalk has a test framework for lowering programs to logic, checking the
lowered logic, and performing queries on it. This is how we test the
implementation of chalk itself, and the viability of the <a href="rustc-guide/traits/./lowering-rules.html">lowering
rules</a>.</p>
<p>The main kind of tests in chalk are <strong>goal tests</strong>. They contain a program,
which is expected to lower to logic successfully, and a set of queries
(goals) along with the expected output. Here's an
<a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L115">example</a>. Since chalk's output can be quite long, goal
tests support specifying only a prefix of the output.</p>
<p><strong>Lowering tests</strong> check the stages that occur before we can issue queries
to the solver: the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/rust_ir/lowering/test.rs">lowering to chalk_rust_ir</a>, and the
<a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/rules/wf/test.rs#L1">well-formedness checks</a> that occur after that.</p>
<h3><a class="header" href="#testing-internals" id="testing-internals">Testing internals</a></h3>
<p>Goal tests use a <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L33"><code>test!</code> macro</a> that takes chalk's Rust-like
syntax and runs it through the full pipeline described above. The macro
ultimately calls the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test.rs#L85"><code>solve_goal</code> function</a>.</p>
<p>Likewise, lowering tests use the <a href="https://github.com/rust-lang/chalk/blob/4bce000801de31bf45c02f742a5fce335c9f035f/src/test_util.rs#L21-L54"><code>lowering_success!</code> and
<code>lowering_error!</code> macros</a>.</p>
<h2><a class="header" href="#more-resources" id="more-resources">More Resources</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/chalk">Chalk Source Code</a></li>
<li><a href="https://github.com/rust-lang/chalk/blob/master/GLOSSARY.md">Chalk Glossary</a></li>
</ul>
<h3><a class="header" href="#blog-posts" id="blog-posts">Blog Posts</a></h3>
<ul>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/">Lowering Rust traits to logic</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/">Unification in Chalk, part 1</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/04/23/unification-in-chalk-part-2/">Unification in Chalk, part 2</a></li>
<li><a href="http://aturon.github.io/blog/2017/04/24/negative-chalk/">Negative reasoning in Chalk</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/05/25/query-structure-in-chalk/">Query structure in chalk</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2017/09/12/tabling-handling-cyclic-queries-in-chalk/">Cyclic queries in chalk</a></li>
<li><a href="http://smallcultfollowing.com/babysteps/blog/2018/01/31/an-on-demand-slg-solver-for-chalk/">An on-demand SLG solver for chalk</a></li>
</ul>
<h1><a class="header" href="#bibliography" id="bibliography">Bibliography</a></h1>
<p>If you'd like to read more background material, here are some
recommended texts and papers:</p>
<p><a href="https://www.amazon.com/Programming-Higher-Order-Logic-Dale-Miller/dp/052187940X">Programming with Higher-order Logic</a>, by Dale Miller and Gopalan
Nadathur, covers the key concepts of Lambda prolog. Although it's a
slim little volume, it's the kind of book where you learn something
new every time you open it.</p>
<p><a name="pphhf"></a></p>
<p><a href="https://dl.acm.org/citation.cfm?id=868380">&quot;A proof procedure for the logic of Hereditary Harrop formulas&quot;</a>,
by Gopalan Nadathur. This paper covers the basics of universes,
environments, and Lambda Prolog-style proof search. Quite readable.</p>
<p><a name="slg"></a> </p>
<p><a href="https://dl.acm.org/citation.cfm?id=651202">&quot;A new formulation of tabled resolution with delay&quot;</a>, by
<a href="http://www3.cs.stonybrook.edu/%7Etswift/">Theresa Swift</a>. This paper gives a kind of abstract treatment of the
SLG formulation that is the basis for our on-demand solver.</p>
<h1><a class="header" href="#type-checking" id="type-checking">Type checking</a></h1>
<p>The <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_typeck"><code>rustc_typeck</code></a> crate contains the source for &quot;type collection&quot;
and &quot;type checking&quot;, as well as a few other bits of related functionality. (It
draws heavily on the <a href="rustc-guide/type-inference.html">type inference</a> and <a href="rustc-guide/traits/resolution.html">trait solving</a>.)</p>
<h2><a class="header" href="#type-collection" id="type-collection">Type collection</a></h2>
<p>Type &quot;collection&quot; is the process of converting the types found in the HIR
(<code>hir::Ty</code>), which represent the syntactic things that the user wrote, into the
<strong>internal representation</strong> used by the compiler (<code>Ty&lt;'tcx&gt;</code>) – we also do
similar conversions for where-clauses and other bits of the function signature.</p>
<p>To try and get a sense for the difference, consider this function:</p>
<pre><code class="language-rust ignore">struct Foo { }
fn foo(x: Foo, y: self::Foo) { ... }
//        ^^^     ^^^^^^^^^
</code></pre>
<p>Those two parameters <code>x</code> and <code>y</code> each have the same type: but they will have
distinct <code>hir::Ty</code> nodes. Those nodes will have different spans, and of course
they encode the path somewhat differently. But once they are &quot;collected&quot; into
<code>Ty&lt;'tcx&gt;</code> nodes, they will be represented by the exact same internal type.</p>
<p>Collection is defined as a bundle of <a href="rustc-guide/query.html">queries</a> for computing information about
the various functions, traits, and other items in the crate being compiled.
Note that each of these queries is concerned with <em>interprocedural</em> things –
for example, for a function definition, collection will figure out the type and
signature of the function, but it will not visit the <em>body</em> of the function in
any way, nor examine type annotations on local variables (that's the job of
type <em>checking</em>).</p>
<p>For more details, see the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/collect/"><code>collect</code></a> module.</p>
<p><strong>TODO</strong>: actually talk about type checking...</p>
<h1><a class="header" href="#method-lookup" id="method-lookup">Method lookup</a></h1>
<p>Method lookup can be rather complex due to the interaction of a number
of factors, such as self types, autoderef, trait lookup, etc. This
file provides an overview of the process. More detailed notes are in
the code itself, naturally.</p>
<p>One way to think of method lookup is that we convert an expression of
the form:</p>
<pre><code class="language-rust ignore">receiver.method(...)
</code></pre>
<p>into a more explicit <a href="https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md">UFCS</a> form:</p>
<pre><code class="language-rust ignore">Trait::method(ADJ(receiver), ...) // for a trait call
ReceiverType::method(ADJ(receiver), ...) // for an inherent method call
</code></pre>
<p>Here <code>ADJ</code> is some kind of adjustment, which is typically a series of
autoderefs and then possibly an autoref (e.g., <code>&amp;**receiver</code>). However
we sometimes do other adjustments and coercions along the way, in
particular unsizing (e.g., converting from <code>[T; n]</code> to <code>[T]</code>).</p>
<p>Method lookup is divided into two major phases:</p>
<ol>
<li>Probing (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/probe/"><code>probe.rs</code></a>). The probe phase is when we decide what method
to call and how to adjust the receiver.</li>
<li>Confirmation (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/method/confirm/"><code>confirm.rs</code></a>). The confirmation phase &quot;applies&quot;
this selection, updating the side-tables, unifying type variables, and
otherwise doing side-effectful things.</li>
</ol>
<p>One reason for this division is to be more amenable to caching.  The
probe phase produces a &quot;pick&quot; (<code>probe::Pick</code>), which is designed to be
cacheable across method-call sites. Therefore, it does not include
inference variables or other information.</p>
<h2><a class="header" href="#the-probe-phase" id="the-probe-phase">The Probe phase</a></h2>
<h3><a class="header" href="#steps" id="steps">Steps</a></h3>
<p>The first thing that the probe phase does is to create a series of
<em>steps</em>. This is done by progressively dereferencing the receiver type
until it cannot be deref'd anymore, as well as applying an optional
&quot;unsize&quot; step. So if the receiver has type <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>, this
might yield:</p>
<pre><code class="language-rust ignore">Rc&lt;Box&lt;[T; 3]&gt;&gt;
Box&lt;[T; 3]&gt;
[T; 3]
[T]
</code></pre>
<h3><a class="header" href="#candidate-assembly-1" id="candidate-assembly-1">Candidate assembly</a></h3>
<p>We then search along those steps to create a list of <em>candidates</em>. A
<code>Candidate</code> is a method item that might plausibly be the method being
invoked. For each candidate, we'll derive a &quot;transformed self type&quot;
that takes into account explicit self.</p>
<p>Candidates are grouped into two kinds, inherent and extension.</p>
<p><strong>Inherent candidates</strong> are those that are derived from the
type of the receiver itself.  So, if you have a receiver of some
nominal type <code>Foo</code> (e.g., a struct), any methods defined within an
impl like <code>impl Foo</code> are inherent methods.  Nothing needs to be
imported to use an inherent method, they are associated with the type
itself (note that inherent impls can only be defined in the same
module as the type itself).</p>
<p>FIXME: Inherent candidates are not always derived from impls.  If you
have a trait object, such as a value of type <code>Box&lt;ToString&gt;</code>, then the
trait methods (<code>to_string()</code>, in this case) are inherently associated
with it. Another case is type parameters, in which case the methods of
their bounds are inherent. However, this part of the rules is subject
to change: when DST's &quot;impl Trait for Trait&quot; is complete, trait object
dispatch could be subsumed into trait matching, and the type parameter
behavior should be reconsidered in light of where clauses.</p>
<p>TODO: Is this FIXME still accurate?</p>
<p><strong>Extension candidates</strong> are derived from imported traits.  If I have
the trait <code>ToString</code> imported, and I call <code>to_string()</code> on a value of
type <code>T</code>, then we will go off to find out whether there is an impl of
<code>ToString</code> for <code>T</code>.  These kinds of method calls are called &quot;extension
methods&quot;.  They can be defined in any module, not only the one that
defined <code>T</code>.  Furthermore, you must import the trait to call such a
method.</p>
<p>So, let's continue our example. Imagine that we were calling a method
<code>foo</code> with the receiver <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> and there is a trait <code>Foo</code>
that defines it with <code>&amp;self</code> for the type <code>Rc&lt;U&gt;</code> as well as a method
on the type <code>Box</code> that defines <code>Foo</code> but with <code>&amp;mut self</code>. Then we
might have two candidates:</p>
<pre><code class="language-text">&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt; from the impl of `Foo` for `Rc&lt;U&gt;` where `U=Box&lt;T; 3]&gt;
&amp;mut Box&lt;[T; 3]&gt;&gt; from the inherent impl on `Box&lt;U&gt;` where `U=[T; 3]`
</code></pre>
<h3><a class="header" href="#candidate-search" id="candidate-search">Candidate search</a></h3>
<p>Finally, to actually pick the method, we will search down the steps,
trying to match the receiver type against the candidate types. At
each step, we also consider an auto-ref and auto-mut-ref to see whether
that makes any of the candidates match. We pick the first step where
we find a match.</p>
<p>In the case of our example, the first step is <code>Rc&lt;Box&lt;[T; 3]&gt;&gt;</code>,
which does not itself match any candidate. But when we autoref it, we
get the type <code>&amp;Rc&lt;Box&lt;[T; 3]&gt;&gt;</code> which does match. We would then
recursively consider all where-clauses that appear on the impl: if
those match (or we cannot rule out that they do), then this is the
method we would pick. Otherwise, we would continue down the series of
steps.</p>
<h1><a class="header" href="#variance-of-type-and-lifetime-parameters" id="variance-of-type-and-lifetime-parameters">Variance of type and lifetime parameters</a></h1>
<p>For a more general background on variance, see the <a href="rustc-guide/./appendix/background.html">background</a> appendix.</p>
<p>During type checking we must infer the variance of type and lifetime
parameters. The algorithm is taken from Section 4 of the paper <a href="https://people.cs.umass.edu/%7Eyannis/variance-extended2011.pdf">&quot;Taming the
Wildcards: Combining Definition- and Use-Site Variance&quot;</a> published in
PLDI'11 and written by Altidor et al., and hereafter referred to as The Paper.</p>
<p>This inference is explicitly designed <em>not</em> to consider the uses of
types within code. To determine the variance of type parameters
defined on type <code>X</code>, we only consider the definition of the type <code>X</code>
and the definitions of any types it references.</p>
<p>We only infer variance for type parameters found on <em>data types</em>
like structs and enums. In these cases, there is a fairly straightforward
explanation for what variance means. The variance of the type
or lifetime parameters defines whether <code>T&lt;A&gt;</code> is a subtype of <code>T&lt;B&gt;</code>
(resp. <code>T&lt;'a&gt;</code> and <code>T&lt;'b&gt;</code>) based on the relationship of <code>A</code> and <code>B</code>
(resp. <code>'a</code> and <code>'b</code>).</p>
<p>We do not infer variance for type parameters found on traits, functions,
or impls. Variance on trait parameters can indeed make sense
(and we used to compute it) but it is actually rather subtle in
meaning and not that useful in practice, so we removed it. See the
<a href="rustc-guide/variance.html#addendum">addendum</a> for some details. Variances on function/impl parameters, on the
other hand, doesn't make sense because these parameters are instantiated and
then forgotten, they don't persist in types or compiled byproducts.</p>
<blockquote>
<p><strong>Notation</strong></p>
<p>We use the notation of The Paper throughout this chapter:</p>
<ul>
<li><code>+</code> is <em>covariance</em>.</li>
<li><code>-</code> is <em>contravariance</em>.</li>
<li><code>*</code> is <em>bivariance</em>.</li>
<li><code>o</code> is <em>invariance</em>.</li>
</ul>
</blockquote>
<h2><a class="header" href="#the-algorithm" id="the-algorithm">The algorithm</a></h2>
<p>The basic idea is quite straightforward. We iterate over the types
defined and, for each use of a type parameter <code>X</code>, accumulate a
constraint indicating that the variance of <code>X</code> must be valid for the
variance of that use site. We then iteratively refine the variance of
<code>X</code> until all constraints are met. There is <em>always</em> a solution, because at
the limit we can declare all type parameters to be invariant and all
constraints will be satisfied.</p>
<p>As a simple example, consider:</p>
<pre><code class="language-rust ignore">enum Option&lt;A&gt; { Some(A), None }
enum OptionalFn&lt;B&gt; { Some(|B|), None }
enum OptionalMap&lt;C&gt; { Some(|C| -&gt; C), None }
</code></pre>
<p>Here, we will generate the constraints:</p>
<pre><code class="language-text">1. V(A) &lt;= +
2. V(B) &lt;= -
3. V(C) &lt;= +
4. V(C) &lt;= -
</code></pre>
<p>These indicate that (1) the variance of A must be at most covariant;
(2) the variance of B must be at most contravariant; and (3, 4) the
variance of C must be at most covariant <em>and</em> contravariant. All of these
results are based on a variance lattice defined as follows:</p>
<pre><code class="language-text">   *      Top (bivariant)
-     +
   o      Bottom (invariant)
</code></pre>
<p>Based on this lattice, the solution <code>V(A)=+</code>, <code>V(B)=-</code>, <code>V(C)=o</code> is the
optimal solution. Note that there is always a naive solution which
just declares all variables to be invariant.</p>
<p>You may be wondering why fixed-point iteration is required. The reason
is that the variance of a use site may itself be a function of the
variance of other type parameters. In full generality, our constraints
take the form:</p>
<pre><code class="language-text">V(X) &lt;= Term
Term := + | - | * | o | V(X) | Term x Term
</code></pre>
<p>Here the notation <code>V(X)</code> indicates the variance of a type/region
parameter <code>X</code> with respect to its defining class. <code>Term x Term</code>
represents the &quot;variance transform&quot; as defined in the paper:</p>
<blockquote>
<p>If the variance of a type variable <code>X</code> in type expression <code>E</code> is <code>V2</code>
and the definition-site variance of the [corresponding] type parameter
of a class <code>C</code> is <code>V1</code>, then the variance of <code>X</code> in the type expression
<code>C&lt;E&gt;</code> is <code>V3 = V1.xform(V2)</code>.</p>
</blockquote>
<h2><a class="header" href="#constraints" id="constraints">Constraints</a></h2>
<p>If I have a struct or enum with where clauses:</p>
<pre><code class="language-rust ignore">struct Foo&lt;T: Bar&gt; { ... }
</code></pre>
<p>you might wonder whether the variance of <code>T</code> with respect to <code>Bar</code> affects the
variance <code>T</code> with respect to <code>Foo</code>. I claim no.  The reason: assume that <code>T</code> is
invariant with respect to <code>Bar</code> but covariant with respect to <code>Foo</code>. And then
we have a <code>Foo&lt;X&gt;</code> that is upcast to <code>Foo&lt;Y&gt;</code>, where <code>X &lt;: Y</code>. However, while
<code>X : Bar</code>, <code>Y : Bar</code> does not hold.  In that case, the upcast will be illegal,
but not because of a variance failure, but rather because the target type
<code>Foo&lt;Y&gt;</code> is itself just not well-formed. Basically we get to assume
well-formedness of all types involved before considering variance.</p>
<h3><a class="header" href="#dependency-graph-management" id="dependency-graph-management">Dependency graph management</a></h3>
<p>Because variance is a whole-crate inference, its dependency graph
can become quite muddled if we are not careful. To resolve this, we refactor
into two queries:</p>
<ul>
<li><code>crate_variances</code> computes the variance for all items in the current crate.</li>
<li><code>variances_of</code> accesses the variance for an individual reading; it
works by requesting <code>crate_variances</code> and extracting the relevant data.</li>
</ul>
<p>If you limit yourself to reading <code>variances_of</code>, your code will only
depend then on the inference of that particular item.</p>
<p>Ultimately, this setup relies on the <a href="rustc-guide/./queries/incremental-compilation.html">red-green algorithm</a>. In particular,
every variance query effectively depends on all type definitions in the entire
crate (through <code>crate_variances</code>), but since most changes will not result in a
change to the actual results from variance inference, the <code>variances_of</code> query
will wind up being considered green after it is re-evaluated.</p>
<p><a name="addendum"></a></p>
<h2><a class="header" href="#addendum-variance-on-traits" id="addendum-variance-on-traits">Addendum: Variance on traits</a></h2>
<p>As mentioned above, we used to permit variance on traits. This was
computed based on the appearance of trait type parameters in
method signatures and was used to represent the compatibility of
vtables in trait objects (and also &quot;virtual&quot; vtables or dictionary
in trait bounds). One complication was that variance for
associated types is less obvious, since they can be projected out
and put to myriad uses, so it's not clear when it is safe to allow
<code>X&lt;A&gt;::Bar</code> to vary (or indeed just what that means). Moreover (as
covered below) all inputs on any trait with an associated type had
to be invariant, limiting the applicability. Finally, the
annotations (<code>MarkerTrait</code>, <code>PhantomFn</code>) needed to ensure that all
trait type parameters had a variance were confusing and annoying
for little benefit.</p>
<p>Just for historical reference, I am going to preserve some text indicating how
one could interpret variance and trait matching.</p>
<h3><a class="header" href="#variance-and-object-types" id="variance-and-object-types">Variance and object types</a></h3>
<p>Just as with structs and enums, we can decide the subtyping
relationship between two object types <code>&amp;Trait&lt;A&gt;</code> and <code>&amp;Trait&lt;B&gt;</code>
based on the relationship of <code>A</code> and <code>B</code>. Note that for object
types we ignore the <code>Self</code> type parameter – it is unknown, and
the nature of dynamic dispatch ensures that we will always call a
function that is expected the appropriate <code>Self</code> type. However, we
must be careful with the other type parameters, or else we could
end up calling a function that is expecting one type but provided
another.</p>
<p>To see what I mean, consider a trait like so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait ConvertTo&lt;A&gt; {
    fn convertTo(&amp;self) -&gt; A;
}
<span class="boring">}
</span></code></pre></pre>
<p>Intuitively, If we had one object <code>O=&amp;ConvertTo&lt;Object&gt;</code> and another
<code>S=&amp;ConvertTo&lt;String&gt;</code>, then <code>S &lt;: O</code> because <code>String &lt;: Object</code>
(presuming Java-like &quot;string&quot; and &quot;object&quot; types, my go to examples
for subtyping). The actual algorithm would be to compare the
(explicit) type parameters pairwise respecting their variance: here,
the type parameter A is covariant (it appears only in a return
position), and hence we require that <code>String &lt;: Object</code>.</p>
<p>You'll note though that we did not consider the binding for the
(implicit) <code>Self</code> type parameter: in fact, it is unknown, so that's
good. The reason we can ignore that parameter is precisely because we
don't need to know its value until a call occurs, and at that time (as
you said) the dynamic nature of virtual dispatch means the code we run
will be correct for whatever value <code>Self</code> happens to be bound to for
the particular object whose method we called. <code>Self</code> is thus different
from <code>A</code>, because the caller requires that <code>A</code> be known in order to
know the return type of the method <code>convertTo()</code>. (As an aside, we
have rules preventing methods where <code>Self</code> appears outside of the
receiver position from being called via an object.)</p>
<h3><a class="header" href="#trait-variance-and-vtable-resolution" id="trait-variance-and-vtable-resolution">Trait variance and vtable resolution</a></h3>
<p>But traits aren't only used with objects. They're also used when
deciding whether a given impl satisfies a given trait bound. To set the
scene here, imagine I had a function:</p>
<pre><code class="language-rust ignore">fn convertAll&lt;A,T:ConvertTo&lt;A&gt;&gt;(v: &amp;[T]) { ... }
</code></pre>
<p>Now imagine that I have an implementation of <code>ConvertTo</code> for <code>Object</code>:</p>
<pre><code class="language-rust ignore">impl ConvertTo&lt;i32&gt; for Object { ... }
</code></pre>
<p>And I want to call <code>convertAll</code> on an array of strings. Suppose
further that for whatever reason I specifically supply the value of
<code>String</code> for the type parameter <code>T</code>:</p>
<pre><code class="language-rust ignore">let mut vector = vec![&quot;string&quot;, ...];
convertAll::&lt;i32, String&gt;(vector);
</code></pre>
<p>Is this legal? To put another way, can we apply the <code>impl</code> for
<code>Object</code> to the type <code>String</code>? The answer is yes, but to see why
we have to expand out what will happen:</p>
<ul>
<li>
<p><code>convertAll</code> will create a pointer to one of the entries in the
vector, which will have type <code>&amp;String</code></p>
</li>
<li>
<p>It will then call the impl of <code>convertTo()</code> that is intended
for use with objects. This has the type <code>fn(self: &amp;Object) -&gt; i32</code>.</p>
<p>It is OK to provide a value for <code>self</code> of type <code>&amp;String</code> because
<code>&amp;String &lt;: &amp;Object</code>.</p>
</li>
</ul>
<p>OK, so intuitively we want this to be legal, so let's bring this back
to variance and see whether we are computing the correct result. We
must first figure out how to phrase the question &quot;is an impl for
<code>Object,i32</code> usable where an impl for <code>String,i32</code> is expected?&quot;</p>
<p>Maybe it's helpful to think of a dictionary-passing implementation of
type classes. In that case, <code>convertAll()</code> takes an implicit parameter
representing the impl. In short, we <em>have</em> an impl of type:</p>
<pre><code class="language-text">V_O = ConvertTo&lt;i32&gt; for Object
</code></pre>
<p>and the function prototype expects an impl of type:</p>
<pre><code class="language-text">V_S = ConvertTo&lt;i32&gt; for String
</code></pre>
<p>As with any argument, this is legal if the type of the value given
(<code>V_O</code>) is a subtype of the type expected (<code>V_S</code>). So is <code>V_O &lt;: V_S</code>?
The answer will depend on the variance of the various parameters. In
this case, because the <code>Self</code> parameter is contravariant and <code>A</code> is
covariant, it means that:</p>
<pre><code class="language-text">V_O &lt;: V_S iff
    i32 &lt;: i32
    String &lt;: Object
</code></pre>
<p>These conditions are satisfied and so we are happy.</p>
<h3><a class="header" href="#variance-and-associated-types" id="variance-and-associated-types">Variance and associated types</a></h3>
<p>Traits with associated types – or at minimum projection
expressions – must be invariant with respect to all of their
inputs. To see why this makes sense, consider what subtyping for a
trait reference means:</p>
<pre><code class="language-text">&lt;T as Trait&gt; &lt;: &lt;U as Trait&gt;
</code></pre>
<p>means that if I know that <code>T as Trait</code>, I also know that <code>U as Trait</code>. Moreover, if you think of it as dictionary passing style,
it means that a dictionary for <code>&lt;T as Trait&gt;</code> is safe to use where
a dictionary for <code>&lt;U as Trait&gt;</code> is expected.</p>
<p>The problem is that when you can project types out from <code>&lt;T as Trait&gt;</code>, the relationship to types projected out of <code>&lt;U as Trait&gt;</code>
is completely unknown unless <code>T==U</code> (see #21726 for more
details). Making <code>Trait</code> invariant ensures that this is true.</p>
<p>Another related reason is that if we didn't make traits with
associated types invariant, then projection is no longer a
function with a single result. Consider:</p>
<pre><code class="language-rust ignore">trait Identity { type Out; fn foo(&amp;self); }
impl&lt;T&gt; Identity for T { type Out = T; ... }
</code></pre>
<p>Now if I have <code>&lt;&amp;'static () as Identity&gt;::Out</code>, this can be
validly derived as <code>&amp;'a ()</code> for any <code>'a</code>:</p>
<pre><code class="language-text">&lt;&amp;'a () as Identity&gt; &lt;: &lt;&amp;'static () as Identity&gt;
if &amp;'static () &lt; : &amp;'a ()   -- Identity is contravariant in Self
if 'static : 'a             -- Subtyping rules for relations
</code></pre>
<p>This change otoh means that <code>&lt;'static () as Identity&gt;::Out</code> is
always <code>&amp;'static ()</code> (which might then be upcast to <code>'a ()</code>,
separately). This was helpful in solving #21750.</p>
<h1><a class="header" href="#existential-types" id="existential-types">Existential Types</a></h1>
<p>Existential types are essentially strong type aliases which only expose
a specific set of traits as their interface and the concrete type in the
background is inferred from a certain set of use sites of the existential
type.</p>
<p>In the language they are expressed via</p>
<pre><code class="language-rust ignore">existential type Foo: Bar;
</code></pre>
<p>This is in existential type named <code>Foo</code> which can be interacted with via
the <code>Bar</code> trait's interface.</p>
<p>Since there needs to be a concrete background type, you can currently
express that type by using the existential type in a &quot;defining use site&quot;.</p>
<pre><code class="language-rust ignore">struct Struct;
impl Bar for Struct { /* stuff */ }
fn foo() -&gt; Foo {
    Struct
}
</code></pre>
<p>Any other &quot;defining use site&quot; needs to produce the exact same type.</p>
<h2><a class="header" href="#defining-use-sites" id="defining-use-sites">Defining use site(s)</a></h2>
<p>Currently only the return value of a function inside can
be a defining use site of an existential type (and only if the return
type of that function contains the existential type).</p>
<p>The defining use of an existential type can be any code <em>within</em> the parent
of the existential type definition. This includes any siblings of the
existential type and all children of the siblings.</p>
<p>The initiative for <em>&quot;not causing fatal brain damage to developers due to
accidentally running infinite loops in their brain while trying to
comprehend what the type system is doing&quot;</em> has decided to disallow children
of existential types to be defining use sites.</p>
<h3><a class="header" href="#associated-existential-types" id="associated-existential-types">Associated existential types</a></h3>
<p>Associated existential types can be defined by any other associated item
on the same trait <code>impl</code> or a child of these associated items.</p>
<h1><a class="header" href="#the-mir-mid-level-ir" id="the-mir-mid-level-ir">The MIR (Mid-level IR)</a></h1>
<p>MIR is Rust's <em>Mid-level Intermediate Representation</em>. It is
constructed from <a href="rustc-guide/mir/../hir.html">HIR</a>. MIR was introduced in
<a href="http://rust-lang.github.io/rfcs/1211-mir.html">RFC 1211</a>. It is a radically simplified form of Rust that is used for
certain flow-sensitive safety checks – notably the borrow checker! –
and also for optimization and code generation.</p>
<p>If you'd like a very high-level introduction to MIR, as well as some
of the compiler concepts that it relies on (such as control-flow
graphs and desugaring), you may enjoy the
<a href="https://blog.rust-lang.org/2016/04/19/MIR.html">rust-lang blog post that introduced MIR</a>.</p>
<h2><a class="header" href="#introduction-to-mir" id="introduction-to-mir">Introduction to MIR</a></h2>
<p>MIR is defined in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc/mir"><code>src/librustc/mir/</code></a> module, but much of the code
that manipulates it is found in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir"><code>src/librustc_mir</code></a>.</p>
<p>Some of the key characteristics of MIR are:</p>
<ul>
<li>It is based on a <a href="rustc-guide/mir/../appendix/background.html#cfg">control-flow graph</a>.</li>
<li>It does not have nested expressions.</li>
<li>All types in MIR are fully explicit.</li>
</ul>
<h2><a class="header" href="#key-mir-vocabulary" id="key-mir-vocabulary">Key MIR vocabulary</a></h2>
<p>This section introduces the key concepts of MIR, summarized here:</p>
<ul>
<li><strong>Basic blocks</strong>: units of the control-flow graph, consisting of:
<ul>
<li><strong>statements:</strong> actions with one successor</li>
<li><strong>terminators:</strong> actions with potentially multiple successors; always at
the end of a block</li>
<li>(if you're not familiar with the term <em>basic block</em>, see the <a href="rustc-guide/mir/../appendix/background.html#cfg">background
chapter</a>)</li>
</ul>
</li>
<li><strong>Locals:</strong> Memory locations allocated on the stack (conceptually, at
least), such as function arguments, local variables, and
temporaries. These are identified by an index, written with a
leading underscore, like <code>_1</code>. There is also a special &quot;local&quot;
(<code>_0</code>) allocated to store the return value.</li>
<li><strong>Places:</strong> expressions that identify a location in memory, like <code>_1</code> or
<code>_1.f</code>.</li>
<li><strong>Rvalues:</strong> expressions that produce a value. The &quot;R&quot; stands for
the fact that these are the &quot;right-hand side&quot; of an assignment.
<ul>
<li><strong>Operands:</strong> the arguments to an rvalue, which can either be a
constant (like <code>22</code>) or a place (like <code>_1</code>).</li>
</ul>
</li>
</ul>
<p>You can get a feeling for how MIR is structed by translating simple
programs into MIR and reading the pretty printed output. In fact, the
playground makes this easy, since it supplies a MIR button that will
show you the MIR for your program. Try putting this program into play
(or <a href="https://play.rust-lang.org/?gist=30074856e62e74e91f06abd19bd72ece&amp;version=stable">clicking on this link</a>), and then clicking the &quot;MIR&quot;
button on the top:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut vec = Vec::new();
    vec.push(1);
    vec.push(2);
}
</code></pre></pre>
<p>You should see something like:</p>
<pre><code class="language-mir">// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn main() -&gt; () {
    ...
}
</code></pre>
<p>This is the MIR format for the <code>main</code> function.</p>
<p><strong>Variable declarations.</strong> If we drill in a bit, we'll see it begins
with a bunch of variable declarations. They look like this:</p>
<pre><code class="language-mir">let mut _0: ();                      // return place
scope 1 {
    let mut _1: std::vec::Vec&lt;i32&gt;;  // &quot;vec&quot; in scope 1 at src/main.rs:2:9: 2:16
}
scope 2 {
}
let mut _2: ();
let mut _3: &amp;mut std::vec::Vec&lt;i32&gt;;
let mut _4: ();
let mut _5: &amp;mut std::vec::Vec&lt;i32&gt;;
</code></pre>
<p>You can see that variables in MIR don't have names, they have indices,
like <code>_0</code> or <code>_1</code>.  We also intermingle the user's variables (e.g.,
<code>_1</code>) with temporary values (e.g., <code>_2</code> or <code>_3</code>). You can tell the
difference between user-defined variables have a comment that gives
you their original name (<code>// &quot;vec&quot; in scope 1...</code>). The &quot;scope&quot; blocks
(e.g., <code>scope 1 { .. }</code>) describe the lexical structure of the source
program (which names were in scope when).</p>
<p><strong>Basic blocks.</strong> Reading further, we see our first <strong>basic block</strong> (naturally
it may look slightly different when you view it, and I am ignoring some of the
comments):</p>
<pre><code class="language-mir">bb0: {
    StorageLive(_1);
    _1 = const &lt;std::vec::Vec&lt;T&gt;&gt;::new() -&gt; bb2;
}
</code></pre>
<p>A basic block is defined by a series of <strong>statements</strong> and a final
<strong>terminator</strong>.  In this case, there is one statement:</p>
<pre><code class="language-mir">StorageLive(_1);
</code></pre>
<p>This statement indicates that the variable <code>_1</code> is &quot;live&quot;, meaning
that it may be used later – this will persist until we encounter a
<code>StorageDead(_1)</code> statement, which indicates that the variable <code>_1</code> is
done being used. These &quot;storage statements&quot; are used by LLVM to
allocate stack space.</p>
<p>The <strong>terminator</strong> of the block <code>bb0</code> is the call to <code>Vec::new</code>:</p>
<pre><code class="language-mir">_1 = const &lt;std::vec::Vec&lt;T&gt;&gt;::new() -&gt; bb2;
</code></pre>
<p>Terminators are different from statements because they can have more
than one successor – that is, control may flow to different
places. Function calls like the call to <code>Vec::new</code> are always
terminators because of the possibility of unwinding, although in the
case of <code>Vec::new</code> we are able to see that indeed unwinding is not
possible, and hence we list only one successor block, <code>bb2</code>.</p>
<p>If we look ahead to <code>bb2</code>, we will see it looks like this:</p>
<pre><code class="language-mir">bb2: {
    StorageLive(_3);
    _3 = &amp;mut _1;
    _2 = const &lt;std::vec::Vec&lt;T&gt;&gt;::push(move _3, const 1i32) -&gt; [return: bb3, unwind: bb4];
}
</code></pre>
<p>Here there are two statements: another <code>StorageLive</code>, introducing the <code>_3</code>
temporary, and then an assignment:</p>
<pre><code class="language-mir">_3 = &amp;mut _1;
</code></pre>
<p>Assignments in general have the form:</p>
<pre><code class="language-text">&lt;Place&gt; = &lt;Rvalue&gt;
</code></pre>
<p>A place is an expression like <code>_3</code>, <code>_3.f</code> or <code>*_3</code> – it denotes a
location in memory.  An <strong>Rvalue</strong> is an expression that creates a
value: in this case, the rvalue is a mutable borrow expression, which
looks like <code>&amp;mut &lt;Place&gt;</code>. So we can kind of define a grammar for
rvalues like so:</p>
<pre><code class="language-text">&lt;Rvalue&gt;  = &amp; (mut)? &lt;Place&gt;
          | &lt;Operand&gt; + &lt;Operand&gt;
          | &lt;Operand&gt; - &lt;Operand&gt;
          | ...

&lt;Operand&gt; = Constant
          | copy Place
          | move Place
</code></pre>
<p>As you can see from this grammar, rvalues cannot be nested – they can
only reference places and constants. Moreover, when you use a place,
we indicate whether we are <strong>copying it</strong> (which requires that the
place have a type <code>T</code> where <code>T: Copy</code>) or <strong>moving it</strong> (which works
for a place of any type). So, for example, if we had the expression <code>x = a + b + c</code> in Rust, that would get compile to two statements and a
temporary:</p>
<pre><code class="language-mir">TMP1 = a + b
x = TMP1 + c
</code></pre>
<p>(<a href="https://play.rust-lang.org/?gist=1751196d63b2a71f8208119e59d8a5b6&amp;version=stable">Try it and see</a>, though you may want to do release mode to skip
over the overflow checks.)</p>
<h2><a class="header" href="#mir-data-types" id="mir-data-types">MIR data types</a></h2>
<p>The MIR data types are defined in the <a href="https://github.com/rust-lang/rust/tree/master/src/librustc/mir"><code>src/librustc/mir/</code></a>
module.  Each of the key concepts mentioned in the previous section
maps in a fairly straightforward way to a Rust type.</p>
<p>The main MIR data type is <code>Mir</code>. It contains the data for a single
function (along with sub-instances of Mir for &quot;promoted constants&quot;,
but <a href="rustc-guide/mir/index.html#promoted">you can read about those below</a>).</p>
<ul>
<li><strong>Basic blocks</strong>: The basic blocks are stored in the field
<code>basic_blocks</code>; this is a vector of <code>BasicBlockData</code>
structures. Nobody ever references a basic block directly: instead,
we pass around <code>BasicBlock</code> values, which are
<a href="rustc-guide/mir/../appendix/glossary.html">newtype'd</a> indices into this vector.</li>
<li><strong>Statements</strong> are represented by the type <code>Statement</code>.</li>
<li><strong>Terminators</strong> are represented by the <code>Terminator</code>.</li>
<li><strong>Locals</strong> are represented by a <a href="rustc-guide/mir/../appendix/glossary.html">newtype'd</a> index type <code>Local</code>. The
data for a local variable is found in the <code>Mir</code> (the <code>local_decls</code>
vector). There is also a special constant <code>RETURN_PLACE</code> identifying
the special &quot;local&quot; representing the return value.</li>
<li><strong>Places</strong> are identified by the enum <code>Place</code>. There are a few variants:
<ul>
<li>Local variables like <code>_1</code></li>
<li>Static variables <code>FOO</code></li>
<li><strong>Projections</strong>, which are fields or other things that &quot;project
out&quot; from a base place. So e.g. the place <code>_1.f</code> is a projection,
with <code>f</code> being the &quot;projection element and <code>_1</code> being the base
path. <code>*_1</code> is also a projection, with the <code>*</code> being represented
by the <code>ProjectionElem::Deref</code> element.</li>
</ul>
</li>
<li><strong>Rvalues</strong> are represented by the enum <code>Rvalue</code>.</li>
<li><strong>Operands</strong> are represented by the enum <code>Operand</code>.</li>
</ul>
<h2><a class="header" href="#representing-constants" id="representing-constants">Representing constants</a></h2>
<p><em>to be written</em></p>
<p><a name="promoted"></a></p>
<h3><a class="header" href="#promoted-constants" id="promoted-constants">Promoted constants</a></h3>
<p><em>to be written</em></p>
<h1><a class="header" href="#mir-construction" id="mir-construction">MIR construction</a></h1>
<p>The lowering of <a href="rustc-guide/mir/../hir.html">HIR</a> to <a href="rustc-guide/mir/./index.html">MIR</a> occurs for the following (probably incomplete)
list of items:</p>
<ul>
<li>Function and Closure bodies</li>
<li>Initializers of <code>static</code> and <code>const</code> items</li>
<li>Initializers of enum discriminants</li>
<li>Glue and Shims of any kind
<ul>
<li>Tuple struct initializer functions</li>
<li>Drop code (the <code>Drop::drop</code> function is not called directly)</li>
<li>Drop implementations of types without an explicit <code>Drop</code> implementation</li>
</ul>
</li>
</ul>
<p>The lowering is triggered by calling the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/fn.mir_built.html"><code>mir_built</code></a> query.
There is an intermediate representation
between <a href="rustc-guide/mir/../hir.html">HIR</a> and <a href="rustc-guide/mir/./index.html">MIR</a> called the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/hair/index.html">HAIR</a> that is only used during the lowering.
The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/hair/index.html">HAIR</a>'s most important feature is that the various adjustments (which happen
without explicit syntax) like coercions, autoderef, autoref and overloaded method
calls have become explicit casts, deref operations, reference expressions or
concrete function calls.</p>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/hair/index.html">HAIR</a> has datatypes that mirror the <a href="rustc-guide/mir/../hir.html">HIR</a> datatypes, but instead of e.g. <code>-x</code>
being a <code>hair::ExprKind::Neg(hair::Expr)</code> it is a <code>hair::ExprKind::Neg(hir::Expr)</code>.
This shallowness enables the <code>HAIR</code> to represent all datatypes that <a href="rustc-guide/mir/../hir.html">HIR</a> has, but
without having to create an in-memory copy of the entire <a href="rustc-guide/mir/../hir.html">HIR</a>.
<a href="rustc-guide/mir/./index.html">MIR</a> lowering will first convert the topmost expression from
<a href="rustc-guide/mir/../hir.html">HIR</a> to <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/hair/index.html">HAIR</a> (in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/hair/cx/expr/index.html">rustc_mir::hair::cx::expr</a>) and then process
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/hair/index.html">HAIR</a> expressions recursively.</p>
<p>The lowering creates local variables for every argument as specified in the signature.
Next it creates local variables for every binding specified (e.g. <code>(a, b): (i32, String)</code>)
produces 3 bindings, one for the argument, and two for the bindings. Next it generates
field accesses that read the fields from the argument and writes the value to the binding
variable.</p>
<p>With this initialization out of the way, the lowering triggers a recursive call
to a function that generates the MIR for the body (a <code>Block</code> expression) and
writes the result into the <code>RETURN_PLACE</code>.</p>
<h2><a class="header" href="#unpack-all-the-things" id="unpack-all-the-things"><code>unpack!</code> all the things</a></h2>
<p>Functions that generate MIR tend to fall into one of two patterns.
First, if the function generates only statements, then it will take a
basic block as argument onto which those statements should be appended.
It can then return a result as normal:</p>
<pre><code class="language-rust ignore">fn generate_some_mir(&amp;mut self, block: BasicBlock) -&gt; ResultType {
   ...
}
</code></pre>
<p>But there are other functions that may generate new basic blocks as well.
For example, lowering an expression like <code>if foo { 22 } else { 44 }</code>
requires generating a small &quot;diamond-shaped graph&quot;.
In this case, the functions take a basic block where their code starts
and return a (potentially) new basic block where the code generation ends.
The <code>BlockAnd</code> type is used to represent this:</p>
<pre><code class="language-rust ignore">fn generate_more_mir(&amp;mut self, block: BasicBlock) -&gt; BlockAnd&lt;ResultType&gt; {
    ...
}
</code></pre>
<p>When you invoke these functions, it is common to have a local variable <code>block</code>
that is effectively a &quot;cursor&quot;. It represents the point at which we are adding new MIR.
When you invoke <code>generate_more_mir</code>, you want to update this cursor.
You can do this manually, but it's tedious:</p>
<pre><code class="language-rust ignore">let mut block;
let v = match self.generate_more_mir(..) {
    BlockAnd { block: new_block, value: v } =&gt; {
        block = new_block;
        v
    }
};
</code></pre>
<p>For this reason, we offer a macro that lets you write
<code>let v = unpack!(block = self.generate_more_mir(...))</code>.
It simply extracts the new block and overwrites the
variable <code>block</code> that you named in the <code>unpack!</code>.</p>
<h2><a class="header" href="#lowering-expressions-into-the-desired-mir" id="lowering-expressions-into-the-desired-mir">Lowering expressions into the desired MIR</a></h2>
<p>There are essentially four kinds of representations one might want of an expression:</p>
<ul>
<li><code>Place</code> refers to a (or part of a) preexisting memory location (local, static, promoted)</li>
<li><code>Rvalue</code> is something that can be assigned to a <code>Place</code></li>
<li><code>Operand</code> is an argument to e.g. a <code>+</code> operation or a function call</li>
<li>a temporary variable containing a copy of the value</li>
</ul>
<p>These following image depicts a general overview of the interactions between the
representations:</p>
<img src="rustc-guide/mir/mir_overview.svg">
<p><a href="rustc-guide/mir/mir_detailed.svg">Click here for a more detailed view</a></p>
<p>We start out with lowering the function body to an <code>Rvalue</code> so we can create an
assignment to <code>RETURN_PLACE</code>, This <code>Rvalue</code> lowering will in turn trigger lowering to
<code>Operand</code> for its arguments (if any). <code>Operand</code> lowering either produces a <code>const</code>
operand, or moves/copies out of a <code>Place</code>, thus triggering a <code>Place</code> lowering. An
expression being lowered to a <code>Place</code> can in turn trigger a temporary to be created
if the expression being lowered contains operations. This is where the snake bites its
own tail and we need to trigger an <code>Rvalue</code> lowering for the expression to be written
into the local.</p>
<h2><a class="header" href="#operator-lowering" id="operator-lowering">Operator lowering</a></h2>
<p>Operators on builtin types are not lowered to function calls (which would end up being
infinite recursion calls, because the trait impls just contain the operation itself
again). Instead there are <code>Rvalue</code>s for binary and unary operators and index operations.
These <code>Rvalue</code>s later get codegened to llvm primitive operations or llvm intrinsics.</p>
<p>Operators on all other types get lowered to a function call to their <code>impl</code> of the
operator's corresponding trait.</p>
<p>Regardless of the lowering kind, the arguments to the operator are lowered to <code>Operand</code>s.
This means all arguments are either constants, or refer to an already existing value
somewhere in a local or static.</p>
<h2><a class="header" href="#method-call-lowering" id="method-call-lowering">Method call lowering</a></h2>
<p>Method calls are lowered to the same <code>TerminatorKind</code> that function calls are.
In <a href="rustc-guide/mir/./index.html">MIR</a> there is no difference between method calls and function calls anymore.</p>
<h2><a class="header" href="#conditions" id="conditions">Conditions</a></h2>
<p><code>if</code> conditions and <code>match</code> statements for <code>enum</code>s without variants with fields are
lowered to <code>TerminatorKind::SwitchInt</code>. Each possible value (so <code>0</code> and <code>1</code> for <code>if</code>
conditions) has a corresponding <code>BasicBlock</code> to which the code continues.
The argument being branched on is (again) an <code>Operand</code> representing the value of
the if condition.</p>
<h3><a class="header" href="#pattern-matching" id="pattern-matching">Pattern matching</a></h3>
<p><code>match</code> statements for <code>enum</code>s with variants that have fields are lowered to
<code>TerminatorKind::SwitchInt</code>, too, but the <code>Operand</code> refers to a <code>Place</code> where the
discriminant of the value can be found. This often involves reading the discriminant
to a new temporary variable.</p>
<h2><a class="header" href="#aggregate-construction" id="aggregate-construction">Aggregate construction</a></h2>
<p>Aggregate values of any kind (e.g. structs or tuples) are built via <code>Rvalue::Aggregate</code>.
All fields are
lowered to <code>Operator</code>s. This is essentially equivalent to one assignment
statement per aggregate field plus an assignment to the discriminant in the
case of <code>enum</code>s.</p>
<h1><a class="header" href="#mir-visitor" id="mir-visitor">MIR visitor</a></h1>
<p>The MIR visitor is a convenient tool for traversing the MIR and either
looking for things or making changes to it. The visitor traits are
defined in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/visit/index.html">the <code>rustc::mir::visit</code> module</a> – there are two of
them, generated via a single macro: <code>Visitor</code> (which operates on a
<code>&amp;Mir</code> and gives back shared references) and <code>MutVisitor</code> (which
operates on a <code>&amp;mut Mir</code> and gives back mutable references).</p>
<p>To implement a visitor, you have to create a type that represents
your visitor. Typically, this type wants to &quot;hang on&quot; to whatever
state you will need while processing MIR:</p>
<pre><code class="language-rust ignore">struct MyVisitor&lt;...&gt; {
    tcx: TyCtxt&lt;'tcx&gt;,
    ...
}
</code></pre>
<p>and you then implement the <code>Visitor</code> or <code>MutVisitor</code> trait for that type:</p>
<pre><code class="language-rust ignore">impl&lt;'tcx&gt; MutVisitor&lt;'tcx&gt; for NoLandingPads {
    fn visit_foo(&amp;mut self, ...) {
        ...
        self.super_foo(...);
    }
}
</code></pre>
<p>As shown above, within the impl, you can override any of the
<code>visit_foo</code> methods (e.g., <code>visit_terminator</code>) in order to write some
code that will execute whenever a <code>foo</code> is found. If you want to
recursively walk the contents of the <code>foo</code>, you then invoke the
<code>super_foo</code> method. (NB. You never want to override <code>super_foo</code>.)</p>
<p>A very simple example of a visitor can be found in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/no_landing_pads/struct.NoLandingPads.html"><code>NoLandingPads</code></a>.
That visitor doesn't even require any state: it just visits all
terminators and removes their <code>unwind</code> successors.</p>
<h2><a class="header" href="#traversal" id="traversal">Traversal</a></h2>
<p>In addition the visitor, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/traversal/index.html">the <code>rustc::mir::traversal</code> module</a>
contains useful functions for walking the MIR CFG in
<a href="https://en.wikipedia.org/wiki/Tree_traversal">different standard orders</a> (e.g. pre-order, reverse
post-order, and so forth).</p>
<h1><a class="header" href="#mir-passes" id="mir-passes">MIR passes</a></h1>
<p>If you would like to get the MIR for a function (or constant, etc),
you can use the <code>optimized_mir(def_id)</code> query. This will give you back
the final, optimized MIR. For foreign def-ids, we simply read the MIR
from the other crate's metadata. But for local def-ids, the query will
construct the MIR and then iteratively optimize it by applying a
series of passes. This section describes how those passes work and how
you can extend them.</p>
<p>To produce the <code>optimized_mir(D)</code> for a given def-id <code>D</code>, the MIR
passes through several suites of optimizations, each represented by a
query. Each suite consists of multiple optimizations and
transformations. These suites represent useful intermediate points
where we want to access the MIR for type checking or other purposes:</p>
<ul>
<li><code>mir_build(D)</code> – not a query, but this constructs the initial MIR</li>
<li><code>mir_const(D)</code> – applies some simple transformations to make MIR ready for
constant evaluation;</li>
<li><code>mir_validated(D)</code> – applies some more transformations, making MIR ready for
borrow checking;</li>
<li><code>optimized_mir(D)</code> – the final state, after all optimizations have been
performed.</li>
</ul>
<h3><a class="header" href="#implementing-and-registering-a-pass" id="implementing-and-registering-a-pass">Implementing and registering a pass</a></h3>
<p>A <code>MirPass</code> is some bit of code that processes the MIR, typically –
but not always – transforming it along the way somehow. For example,
it might perform an optimization. The <code>MirPass</code> trait itself is found
in in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/">the <code>rustc_mir::transform</code> module</a>, and it
basically consists of one method, <code>run_pass</code>, that simply gets an
<code>&amp;mut Mir</code> (along with the tcx and some information about where it
came from). The MIR is therefore modified in place (which helps to
keep things efficient).</p>
<p>A good example of a basic MIR pass is <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/transform/no_landing_pads/struct.NoLandingPads.html"><code>NoLandingPads</code></a>, which walks
the MIR and removes all edges that are due to unwinding – this is
used when configured with <code>panic=abort</code>, which never unwinds. As you
can see from its source, a MIR pass is defined by first defining a
dummy type, a struct with no fields, something like:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct MyPass;
<span class="boring">}
</span></code></pre></pre>
<p>for which you then implement the <code>MirPass</code> trait. You can then insert
this pass into the appropriate list of passes found in a query like
<code>optimized_mir</code>, <code>mir_validated</code>, etc. (If this is an optimization, it
should go into the <code>optimized_mir</code> list.)</p>
<p>If you are writing a pass, there's a good chance that you are going to
want to use a <a href="rustc-guide/mir/./visitor.html">MIR visitor</a>. MIR visitors are a handy way to walk all
the parts of the MIR, either to search for something or to make small
edits.</p>
<h3><a class="header" href="#stealing" id="stealing">Stealing</a></h3>
<p>The intermediate queries <code>mir_const()</code> and <code>mir_validated()</code> yield up
a <code>&amp;'tcx Steal&lt;Mir&lt;'tcx&gt;&gt;</code>, allocated using
<code>tcx.alloc_steal_mir()</code>. This indicates that the result may be
<strong>stolen</strong> by the next suite of optimizations – this is an
optimization to avoid cloning the MIR. Attempting to use a stolen
result will cause a panic in the compiler. Therefore, it is important
that you do not read directly from these intermediate queries except as
part of the MIR processing pipeline.</p>
<p>Because of this stealing mechanism, some care must also be taken to
ensure that, before the MIR at a particular phase in the processing
pipeline is stolen, anyone who may want to read from it has already
done so. Concretely, this means that if you have some query <code>foo(D)</code>
that wants to access the result of <code>mir_const(D)</code> or
<code>mir_validated(D)</code>, you need to have the successor pass &quot;force&quot;
<code>foo(D)</code> using <code>ty::queries::foo::force(...)</code>. This will force a query
to execute even though you don't directly require its result.</p>
<p>As an example, consider MIR const qualification. It wants to read the
result produced by the <code>mir_const()</code> suite. However, that result will
be <strong>stolen</strong> by the <code>mir_validated()</code> suite. If nothing was done,
then <code>mir_const_qualif(D)</code> would succeed if it came before
<code>mir_validated(D)</code>, but fail otherwise. Therefore, <code>mir_validated(D)</code>
will <strong>force</strong> <code>mir_const_qualif</code> before it actually steals, thus
ensuring that the reads have already happened (remember that
<a href="rustc-guide/mir/../query.html">queries are memoized</a>, so executing a query twice
simply loads from a cache the second time):</p>
<pre><code class="language-text">mir_const(D) --read-by--&gt; mir_const_qualif(D)
     |                       ^
  stolen-by                  |
     |                    (forces)
     v                       |
mir_validated(D) ------------+
</code></pre>
<p>This mechanism is a bit dodgy. There is a discussion of more elegant
alternatives in <a href="https://github.com/rust-lang/rust/issues/41710">rust-lang/rust#41710</a>.</p>
<h1><a class="header" href="#mir-optimizations" id="mir-optimizations">MIR optimizations</a></h1>
<h1><a class="header" href="#mir-debugging" id="mir-debugging">MIR Debugging</a></h1>
<p>The <code>-Zdump-mir</code> flag can be used to dump a text representation of the MIR. The
<code>-Zdump-mir-graphviz</code> flag can be used to dump a <code>.dot</code> file that represents
MIR as a control-flow graph.</p>
<p><code>-Zdump-mir=F</code> is a handy compiler options that will let you view the MIR for
each function at each stage of compilation. <code>-Zdump-mir</code> takes a <strong>filter</strong> <code>F</code>
which allows you to control which functions and which passes you are
interesting in. For example:</p>
<pre><code class="language-bash">&gt; rustc -Zdump-mir=foo ...
</code></pre>
<p>This will dump the MIR for any function whose name contains <code>foo</code>; it
will dump the MIR both before and after every pass. Those files will
be created in the <code>mir_dump</code> directory. There will likely be quite a
lot of them!</p>
<pre><code class="language-bash">&gt; cat &gt; foo.rs
fn main() {
    println!(&quot;Hello, world!&quot;);
}
^D
&gt; rustc -Zdump-mir=main foo.rs
&gt; ls mir_dump/* | wc -l
     161
</code></pre>
<p>The files have names like <code>rustc.main.000-000.CleanEndRegions.after.mir</code>. These
names have a number of parts:</p>
<pre><code class="language-text">rustc.main.000-000.CleanEndRegions.after.mir
      ---- --- --- --------------- ----- either before or after
      |    |   |   name of the pass
      |    |   index of dump within the pass (usually 0, but some passes dump intermediate states)
      |    index of the pass
      def-path to the function etc being dumped
</code></pre>
<p>You can also make more selective filters. For example, <code>main &amp; CleanEndRegions</code>
will select for things that reference <em>both</em> <code>main</code> and the pass
<code>CleanEndRegions</code>:</p>
<pre><code class="language-bash">&gt; rustc -Zdump-mir='main &amp; CleanEndRegions' foo.rs
&gt; ls mir_dump
rustc.main.000-000.CleanEndRegions.after.mir	rustc.main.000-000.CleanEndRegions.before.mir
</code></pre>
<p>Filters can also have <code>|</code> parts to combine multiple sets of
<code>&amp;</code>-filters. For example <code>main &amp; CleanEndRegions | main &amp; NoLandingPads</code> will select <em>either</em> <code>main</code> and <code>CleanEndRegions</code> <em>or</em>
<code>main</code> and <code>NoLandingPads</code>:</p>
<pre><code class="language-bash">&gt; rustc -Zdump-mir='main &amp; CleanEndRegions | main &amp; NoLandingPads' foo.rs
&gt; ls mir_dump
rustc.main-promoted[0].002-000.NoLandingPads.after.mir
rustc.main-promoted[0].002-000.NoLandingPads.before.mir
rustc.main-promoted[0].002-006.NoLandingPads.after.mir
rustc.main-promoted[0].002-006.NoLandingPads.before.mir
rustc.main-promoted[1].002-000.NoLandingPads.after.mir
rustc.main-promoted[1].002-000.NoLandingPads.before.mir
rustc.main-promoted[1].002-006.NoLandingPads.after.mir
rustc.main-promoted[1].002-006.NoLandingPads.before.mir
rustc.main.000-000.CleanEndRegions.after.mir
rustc.main.000-000.CleanEndRegions.before.mir
rustc.main.002-000.NoLandingPads.after.mir
rustc.main.002-000.NoLandingPads.before.mir
rustc.main.002-006.NoLandingPads.after.mir
rustc.main.002-006.NoLandingPads.before.mir
</code></pre>
<p>(Here, the <code>main-promoted[0]</code> files refer to the MIR for &quot;promoted constants&quot;
that appeared within the <code>main</code> function.)</p>
<p>TODO: anything else?</p>
<h1><a class="header" href="#mir-borrow-check" id="mir-borrow-check">MIR borrow check</a></h1>
<p>The borrow check is Rust's &quot;secret sauce&quot; – it is tasked with
enforcing a number of properties:</p>
<ul>
<li>That all variables are initialized before they are used.</li>
<li>That you can't move the same value twice.</li>
<li>That you can't move a value while it is borrowed.</li>
<li>That you can't access a place while it is mutably borrowed (except through
the reference).</li>
<li>That you can't mutate a place while it is shared borrowed.</li>
<li>etc</li>
</ul>
<p>At the time of this writing, the code is in a state of transition. The
&quot;main&quot; borrow checker still works by processing <a href="rustc-guide/hir.html">the HIR</a>,
but that is being phased out in favor of the MIR-based borrow checker.
Accordingly, this documentation focuses on the new, MIR-based borrow
checker.</p>
<p>Doing borrow checking on MIR has several advantages:</p>
<ul>
<li>The MIR is <em>far</em> less complex than the HIR; the radical desugaring
helps prevent bugs in the borrow checker. (If you're curious, you
can see
<a href="https://github.com/rust-lang/rust/issues/47366">a list of bugs that the MIR-based borrow checker fixes here</a>.)</li>
<li>Even more importantly, using the MIR enables <a href="http://rust-lang.github.io/rfcs/2094-nll.html">&quot;non-lexical lifetimes&quot;</a>,
which are regions derived from the control-flow graph.</li>
</ul>
<h3><a class="header" href="#major-phases-of-the-borrow-checker" id="major-phases-of-the-borrow-checker">Major phases of the borrow checker</a></h3>
<p>The borrow checker source is found in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/index.html">the <code>rustc_mir::borrow_check</code> module</a>. The main entry point is
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/fn.mir_borrowck.html"><code>mir_borrowck</code></a> query.</p>
<ul>
<li>We first create a <strong>local copy</strong> of the MIR. In the coming steps,
we will modify this copy in place to modify the types and things to
include references to the new regions that we are computing.</li>
<li>We then invoke <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a> to modify our local MIR.
Among other things, this function will replace all of the <a href="rustc-guide/./appendix/glossary.html">regions</a> in
the MIR with fresh <a href="rustc-guide/./appendix/glossary.html">inference variables</a>.</li>
<li>Next, we perform a number of
<a href="rustc-guide/./appendix/background.html#dataflow">dataflow analyses</a> that
compute what data is moved and when.</li>
<li>We then do a <a href="rustc-guide/borrow_check/type_check.html">second type check</a> across the MIR:
the purpose of this type check is to determine all of the constraints between
different regions.</li>
<li>Next, we do <a href="rustc-guide/borrow_check/region_inference.html">region inference</a>, which computes
the values of each region — basically, the points in the control-flow graph where
each lifetime must be valid according to the constraints we collected.</li>
<li>At this point, we can compute the &quot;borrows in scope&quot; at each point.</li>
<li>Finally, we do a second walk over the MIR, looking at the actions it
does and reporting errors. For example, if we see a statement like
<code>*a + 1</code>, then we would check that the variable <code>a</code> is initialized
and that it is not mutably borrowed, as either of those would
require an error to be reported. Doing this check requires the results of all
the previous analyses.</li>
</ul>
<h1><a class="header" href="#tracking-moves-and-initialization" id="tracking-moves-and-initialization">Tracking moves and initialization</a></h1>
<p>Part of the borrow checker's job is to track which variables are
&quot;initialized&quot; at any given point in time -- this also requires
figuring out where moves occur and tracking those.</p>
<h2><a class="header" href="#initialization-and-moves" id="initialization-and-moves">Initialization and moves</a></h2>
<p>From a user's perspective, initialization -- giving a variable some
value -- and moves -- transferring ownership to another place -- might
seem like distinct topics. Indeed, our borrow checker error messages
often talk about them differently. But <strong>within the borrow checker</strong>,
they are not nearly as separate. Roughly speaking, the borrow checker
tracks the set of &quot;initialized places&quot; at any point in the source
code. Assigning to a previously uninitialized local variable adds it
to that set; moving from a local variable removes it from that set.</p>
<p>Consider this example:</p>
<pre><code class="language-rust ignore">fn foo() {
    let a: Vec&lt;u32&gt;;
    
    // a is not initialized yet
    
    a = vec![22];
    
    // a is initialized here
    
    std::mem::drop(a); // a is moved here
    
    // a is no longer initialized here

    let l = a.len(); //~ ERROR
}
</code></pre>
<p>Here you can see that <code>a</code> starts off as uninitialized; once it is
assigned, it becomes initialized. But when <code>drop(a)</code> is called, that
moves <code>a</code> into the call, and hence it becomes uninitialized again.</p>
<h2><a class="header" href="#subsections" id="subsections">Subsections</a></h2>
<p>To make it easier to peruse, this section is broken into a number of
subsections:</p>
<ul>
<li><a href="rustc-guide/borrow_check/./moves_and_initialization/move_paths.html">Move paths</a> the
<em>move path</em> concept that we use to track which local variables (or parts of
local variables, in some cases) are initialized.</li>
<li>TODO <em>Rest not yet written</em> =)</li>
</ul>
<h1><a class="header" href="#move-paths" id="move-paths">Move paths</a></h1>
<p>In reality, it's not enough to track initialization at the granularity
of local variables. Rust also allows us to do moves and initialization
at the field granularity:</p>
<pre><code class="language-rust ignore">fn foo() {
    let a: (Vec&lt;u32&gt;, Vec&lt;u32&gt;) = (vec![22], vec![44]);
    
    // a.0 and a.1 are both initialized
    
    let b = a.0; // moves a.0
    
    // a.0 is not initializd, but a.1 still is

    let c = a.0; // ERROR
    let d = a.1; // OK
}
</code></pre>
<p>To handle this, we track initialization at the granularity of a <strong>move
path</strong>. A <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePath.html"><code>MovePath</code></a> represents some location that the user can
initialize, move, etc. So e.g. there is a move-path representing the
local variable <code>a</code>, and there is a move-path representing <code>a.0</code>.  Move
paths roughly correspond to the concept of a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a> from MIR, but
they are indexed in ways that enable us to do move analysis more
efficiently.</p>
<h2><a class="header" href="#move-path-indices" id="move-path-indices">Move path indices</a></h2>
<p>Although there is a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePath.html"><code>MovePath</code></a> data structure, they are never referenced
directly.  Instead, all the code passes around <em>indices</em> of type
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>. If you need to get information about a move path, you use
this index with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MoveData.html#structfield.move_paths"><code>move_paths</code> field of the <code>MoveData</code></a>. For
example, to convert a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> <code>mpi</code> into a MIR <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a>, you might
access the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePath.html#structfield.place"><code>MovePath::place</code></a> field like so:</p>
<pre><code class="language-rust ignore">move_data.move_paths[mpi].place
</code></pre>
<h2><a class="header" href="#building-move-paths" id="building-move-paths">Building move paths</a></h2>
<p>One of the first things we do in the MIR borrow check is to construct
the set of move paths. This is done as part of the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MoveData.html#method.gather_moves"><code>MoveData::gather_moves</code></a> function. This function uses a MIR visitor
called <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/builder/struct.Gatherer.html"><code>Gatherer</code></a> to walk the MIR and look at how each <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a>
within is accessed. For each such <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a>, it constructs a
corresponding <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>. It also records when/where that
particular move path is moved/initialized, but we'll get to that in a
later section.</p>
<h3><a class="header" href="#illegal-move-paths" id="illegal-move-paths">Illegal move paths</a></h3>
<p>We don't actually create a move-path for <strong>every</strong> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a> that gets
used.  In particular, if it is illegal to move from a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a>, then
there is no need for a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>. Some examples:</p>
<ul>
<li>You cannot move from a static variable, so we do not create a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>
for static variables.</li>
<li>You cannot move an individual element of an array, so if we have e.g. <code>foo: [String; 3]</code>,
there would be no move-path for <code>foo[1]</code>.</li>
<li>You cannot move from inside of a borrowed reference, so if we have e.g. <code>foo: &amp;String</code>,
there would be no move-path for <code>*foo</code>.</li>
</ul>
<p>These rules are enforced by the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/builder/struct.Gatherer.html#method.move_path_for"><code>move_path_for</code></a> function, which
converts a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a> into a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> -- in error cases like
those just discussed, the function returns an <code>Err</code>. This in turn
means we don't have to bother tracking whether those places are
initialized (which lowers overhead).</p>
<h2><a class="header" href="#looking-up-a-move-path" id="looking-up-a-move-path">Looking up a move-path</a></h2>
<p>If you have a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a> and you would like to convert it to a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>, you 
can do that using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathLookup.html"><code>MovePathLookup</code></a> structure found in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MoveData.html#structfield.rev_lookup"><code>rev_lookup</code></a> field
of [<code>MoveData</code>]. There are two different methods:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathLookup.html#method.find_local"><code>find_local</code></a>, which takes a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/struct.Local.html"><code>mir::Local</code></a> representing a local
variable. This is the easier method, because we <strong>always</strong> create a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> for every local variable.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathLookup.html#method.find"><code>find</code></a>, which takes an arbitrary <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a>. This method is a bit
more annoying to use, precisely because we don't have a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> for <strong>every</strong> <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.Place.html"><code>Place</code></a> (as we just discussed in
the &quot;illegal move paths&quot; section). Therefore, <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathLookup.html#method.find"><code>find</code></a> returns a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/enum.LookupResult.html"><code>LookupResult</code></a> indicating the closest path it was able to find
that exists (e.g., for <code>foo[1]</code>, it might return just the path for
<code>foo</code>).</li>
</ul>
<h2><a class="header" href="#cross-references" id="cross-references">Cross-references</a></h2>
<p>As we noted above, move-paths are stored in a big vector and
referenced via their <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a>. However, within this vector,
they are also structured into a tree. So for example if you have the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/move_paths/struct.MovePathIndex.html"><code>MovePathIndex</code></a> for <code>a.b.c</code>, you can go to its parent move-path
<code>a.b</code>. You can also iterate over all children paths: so, from <code>a.b</code>,
you might iterate to find the path <code>a.b.c</code> (here you are iterating
just over the paths that are <strong>actually referenced</strong> in the source,
not all <strong>possible</strong> paths that could have been referenced). These
references are used for example in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/dataflow/at_location/struct.FlowAtLocation.html#method.has_any_child_of"><code>has_any_child_of</code></a> function,
which checks whether the dataflow results contain a value for the
given move-path (e.g., <code>a.b</code>) or any child of that move-path (e.g.,
<code>a.b.c</code>).</p>
<h1><a class="header" href="#the-mir-type-check" id="the-mir-type-check">The MIR type-check</a></h1>
<p>A key component of the borrow check is the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/type_check/index.html">MIR type-check</a>.
This check walks the MIR and does a complete &quot;type check&quot; -- the same
kind you might find in any other language. In the process of doing
this type-check, we also uncover the region constraints that apply to
the program.</p>
<p>TODO -- elaborate further? Maybe? :)</p>
<h1><a class="header" href="#region-inference-nll" id="region-inference-nll">Region inference (NLL)</a></h1>
<p>The MIR-based region checking code is located in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/index.html">the <code>rustc_mir::borrow_check::nll</code> module</a>. (NLL, of course,
stands for &quot;non-lexical lifetimes&quot;, a term that will hopefully be
deprecated once they become the standard kind of lifetime.)</p>
<p>The MIR-based region analysis consists of two major functions:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a>, invoked first, has two jobs:
<ul>
<li>First, it finds the set of regions that appear within the
signature of the function (e.g., <code>'a</code> in <code>fn foo&lt;'a&gt;(&amp;'a u32) { ... }</code>). These are called the &quot;universal&quot; or &quot;free&quot; regions – in
particular, they are the regions that <a href="rustc-guide/borrow_check/../appendix/background.html#free-vs-bound">appear free</a> in the
function body.</li>
<li>Second, it replaces all the regions from the function body with
fresh inference variables. This is because (presently) those
regions are the results of lexical region inference and hence are
not of much interest. The intention is that – eventually – they
will be &quot;erased regions&quot; (i.e., no information at all), since we
won't be doing lexical region inference at all.</li>
</ul>
</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.compute_regions.html"><code>compute_regions</code></a>, invoked second: this is given as argument the
results of move analysis. It has the job of computing values for all
the inference variables that <code>replace_regions_in_mir</code> introduced.
<ul>
<li>To do that, it first runs the <a href="rustc-guide/borrow_check/./type_check.html">MIR type checker</a>. This is
basically a normal type-checker but specialized to MIR, which is
much simpler than full Rust, of course. Running the MIR type
checker will however create various <a href="rustc-guide/borrow_check/./region_inference/constraint_propagation.html">constraints</a> between region
variables, indicating their potential values and relationships to
one another.</li>
<li>After this, we perform <a href="rustc-guide/borrow_check/./region_inference/constraint_propagation.html">constraint propagation</a> by creating a
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"><code>RegionInferenceContext</code></a> and invoking its <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.solve"><code>solve</code></a>
method.</li>
<li>The <a href="http://rust-lang.github.io/rfcs/2094-nll.html">NLL RFC</a> also includes fairly thorough (and hopefully readable)
coverage.</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#universal-regions" id="universal-regions">Universal regions</a></h2>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/universal_regions/struct.UniversalRegions.html"><code>UniversalRegions</code></a> type represents a collection of <em>universal</em> regions
corresponding to some MIR <code>DefId</code>. It is constructed in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a> when we replace all regions with fresh inference
variables. <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/universal_regions/struct.UniversalRegions.html"><code>UniversalRegions</code></a> contains indices for all the free regions in
the given MIR along with any relationships that are <em>known</em> to hold between
them (e.g. implied bounds, where clauses, etc.).</p>
<p>For example, given the MIR for the following function:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo&lt;'a&gt;(x: &amp;'a u32) {
    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>we would create a universal region for <code>'a</code> and one for <code>'static</code>. There may
also be some complications for handling closures, but we will ignore those for
the moment.</p>
<p>TODO: write about <em>how</em> these regions are computed.</p>
<p><a name="region-variables"></a></p>
<h2><a class="header" href="#region-variables" id="region-variables">Region variables</a></h2>
<p>The value of a region can be thought of as a <strong>set</strong>. This set contains all
points in the MIR where the region is valid along with any regions that are
outlived by this region (e.g. if <code>'a: 'b</code>, then <code>end('b)</code> is in the set for
<code>'a</code>); we call the domain of this set a <code>RegionElement</code>. In the code, the value
for all regions is maintained in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_mir/borrow_check/nll/region_infer/">the
<code>rustc_mir::borrow_check::nll::region_infer</code> module</a>. For each region we
maintain a set storing what elements are present in its value (to make this
efficient, we give each kind of element an index, the <code>RegionElementIndex</code>, and
use sparse bitsets).</p>
<p>The kinds of region elements are as follows:</p>
<ul>
<li>Each <strong>location</strong> in the MIR control-flow graph: a location is just
the pair of a basic block and an index. This identifies the point
<strong>on entry</strong> to the statement with that index (or the terminator, if
the index is equal to <code>statements.len()</code>).</li>
<li>There is an element <code>end('a)</code> for each universal region <code>'a</code>,
corresponding to some portion of the caller's (or caller's caller,
etc) control-flow graph.</li>
<li>Similarly, there is an element denoted <code>end('static)</code> corresponding
to the remainder of program execution after this function returns.</li>
<li>There is an element <code>!1</code> for each placeholder region <code>!1</code>. This
corresponds (intuitively) to some unknown set of other elements –
for details on placeholders, see the section
<a href="rustc-guide/borrow_check/region_inference.html#placeholder">placeholders and universes</a>.</li>
</ul>
<h2><a class="header" href="#constraints-1" id="constraints-1">Constraints</a></h2>
<p>Before we can infer the value of regions, we need to collect
constraints on the regions. The full set of constraints is described
in <a href="rustc-guide/borrow_check/./region_inference/constraint_propagation.html">the section on constraint propagation</a>, but the two most
common sorts of constraints are:</p>
<ol>
<li>Outlives constraints. These are constraints that one region outlives another
(e.g. <code>'a: 'b</code>). Outlives constraints are generated by the <a href="rustc-guide/borrow_check/./type_check.html">MIR type
checker</a>.</li>
<li>Liveness constraints. Each region needs to be live at points where it can be
used. These constraints are collected by <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/constraint_generation/fn.generate_constraints.html"><code>generate_constraints</code></a>.</li>
</ol>
<h2><a class="header" href="#inference-overview" id="inference-overview">Inference Overview</a></h2>
<p>So how do we compute the contents of a region? This process is called <em>region
inference</em>. The high-level idea is pretty simple, but there are some details we
need to take care of.</p>
<p>Here is the high-level idea: we start off each region with the MIR locations we
know must be in it from the liveness constraints. From there, we use all of the
outlives constraints computed from the type checker to <em>propagate</em> the
constraints: for each region <code>'a</code>, if <code>'a: 'b</code>, then we add all elements of
<code>'b</code> to <code>'a</code>, including <code>end('b)</code>. This all happens in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.propagate_constraints"><code>propagate_constraints</code></a>.</p>
<p>Then, we will check for errors. We first check that type tests are satisfied by
calling <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.check_type_tests"><code>check_type_tests</code></a>. This checks constraints like <code>T: 'a</code>. Second, we
check that universal regions are not &quot;too big&quot;. This is done by calling
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.check_universal_regions"><code>check_universal_regions</code></a>. This checks that for each region <code>'a</code> if <code>'a</code>
contains the element <code>end('b)</code>, then we must already know that <code>'a: 'b</code> holds
(e.g. from a where clause). If we don't already know this, that is an error...
well, almost. There is some special handling for closures that we will discuss
later.</p>
<h3><a class="header" href="#example-1" id="example-1">Example</a></h3>
<p>Consider the following example:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a, 'b&gt;(x: &amp;'a usize) -&gt; &amp;'b usize {
    x
}
</code></pre>
<p>Clearly, this should not compile because we don't know if <code>'a</code> outlives <code>'b</code>
(if it doesn't then the return value could be a dangling reference).</p>
<p>Let's back up a bit. We need to introduce some free inference variables (as is
done in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a>). This example doesn't use the exact regions
produced, but it (hopefully) is enough to get the idea across.</p>
<pre><code class="language-rust ignore">fn foo&lt;'a, 'b&gt;(x: &amp;'a /* '#1 */ usize) -&gt; &amp;'b /* '#3 */ usize {
    x // '#2, location L1
}
</code></pre>
<p>Some notation: <code>'#1</code>, <code>'#3</code>, and <code>'#2</code> represent the universal regions for the
argument, return value, and the expression <code>x</code>, respectively. Additionally, I
will call the location of the expression <code>x</code> <code>L1</code>.</p>
<p>So now we can use the liveness constraints to get the following starting points:</p>
<table><thead><tr><th>Region</th><th>Contents</th></tr></thead><tbody>
<tr><td>'#1</td><td></td></tr>
<tr><td>'#2</td><td><code>L1</code></td></tr>
<tr><td>'#3</td><td><code>L1</code></td></tr>
</tbody></table>
<p>Now we use the outlives constraints to expand each region. Specifically, we
know that <code>'#2: '#3</code> ...</p>
<table><thead><tr><th>Region</th><th>Contents</th></tr></thead><tbody>
<tr><td>'#1</td><td><code>L1</code></td></tr>
<tr><td>'#2</td><td><code>L1, end('#3) // add contents of '#3 and end('#3)</code></td></tr>
<tr><td>'#3</td><td><code>L1</code></td></tr>
</tbody></table>
<p>... and <code>'#1: '#2</code>, so ...</p>
<table><thead><tr><th>Region</th><th>Contents</th></tr></thead><tbody>
<tr><td>'#1</td><td><code>L1, end('#2), end('#3) // add contents of '#2 and end('#2)</code></td></tr>
<tr><td>'#2</td><td><code>L1, end('#3)</code></td></tr>
<tr><td>'#3</td><td><code>L1</code></td></tr>
</tbody></table>
<p>Now, we need to check that no regions were too big (we don't have any type
tests to check in this case). Notice that <code>'#1</code> now contains <code>end('#3)</code>, but
we have no <code>where</code> clause or implied bound to say that <code>'a: 'b</code>... that's an
error!</p>
<h3><a class="header" href="#some-details" id="some-details">Some details</a></h3>
<p>The <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"><code>RegionInferenceContext</code></a> type contains all of the information needed to
do inference, including the universal regions from <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a> and
the constraints computed for each region. It is constructed just after we
compute the liveness constraints.</p>
<p>Here are some of the fields of the struct:</p>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#structfield.constraints"><code>constraints</code></a>: contains all the outlives constraints.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#structfield.liveness_constraints"><code>liveness_constraints</code></a>: contains all the liveness constraints.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#structfield.universal_regions"><code>universal_regions</code></a>: contains the <code>UniversalRegions</code> returned by
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/fn.replace_regions_in_mir.html"><code>replace_regions_in_mir</code></a>.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#structfield.universal_region_relations"><code>universal_region_relations</code></a>: contains relations known to be true about
universal regions. For example, if we have a where clause that <code>'a: 'b</code>, that
relation is assumed to be true while borrow checking the implementation (it
is checked at the caller), so <code>universal_region_relations</code> would contain <code>'a: 'b</code>.</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#structfield.type_tests"><code>type_tests</code></a>: contains some constraints on types that we must check after
inference (e.g. <code>T: 'a</code>).</li>
<li><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#structfield.closure_bounds_mapping"><code>closure_bounds_mapping</code></a>: used for propagating region constraints from
closures back out to the creater of the closure.</li>
</ul>
<p>TODO: should we discuss any of the others fields? What about the SCCs?</p>
<p>Ok, now that we have constructed a <code>RegionInferenceContext</code>, we can do
inference. This is done by calling the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.solve"><code>solve</code></a> method on the context. This
is where we call <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.propagate_constraints"><code>propagate_constraints</code></a> and then check the resulting type
tests and universal regions, as discussed above.</p>
<h1><a class="header" href="#constraint-propagation" id="constraint-propagation">Constraint propagation</a></h1>
<p>The main work of the region inference is <strong>constraint propagation</strong>,
which is done in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.propagate_constraints"><code>propagate_constraints</code></a> function.  There are
three sorts of constraints that are used in NLL, and we'll explain how
<code>propagate_constraints</code> works by &quot;layering&quot; those sorts of constraints
on one at a time (each of them is fairly independent from the others):</p>
<ul>
<li>liveness constraints (<code>R live at E</code>), which arise from liveness;</li>
<li>outlives constraints (<code>R1: R2</code>), which arise from subtyping;</li>
<li><a href="rustc-guide/borrow_check/region_inference/./member_constraints.html">member constraints</a> (<code>member R_m of [R_c...]</code>), which arise from impl Trait.</li>
</ul>
<p>In this chapter, we'll explain the &quot;heart&quot; of constraint propagation,
covering both liveness and outlives constraints.</p>
<h2><a class="header" href="#notation-and-high-level-concepts" id="notation-and-high-level-concepts">Notation and high-level concepts</a></h2>
<p>Conceptually, region inference is a &quot;fixed-point&quot; computation. It is
given some set of constraints <code>{C}</code> and it computes a set of values
<code>Values: R -&gt; {E}</code> that maps each region <code>R</code> to a set of elements
<code>{E}</code> (see <a href="rustc-guide/borrow_check/region_inference/../region_inference.html#region-variables">here</a> for more notes on region elements):</p>
<ul>
<li>Initially, each region is mapped to an empty set, so <code>Values(R) = {}</code> for all regions <code>R</code>.</li>
<li>Next, we process the constraints repeatedly until a fixed-point is reached:
<ul>
<li>For each constraint C:
<ul>
<li>Update <code>Values</code> as needed to satisfy the constraint</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>As a simple example, if we have a liveness constraint <code>R live at E</code>,
then we can apply <code>Values(R) = Values(R) union {E}</code> to make the
constraint be satisfied. Similarly, if we have an outlives constraints
<code>R1: R2</code>, we can apply <code>Values(R1) = Values(R1) union Values(R2)</code>.
(Member constraints are more complex and we discuss them <a href="rustc-guide/borrow_check/region_inference/./member_constraints.html">in this section</a>.)</p>
<p>In practice, however, we are a bit more clever. Instead of applying
the constraints in a loop, we can analyze the constraints and figure
out the correct order to apply them, so that we only have to apply
each constraint once in order to find the final result.</p>
<p>Similarly, in the implementation, the <code>Values</code> set is stored in the
<code>scc_values</code> field, but they are indexed not by a <em>region</em> but by a
<em>strongly connected component</em> (SCC). SCCs are an optimization that
avoids a lot of redundant storage and computation.  They are explained
in the section on outlives constraints.</p>
<h2><a class="header" href="#liveness-constraints" id="liveness-constraints">Liveness constraints</a></h2>
<p>A <strong>liveness constraint</strong> arises when some variable whose type
includes a region R is live at some <a href="rustc-guide/borrow_check/region_inference/../../appendix/glossary.html">point</a> P. This simply means that
the value of R must include the point P. Liveness constraints are
computed by the MIR type checker.</p>
<p>A liveness constraint <code>R live at E</code> is satisfied if <code>E</code> is a member of
<code>Values(R)</code>. So to &quot;apply&quot; such a constraint to <code>Values</code>, we just have
to compute <code>Values(R) = Values(R) union {E}</code>.</p>
<p>The liveness values are computed in the type-check and passed to the
region inference upon creation in the <code>liveness_constraints</code> argument.
These are not represented as individual constraints like <code>R live at E</code>
though; instead, we store a (sparse) bitset per region variable (of
type <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/values/struct.LivenessValues.html"><code>LivenessValues</code></a>). This way we only need a single bit for each
liveness constraint.</p>
<p>One thing that is worth mentioning: All lifetime parameters are always
considered to be live over the entire function body. This is because
they correspond to some portion of the <em>caller's</em> execution, and that
execution clearly includes the time spent in this function, since the
caller is waiting for us to return.</p>
<h2><a class="header" href="#outlives-constraints" id="outlives-constraints">Outlives constraints</a></h2>
<p>An outlives constraint <code>'a: 'b</code> indicates that the value of <code>'a</code> must
be a <strong>superset</strong> of the value of <code>'b</code>. That is, an outlives
constraint <code>R1: R2</code> is satisfied if <code>Values(R1)</code> is a superset of
<code>Values(R2)</code>. So to &quot;apply&quot; such a constraint to <code>Values</code>, we just
have to compute <code>Values(R1) = Values(R1) union Values(R2)</code>.</p>
<p>One observation that follows from this is that if you have <code>R1: R2</code>
and <code>R2: R1</code>, then <code>R1 = R2</code> must be true. Similarly, if you have:</p>
<pre><code class="language-txt">R1: R2
R2: R3
R3: R4
R4: R1
</code></pre>
<p>then <code>R1 = R2 = R3 = R4</code> follows. We take advantage of this to make things
much faster, as described shortly.</p>
<p>In the code, the set of outlives constraints is given to the region
inference context on creation in a parameter of type
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/constraints/struct.OutlivesConstraintSet.html"><code>ConstraintSet</code></a>. The constraint set is basically just a list of <code>'a: 'b</code> constraints.</p>
<h3><a class="header" href="#the-outlives-constraint-graph-and-sccs" id="the-outlives-constraint-graph-and-sccs">The outlives constraint graph and SCCs</a></h3>
<p>In order to work more efficiently with outlives constraints, they are
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/constraints/struct.OutlivesConstraintSet.html#method.graph">converted into the form of a graph</a>, where the nodes of the
graph are region variables (<code>'a</code>, <code>'b</code>) and each constraint <code>'a: 'b</code>
induces an edge <code>'a -&gt; 'b</code>. This conversion happens in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.new"><code>RegionInferenceContext::new</code></a> function that creates the inference
context.</p>
<p>When using a graph representation, we can detect regions that must be equal
by looking for cycles. That is, if you have a constraint like</p>
<pre><code class="language-txt">'a: 'b
'b: 'c
'c: 'd
'd: 'a
</code></pre>
<p>then this will correspond to a cycle in the graph containing the
elements <code>'a...'d</code>.</p>
<p>Therefore, one of the first things that we do in propagating region
values is to compute the <strong>strongly connected components</strong> (SCCs) in
the constraint graph. The result is stored in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#structfield.constraint_sccs"><code>constraint_sccs</code></a>
field. You can then easily find the SCC that a region <code>r</code> is a part of
by invoking <code>constraint_sccs.scc(r)</code>.</p>
<p>Working in terms of SCCs allows us to be more efficient: if we have a
set of regions <code>'a...'d</code> that are part of a single SCC, we don't have
to compute/store their values separarely. We can just store one value
<strong>for the SCC</strong>, since they must all be equal.</p>
<p>If you look over the region inference code, you will see that a number
of fields are defined in terms of SCCs. For example, the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#structfield.scc_values"><code>scc_values</code></a> field stores the values of each SCC. To get the value
of a specific region <code>'a</code> then, we first figure out the SCC that the
region is a part of, and then find the value of that SCC.</p>
<p>When we compute SCCs, we not only figure out which regions are a
member of each SCC, we also figure out the edges between them. So for example
consider this set of outlives constraints:</p>
<pre><code class="language-txt">'a: 'b
'b: 'a

'a: 'c

'c: 'd
'd: 'c
</code></pre>
<p>Here we have two SCCs: S0 contains <code>'a</code> and <code>'b</code>, and S1 contains <code>'c</code>
and <code>'d</code>.  But these SCCs are not independent: because <code>'a: 'c</code>, that
means that <code>S0: S1</code> as well. That is -- the value of <code>S0</code> must be a
superset of the value of <code>S1</code>. One crucial thing is that this graph of
SCCs is always a DAG -- that is, it never has cycles. This is because
all the cycles have been removed to form the SCCs themselves.</p>
<h3><a class="header" href="#applying-liveness-constraints-to-sccs" id="applying-liveness-constraints-to-sccs">Applying liveness constraints to SCCs</a></h3>
<p>The liveness constraints that come in from the type-checker are
expressed in terms of regions -- that is, we have a map like
<code>Liveness: R -&gt; {E}</code>.  But we want our final result to be expressed
in terms of SCCs -- we can integrate these liveness constraints very
easily just by taking the union:</p>
<pre><code class="language-txt">for each region R:
  let S be the SCC that contains R
  Values(S) = Values(S) union Liveness(R)
</code></pre>
<p>In the region inferencer, this step is done in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.new"><code>RegionInferenceContext::new</code></a>.</p>
<h3><a class="header" href="#applying-outlives-constraints" id="applying-outlives-constraints">Applying outlives constraints</a></h3>
<p>Once we have computed the DAG of SCCs, we use that to structure out
entire computation. If we have an edge <code>S1 -&gt; S2</code> between two SCCs,
that means that <code>Values(S1) &gt;= Values(S2)</code> must hold. So, to compute
the value of <code>S1</code>, we first compute the values of each successor <code>S2</code>.
Then we simply union all of those values together. To use a
quasi-iterator-like notation:</p>
<pre><code class="language-txt">Values(S1) =
  s1.successors()
    .map(|s2| Values(s2))
    .union()
</code></pre>
<p>In the code, this work starts in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.propagate_constraints"><code>propagate_constraints</code></a>
function, which iterates over all the SCCs. For each SCC <code>S1</code>, we
compute its value by first computing the value of its
successors. Since SCCs form a DAG, we don't have to be concerned about
cycles, though we do need to keep a set around to track whether we
have already processed a given SCC or not. For each successor <code>S2</code>, once
we have computed <code>S2</code>'s value, we can union those elements into the
value for <code>S1</code>. (Although we have to be careful in this process to
properly handle <a href="rustc-guide/borrow_check/region_inference/./placeholders_and_universes.html">higher-ranked
placeholders</a>. Note that the value
for <code>S1</code> already contains the liveness constraints, since they were
added in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.new"><code>RegionInferenceContext::new</code></a>.</p>
<p>Once that process is done, we now have the &quot;minimal value&quot; for <code>S1</code>,
taking into account all of the liveness and outlives
constraints. However, in order to complete the process, we must also
consider <a href="rustc-guide/borrow_check/region_inference/./member_constraints.html">member constraints</a>, which are described in <a href="rustc-guide/borrow_check/region_inference/./member_constraints.html">a later
section</a>.</p>
<h1><a class="header" href="#universal-regions-1" id="universal-regions-1">Universal regions</a></h1>
<p>&quot;Universal regions&quot; is the name that the code uses to refer to &quot;named
lifetimes&quot; -- e.g., lifetime parameters and <code>'static</code>. The name
derives from the fact that such lifetimes are &quot;universally quantified&quot;
(i.e., we must make sure the code is true for all values of those
lifetimes). It is worth spending a bit of discussing how lifetime
parameters are handled during region inference. Consider this example:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a, 'b&gt;(x: &amp;'a u32, y: &amp;'b u32) -&gt; &amp;'b u32 {
  x
}
</code></pre>
<p>This example is intended not to compile, because we are returning <code>x</code>,
which has type <code>&amp;'a u32</code>, but our signature promises that we will
return a <code>&amp;'b u32</code> value. But how are lifetimes like <code>'a</code> and <code>'b</code>
integrated into region inference, and how this error wind up being
detected?</p>
<h2><a class="header" href="#universal-regions-and-their-relationships-to-one-another" id="universal-regions-and-their-relationships-to-one-another">Universal regions and their relationships to one another</a></h2>
<p>Early on in region inference, one of the first things we do is to
construct a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/universal_regions/struct.UniversalRegions.html"><code>UniversalRegions</code></a> struct. This struct tracks the
various universal regions in scope on a particular function.  We also
create a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/type_check/free_region_relations/struct.UniversalRegionRelations.html"><code>UniversalRegionRelations</code></a> struct, which tracks their
relationships to one another. So if you have e.g. <code>where 'a: 'b</code>, then
the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/type_check/free_region_relations/struct.UniversalRegionRelations.html"><code>UniversalRegionRelations</code></a> struct would track that <code>'a: 'b</code> is
known to hold (which could be tested with the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/type_check/free_region_relations/struct.UniversalRegionRelations.html#method.outlives"><code>outlives</code></a> function.</p>
<h2><a class="header" href="#everything-is-a-region-variable" id="everything-is-a-region-variable">Everything is a region variable</a></h2>
<p>One important aspect of how NLL region inference works is that <strong>all
lifetimes</strong> are represented as numbered variables. This means that the
only variant of <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/enum.RegionKind.html"><code>ty::RegionKind</code></a> that we use is the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/enum.RegionKind.html#variant.ReVar"><code>ReVar</code></a>
variant. These region variables are broken into two major categories,
based on their index:</p>
<ul>
<li>0..N: universal regions -- the ones we are discussing here. In this
case, the code must be correct with respect to any value of those
variables that meets the declared relationships.</li>
<li>N..M: existential regions -- inference variables where the region
inferencer is tasked with finding <em>some</em> suitable value.</li>
</ul>
<p>In fact, the universal regions can be further subdivided based on
where they were brought into scope (see the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/universal_regions/enum.RegionClassification.html#variant.Local"><code>RegionClassification</code></a>
type). These subdivions are not important for the topics discussed
here, but become important when we consider <a href="rustc-guide/borrow_check/region_inference/./closure_constraints.html">closure constraint
propagation</a>, so we discuss them there.</p>
<h2><a class="header" href="#universal-lifetimes-as-the-elements-of-a-regions-value" id="universal-lifetimes-as-the-elements-of-a-regions-value">Universal lifetimes as the elements of a region's value</a></h2>
<p>As noted previously, the value that we infer for each region is a set
<code>{E}</code>. The elements of this set can be points in the control-flow
graph, but they can also be an element <code>end('a)</code> corresponding to each
universal lifetime <code>'a</code>. If the value for some region <code>R0</code> includes
<code>end('a</code>), then this implies that <code>R0</code> must extend until the end of <code>'a</code>
in the caller.</p>
<h2><a class="header" href="#the-value-of-a-universal-region" id="the-value-of-a-universal-region">The &quot;value&quot; of a universal region</a></h2>
<p>During region inference, we compute a value for each universal region
in the same way as we compute values for other regions. This value
represents, effectively, the <strong>lower bound</strong> on that universal region
-- the things that it must outlive. We now describe how we use this
value to check for errors.</p>
<h2><a class="header" href="#liveness-and-universal-regions" id="liveness-and-universal-regions">Liveness and universal regions</a></h2>
<p>All universal regions have an initial liveness constraint that
includes the entire function body. This is because lifetime parameters
are defined in the caller and must include the entirety of the
function call that invokes this particular function. In addition, each
universal region <code>'a</code> includes itself (that is, <code>end('a)</code>) in its
liveness constraint (i.e., <code>'a</code> must extend until the end of
itself). In the code, these liveness constraints are setup in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.init_free_and_bound_regions"><code>init_free_and_bound_regions</code></a>.</p>
<h2><a class="header" href="#propagating-outlives-constraints-for-universal-regions" id="propagating-outlives-constraints-for-universal-regions">Propagating outlives constraints for universal regions</a></h2>
<p>So, consider the first example of this section:</p>
<pre><code class="language-rust ignore">fn foo&lt;'a, 'b&gt;(x: &amp;'a u32, y: &amp;'b u32) -&gt; &amp;'b u32 {
  x
}
</code></pre>
<p>Here, returning <code>x</code> requires that <code>&amp;'a u32 &lt;: &amp;'b u32</code>, which gives
rise to an outlives constraint <code>'a: 'b</code>. Combined with our default liveness
constraints we get:</p>
<pre><code class="language-txt">'a live at {B, end('a)} // B represents the &quot;function body&quot;
'b live at {B, end('b)}
'a: 'b
</code></pre>
<p>When we process the <code>'a: 'b</code> constraint, therefore, we will add
<code>end('b)</code> into the value for <code>'a</code>, resulting in a final value of <code>{B, end('a), end('b)}</code>.</p>
<h2><a class="header" href="#detecting-errors" id="detecting-errors">Detecting errors</a></h2>
<p>Once we have finished constraint propagation, we then enforce a
constraint that if some universal region <code>'a</code> includes an element
<code>end('b)</code>, then <code>'a: 'b</code> must be declared in the function's bounds. If
not, as in our example, that is an error. This check is done in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html#method.check_universal_regions"><code>check_universal_regions</code></a> function, which simply iterates over all
universal regions, inspects their final value, and tests against the
declared <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/type_check/free_region_relations/struct.UniversalRegionRelations.html"><code>UniversalRegionRelations</code></a>.</p>
<h1><a class="header" href="#member-constraints" id="member-constraints">Member constraints</a></h1>
<p>A member constraint <code>'m member of ['c_1..'c_N]</code> expresses that the
region <code>'m</code> must be <em>equal</em> to some <strong>choice regions</strong> <code>'c_i</code> (for
some <code>i</code>). These constraints cannot be expressed by users, but they
arise from <code>impl Trait</code> due to its lifetime capture rules. Consider a
function such as the following:</p>
<pre><code class="language-rust ignore">fn make(a: &amp;'a u32, b: &amp;'b u32) -&gt; impl Trait&lt;'a, 'b&gt; { .. }
</code></pre>
<p>Here, the true return type (often called the &quot;hidden type&quot;) is only
permitted to capture the lifetimes <code>'a</code> or <code>'b</code>. You can kind of see
this more clearly by desugaring that <code>impl Trait</code> return type into its
more explicit form:</p>
<pre><code class="language-rust ignore">type MakeReturn&lt;'x, 'y&gt; = impl Trait&lt;'x, 'y&gt;;
fn make(a: &amp;'a u32, b: &amp;'b u32) -&gt; MakeReturn&lt;'a, 'b&gt; { .. }
</code></pre>
<p>Here, the idea is that the hidden type must be some type that could
have been written in place of the <code>impl Trait&lt;'x, 'y&gt;</code> -- but clearly
such a type can only reference the regions <code>'x</code> or <code>'y</code> (or
<code>'static</code>!), as those are the only names in scope. This limitation is
then translated into a restriction to only access <code>'a</code> or <code>'b</code> because
we are returning <code>MakeReturn&lt;'a, 'b&gt;</code>, where <code>'x</code> and <code>'y</code> have been
replaced with <code>'a</code> and <code>'b</code> respectively.</p>
<h2><a class="header" href="#detailed-example" id="detailed-example">Detailed example</a></h2>
<p>To help us explain member constraints in more detail, let's spell out
the <code>make</code> example in a bit more detail. First off, let's assume that
you have some dummy trait:</p>
<pre><code class="language-rust ignore">trait Trait&lt;'a, 'b&gt; { }
impl&lt;T&gt; Trait&lt;'_, '_&gt; for T { }
</code></pre>
<p>and this is the <code>make</code> function (in desugared form):</p>
<pre><code class="language-rust ignore">type MakeReturn&lt;'x, 'y&gt; = impl Trait&lt;'x, 'y&gt;;
fn make(a: &amp;'a u32, b: &amp;'b u32) -&gt; MakeReturn&lt;'a, 'b&gt; {
  (a, b)
}
</code></pre>
<p>What happens in this case is that the return type will be <code>(&amp;'0 u32, &amp;'1 u32)</code>,
where <code>'0</code> and <code>'1</code> are fresh region variables. We will have the following
region constraints:</p>
<pre><code class="language-txt">'0 live at {L}
'1 live at {L}
'a: '0
'b: '1
'0 member of ['a, 'b, 'static]
'1 member of ['a, 'b, 'static]
</code></pre>
<p>Here the &quot;liveness set&quot; <code>{L}</code> corresponds to that subset of the body
where <code>'0</code> and <code>'1</code> are live -- basically the point from where the
return tuple is constructed to where it is returned (in fact, <code>'0</code> and
<code>'1</code> might have slightly different liveness sets, but that's not very
interesting to the point we are illustrating here).</p>
<p>The <code>'a: '0</code> and <code>'b: '1</code> constraints arise from subtyping. When we
construct the <code>(a, b)</code> value, it will be assigned type <code>(&amp;'0 u32, &amp;'1 u32)</code> -- the region variables reflect that the lifetimes of these
references could be made smaller. For this value to be created from
<code>a</code> and <code>b</code>, however, we do require that:</p>
<pre><code class="language-txt">(&amp;'a u32, &amp;'b u32) &lt;: (&amp;'0 u32, &amp;'1 u32)
</code></pre>
<p>which means in turn that <code>&amp;'a u32 &lt;: &amp;'0 u32</code> and hence that <code>'a: '0</code>
(and similarly that <code>&amp;'b u32 &lt;: &amp;'1 u32</code>, <code>'b: '1</code>).</p>
<p>Note that if we ignore member constraints, the value of <code>'0</code> would be
inferred to some subset of the function body (from the liveness
constraints, which we did not write explicitly). It would never become
<code>'a</code>, because there is no need for it too -- we have a constraint that
<code>'a: '0</code>, but that just puts a &quot;cap&quot; on how <em>large</em> <code>'0</code> can grow to
become. Since we compute the <em>minimal</em> value that we can, we are happy
to leave <code>'0</code> as being just equal to the liveness set. This is where
member constraints come in.</p>
<h2><a class="header" href="#choices-are-always-lifetime-parameters" id="choices-are-always-lifetime-parameters">Choices are always lifetime parameters</a></h2>
<p>At present, the &quot;choice&quot; regions from a member constraint are always
lifetime parameters from the current function. This falls out from the
placement of impl Trait, though in the future it may not be the case.
We take some advantage of this fact, as it simplifies the current
code. In particular, we don't have to consider a case like <code>'0 member of ['1, 'static]</code>, in which the value of both <code>'0</code> and <code>'1</code> are being
inferred and hence changing. See [rust-lang/rust#61773] for more
information.</p>
<h2><a class="header" href="#applying-member-constraints" id="applying-member-constraints">Applying member constraints</a></h2>
<p>Member constraints are a bit more complex than other forms of
constraints. This is because they have a &quot;or&quot; quality to them -- that
is, they describe multiple choices that we must select from. E.g., in
our example constraint <code>'0 member of ['a, 'b, 'static]</code>, it might be
that <code>'0</code> is equal to <code>'a</code>, <code>'b</code>, <em>or</em> <code>'static</code>. How can we pick the
correct one?  What we currently do is to look for a <em>minimal choice</em>
-- if we find one, then we will grow <code>'0</code> to be equal to that minimal
choice. To find that minimal choice, we take two factors into
consideration: lower and upper bounds.</p>
<h3><a class="header" href="#lower-bounds" id="lower-bounds">Lower bounds</a></h3>
<p>The <em>lower bounds</em> are those lifetimes that <code>'0</code> <em>must outlive</em> --
i.e., that <code>'0</code> must be larger than. In fact, when it comes time to
apply member constraints, we've already <em>computed</em> the lower bounds of
<code>'0</code> because we computed its minimal value (or at least, the lower
bounds considering everything but member constraints).</p>
<p>Let <code>LB</code> be the current value of <code>'0</code>. We know then that <code>'0: LB</code> must
hold, whatever the final value of <code>'0</code> is. Therefore, we can rule out
any choice <code>'choice</code> where <code>'choice: LB</code> does not hold.</p>
<p>Unfortunately, in our example, this is not very helpful. The lower
bound for <code>'0</code> will just be the liveness set <code>{L}</code>, and we know that
all the lifetime parameters outlive that set. So we are left with the
same set of choices here. (But in other examples, particularly those
with different variance, lower bound constraints may be relevant.)</p>
<h3><a class="header" href="#upper-bounds" id="upper-bounds">Upper bounds</a></h3>
<p>The <em>upper bounds</em> are those lifetimes that <em>must outlive</em> <code>'0</code> --
i.e., that <code>'0</code> must be <em>smaller</em> than. In our example, this would be
<code>'a</code>, because we have the constraint that <code>'a: '0</code>. In more complex
examples, the chain may be more indirect.</p>
<p>We can use upper bounds to rule out members in a very similar way to
lower lower bounds. If UB is some upper bound, then we know that <code>UB: '0</code> must hold, so we can rule out any choice <code>'choice</code> where <code>UB: 'choice</code> does not hold.</p>
<p>In our example, we would be able to reduce our choice set from <code>['a, 'b, 'static]</code> to just <code>['a]</code>. This is because <code>'0</code> has an upper bound
of <code>'a</code>, and neither <code>'a: 'b</code> nor <code>'a: 'static</code> is known to hold.</p>
<p>(For notes on how we collect upper bounds in the implementation, see
<a href="rustc-guide/borrow_check/region_inference/member_constraints.html#collecting">the section below</a>.)</p>
<h3><a class="header" href="#minimal-choice" id="minimal-choice">Minimal choice</a></h3>
<p>After applying lower and upper bounds, we can still sometimes have
multiple possibilities. For example, imagine a variant of our example
using types with the opposite variance. In that case, we would have
the constraint <code>'0: 'a</code> instead of <code>'a: '0</code>. Hence the current value
of <code>'0</code> would be <code>{L, 'a}</code>. Using this as a lower bound, we would be
able to narrow down the member choices to <code>['a, 'static]</code> because <code>'b: 'a</code> is not known to hold (but <code>'a: 'a</code> and <code>'static: 'a</code> do hold). We
would not have any upper bounds, so that would be our final set of choices.</p>
<p>In that case, we apply the <strong>minimal choice</strong> rule -- basically, if
one of our choices if smaller than the others, we can use that. In
this case, we would opt for <code>'a</code> (and not <code>'static</code>).</p>
<p>This choice is consistent with the general 'flow' of region
propagation, which always aims to compute a minimal value for the
region being inferred. However, it is somewhat arbitrary.</p>
<p><a name="collecting"></a></p>
<h3><a class="header" href="#collecting-upper-bounds-in-the-implementation" id="collecting-upper-bounds-in-the-implementation">Collecting upper bounds in the implementation</a></h3>
<p>In practice, computing upper bounds is a bit inconvenient, because our
data structures are setup for the opposite. What we do is to compute
the <strong>reverse SCC graph</strong> (we do this lazilly and cache the result) --
that is, a graph where <code>'a: 'b</code> induces an edge <code>SCC('b) -&gt; SCC('a)</code>. Like the normal SCC graph, this is a DAG. We can then do a
depth-first search starting from <code>SCC('0)</code> in this graph. This will
take us to all the SCCs that must outlive <code>'0</code>. </p>
<p>One wrinkle is that, as we walk the &quot;upper bound&quot; SCCs, their values
will not yet have been fully computed. However, we <strong>have</strong> already
applied their liveness constraints, so we have some information about
their value. In particular, for any regions representing lifetime
parameters, their value will contain themselves (i.e., the initial
value for <code>'a</code> includes <code>'a</code> and the value for <code>'b</code> contains <code>'b</code>). So
we can collect all of the lifetime parameters that are reachable,
which is precisely what we are interested in.</p>
<h1><a class="header" href="#placeholders-and-universes" id="placeholders-and-universes">Placeholders and universes</a></h1>
<p>From time to time we have to reason about regions that we can't
concretely know. For example, consider this program:</p>
<pre><code class="language-rust ignore">// A function that needs a static reference
fn foo(x: &amp;'static u32) { }

fn bar(f: for&lt;'a&gt; fn(&amp;'a u32)) {
       // ^^^^^^^^^^^^^^^^^^^ a function that can accept **any** reference
    let x = 22;
    f(&amp;x);
}

fn main() {
    bar(foo);
}
</code></pre>
<p>This program ought not to type-check: <code>foo</code> needs a static reference
for its argument, and <code>bar</code> wants to be given a function that that
accepts <strong>any</strong> reference (so it can call it with something on its
stack, for example). But <em>how</em> do we reject it and <em>why</em>?</p>
<h2><a class="header" href="#subtyping-and-placeholders" id="subtyping-and-placeholders">Subtyping and Placeholders</a></h2>
<p>When we type-check <code>main</code>, and in particular the call <code>bar(foo)</code>, we
are going to wind up with a subtyping relationship like this one:</p>
<pre><code class="language-text">fn(&amp;'static u32) &lt;: for&lt;'a&gt; fn(&amp;'a u32)
----------------    -------------------
the type of `foo`   the type `bar` expects
</code></pre>
<p>We handle this sort of subtyping by taking the variables that are
bound in the supertype and replacing them with
<a href="rustc-guide/borrow_check/region_inference/../../appendix/background.html#quantified">universally quantified</a>
representatives, denoted like <code>!1</code> here. We call these regions &quot;placeholder
regions&quot; – they represent, basically, &quot;some unknown region&quot;.</p>
<p>Once we've done that replacement, we have the following relation:</p>
<pre><code class="language-text">fn(&amp;'static u32) &lt;: fn(&amp;'!1 u32)
</code></pre>
<p>The key idea here is that this unknown region <code>'!1</code> is not related to
any other regions. So if we can prove that the subtyping relationship
is true for <code>'!1</code>, then it ought to be true for any region, which is
what we wanted.</p>
<p>So let's work through what happens next. To check if two functions are
subtypes, we check if their arguments have the desired relationship
(fn arguments are <a href="rustc-guide/borrow_check/region_inference/../../appendix/background.html#variance">contravariant</a>, so
we swap the left and right here):</p>
<pre><code class="language-text">&amp;'!1 u32 &lt;: &amp;'static u32
</code></pre>
<p>According to the basic subtyping rules for a reference, this will be
true if <code>'!1: 'static</code>. That is – if &quot;some unknown region <code>!1</code>&quot; lives
outlives <code>'static</code>. Now, this <em>might</em> be true – after all, <code>'!1</code>
could be <code>'static</code> – but we don't <em>know</em> that it's true. So this
should yield up an error (eventually).</p>
<h2><a class="header" href="#what-is-a-universe" id="what-is-a-universe">What is a universe?</a></h2>
<p>In the previous section, we introduced the idea of a placeholder
region, and we denoted it <code>!1</code>. We call this number <code>1</code> the <strong>universe
index</strong>. The idea of a &quot;universe&quot; is that it is a set of names that
are in scope within some type or at some point. Universes are formed
into a tree, where each child extends its parents with some new names.
So the <strong>root universe</strong> conceptually contains global names, such as
the the lifetime <code>'static</code> or the type <code>i32</code>. In the compiler, we also
put generic type parameters into this root universe (in this sense,
there is not just one root universe, but one per item). So consider
this function <code>bar</code>:</p>
<pre><code class="language-rust ignore">struct Foo { }

fn bar&lt;'a, T&gt;(t: &amp;'a T) {
    ...
}
</code></pre>
<p>Here, the root universe would consist of the lifetimes <code>'static</code> and
<code>'a</code>.  In fact, although we're focused on lifetimes here, we can apply
the same concept to types, in which case the types <code>Foo</code> and <code>T</code> would
be in the root universe (along with other global types, like <code>i32</code>).
Basically, the root universe contains all the names that
<a href="rustc-guide/borrow_check/region_inference/../../appendix/background.html#free-vs-bound">appear free</a> in the body of <code>bar</code>.</p>
<p>Now let's extend <code>bar</code> a bit by adding a variable <code>x</code>:</p>
<pre><code class="language-rust ignore">fn bar&lt;'a, T&gt;(t: &amp;'a T) {
    let x: for&lt;'b&gt; fn(&amp;'b u32) = ...;
}
</code></pre>
<p>Here, the name <code>'b</code> is not part of the root universe. Instead, when we
&quot;enter&quot; into this <code>for&lt;'b&gt;</code> (e.g., by replacing it with a placeholder), we will create
a child universe of the root, let's call it U1:</p>
<pre><code class="language-text">U0 (root universe)
│
└─ U1 (child universe)
</code></pre>
<p>The idea is that this child universe U1 extends the root universe U0
with a new name, which we are identifying by its universe number:
<code>!1</code>.</p>
<p>Now let's extend <code>bar</code> a bit by adding one more variable, <code>y</code>:</p>
<pre><code class="language-rust ignore">fn bar&lt;'a, T&gt;(t: &amp;'a T) {
    let x: for&lt;'b&gt; fn(&amp;'b u32) = ...;
    let y: for&lt;'c&gt; fn(&amp;'b u32) = ...;
}
</code></pre>
<p>When we enter <em>this</em> type, we will again create a new universe, which
we'll call <code>U2</code>. Its parent will be the root universe, and U1 will be
its sibling:</p>
<pre><code class="language-text">U0 (root universe)
│
├─ U1 (child universe)
│
└─ U2 (child universe)
</code></pre>
<p>This implies that, while in U2, we can name things from U0 or U2, but
not U1.</p>
<p><strong>Giving existential variables a universe.</strong> Now that we have this
notion of universes, we can use it to extend our type-checker and
things to prevent illegal names from leaking out. The idea is that we
give each inference (existential) variable – whether it be a type or
a lifetime – a universe. That variable's value can then only
reference names visible from that universe. So for example if a
lifetime variable is created in U0, then it cannot be assigned a value
of <code>!1</code> or <code>!2</code>, because those names are not visible from the universe
U0.</p>
<p><strong>Representing universes with just a counter.</strong> You might be surprised
to see that the compiler doesn't keep track of a full tree of
universes. Instead, it just keeps a counter – and, to determine if
one universe can see another one, it just checks if the index is
greater. For example, U2 can see U0 because 2 &gt;= 0. But U0 cannot see
U2, because 0 &gt;= 2 is false.</p>
<p>How can we get away with this? Doesn't this mean that we would allow
U2 to also see U1? The answer is that, yes, we would, <strong>if that
question ever arose</strong>.  But because of the structure of our type
checker etc, there is no way for that to happen. In order for
something happening in the universe U1 to &quot;communicate&quot; with something
happening in U2, they would have to have a shared inference variable X
in common. And because everything in U1 is scoped to just U1 and its
children, that inference variable X would have to be in U0. And since
X is in U0, it cannot name anything from U1 (or U2). This is perhaps easiest
to see by using a kind of generic &quot;logic&quot; example:</p>
<pre><code class="language-text">exists&lt;X&gt; {
   forall&lt;Y&gt; { ... /* Y is in U1 ... */ }
   forall&lt;Z&gt; { ... /* Z is in U2 ... */ }
}
</code></pre>
<p>Here, the only way for the two foralls to interact would be through X,
but neither Y nor Z are in scope when X is declared, so its value
cannot reference either of them.</p>
<h2><a class="header" href="#universes-and-placeholder-region-elements" id="universes-and-placeholder-region-elements">Universes and placeholder region elements</a></h2>
<p>But where does that error come from?  The way it happens is like this.
When we are constructing the region inference context, we can tell
from the type inference context how many placeholder variables exist
(the <code>InferCtxt</code> has an internal counter). For each of those, we
create a corresponding universal region variable <code>!n</code> and a &quot;region
element&quot; <code>placeholder(n)</code>. This corresponds to &quot;some unknown set of other
elements&quot;. The value of <code>!n</code> is <code>{placeholder(n)}</code>.</p>
<p>At the same time, we also give each existential variable a
<strong>universe</strong> (also taken from the <code>InferCtxt</code>). This universe
determines which placeholder elements may appear in its value: For
example, a variable in universe U3 may name <code>placeholder(1)</code>, <code>placeholder(2)</code>, and
<code>placeholder(3)</code>, but not <code>placeholder(4)</code>. Note that the universe of an inference
variable controls what region elements <strong>can</strong> appear in its value; it
does not say region elements <strong>will</strong> appear.</p>
<h2><a class="header" href="#placeholders-and-outlives-constraints" id="placeholders-and-outlives-constraints">Placeholders and outlives constraints</a></h2>
<p>In the region inference engine, outlives constraints have the form:</p>
<pre><code class="language-text">V1: V2 @ P
</code></pre>
<p>where <code>V1</code> and <code>V2</code> are region indices, and hence map to some region
variable (which may be universally or existentially quantified). The
<code>P</code> here is a &quot;point&quot; in the control-flow graph; it's not important
for this section. This variable will have a universe, so let's call
those universes <code>U(V1)</code> and <code>U(V2)</code> respectively. (Actually, the only
one we are going to care about is <code>U(V1)</code>.)</p>
<p>When we encounter this constraint, the ordinary procedure is to start
a DFS from <code>P</code>. We keep walking so long as the nodes we are walking
are present in <code>value(V2)</code> and we add those nodes to <code>value(V1)</code>. If
we reach a return point, we add in any <code>end(X)</code> elements. That part
remains unchanged.</p>
<p>But then <em>after that</em> we want to iterate over the placeholder <code>placeholder(x)</code>
elements in V2 (each of those must be visible to <code>U(V2)</code>, but we
should be able to just assume that is true, we don't have to check
it). We have to ensure that <code>value(V1)</code> outlives each of those
placeholder elements.</p>
<p>Now there are two ways that could happen. First, if <code>U(V1)</code> can see
the universe <code>x</code> (i.e., <code>x &lt;= U(V1)</code>), then we can just add <code>placeholder(x)</code>
to <code>value(V1)</code> and be done. But if not, then we have to approximate:
we may not know what set of elements <code>placeholder(x)</code> represents, but we
should be able to compute some sort of <strong>upper bound</strong> B for it –
some region B that outlives <code>placeholder(x)</code>. For now, we'll just use
<code>'static</code> for that (since it outlives everything) – in the future, we
can sometimes be smarter here (and in fact we have code for doing this
already in other contexts). Moreover, since <code>'static</code> is in the root
universe U0, we know that all variables can see it – so basically if
we find that <code>value(V2)</code> contains <code>placeholder(x)</code> for some universe <code>x</code>
that <code>V1</code> can't see, then we force <code>V1</code> to <code>'static</code>.</p>
<h2><a class="header" href="#extending-the-universal-regions-check" id="extending-the-universal-regions-check">Extending the &quot;universal regions&quot; check</a></h2>
<p>After all constraints have been propagated, the NLL region inference
has one final check, where it goes over the values that wound up being
computed for each universal region and checks that they did not get
'too large'. In our case, we will go through each placeholder region
and check that it contains <em>only</em> the <code>placeholder(u)</code> element it is known to
outlive. (Later, we might be able to know that there are relationships
between two placeholder regions and take those into account, as we do
for universal regions from the fn signature.)</p>
<p>Put another way, the &quot;universal regions&quot; check can be considered to be
checking constraints like:</p>
<pre><code class="language-text">{placeholder(1)}: V1
</code></pre>
<p>where <code>{placeholder(1)}</code> is like a constant set, and V1 is the variable we
made to represent the <code>!1</code> region.</p>
<h2><a class="header" href="#back-to-our-example" id="back-to-our-example">Back to our example</a></h2>
<p>OK, so far so good. Now let's walk through what would happen with our
first example:</p>
<pre><code class="language-text">fn(&amp;'static u32) &lt;: fn(&amp;'!1 u32) @ P  // this point P is not imp't here
</code></pre>
<p>The region inference engine will create a region element domain like this:</p>
<pre><code class="language-text">{ CFG; end('static); placeholder(1) }
  ---  ------------  ------- from the universe `!1`
  |    'static is always in scope
  all points in the CFG; not especially relevant here
</code></pre>
<p>It will always create two universal variables, one representing
<code>'static</code> and one representing <code>'!1</code>. Let's call them Vs and V1. They
will have initial values like so:</p>
<pre><code class="language-text">Vs = { CFG; end('static) } // it is in U0, so can't name anything else
V1 = { placeholder(1) }
</code></pre>
<p>From the subtyping constraint above, we would have an outlives constraint like</p>
<pre><code class="language-text">'!1: 'static @ P
</code></pre>
<p>To process this, we would grow the value of V1 to include all of Vs:</p>
<pre><code class="language-text">Vs = { CFG; end('static) }
V1 = { CFG; end('static), placeholder(1) }
</code></pre>
<p>At that point, constraint propagation is complete, because all the
outlives relationships are satisfied. Then we would go to the &quot;check
universal regions&quot; portion of the code, which would test that no
universal region grew too large.</p>
<p>In this case, <code>V1</code> <em>did</em> grow too large – it is not known to outlive
<code>end('static)</code>, nor any of the CFG – so we would report an error.</p>
<h2><a class="header" href="#another-example" id="another-example">Another example</a></h2>
<p>What about this subtyping relationship?</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32)
    &lt;:
for&lt;'b, 'c&gt; fn(&amp;'b u32, &amp;'c u32)
</code></pre>
<p>Here we would replace the bound region in the supertype with a placeholder, as before, yielding:</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32)
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32)
</code></pre>
<p>then we instantiate the variable on the left-hand side with an
existential in universe U2, yielding the following (<code>?n</code> is a notation
for an existential variable):</p>
<pre><code class="language-text">fn(&amp;'?3 u32, &amp;'?3 u32)
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32)
</code></pre>
<p>Then we break this down further:</p>
<pre><code class="language-text">&amp;'!1 u32 &lt;: &amp;'?3 u32
&amp;'!2 u32 &lt;: &amp;'?3 u32
</code></pre>
<p>and even further, yield up our region constraints:</p>
<pre><code class="language-text">'!1: '?3
'!2: '?3
</code></pre>
<p>Note that, in this case, both <code>'!1</code> and <code>'!2</code> have to outlive the
variable <code>'?3</code>, but the variable <code>'?3</code> is not forced to outlive
anything else. Therefore, it simply starts and ends as the empty set
of elements, and hence the type-check succeeds here.</p>
<p>(This should surprise you a little. It surprised me when I first realized it.
We are saying that if we are a fn that <strong>needs both of its arguments to have
the same region</strong>, we can accept being called with <strong>arguments with two
distinct regions</strong>. That seems intuitively unsound. But in fact, it's fine, as
I tried to explain in <a href="https://github.com/rust-lang/rust/issues/32330#issuecomment-202536977">this issue</a> on the Rust issue
tracker long ago.  The reason is that even if we get called with arguments of
two distinct lifetimes, those two lifetimes have some intersection (the call
itself), and that intersection can be our value of <code>'a</code> that we use as the
common lifetime of our arguments. -nmatsakis)</p>
<h2><a class="header" href="#final-example" id="final-example">Final example</a></h2>
<p>Let's look at one last example. We'll extend the previous one to have
a return type:</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32) -&gt; &amp;'a u32
    &lt;:
for&lt;'b, 'c&gt; fn(&amp;'b u32, &amp;'c u32) -&gt; &amp;'b u32
</code></pre>
<p>Despite seeming very similar to the previous example, this case is going to get
an error. That's good: the problem is that we've gone from a fn that promises
to return one of its two arguments, to a fn that is promising to return the
first one. That is unsound. Let's see how it plays out.</p>
<p>First, we replace the bound region in the supertype with a placeholder:</p>
<pre><code class="language-text">for&lt;'a&gt; fn(&amp;'a u32, &amp;'a u32) -&gt; &amp;'a u32
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32) -&gt; &amp;'!1 u32
</code></pre>
<p>Then we instantiate the subtype with existentials (in U2):</p>
<pre><code class="language-text">fn(&amp;'?3 u32, &amp;'?3 u32) -&gt; &amp;'?3 u32
    &lt;:
fn(&amp;'!1 u32, &amp;'!2 u32) -&gt; &amp;'!1 u32
</code></pre>
<p>And now we create the subtyping relationships:</p>
<pre><code class="language-text">&amp;'!1 u32 &lt;: &amp;'?3 u32 // arg 1
&amp;'!2 u32 &lt;: &amp;'?3 u32 // arg 2
&amp;'?3 u32 &lt;: &amp;'!1 u32 // return type
</code></pre>
<p>And finally the outlives relationships. Here, let V1, V2, and V3 be the
variables we assign to <code>!1</code>, <code>!2</code>, and <code>?3</code> respectively:</p>
<pre><code class="language-text">V1: V3
V2: V3
V3: V1
</code></pre>
<p>Those variables will have these initial values:</p>
<pre><code class="language-text">V1 in U1 = {placeholder(1)}
V2 in U2 = {placeholder(2)}
V3 in U2 = {}
</code></pre>
<p>Now because of the <code>V3: V1</code> constraint, we have to add <code>placeholder(1)</code> into <code>V3</code> (and
indeed it is visible from <code>V3</code>), so we get:</p>
<pre><code class="language-text">V3 in U2 = {placeholder(1)}
</code></pre>
<p>then we have this constraint <code>V2: V3</code>, so we wind up having to enlarge
<code>V2</code> to include <code>placeholder(1)</code> (which it can also see):</p>
<pre><code class="language-text">V2 in U2 = {placeholder(1), placeholder(2)}
</code></pre>
<p>Now constraint propagation is done, but when we check the outlives
relationships, we find that <code>V2</code> includes this new element <code>placeholder(1)</code>,
so we report an error.</p>
<h1><a class="header" href="#propagating-closure-constraints" id="propagating-closure-constraints">Propagating closure constraints</a></h1>
<p>When we are checking the type tests and universal regions, we may come
across a constraint that we can't prove yet if we are in a closure
body! However, the necessary constraints may actually hold (we just
don't know it yet). Thus, if we are inside a closure, we just collect
all the constraints we can't prove yet and return them. Later, when we
are borrow check the MIR node that created the closure, we can also
check that these constraints hold. At that time, if we can't prove
they hold, we report an error.</p>
<h1><a class="header" href="#reporting-region-errors" id="reporting-region-errors">Reporting region errors</a></h1>
<p>TODO: we should discuss how to generate errors from the results of these analyses.</p>
<h1><a class="header" href="#two-phase-borrows" id="two-phase-borrows">Two-phase borrows</a></h1>
<p>Two-phase borrows are a more permissive version of mutable borrows that allow
nested method calls such as <code>vec.push(vec.len())</code>. Such borrows first act as
shared borrows in a &quot;reservation&quot; phase and can later be &quot;activated&quot; into a
full mutable borrow.</p>
<p>Only certain implicit mutable borrows can be two-phase, any <code>&amp;mut</code> or <code>ref mut</code>
in the source code is never a two-phase borrow. The cases where we generate a
two-phase borrow are:</p>
<ol>
<li>The autoref borrow when calling a method with a mutable reference receiver.</li>
<li>A mutable reborrow in function arguments.</li>
<li>The implicit mutable borrow in an overloaded compound assignment operator.</li>
</ol>
<p>To give some examples:</p>
<pre><pre class="playpen"><code class="language-rust2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// In the source code

// Case 1:
let mut v = Vec::new();
v.push(v.len());
let r = &amp;mut Vec::new();
r.push(r.len());

// Case 2:
std::mem::replace(r, vec![1, r.len()]);

// Case 3:
let mut x = std::num::Wrapping(2);
x += x;
<span class="boring">}
</span></code></pre></pre>
<p>Expanding these enough to show the two-phase borrows:</p>
<pre><code class="language-rust ignore">// Case 1:
let mut v = Vec::new();
let temp1 = &amp;two_phase v;
let temp2 = v.len();
Vec::push(temp1, temp2);
let r = &amp;mut Vec::new();
let temp3 = &amp;two_phase *r;
let temp4 = r.len();
Vec::push(temp3, temp4);

// Case 2:
let temp5 = &amp;two_phase *r;
let temp6 = vec![1, r.len()];
std::mem::replace(temp5, temp6);

// Case 3:
let mut x = std::num::Wrapping(2);
let temp7 = &amp;two_phase x;
let temp8 = x;
std::ops::AddAssign::add_assign(temp7, temp8);
</code></pre>
<p>Whether a borrow can be two-phase is tracked by a flag on the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/adjustment/enum.AutoBorrow.html"><code>AutoBorrow</code></a>
after type checking, which is then <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/hair/cx/expr/trait.ToBorrowKind.html#method.to_borrow_kind">converted</a> to a <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/enum.BorrowKind.html"><code>BorrowKind</code></a> during MIR
construction.</p>
<p>Each two-phase borrow is assigned to a temporary that is only used once. As
such we can define:</p>
<ul>
<li>The point where the temporary is assigned to is called the <em>reservation</em>
point of the two-phase borrow.</li>
<li>The point where the temporary is used, which is effectively always a
function call, is called the <em>activation</em> point.</li>
</ul>
<p>The activation points are found using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/mir/visit/trait.Visitor.html#method.visit_local"><code>GatherBorrows</code></a> visitor. The
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/borrow_set/struct.BorrowData.html"><code>BorrowData</code></a> then holds both the reservation and activation points for the
borrow.</p>
<h2><a class="header" href="#checking-two-phase-borrows" id="checking-two-phase-borrows">Checking two-phase borrows</a></h2>
<p>Two-phase borrows are treated as if they were mutable borrows with the
following exceptions:</p>
<ol>
<li>At every location in the MIR we <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/struct.MirBorrowckCtxt.html#method.check_activations">check</a> if any two-phase borrows are
activated at this location. If a live two phase borrow is activated at a
location, then we check that there are no borrows that conflict with the
two-phase borrow.</li>
<li>At the reservation point we error if there are conflicting live <em>mutable</em>
borrows. And lint if there are any conflicting shared borrows.</li>
<li>Between the reservation and the activation point, the two-phase borrow acts
as a shared borrow. We determine (in <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/path_utils/fn.is_active.html"><code>is_active</code></a>) if we're at such a point
by using the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_data_structures/graph/dominators/struct.Dominators.html"><code>Dominators</code></a> for the MIR graph.</li>
<li>After the activation point, the two-phase borrow acts as a mutable borrow.</li>
</ol>
<h1><a class="header" href="#constant-evaluation" id="constant-evaluation">Constant Evaluation</a></h1>
<p>Constant evaluation is the process of computing values at compile time. For a
specific item (constant/static/array length) this happens after the MIR for the
item is borrow-checked and optimized. In many cases trying to const evaluate an
item will trigger the computation of its MIR for the first time.</p>
<p>Prominent examples are</p>
<ul>
<li>The initializer of a <code>static</code></li>
<li>Array length
<ul>
<li>needs to be known to reserve stack or heap space</li>
</ul>
</li>
<li>Enum variant discriminants
<ul>
<li>needs to be known to prevent two variants from having the same
discriminant</li>
</ul>
</li>
<li>Patterns
<ul>
<li>need to be known to check for overlapping patterns</li>
</ul>
</li>
</ul>
<p>Additionally constant evaluation can be used to reduce the workload or binary
size at runtime by precomputing complex operations at compiletime and only
storing the result.</p>
<p>Constant evaluation can be done by calling the <code>const_eval</code> query of <code>TyCtxt</code>.</p>
<p>The <code>const_eval</code> query takes a <a href="rustc-guide/./param_env.html"><code>ParamEnv</code></a> of environment in
which the constant is evaluated (e.g. the function within which the constant is
used) and a <code>GlobalId</code>. The <code>GlobalId</code> is made up of an
<code>Instance</code> referring to a constant or static or of an
<code>Instance</code> of a function and an index into the function's <code>Promoted</code> table.</p>
<p>Constant evaluation returns a <code>Result</code> with either the error, or the simplest
representation of the constant. &quot;simplest&quot; meaning if it is representable as an
integer or fat pointer, it will directly yield the value (via <code>ConstValue::Scalar</code> or
<code>ConstValue::ScalarPair</code>), instead of referring to the <a href="rustc-guide/./miri.html"><code>miri</code></a> virtual
memory allocation (via <code>ConstValue::ByRef</code>). This means that the <code>const_eval</code>
function cannot be used to create miri-pointers to the evaluated constant or
static. If you need that, you need to directly work with the functions in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/const_eval/index.html">src/librustc_mir/const_eval.rs</a>.</p>
<h1><a class="header" href="#miri" id="miri">Miri</a></h1>
<p>Miri (<strong>MIR</strong> <strong>I</strong>nterpreter) is a virtual machine for executing MIR without
compiling to machine code. It is usually invoked via <code>tcx.const_eval</code>.</p>
<p>If you start out with a constant</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const FOO: usize = 1 &lt;&lt; 12;
<span class="boring">}
</span></code></pre></pre>
<p>rustc doesn't actually invoke anything until the constant is either used or
placed into metadata.</p>
<p>Once you have a use-site like</p>
<pre><code class="language-rust ignore">type Foo = [u8; FOO - 42];
</code></pre>
<p>The compiler needs to figure out the length of the array before being able to
create items that use the type (locals, constants, function arguments, ...).</p>
<p>To obtain the (in this case empty) parameter environment, one can call
<code>let param_env = tcx.param_env(length_def_id);</code>. The <code>GlobalId</code> needed is</p>
<pre><code class="language-rust ignore">let gid = GlobalId {
    promoted: None,
    instance: Instance::mono(length_def_id),
};
</code></pre>
<p>Invoking <code>tcx.const_eval(param_env.and(gid))</code> will now trigger the creation of
the MIR of the array length expression. The MIR will look something like this:</p>
<pre><code class="language-mir">const Foo::{{initializer}}: usize = {
    let mut _0: usize;                   // return pointer
    let mut _1: (usize, bool);

    bb0: {
        _1 = CheckedSub(const Unevaluated(FOO, Slice([])), const 42usize);
        assert(!(_1.1: bool), &quot;attempt to subtract with overflow&quot;) -&gt; bb1;
    }

    bb1: {
        _0 = (_1.0: usize);
        return;
    }
}
</code></pre>
<p>Before the evaluation, a virtual memory location (in this case essentially a
<code>vec![u8; 4]</code> or <code>vec![u8; 8]</code>) is created for storing the evaluation result.</p>
<p>At the start of the evaluation, <code>_0</code> and <code>_1</code> are
<code>ConstValue::Scalar(Scalar::Undef)</code>. When the initialization of <code>_1</code> is invoked, the
value of the <code>FOO</code> constant is required, and triggers another call to
<code>tcx.const_eval</code>, which will not be shown here. If the evaluation of FOO is
successful, 42 will be subtracted by its value <code>4096</code> and the result stored in
<code>_1</code> as <code>ConstValue::ScalarPair(Scalar::Bytes(4054), Scalar::Bytes(0))</code>. The first
part of the pair is the computed value, the second part is a bool that's true if
an overflow happened.</p>
<p>The next statement asserts that said boolean is <code>0</code>. In case the assertion
fails, its error message is used for reporting a compile-time error.</p>
<p>Since it does not fail, <code>ConstValue::Scalar(Scalar::Bytes(4054))</code> is stored in the
virtual memory was allocated before the evaluation. <code>_0</code> always refers to that
location directly.</p>
<p>After the evaluation is done, the virtual memory allocation is interned into the
<code>TyCtxt</code>. Future evaluations of the same constants will not actually invoke
miri, but just extract the value from the interned allocation.</p>
<p>The <code>tcx.const_eval</code> function has one additional feature: it will not return a
<code>ByRef(interned_allocation_id)</code>, but a <code>Scalar(computed_value)</code> if possible. This
makes using the result much more convenient, as no further queries need to be
executed in order to get at something as simple as a <code>usize</code>.</p>
<h2><a class="header" href="#datastructures" id="datastructures">Datastructures</a></h2>
<p>Miri's core datastructures can be found in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc/mir/interpret">librustc/mir/interpret</a>.
This is mainly the error enum and the <code>ConstValue</code> and <code>Scalar</code> types. A <code>ConstValue</code> can
be either <code>Scalar</code> (a single <code>Scalar</code>), <code>ScalarPair</code> (two <code>Scalar</code>s, usually fat
pointers or two element tuples) or <code>ByRef</code>, which is used for anything else and
refers to a virtual allocation. These allocations can be accessed via the
methods on <code>tcx.interpret_interner</code>.</p>
<p>If you are expecting a numeric result, you can use <code>unwrap_usize</code> (panics on
anything that can't be representad as a <code>u64</code>) or <code>assert_usize</code> which results
in an <code>Option&lt;u128&gt;</code> yielding the <code>Scalar</code> if possible.</p>
<h2><a class="header" href="#allocations" id="allocations">Allocations</a></h2>
<p>A miri allocation is either a byte sequence of the memory or an <code>Instance</code> in
the case of function pointers. Byte sequences can additionally contain
relocations that mark a group of bytes as a pointer to another allocation. The
actual bytes at the relocation refer to the offset inside the other allocation.</p>
<p>These allocations exist so that references and raw pointers have something to
point to. There is no global linear heap in which things are allocated, but each
allocation (be it for a local variable, a static or a (future) heap allocation)
gets its own little memory with exactly the required size. So if you have a
pointer to an allocation for a local variable <code>a</code>, there is no possible (no
matter how unsafe) operation that you can do that would ever change said pointer
to a pointer to <code>b</code>.</p>
<h2><a class="header" href="#interpretation" id="interpretation">Interpretation</a></h2>
<p>Although the main entry point to constant evaluation is the <code>tcx.const_eval</code>
query, there are additional functions in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/const_eval/index.html">librustc_mir/const_eval.rs</a>
that allow accessing the fields of a <code>ConstValue</code> (<code>ByRef</code> or otherwise). You should
never have to access an <code>Allocation</code> directly except for translating it to the
compilation target (at the moment just LLVM).</p>
<p>Miri starts by creating a virtual stack frame for the current constant that is
being evaluated. There's essentially no difference between a constant and a
function with no arguments, except that constants do not allow local (named)
variables at the time of writing this guide.</p>
<p>A stack frame is defined by the <code>Frame</code> type in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/eval_context.rs">librustc_mir/interpret/eval_context.rs</a>
and contains all the local
variables memory (<code>None</code> at the start of evaluation). Each frame refers to the
evaluation of either the root constant or subsequent calls to <code>const fn</code>. The
evaluation of another constant simply calls <code>tcx.const_eval</code>, which produces an
entirely new and independent stack frame.</p>
<p>The frames are just a <code>Vec&lt;Frame&gt;</code>, there's no way to actually refer to a
<code>Frame</code>'s memory even if horrible shenigans are done via unsafe code. The only
memory that can be referred to are <code>Allocation</code>s.</p>
<p>Miri now calls the <code>step</code> method (in
<a href="https://github.com/rust-lang/rust/blob/master/src/librustc_mir/interpret/step.rs">librustc_mir/interpret/step.rs</a>
) until it either returns an error or has no further statements to execute. Each
statement will now initialize or modify the locals or the virtual memory
referred to by a local. This might require evaluating other constants or
statics, which just recursively invokes <code>tcx.const_eval</code>.</p>
<h1><a class="header" href="#parameter-environment" id="parameter-environment">Parameter Environment</a></h1>
<p>When working with associated and/or or generic items (types, constants,
functions/methods) it is often relevant to have more information about the
<code>Self</code> or generic parameters. Trait bounds and similar information is encoded in
the <code>ParamEnv</code>. Often this is not enough information to obtain things like the
type's <code>Layout</code>, but you can do all kinds of other checks on it (e.g. whether a
type implements <code>Copy</code>) or you can evaluate an associated constant whose value
does not depend on anything from the parameter environment.</p>
<p>For example if you have a function</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T: Copy&gt;(t: T) {
}
<span class="boring">}
</span></code></pre></pre>
<p>the parameter environment for that function is <code>[T: Copy]</code>. This means any
evaluation within this function will, when accessing the type <code>T</code>, know about
its <code>Copy</code> bound via the parameter environment.</p>
<p>Although you can obtain a valid <code>ParamEnv</code> for any item via
<code>tcx.param_env(def_id)</code>, this <code>ParamEnv</code> can be too generic for your use case.
Using the <code>ParamEnv</code> from the surrounding context can allow you to evaluate more
things.</p>
<p>Another great thing about <code>ParamEnv</code> is that you can use it to bundle the thing
depending on generic parameters (e.g. a <code>Ty</code>) by calling <code>param_env.and(ty)</code>.
This will produce a <code>ParamEnvAnd&lt;Ty&gt;</code>, making clear that you should probably not
be using the inner value without taking care to also use the <code>ParamEnv</code>.</p>
<h1><a class="header" href="#code-generation" id="code-generation">Code generation</a></h1>
<p>Code generation or &quot;codegen&quot; is the part of the compiler that actually
generates an executable binary. rustc uses LLVM for code generation.</p>
<blockquote>
<p>NOTE: If you are looking for hints on how to debug code generation bugs,
please see <a href="rustc-guide/codegen/debugging.html">this section of the debugging chapter</a>.</p>
</blockquote>
<h2><a class="header" href="#what-is-llvm" id="what-is-llvm">What is LLVM?</a></h2>
<p>All of the preceding chapters of this guide have one thing in common: we never
generated any executable machine code at all! With this chapter, all of that
changes.</p>
<p>Like most compilers, rustc is composed of a &quot;frontend&quot; and a &quot;backend&quot;. The
&quot;frontend&quot; is responsible for taking raw source code, checking it for
correctness, and getting it into a format <code>X</code> from which we can generate
executable machine code. The &quot;backend&quot; then takes that format <code>X</code> and produces
(possibly optimized) executable machine code for some platform. All of the
previous chapters deal with rustc's frontend.</p>
<p>rustc's backend is <a href="https://llvm.org">LLVM</a>, &quot;a collection of modular and
reusable compiler and toolchain technologies&quot;. In particular, the LLVM project
contains a pluggable compiler backend (also called &quot;LLVM&quot;), which is used by
many compiler projects, including the <code>clang</code> C compiler and our beloved
<code>rustc</code>.</p>
<p>LLVM's &quot;format <code>X</code>&quot; is called LLVM IR. It is basically assembly code with
additional low-level types and annotations added. These annotations are helpful
for doing optimizations on the LLVM IR and outputted machine code. The end
result of all this is (at long last) something executable (e.g. an ELF object
or wasm).</p>
<p>There are a few benefits to using LLVM:</p>
<ul>
<li>We don't have to write a whole compiler backend. This reduces implementation
and maintenance burden.</li>
<li>We benefit from the large suite of advanced optimizations that the LLVM
project has been collecting.</li>
<li>We automatically can compile Rust to any of the platforms for which LLVM has
support. For example, as soon as LLVM added support for wasm, voila! rustc,
clang, and a bunch of other languages were able to compile to wasm! (Well,
there was some extra stuff to be done, but we were 90% there anyway).</li>
<li>We and other compiler projects benefit from each other. For example, when the
<a href="https://meltdownattack.com/">Spectre and Meltdown security vulnerabilities</a> were discovered,
only LLVM needed to be patched.</li>
</ul>
<h2><a class="header" href="#generating-llvm-ir" id="generating-llvm-ir">Generating LLVM IR</a></h2>
<p>TODO</p>
<h1><a class="header" href="#updating-llvm" id="updating-llvm">Updating LLVM</a></h1>
<p>The Rust compiler uses LLVM as its primary codegen backend today, and naturally
we want to at least occasionally update this dependency! Currently we do not
have a strict policy about when to update LLVM or what it can be updated to, but
a few guidelines are applied:</p>
<ul>
<li>We try to always support the latest released version of LLVM</li>
<li>We try to support the &quot;last few&quot; versions of LLVM (how many is changing over
time)</li>
<li>We allow moving to arbitrary commits during development.</li>
<li>Strongly prefer to upstream all patches to LLVM before including them in
rustc.</li>
</ul>
<p>This policy may change over time (or may actually start to exist as a formal
policy!), but for now these are rough guidelines!</p>
<h2><a class="header" href="#why-update-llvm" id="why-update-llvm">Why update LLVM?</a></h2>
<p>There are two primary reasons nowadays that we want to update LLVM in one way or
another:</p>
<ul>
<li>
<p>First, a bug could have been fixed! Often we find bugs in the compiler and fix
them upstream in LLVM. We'll want to pull fixes back to the compiler itself as
they're merged upstream.</p>
</li>
<li>
<p>Second, a new feature may be avaiable in LLVM that we want to use in rustc,
but we don't want to wait for a full LLVM release to test it out.</p>
</li>
</ul>
<p>Each of these reasons has a different strategy for updating LLVM, and we'll go
over both in detail here.</p>
<h2><a class="header" href="#bugfix-updates" id="bugfix-updates">Bugfix Updates</a></h2>
<p>For updates of LLVM that typically just update a bug, we cherry-pick the bugfix
to the branch we're already using. The steps for this are:</p>
<ol>
<li>Make sure the bugfix is in upstream LLVM.</li>
<li>Identify the branch that rustc is currently using. The <code>src/llvm-project</code>
submodule is always pinned to a branch of the
<a href="https://github.com/rust-lang/llvm-project">rust-lang/llvm-project</a> repository.</li>
<li>Fork the rust-lang/llvm-project repository</li>
<li>Check out the appropriate branch (typically named <code>rustc/a.b-yyyy-mm-dd</code>)</li>
<li>Cherry-pick the upstream commit onto the branch</li>
<li>Push this branch to your fork</li>
<li>Send a Pull Request to rust-lang/llvm-project to the same branch as before</li>
<li>Wait for the PR to be merged</li>
<li>Send a PR to rust-lang/rust updating the <code>src/llvm-project</code> submodule with
your bugfix</li>
<li>Wait for PR to be merged</li>
</ol>
<p>The tl;dr; is that we can cherry-pick bugfixes at any time and pull them back
into the rust-lang/llvm-project branch that we're using, and getting it into the
compiler is just updating the submodule via a PR!</p>
<p>Example PRs look like:
<a href="https://github.com/rust-lang/rust/pull/59089">#59089</a></p>
<h2><a class="header" href="#feature-updates" id="feature-updates">Feature updates</a></h2>
<blockquote>
<p>Note that this is all information as applies to the current day in age. This
process for updating LLVM changes with practically all LLVM updates, so this
may be out of date!</p>
</blockquote>
<p>Unlike bugfixes, updating to pick up a new feature of LLVM typically requires a
lot more work. This is where we can't reasonably cherry-pick commits backwards
so we need to do a full update. There's a lot of stuff to do here, so let's go
through each in detail.</p>
<ol>
<li>
<p>Create a new branch in the rust-lang/llvm-project repository. This branch
should be named <code>rustc/a.b-yyyy-mm-dd</code> where <code>a.b</code> is the current version
number of LLVM in-tree at the time of the branch and the remaining part is
today's date.</p>
</li>
<li>
<p>Apply Rust-specific patches to the llvm-project repository. All features and
bugfixes are upstream, but there's often some weird build-related patches
that don't make sense to upstream which we have on our repositories. These
patches are around the latest patches in the rust-lang/llvm-project branch
that rustc is currently using.</p>
</li>
<li>
<p>Update the <code>compiler-rt</code> submodule in the
<code>rust-lang-nursery/compiler-builtins</code> repository. Push this update to the
same branch name of the <code>llvm-project</code> submodule to the
of the <code>rust-lang/compiler-rt</code> repository. Then push this update to a branch
of <code>compiler-builtins</code> with the same-named branch. Note that this step is
frequently optional since we may not need to update <code>compiler-rt</code>.</p>
</li>
<li>
<p>Prepare a commit to rust-lang/rust</p>
</li>
</ol>
<ul>
<li>Update <code>src/llvm-project</code></li>
<li>Update <code>compiler-builtins</code> crate in <code>Cargo.lock</code> (if necessary)</li>
</ul>
<ol start="5">
<li>
<p>Build your commit. Make sure you've committed the previous changes to ensure
submodule updates aren't reverted. Some commands you should execute are:</p>
<ul>
<li><code>./x.py build src/llvm</code> - test that LLVM still builds</li>
<li><code>./x.py build src/tools/lld</code> - same for LLD</li>
<li><code>./x.py build</code> - build the rest of rustc</li>
</ul>
<p>You'll likely need to update <code>src/rustllvm/*.cpp</code> to compile with updated
LLVM bindings. Note that you should use <code>#ifdef</code> and such to ensure that the
bindings still compile on older LLVM versions.</p>
</li>
<li>
<p>Test for regressions across other platforms. LLVM often has at least one bug
for non-tier-1 architectures, so it's good to do some more testing before
sending this to bors! If you're low on resources you can send the PR as-is
now to bors, though, and it'll get tested anyway.</p>
<p>Ideally, build LLVM and test it on a few platforms:</p>
<ul>
<li>Linux</li>
<li>OSX</li>
<li>Windows</li>
</ul>
<p>and afterwards run some docker containers that CI also does:</p>
<ul>
<li><code>./src/ci/docker/run.sh wasm32-unknown</code></li>
<li><code>./src/ci/docker/run.sh arm-android</code></li>
<li><code>./src/ci/docker/run.sh dist-various-1</code></li>
<li><code>./src/ci/docker/run.sh dist-various-2</code></li>
<li><code>./src/ci/docker/run.sh armhf-gnu</code></li>
</ul>
</li>
<li>
<p>Send a PR! Hopefully it's smooth sailing from here :).</p>
</li>
</ol>
<p>For prior art, previous LLVM updates look like
<a href="https://github.com/rust-lang/rust/pull/55835">#55835</a>
<a href="https://github.com/rust-lang/rust/pull/47828">#47828</a></p>
<h3><a class="header" href="#caveats-and-gotchas" id="caveats-and-gotchas">Caveats and gotchas</a></h3>
<p>Ideally the above instructions are pretty smooth, but here's some caveats to
keep in mind while going through them:</p>
<ul>
<li>LLVM bugs are hard to find, don't hesitate to ask for help! Bisection is
definitely your friend here (yes LLVM takes forever to build, yet bisection is
still your friend)</li>
<li>Updating LLDB has some Rust-specific patches currently that aren't upstream.
If you have difficulty @tromey can likely help out.</li>
<li>If you've got general questions, @alexcrichton can help you out.</li>
<li>Creating branches is a privileged operation on GitHub, so you'll need someone
with write access to create the branches for you most likely.</li>
</ul>
<h2><a class="header" href="#debugging-llvm" id="debugging-llvm">Debugging LLVM</a></h2>
<blockquote>
<p>NOTE: If you are looking for info about code generation, please see <a href="rustc-guide/codegen/../codegen.html">this
chapter</a> instead.</p>
</blockquote>
<p>This section is about debugging compiler bugs in code generation (e.g. why the
compiler generated some piece of code or crashed in LLVM).  LLVM is a big
project on its own that probably needs to have its own debugging document (not
that I could find one). But here are some tips that are important in a rustc
context:</p>
<p>As a general rule, compilers generate lots of information from analyzing code.
Thus, a useful first step is usually to find a minimal example. One way to do
this is to</p>
<ol>
<li>
<p>create a new crate that reproduces the issue (e.g. adding whatever crate is
at fault as a dependency, and using it from there)</p>
</li>
<li>
<p>minimize the crate by removing external dependencies; that is, moving
everything relevant to the new crate</p>
</li>
<li>
<p>further minimize the issue by making the code shorter (there are tools that
help with this like <code>creduce</code>)</p>
</li>
</ol>
<p>The official compilers (including nightlies) have LLVM assertions disabled,
which means that LLVM assertion failures can show up as compiler crashes (not
ICEs but &quot;real&quot; crashes) and other sorts of weird behavior. If you are
encountering these, it is a good idea to try using a compiler with LLVM
assertions enabled - either an &quot;alt&quot; nightly or a compiler you build yourself
by setting <code>[llvm] assertions=true</code> in your config.toml - and see whether
anything turns up.</p>
<p>The rustc build process builds the LLVM tools into
<code>./build/&lt;host-triple&gt;/llvm/bin</code>. They can be called directly.</p>
<p>The default rustc compilation pipeline has multiple codegen units, which is
hard to replicate manually and means that LLVM is called multiple times in
parallel.  If you can get away with it (i.e. if it doesn't make your bug
disappear), passing <code>-C codegen-units=1</code> to rustc will make debugging easier.</p>
<p>To rustc to generate LLVM IR, you need to pass the <code>--emit=llvm-ir</code> flag. If
you are building via cargo, use the <code>RUSTFLAGS</code> environment variable (e.g.
<code>RUSTFLAGS='--emit=llvm-ir'</code>). This causes rustc to spit out LLVM IR into the
target directory.</p>
<p><code>cargo llvm-ir [options] path</code> spits out the LLVM IR for a particular function
at <code>path</code>. (<code>cargo install cargo-asm</code> installs <code>cargo asm</code> and <code>cargo llvm-ir</code>). <code>--build-type=debug</code> emits code for debug builds. There are also
other useful options. Also, debug info in LLVM IR can clutter the output a lot:
<code>RUSTFLAGS=&quot;-C debuginfo=0&quot;</code> is really useful.</p>
<p><code>RUSTFLAGS=&quot;-C save-temps&quot;</code> outputs LLVM bitcode (not the same as IR) at
different stages during compilation, which is sometimes useful. One just needs
to convert the bitcode files to <code>.ll</code> files using <code>llvm-dis</code> which should be in
the target local compilation of rustc.</p>
<p>If you want to play with the optimization pipeline, you can use the <code>opt</code> tool
from <code>./build/&lt;host-triple&gt;/llvm/bin/</code> with the LLVM IR emitted by rustc.  Note
that rustc emits different IR depending on whether <code>-O</code> is enabled, even
without LLVM's optimizations, so if you want to play with the IR rustc emits,
you should:</p>
<pre><code class="language-bash">$ rustc +local my-file.rs --emit=llvm-ir -O -C no-prepopulate-passes \
    -C codegen-units=1
$ OPT=./build/$TRIPLE/llvm/bin/opt
$ $OPT -S -O2 &lt; my-file.ll &gt; my
</code></pre>
<p>If you just want to get the LLVM IR during the LLVM pipeline, to e.g. see which
IR causes an optimization-time assertion to fail, or to see when LLVM performs
a particular optimization, you can pass the rustc flag <code>-C llvm-args=-print-after-all</code>, and possibly add <code>-C llvm-args='-filter-print-funcs=EXACT_FUNCTION_NAME</code> (e.g.  <code>-C llvm-args='-filter-print-funcs=_ZN11collections3str21_$LT$impl$u20$str$GT$\ 7replace17hbe10ea2e7c809b0bE'</code>).</p>
<p>That produces a lot of output into standard error, so you'll want to pipe that
to some file. Also, if you are using neither <code>-filter-print-funcs</code> nor <code>-C codegen-units=1</code>, then, because the multiple codegen units run in parallel, the
printouts will mix together and you won't be able to read anything.</p>
<p>If you want just the IR for a specific function (say, you want to see why it
causes an assertion or doesn't optimize correctly), you can use <code>llvm-extract</code>,
e.g.</p>
<pre><code class="language-bash">$ ./build/$TRIPLE/llvm/bin/llvm-extract \
    -func='_ZN11collections3str21_$LT$impl$u20$str$GT$7replace17hbe10ea2e7c809b0bE' \
    -S \
    &lt; unextracted.ll \
    &gt; extracted.ll
</code></pre>
<h3><a class="header" href="#filing-llvm-bug-reports" id="filing-llvm-bug-reports">Filing LLVM bug reports</a></h3>
<p>When filing an LLVM bug report, you will probably want some sort of minimal
working example that demonstrates the problem. The Godbolt compiler explorer is
really helpful for this.</p>
<ol>
<li>
<p>Once you have some LLVM IR for the problematic code (see above), you can
create a minimal working example with Godbolt. Go to
<a href="https://gcc.godbolt.org">gcc.godbolt.org</a>.</p>
</li>
<li>
<p>Choose <code>LLVM-IR</code> as programming language.</p>
</li>
<li>
<p>Use <code>llc</code> to compile the IR to a particular target as is:</p>
<ul>
<li>There are some useful flags: <code>-mattr</code> enables target features, <code>-march=</code>
selects the target, <code>-mcpu=</code> selects the CPU, etc.</li>
<li>Commands like <code>llc -march=help</code> output all architectures available, which
is useful because sometimes the Rust arch names and the LLVM names do not
match.</li>
<li>If you have compiled rustc yourself somewhere, in the target directory
you have binaries for <code>llc</code>, <code>opt</code>, etc.</li>
</ul>
</li>
<li>
<p>If you want to optimize the LLVM-IR, you can use <code>opt</code> to see how the LLVM
optimizations transform it.</p>
</li>
<li>
<p>Once you have a godbolt link demonstrating the issue, it is pretty easy to
fill in an LLVM bug.</p>
</li>
</ol>
<h1><a class="header" href="#profile-guided-optimization" id="profile-guided-optimization">Profile Guided Optimization</a></h1>
<p><code>rustc</code> supports doing profile-guided optimization (PGO).
This chapter describes what PGO is and how the support for it is
implemented in <code>rustc</code>.</p>
<h2><a class="header" href="#what-is-profiled-guided-optimization" id="what-is-profiled-guided-optimization">What Is Profiled-Guided Optimization?</a></h2>
<p>The basic concept of PGO is to collect data about the typical execution of
a program (e.g. which branches it is likely to take) and then use this data
to inform optimizations such as inlining, machine-code layout,
register allocation, etc.</p>
<p>There are different ways of collecting data about a program's execution.
One is to run the program inside a profiler (such as <code>perf</code>) and another
is to create an instrumented binary, that is, a binary that has data
collection built into it, and run that.
The latter usually provides more accurate data.</p>
<h2><a class="header" href="#how-is-pgo-implemented-in-rustc" id="how-is-pgo-implemented-in-rustc">How is PGO implemented in <code>rustc</code>?</a></h2>
<p><code>rustc</code> current PGO implementation relies entirely on LLVM.
LLVM actually <a href="https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization">supports multiple forms</a> of PGO:</p>
<ul>
<li>Sampling-based PGO where an external profiling tool like <code>perf</code> is used
to collect data about a program's execution.</li>
<li>GCOV-based profiling, where code coverage infrastructure is used to collect
profiling information.</li>
<li>Front-end based instrumentation, where the compiler front-end (e.g. Clang)
inserts instrumentation intrinsics into the LLVM IR it generates.</li>
<li>IR-level instrumentation, where LLVM inserts the instrumentation intrinsics
itself during optimization passes.</li>
</ul>
<p><code>rustc</code> supports only the last approach, IR-level instrumentation, mainly
because it is almost exclusively implemented in LLVM and needs little
maintenance on the Rust side. Fortunately, it is also the most modern approach,
yielding the best results.</p>
<p>So, we are dealing with an instrumentation-based approach, i.e. profiling data
is generated by a specially instrumented version of the program that's being
optimized. Instrumentation-based PGO has two components: a compile-time
component and run-time component, and one needs to understand the overall
workflow to see how they interact.</p>
<h3><a class="header" href="#overall-workflow" id="overall-workflow">Overall Workflow</a></h3>
<p>Generating a PGO-optimized program involves the following four steps:</p>
<ol>
<li>Compile the program with instrumentation enabled (e.g. <code>rustc -Cprofile-generate main.rs</code>)</li>
<li>Run the instrumented program (e.g. <code>./main</code>) which generates a <code>default-&lt;id&gt;.profraw</code> file</li>
<li>Convert the <code>.profraw</code> file into a <code>.profdata</code> file using LLVM's <code>llvm-profdata</code> tool.</li>
<li>Compile the program again, this time making use of the profiling data
(e.g. <code>rustc -Cprofile-use=merged.profdata main.rs</code>)</li>
</ol>
<h3><a class="header" href="#compile-time-aspects" id="compile-time-aspects">Compile-Time Aspects</a></h3>
<p>Depending on which step in the above workflow we are in, two different things
can happen at compile time:</p>
<h4><a class="header" href="#create-binaries-with-instrumentation" id="create-binaries-with-instrumentation">Create Binaries with Instrumentation</a></h4>
<p>As mentioned above, the profiling instrumentation is added by LLVM.
<code>rustc</code> instructs LLVM to do so <a href="https://github.com/rust-lang/rust/blob/1.34.1/src/rustllvm/PassWrapper.cpp#L412-L416">by setting the appropriate</a>
flags when creating LLVM <code>PassManager</code>s:</p>
<pre><code class="language-C">	// `PMBR` is an `LLVMPassManagerBuilderRef`
    unwrap(PMBR)-&gt;EnablePGOInstrGen = true;
    // Instrumented binaries have a default output path for the `.profraw` file
    // hard-coded into them:
    unwrap(PMBR)-&gt;PGOInstrGen = PGOGenPath;
</code></pre>
<p><code>rustc</code> also has to make sure that some of the symbols from LLVM's profiling
runtime are not removed <a href="https://github.com/rust-lang/rust/blob/1.34.1/src/librustc_codegen_ssa/back/symbol_export.rs#L212-L225">by marking the with the right export level</a>.</p>
<h4><a class="header" href="#compile-binaries-where-optimizations-make-use-of-profiling-data" id="compile-binaries-where-optimizations-make-use-of-profiling-data">Compile Binaries Where Optimizations Make Use Of Profiling Data</a></h4>
<p>In the final step of the workflow described above, the program is compiled
again, with the compiler using the gathered profiling data in order to drive
optimization decisions. <code>rustc</code> again leaves most of the work to LLVM here,
basically <a href="https://github.com/rust-lang/rust/blob/1.34.1/src/rustllvm/PassWrapper.cpp#L417-L420">just telling</a> the LLVM <code>PassManagerBuilder</code>
where the profiling data can be found:</p>
<pre><code class="language-C">	unwrap(PMBR)-&gt;PGOInstrUse = PGOUsePath;
</code></pre>
<p>LLVM does the rest (e.g. setting branch weights, marking functions with
<code>cold</code> or <code>inlinehint</code>, etc).</p>
<h3><a class="header" href="#runtime-aspects" id="runtime-aspects">Runtime Aspects</a></h3>
<p>Instrumentation-based approaches always also have a runtime component, i.e.
once we have an instrumented program, that program needs to be run in order
to generate profiling data, and collecting and persisting this profiling
data needs some infrastructure in place.</p>
<p>In the case of LLVM, these runtime components are implemented in
<a href="https://github.com/llvm/llvm-project/tree/master/compiler-rt/lib/profile">compiler-rt</a> and statically linked into any instrumented
binaries.
The <code>rustc</code> version of this can be found in <code>src/libprofiler_builtins</code> which
basically packs the C code from <code>compiler-rt</code> into a Rust crate.</p>
<p>In order for <code>libprofiler_builtins</code> to be built, <code>profiler = true</code> must be set
in <code>rustc</code>'s <code>config.toml</code>.</p>
<h2><a class="header" href="#testing-pgo" id="testing-pgo">Testing PGO</a></h2>
<p>Since the PGO workflow spans multiple compiler invocations most testing happens
in <a href="https://github.com/rust-lang/rust/tree/master/src/test/run-make-fulldeps">run-make tests</a> (the relevant tests have <code>pgo</code> in their name).
There is also a <a href="https://github.com/rust-lang/rust/blob/master/src/test/codegen/pgo-instrumentation.rs">codegen test</a> that checks that some expected
instrumentation artifacts show up in LLVM IR.</p>
<h2><a class="header" href="#additional-information" id="additional-information">Additional Information</a></h2>
<p>Clang's documentation contains a good overview on PGO in LLVM here:
https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization</p>
<h1><a class="header" href="#debugging-support-in-the-rust-compiler" id="debugging-support-in-the-rust-compiler">Debugging support in the Rust compiler</a></h1>
<p>This document explains the state of debugging tools support in the Rust compiler (rustc).
The document gives an overview of debugging tools like GDB, LLDB etc. and infrastrcture
around Rust compiler to debug Rust code. If you want to learn how to debug the Rust compiler
itself, then you must see <a href="rustc-guide/compiler-debugging.html">Debugging the Compiler</a> page.</p>
<p>The material is gathered from YouTube video <a href="https://www.youtube.com/watch?v=elBxMRSNYr4">Tom Tromey discusses debugging support in rustc</a>.</p>
<h2><a class="header" href="#preliminaries" id="preliminaries">Preliminaries</a></h2>
<h3><a class="header" href="#debuggers" id="debuggers">Debuggers</a></h3>
<p>According to Wikipedia</p>
<blockquote>
<p>A <a href="https://en.wikipedia.org/wiki/Debugger">debugger or debugging tool</a> is a computer program that is used to test and debug
other programs (the &quot;target&quot; program).</p>
</blockquote>
<p>Writing a debugger from scratch for a language requires a lot of work, especially if
debuggers have to be supported on various platforms. GDB and LLDB, however, can be
extended to support debugging a language. This is the path that Rust has chosen.
This document's main goal is to document the said debuggers support in Rust compiler.</p>
<h3><a class="header" href="#dwarf" id="dwarf">DWARF</a></h3>
<p>According to the <a href="http://dwarfstd.org">DWARF</a> standard website</p>
<blockquote>
<p>DWARF is a debugging file format used by many compilers and debuggers to support source level
debugging. It addresses the requirements of a number of procedural languages,
such as C, C++, and Fortran, and is designed to be extensible to other languages.
DWARF is architecture independent and applicable to any processor or operating system.
It is widely used on Unix, Linux and other operating systems,
as well as in stand-alone environments.</p>
</blockquote>
<p>DWARF reader is a program that consumes the DWARF format and creates debugger compatible output.
This program may live in the compiler itself.  DWARF uses a data structure called
Debugging Information Entry (DIE) which stores the information as &quot;tags&quot; to denote functions,
variables etc., e.g., <code>DW_TAG_variable</code>, <code>DW_TAG_pointer_type</code>, <code>DW_TAG_subprogram</code> etc.
You can also invent your own tags and attributes.</p>
<h2><a class="header" href="#supported-debuggers" id="supported-debuggers">Supported debuggers</a></h2>
<h3><a class="header" href="#gdb" id="gdb">GDB</a></h3>
<p>We have our own fork of GDB - <a href="https://github.com/rust-dev-tools/gdb">https://github.com/rust-dev-tools/gdb</a></p>
<h4><a class="header" href="#rust-expression-parser" id="rust-expression-parser">Rust expression parser</a></h4>
<p>To be able to show debug output we need an expression parser.
This (GDB) expression parser is written in <a href="https://www.gnu.org/software/bison/">Bison</a> and is only a subset of Rust expressions.
This means that this parser can parse only a subset of Rust expressions.
GDB parser was written from scratch and has no relation to any other parser.
For example, this parser is not related to Rustc's parser.</p>
<p>GDB has Rust like value and type output. It can print values and types in a way
that look like Rust syntax in the output. Or when you print a type as <a href="https://ftp.gnu.org/old-gnu/Manuals/gdb/html_node/gdb_109.html">ptype</a> in GDB,
it also looks like Rust source code. Checkout the documentation in the <a href="https://sourceware.org/gdb/onlinedocs/gdb/Rust.html">manual for GDB/Rust</a>.</p>
<h4><a class="header" href="#parser-extensions" id="parser-extensions">Parser extensions</a></h4>
<p>Expression parser has a couple of extensions in it to facilitate features that you cannot do
with Rust. Some limitations are listed in the <a href="https://sourceware.org/gdb/onlinedocs/gdb/Rust.html">manual for GDB/Rust</a>. There is some special
code in the DWARF reader in GDB to support the extensions.</p>
<p>A couple of examples of DWARF reader support needed are as follows -</p>
<ol>
<li>
<p>Enum: Needed for support for enum types. The Rustc writes the information about enum into
DWARF and GDB reads the DWARF to understand where is the tag field or is there a tag
field or is the tag slot shared with non-zero optimization etc.</p>
</li>
<li>
<p>Dissect trait objects: DWARF extension where the trait object's description in the DWARF
also points to a stub description of the corresponding vtable which in turn points to the
concrete type for which this trait object exists. This means that you can do a <code>print *object</code>
for that trait object, and GDB will understand how to find the correct type of the payload in
the trait object.</p>
</li>
</ol>
<p><strong>TODO</strong>: Figure out if the following should be mentioned in the GDB-Rust document rather than
this guide page so there is no duplication. This is regarding the following comments:</p>
<p><a href="https://github.com/rust-lang/rustc-guide/pull/316#discussion_r284027340">This comment by Tom</a></p>
<blockquote>
<p>gdb's Rust extensions and limitations are documented in the gdb manual:
https://sourceware.org/gdb/onlinedocs/gdb/Rust.html -- however, this neglects to mention that
gdb convenience variables and registers follow the gdb $ convention, and that the Rust parser
implements the gdb @ extension.</p>
</blockquote>
<p><a href="https://github.com/rust-lang/rustc-guide/pull/316#discussion_r285401353">This question by Aman</a></p>
<blockquote>
<p>@tromey do you think we should mention this part in the GDB-Rust document rather than this
document so there is no duplication etc.?</p>
</blockquote>
<h4><a class="header" href="#developer-notes" id="developer-notes">Developer notes</a></h4>
<ul>
<li>This work is now upstream. Bugs can be reported in <a href="https://sourceware.org/bugzilla/">GDB Bugzilla</a>.</li>
</ul>
<h3><a class="header" href="#lldb" id="lldb">LLDB</a></h3>
<p>We have our own fork of LLDB - <a href="https://github.com/rust-lang/lldb">https://github.com/rust-lang/lldb</a></p>
<p>Fork of LLVM project - <a href="https://github.com/rust-lang/llvm-project">https://github.com/rust-lang/llvm-project</a></p>
<p>LLDB currently only works on macOS because of a dependency issue. This issue was easier to
solve for macOS as compared to Linux. However, Tom has a possible solution which can enable
us to ship LLDB everywhere.</p>
<h4><a class="header" href="#rust-expression-parser-1" id="rust-expression-parser-1">Rust expression parser</a></h4>
<p>This expression parser is written in C++. It is a type of <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">Recursive Descent parser</a>.
Implements slightly less of the Rust language than GDB. LLDB has Rust like value and type output.</p>
<h4><a class="header" href="#parser-extensions-1" id="parser-extensions-1">Parser extensions</a></h4>
<p>There is some special code in the DWARF reader in LLDB to support the extensions.
A couple of examples of DWARF reader support needed are as follows -</p>
<ol>
<li>Enum: Needed for support for enum types. The Rustc writes the information about
enum into DWARF and LLDB reads the DWARF to understand where is the tag field or
is there a tag field or is the tag slot shared with non-zero optimization etc.
In other words, it has enum support as well.</li>
</ol>
<h4><a class="header" href="#developer-notes-1" id="developer-notes-1">Developer notes</a></h4>
<ul>
<li>None of the LLDB work is upstream. This <a href="https://github.com/rust-lang/lldb/wiki">rust-lang/lldb wiki page</a> explains a few details.</li>
<li>The reason for forking LLDB is that LLDB recently removed all the other language plugins
due to lack of maintenance.</li>
<li>LLDB has a plugin architecture but that does not work for language support.</li>
<li>LLDB is available via Rust build (<code>rustup</code>).</li>
<li>GDB generally works better on Linux.</li>
</ul>
<h2><a class="header" href="#dwarf-and-rustc" id="dwarf-and-rustc">DWARF and Rustc</a></h2>
<p><a href="http://dwarfstd.org">DWARF</a> is the standard way compilers generate debugging information that debuggers read.
It is <em>the</em> debugging format on macOS and Linux. It is a multi-language, extensible format
and is mostly good enough for Rust's purposes. Hence, the current implementation reuses DWARF's
concepts. This is true even if some of the concepts in DWARF do not align with Rust
semantically because generally there can be some kind of mapping between the two.</p>
<p>We have some DWARF extensions that the Rust compiler emits and the debuggers understand that
are <em>not</em> in the DWARF standard.</p>
<ul>
<li>
<p>Rust compiler will emit DWARF for a virtual table, and this <code>vtable</code> object will have a
<code>DW_AT_containing_type</code> that points to the real type. This lets debuggers dissect a trait object
pointer to correctly find the payload. E.g., here's such a DIE, from a test case in the gdb
repository:</p>
<pre><code class="language-asm">&lt;1&gt;&lt;1a9&gt;: Abbrev Number: 3 (DW_TAG_structure_type)
   &lt;1aa&gt;   DW_AT_containing_type: &lt;0x1b4&gt;
   &lt;1ae&gt;   DW_AT_name        : (indirect string, offset: 0x23d): vtable
   &lt;1b2&gt;   DW_AT_byte_size   : 0
   &lt;1b3&gt;   DW_AT_alignment   : 8
</code></pre>
</li>
<li>
<p>The other extension is that the Rust compiler can emit a tagless discriminated union.
See <a href="http://dwarfstd.org/ShowIssue.php?issue=180517.2">DWARF feature request</a> for this item.</p>
</li>
</ul>
<h3><a class="header" href="#current-limitations-of-dwarf" id="current-limitations-of-dwarf">Current limitations of DWARF</a></h3>
<ul>
<li>Traits - require a bigger change than normal to DWARF, on how to represent Traits in DWARF.</li>
<li>DWARF provides no way to differentiate between Structs and Tuples. Rust compiler emits
fields with <code>__0</code> and debuggers look for a sequence of such names to overcome this limitation.
For example, in this case the debugger would look at a field via <code>x.__0</code> instead of <code>x.0</code>.
This is resolved via the Rust parser in the debugger so now you can do <code>x.0</code>.</li>
</ul>
<p>DWARF relies on debuggers to know some information about platform ABI.
Rust does not do that all the time.</p>
<h2><a class="header" href="#developer-notes-2" id="developer-notes-2">Developer notes</a></h2>
<p>This section is from the talk about certain aspects of development.</p>
<h2><a class="header" href="#what-is-missing" id="what-is-missing">What is missing</a></h2>
<h3><a class="header" href="#shipping-gdb-in-rustup" id="shipping-gdb-in-rustup">Shipping GDB in Rustup</a></h3>
<p>Tracking issue: <a href="https://github.com/rust-lang/rust/issues/34457">https://github.com/rust-lang/rust/issues/34457</a></p>
<p>Shipping GDB requires change to Rustup delivery system. To manage Rustup build size and
times we need to build GDB separately, on its own and somehow provide the artifacts produced
to be included in the final build. However, if we can ship GDB with rustup, it will simplify
the development process by having compiler emit new debug info which can be readily consumed.</p>
<p>Main issue in achieving this is setting up dependencies. One such dependency is Python. That
is why we have our own fork of GDB because one of the drivers is patched on Rust's side to
check the correct version of Python (Python 2.7 in this case. <em>Note: Python3 is not chosen
for this purpose because Python's stable ABI is limited and is not sufficient for GDB's needs.
See <a href="https://docs.python.org/3/c-api/stable.html">https://docs.python.org/3/c-api/stable.html</a></em>).</p>
<p>This is to keep updates to debugger as fast as possible as we make changes to the debugging symbols.
In essence, to ship the debugger as soon as new debugging info is added. GDB only releases
every six months or so. However, the changes that are
not related to Rust itself should ideally be first merged to upstream eventually.</p>
<h3><a class="header" href="#code-signing-for-lldb-debug-server-on-macos" id="code-signing-for-lldb-debug-server-on-macos">Code signing for LLDB debug server on macOS</a></h3>
<p>According to Wikipedia, <a href="https://en.wikipedia.org/wiki/System_Integrity_Protection">System Integrity Protection</a> is</p>
<blockquote>
<p>System Integrity Protection (SIP, sometimes referred to as rootless) is a security feature
of Apple's macOS operating system introduced in OS X El Capitan. It comprises a number of
mechanisms that are enforced by the kernel. A centerpiece is the protection of system-owned
files and directories against modifications by processes without a specific &quot;entitlement&quot;,
even when executed by the root user or a user with root privileges (sudo).</p>
</blockquote>
<p>It prevents processes using <code>ptrace</code> syscall. If a process wants to use <code>ptrace</code> it has to be
code signed. The certificate that signs it has to be trusted on your machine.</p>
<p>See <a href="https://developer.apple.com/library/archive/releasenotes/MacOSX/WhatsNewInOSX/Articles/MacOSX10_11.html#//apple_ref/doc/uid/TP40016227-SW11">Apple developer documentation for System Integrity Protection</a>.</p>
<p>We may need to sign up with Apple and get the keys to do this signing. Tom has looked into if
Mozilla cannot do this because it is at the maximum number of
keys it is allowed to sign. Tom does not know if Mozilla could get more keys.</p>
<p>Alternatively, Tom suggests that maybe a Rust legal entity is needed to get the keys via Apple.
This problem is not technical in nature. If we had such a key we could sign GDB as well and
ship that.</p>
<h3><a class="header" href="#dwarf-and-traits" id="dwarf-and-traits">DWARF and Traits</a></h3>
<p>Rust traits are not emitted into DWARF at all. The impact of this is calling a method <code>x.method()</code>
does not work as is. The reason being that method is implemented by a trait, as opposed
to a type. That information is not present so finding trait methods is missing.</p>
<p>DWARF has a notion of interface types (possibly added for Java). Tom's idea was to use this
interface type as traits.</p>
<p>DWARF only deals with concrete names, not the reference types. So, a given implementation of a
trait for a type would be one of these interfaces (<code>DW_tag_interface</code> type). Also, the type for
which it is implemented would describe all the interfaces this type implements. This requires a
DWARF extension.</p>
<p>Issue on Github: <a href="https://github.com/rust-lang/rust/issues/33014">https://github.com/rust-lang/rust/issues/33014</a></p>
<h2><a class="header" href="#typical-process-for-a-debug-info-change-llvm" id="typical-process-for-a-debug-info-change-llvm">Typical process for a Debug Info change (LLVM)</a></h2>
<p>LLVM has Debug Info (DI) builders. This is the primary thing that Rust calls into.
This is why we need to change LLVM first because that is emitted first and not DWARF directly.
This is a kind of metadata that you construct and hand-off to LLVM. For the Rustc/LLVM hand-off
some LLVM DI builder methods are called to construct representation of a type.</p>
<p>The steps of this process are as follows -</p>
<ol>
<li>
<p>LLVM needs changing.</p>
<p>LLVM does not emit Interface types at all, so this needs to be implemented in the LLVM first.</p>
<p>Get sign off on LLVM maintainers that this is a good idea.</p>
</li>
<li>
<p>Change the DWARF extension.</p>
</li>
<li>
<p>Update the debuggers.</p>
<p>Update DWARF readers, expression evaluators.</p>
</li>
<li>
<p>Update Rust compiler.</p>
<p>Change it to emit this new information.</p>
</li>
</ol>
<h3><a class="header" href="#procedural-macro-stepping" id="procedural-macro-stepping">Procedural macro stepping</a></h3>
<p>A deeply profound question is that how do you actually debug a procedural macro?
What is the location you emit for a macro expansion? Consider some of the following cases -</p>
<ul>
<li>You can emit location of the invocation of the macro.</li>
<li>You can emit the location of the definition of the macro.</li>
<li>You can emit locations of the content of the macro.</li>
</ul>
<p>RFC: <a href="https://github.com/rust-lang/rfcs/pull/2117">https://github.com/rust-lang/rfcs/pull/2117</a></p>
<p>Focus is to let macros decide what to do. This can be achieved by having some kind of attribute
that lets the macro tell the compiler where the line marker should be. This affects where you
set the breakpoints and what happens when you step it.</p>
<h2><a class="header" href="#future-work" id="future-work">Future work</a></h2>
<h4><a class="header" href="#name-mangling-changes" id="name-mangling-changes">Name mangling changes</a></h4>
<ul>
<li>New demangler in <code>libiberty</code> (gcc source tree).</li>
<li>New demangler in LLVM or LLDB.</li>
</ul>
<p><strong>TODO</strong>: Check the location of the demangler source.
<a href="https://github.com/rust-lang/rustc-guide/pull/316#discussion_r283062536">Question on Github</a>.</p>
<h4><a class="header" href="#reuse-rust-compiler-for-expressions" id="reuse-rust-compiler-for-expressions">Reuse Rust compiler for expressions</a></h4>
<p>This is an important idea because debuggers by and large do not try to implement type
inference. You need to be much more explicit when you type into the debugger than your
actual source code. So, you cannot just copy and paste an expression from your source
code to debugger and expect the same answer but this would be nice. This can be helped
by using compiler.</p>
<p>It is certainly doable but it is a large project. You certainly need a bridge to the
debugger because the debugger alone has access to the memory. Both GDB (gcc) and LLDB (clang)
have this feature. LLDB uses Clang to compile code to JIT and GDB can do the same with GCC.</p>
<p>Both debuggers expression evaluation implement both a superset and a subset of Rust.
They implement just the expression language but they also add some extensions like GDB has
convenience variables. Therefore, if you are taking this route then you not only need
to do this bridge but may have to add some mode to let the compiler understand some extensions.</p>
<h4><a class="header" href="#windows-debugging-pdb-is-missing" id="windows-debugging-pdb-is-missing">Windows debugging (PDB) is missing</a></h4>
<p>This is a complete unknown.</p>
<h1><a class="header" href="#appendix-a-a-tutorial-on-creating-a-drop-in-replacement-for-rustc" id="appendix-a-a-tutorial-on-creating-a-drop-in-replacement-for-rustc">Appendix A: A tutorial on creating a drop-in replacement for rustc</a></h1>
<blockquote>
<p><strong>Note:</strong> This is a copy of <code>@nrc</code>'s amazing <a href="https://github.com/nrc/stupid-stats">stupid-stats</a>. You should find
a copy of the code on the GitHub repository.</p>
<p>Due to the compiler's constantly evolving nature, the <code>rustc_driver</code>
mechanisms described in this chapter have changed. In particular, the
<code>CompilerCalls</code> and <code>CompileController</code> types have been replaced by
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/trait.Callbacks.html"><code>Callbacks</code></a>.  Also, there is a new query-based interface in the
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/index.html"><code>rustc_interface</code></a> crate. See <a href="rustc-guide/appendix/../rustc-driver.html">The Rustc Driver and Interface</a> for more
information.</p>
</blockquote>
<p>Many tools benefit from being a drop-in replacement for a compiler. By this, I
mean that any user of the tool can use <code>mytool</code> in all the ways they would
normally use <code>rustc</code> - whether manually compiling a single file or as part of a
complex make project or Cargo build, etc. That could be a lot of work;
rustc, like most compilers, takes a large number of command line arguments which
can affect compilation in complex and interacting ways. Emulating all of this
behaviour in your tool is annoying at best, especically if you are making many
of the same calls into librustc that the compiler is.</p>
<p>The kind of things I have in mind are tools like rustdoc or a future rustfmt.
These want to operate as closely as possible to real compilation, but have
totally different outputs (documentation and formatted source code,
respectively). Another use case is a customised compiler. Say you want to add a
custom code generation phase after macro expansion, then creating a new tool
should be easier than forking the compiler (and keeping it up to date as the
compiler evolves).</p>
<p>I have gradually been trying to improve the API of librustc to make creating a
drop-in tool easier to produce (many others have also helped improve these
interfaces over the same time frame). It is now pretty simple to make a tool
which is as close to rustc as you want it to be. In this tutorial I'll show
how.</p>
<p>Note/warning, everything I talk about in this tutorial is internal API for
rustc. It is all extremely unstable and likely to change often and in
unpredictable ways. Maintaining a tool which uses these APIs will be non-
trivial, although hopefully easier than maintaining one that does similar things
without using them.</p>
<p>This tutorial starts with a very high level view of the rustc compilation
process and of some of the code that drives compilation. Then I'll describe how
that process can be customised. In the final section of the tutorial, I'll go
through an example - stupid-stats - which shows how to build a drop-in tool.</p>
<h2><a class="header" href="#overview-of-the-compilation-process" id="overview-of-the-compilation-process">Overview of the compilation process</a></h2>
<p>Compilation using rustc happens in several phases. We start with parsing, this
includes lexing. The output of this phase is an AST (abstract syntax tree).
There is a single AST for each crate (indeed, the entire compilation process
operates over a single crate). Parsing abstracts away details about individual
files which will all have been read in to the AST in this phase. At this stage
the AST includes all macro uses, attributes will still be present, and nothing
will have been eliminated due to <code>cfg</code>s.</p>
<p>The next phase is configuration and macro expansion. This can be thought of as a
function over the AST. The unexpanded AST goes in and an expanded AST comes out.
Macros and syntax extensions are expanded, and <code>cfg</code> attributes will cause some
code to disappear. The resulting AST won't have any macros or macro uses left
in.</p>
<p>The code for these first two phases is in <a href="https://github.com/rust-lang/rust/tree/master/src/libsyntax">libsyntax</a>.</p>
<p>After this phase, the compiler allocates ids to each node in the AST
(technically not every node, but most of them). If we are writing out
dependencies, that happens now.</p>
<p>The next big phase is analysis. This is the most complex phase and
uses the bulk of the code in rustc. This includes name resolution, type
checking, borrow checking, type and lifetime inference, trait selection, method
selection, linting, and so forth. Most error detection is done in this phase
(although parse errors are found during parsing). The 'output' of this phase is
a bunch of side tables containing semantic information about the source program.
The analysis code is in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc">librustc</a>
and a bunch of other crates with the 'librustc_' prefix.</p>
<p>Next is translation, this translates the AST (and all those side tables) into
LLVM IR (intermediate representation). We do this by calling into the LLVM
libraries, rather than actually writing IR directly to a file. The code for
this is in librustc_trans.</p>
<p>The next phase is running the LLVM backend. This runs LLVM's optimisation passes
on the generated IR and then generates machine code. The result is object files.
This phase is all done by LLVM, it is not really part of the rust compiler. The
interface between LLVM and rustc is in <a href="https://github.com/rust-lang/rust/tree/master/src/librustc_llvm">librustc_llvm</a>.</p>
<p>Finally, we link the object files into an executable. Again we outsource this to
other programs and it's not really part of the rust compiler. The interface is
in librustc_back (which also contains some things used primarily during
translation).</p>
<blockquote>
<p>NOTE: <code>librustc_trans</code> and <code>librustc_back</code> no longer exist, and we don't
translate AST or HIR directly to LLVM IR anymore.  Instead, see
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/index.html"><code>librustc_codegen_llvm</code></a>
and <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_utils/index.html"><code>librustc_codegen_utils</code></a>.</p>
</blockquote>
<p>All these phases are coordinated by the driver. To see the exact sequence, look
at the <code>compile_input</code> function in <code>librustc_driver</code>.
The driver handles all the highest level coordination of compilation -
1. handling command-line arguments
2. maintaining compilation state (primarily in the <code>Session</code>)
3. calling the appropriate code to run each phase of compilation
4. handles high level coordination of pretty printing and testing.
To create a drop-in compiler replacement or a compiler replacement,
we leave most of compilation alone and customise the driver using its APIs.</p>
<h2><a class="header" href="#the-driver-customisation-apis" id="the-driver-customisation-apis">The driver customisation APIs</a></h2>
<p>There are two primary ways to customise compilation - high level control of the
driver using <code>CompilerCalls</code> and controlling each phase of compilation using a
<code>CompileController</code>. The former lets you customise handling of command line
arguments etc., the latter lets you stop compilation early or execute code
between phases.</p>
<h3><a class="header" href="#compilercalls" id="compilercalls"><code>CompilerCalls</code></a></h3>
<p><code>CompilerCalls</code> is a trait that you implement in your tool. It contains a fairly
ad-hoc set of methods to hook in to the process of processing command line
arguments and driving the compiler. For details, see the comments in
<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_driver/index.html">librustc_driver/lib.rs</a>.
I'll summarise the methods here.</p>
<p><code>early_callback</code> and <code>late_callback</code> let you call arbitrary code at different
points - early is after command line arguments have been parsed, but before
anything is done with them; late is pretty much the last thing before
compilation starts, i.e., after all processing of command line arguments, etc.
is done. Currently, you get to choose whether compilation stops or continues at
each point, but you don't get to change anything the driver has done. You can
record some info for later, or perform other actions of your own.</p>
<p><code>some_input</code> and <code>no_input</code> give you an opportunity to modify the primary input
to the compiler (usually the input is a file containing the top module for a
crate, but it could also be a string). You could record the input or perform
other actions of your own.</p>
<p>Ignore <code>parse_pretty</code>, it is unfortunate and hopefully will get improved. There
is a default implementation, so you can pretend it doesn't exist.</p>
<p><code>build_controller</code> returns a <code>CompileController</code> object for more fine-grained
control of compilation, it is described next.</p>
<p>We might add more options in the future.</p>
<h3><a class="header" href="#compilercontroller" id="compilercontroller"><code>CompilerController</code></a></h3>
<p><code>CompilerController</code> is a struct consisting of <code>PhaseController</code>s and flags.
Currently, there is only flag, <code>make_glob_map</code> which signals whether to produce
a map of glob imports (used by save-analysis and potentially other tools). There
are probably flags in the session that should be moved here.</p>
<p>There is a <code>PhaseController</code> for each of the phases described in the above
summary of compilation (and we could add more in the future for finer-grained
control). They are all <code>after_</code> a phase because they are checked at the end of a
phase (again, that might change), e.g., <code>CompilerController::after_parse</code>
controls what happens immediately after parsing (and before macro expansion).</p>
<p>Each <code>PhaseController</code> contains a flag called <code>stop</code> which indicates whether
compilation should stop or continue, and a callback to be executed at the point
indicated by the phase. The callback is called whether or not compilation
continues.</p>
<p>Information about the state of compilation is passed to these callbacks in a
<code>CompileState</code> object. This contains all the information the compiler has. Note
that this state information is immutable - your callback can only execute code
using the compiler state, it can't modify the state. (If there is demand, we
could change that). The state available to a callback depends on where during
compilation the callback is called. For example, after parsing there is an AST
but no semantic analysis (because the AST has not been analysed yet). After
translation, there is translation info, but no AST or analysis info (since these
have been consumed/forgotten).</p>
<h2><a class="header" href="#an-example---stupid-stats" id="an-example---stupid-stats">An example - stupid-stats</a></h2>
<p>Our example tool is very simple, it simply collects some simple and not very
useful statistics about a program; it is called stupid-stats. You can find
the (more heavily commented) complete source for the example on <a href="https://github.com/nick29581/stupid-stats/blob/master/src">Github</a>.
To build, just do <code>cargo build</code>. To run on a file <code>foo.rs</code>, do <code>cargo run foo.rs</code> (assuming you have a Rust program called <code>foo.rs</code>. You can also pass any
command line arguments that you would normally pass to rustc). When you run it
you'll see output similar to</p>
<pre><code class="language-text">In crate: foo,

Found 12 uses of `println!`;
The most common number of arguments is 1 (67% of all functions);
25% of functions have four or more arguments.
</code></pre>
<p>To make things easier, when we talk about functions, we're excluding methods and
closures.</p>
<p>You can also use the executable as a drop-in replacement for rustc, because
after all, that is the whole point of this exercise. So, however you use rustc
in your makefile setup, you can use <code>target/stupid</code> (or whatever executable you
end up with) instead. That might mean setting an environment variable or it
might mean renaming your executable to <code>rustc</code> and setting your PATH. Similarly,
if you're using Cargo, you'll need to rename the executable to rustc and set the
PATH. Alternatively, you should be able to use
<a href="https://github.com/brson/multirust">multirust</a> to get around all the PATH stuff
(although I haven't actually tried that).</p>
<p>(Note that this example prints to stdout. I'm not entirely sure what Cargo does
with stdout from rustc under different circumstances. If you don't see any
output, try inserting a <code>panic!</code> after the <code>println!</code>s to error out, then Cargo
should dump stupid-stats' stdout to Cargo's stdout).</p>
<p>Let's start with the <code>main</code> function for our tool, it is pretty simple:</p>
<pre><code class="language-rust ignore">fn main() {
    let args: Vec&lt;_&gt; = std::env::args().collect();
    rustc_driver::run_compiler(&amp;args, &amp;mut StupidCalls::new());
    std::env::set_exit_status(0);
}
</code></pre>
<p>The first line grabs any command line arguments. The second line calls the
compiler driver with those arguments. The final line sets the exit code for the
program.</p>
<p>The only interesting thing is the <code>StupidCalls</code> object we pass to the driver.
This is our implementation of the <code>CompilerCalls</code> trait and is what will make
this tool different from rustc.</p>
<p><code>StupidCalls</code> is a mostly empty struct:</p>
<pre><code class="language-rust ignore">struct StupidCalls {
    default_calls: RustcDefaultCalls,
}
</code></pre>
<p>This tool is so simple that it doesn't need to store any data here, but usually
you would. We embed a <code>RustcDefaultCalls</code> object to delegate to in our impl when
we want exactly the same behaviour as the Rust compiler. Mostly you don't want
to do that (or at least don't need to) in a tool. However, Cargo calls rustc
with the <code>--print file-names</code>, so we delegate in <code>late_callback</code> and <code>no_input</code>
to keep Cargo happy.</p>
<p>Most of the rest of the impl of <code>CompilerCalls</code> is trivial:</p>
<pre><code class="language-rust ignore">impl&lt;'a&gt; CompilerCalls&lt;'a&gt; for StupidCalls {
    fn early_callback(&amp;mut self,
                        _: &amp;getopts::Matches,
                        _: &amp;config::Options,
                        _: &amp;diagnostics::registry::Registry,
                        _: ErrorOutputType)
                      -&gt; Compilation {
        Compilation::Continue
    }

    fn late_callback(&amp;mut self,
                     t: &amp;TransCrate,
                     m: &amp;getopts::Matches,
                     s: &amp;Session,
                     c: &amp;CrateStore,
                     i: &amp;Input,
                     odir: &amp;Option&lt;PathBuf&gt;,
                     ofile: &amp;Option&lt;PathBuf&gt;)
                     -&gt; Compilation {
        self.default_calls.late_callback(t, m, s, c, i, odir, ofile);
        Compilation::Continue
    }

    fn some_input(&amp;mut self,
                  input: Input,
                  input_path: Option&lt;Path&gt;)
                  -&gt; (Input, Option&lt;Path&gt;) {
        (input, input_path)
    }

    fn no_input(&amp;mut self,
                m: &amp;getopts::Matches,
                o: &amp;config::Options,
                odir: &amp;Option&lt;Path&gt;,
                ofile: &amp;Option&lt;Path&gt;,
                r: &amp;diagnostics::registry::Registry)
                -&gt; Option&lt;(Input, Option&lt;Path&gt;)&gt; {
        self.default_calls.no_input(m, o, odir, ofile, r);

        // This is not optimal error handling.
        panic!(&quot;No input supplied to stupid-stats&quot;);
    }

    fn build_controller(&amp;mut self, _: &amp;Session) -&gt; driver::CompileController&lt;'a&gt; {
        ...
    }
}
</code></pre>
<p>We don't do anything for either of the callbacks, nor do we change the input if
the user supplies it. If they don't, we just <code>panic!</code>, this is the simplest way
to handle the error, but not very user-friendly, a real tool would give a
constructive message or perform a default action.</p>
<p>In <code>build_controller</code> we construct our <code>CompileController</code>. We only want to
parse, and we want to inspect macros before expansion, so we make compilation
stop after the first phase (parsing). The callback after that phase is where the
tool does it's actual work by walking the AST. We do that by creating an AST
visitor and making it walk the AST from the top (the crate root). Once we've
walked the crate, we print the stats we've collected:</p>
<pre><code class="language-rust ignore">fn build_controller(&amp;mut self, _: &amp;Session) -&gt; driver::CompileController&lt;'a&gt; {
    // We mostly want to do what rustc does, which is what basic() will return.
    let mut control = driver::CompileController::basic();
    // But we only need the AST, so we can stop compilation after parsing.
    control.after_parse.stop = Compilation::Stop;

    // And when we stop after parsing we'll call this closure.
    // Note that this will give us an AST before macro expansions, which is
    // not usually what you want.
    control.after_parse.callback = box |state| {
        // Which extracts information about the compiled crate...
        let krate = state.krate.unwrap();

        // ...and walks the AST, collecting stats.
        let mut visitor = StupidVisitor::new();
        visit::walk_crate(&amp;mut visitor, krate);

        // And finally prints out the stupid stats that we collected.
        let cratename = match attr::find_crate_name(&amp;krate.attrs[]) {
            Some(name) =&gt; name.to_string(),
            None =&gt; String::from_str(&quot;unknown_crate&quot;),
        };
        println!(&quot;In crate: {},\n&quot;, cratename);
        println!(&quot;Found {} uses of `println!`;&quot;, visitor.println_count);

        let (common, common_percent, four_percent) = visitor.compute_arg_stats();
        println!(&quot;The most common number of arguments is {} ({:.0}% of all functions);&quot;,
                 common, common_percent);
        println!(&quot;{:.0}% of functions have four or more arguments.&quot;, four_percent);
    };

    control
}
</code></pre>
<p>That is all it takes to create your own drop-in compiler replacement or custom
compiler! For the sake of completeness I'll go over the rest of the stupid-stats
tool.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct StupidVisitor {
    println_count: usize,
    arg_counts: Vec&lt;usize&gt;,
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>StupidVisitor</code> struct just keeps track of the number of <code>println!</code>s it has
seen and the count for each number of arguments. It implements
<code>syntax::visit::Visitor</code> to walk the AST. Mostly we just use the default
methods, these walk the AST taking no action. We override <code>visit_item</code> and
<code>visit_mac</code> to implement custom behaviour when we walk into items (items include
functions, modules, traits, structs, and so forth, we're only interested in
functions) and macros:</p>
<pre><code class="language-rust ignore">impl&lt;'v&gt; visit::Visitor&lt;'v&gt; for StupidVisitor {
    fn visit_item(&amp;mut self, i: &amp;'v ast::Item) {
        match i.node {
            ast::Item_::ItemFn(ref decl, _, _, _, _) =&gt; {
                // Record the number of args.
                self.increment_args(decl.inputs.len());
            }
            _ =&gt; {}
        }

        // Keep walking.
        visit::walk_item(self, i)
    }

    fn visit_mac(&amp;mut self, mac: &amp;'v ast::Mac) {
        // Find its name and check if it is &quot;println&quot;.
        let ast::Mac_::MacInvocTT(ref path, _, _) = mac.node;
        if path_to_string(path) == &quot;println&quot; {
            self.println_count += 1;
        }

        // Keep walking.
        visit::walk_mac(self, mac)
    }
}
</code></pre>
<p>The <code>increment_args</code> method increments the correct count in
<code>StupidVisitor::arg_counts</code>. After we're done walking, <code>compute_arg_stats</code> does
some pretty basic maths to come up with the stats we want about arguments.</p>
<h2><a class="header" href="#what-next" id="what-next">What next?</a></h2>
<p>These APIs are pretty new and have a long way to go until they're really good.
If there are improvements you'd like to see or things you'd like to be able to
do, let me know in a comment or <a href="https://github.com/rust-lang/rust/issues">GitHub issue</a>.
In particular, it's not clear to me exactly what extra flexibility is required.
If you have an existing tool that would be suited to this setup, please try it
out and let me know if you have problems.</p>
<p>It'd be great to see Rustdoc converted to using these APIs, if that is possible
(although long term, I'd prefer to see Rustdoc run on the output from save-
analysis, rather than doing its own analysis). Other parts of the compiler
(e.g., pretty printing, testing) could be refactored to use these APIs
internally (I already changed save-analysis to use <code>CompilerController</code>). I've
been experimenting with a prototype rustfmt which also uses these APIs.</p>
<h1><a class="header" href="#appendix-b-background-topics" id="appendix-b-background-topics">Appendix B: Background topics</a></h1>
<p>This section covers a numbers of common compiler terms that arise in
this guide. We try to give the general definition while providing some
Rust-specific context.</p>
<p><a name="cfg"></a></p>
<h2><a class="header" href="#what-is-a-control-flow-graph" id="what-is-a-control-flow-graph">What is a control-flow graph?</a></h2>
<p>A control-flow graph is a common term from compilers. If you've ever
used a flow-chart, then the concept of a control-flow graph will be
pretty familiar to you. It's a representation of your program that
exposes the underlying control flow in a very clear way.</p>
<p>A control-flow graph is structured as a set of <strong>basic blocks</strong>
connected by edges. The key idea of a basic block is that it is a set
of statements that execute &quot;together&quot; – that is, whenever you branch
to a basic block, you start at the first statement and then execute
all the remainder. Only at the end of the block is there the
possibility of branching to more than one place (in MIR, we call that
final statement the <strong>terminator</strong>):</p>
<pre><code class="language-mir">bb0: {
    statement0;
    statement1;
    statement2;
    ...
    terminator;
}
</code></pre>
<p>Many expressions that you are used to in Rust compile down to multiple
basic blocks. For example, consider an if statement:</p>
<pre><code class="language-rust ignore">a = 1;
if some_variable {
    b = 1;
} else {
    c = 1;
}
d = 1;
</code></pre>
<p>This would compile into four basic blocks:</p>
<pre><code class="language-mir">BB0: {
    a = 1;
    if some_variable { goto BB1 } else { goto BB2 }
}

BB1: {
    b = 1;
    goto BB3;
}

BB2: {
    c = 1;
    goto BB3;
}

BB3: {
    d = 1;
    ...;
}
</code></pre>
<p>When using a control-flow graph, a loop simply appears as a cycle in
the graph, and the <code>break</code> keyword translates into a path out of that
cycle.</p>
<p><a name="dataflow"></a></p>
<h2><a class="header" href="#what-is-a-dataflow-analysis" id="what-is-a-dataflow-analysis">What is a dataflow analysis?</a></h2>
<p><a href="https://cs.au.dk/%7Eamoeller/spa/"><em>Static Program Analysis</em></a> by Anders Møller
and Michael I. Schwartzbach is an incredible resource!</p>
<p><em>to be written</em></p>
<p><a name="quantified"></a></p>
<h2><a class="header" href="#what-is-universally-quantified-what-about-existentially-quantified" id="what-is-universally-quantified-what-about-existentially-quantified">What is &quot;universally quantified&quot;? What about &quot;existentially quantified&quot;?</a></h2>
<p><em>to be written</em></p>
<p><a name="variance"></a></p>
<h2><a class="header" href="#what-is-co--and-contra-variance" id="what-is-co--and-contra-variance">What is co- and contra-variance?</a></h2>
<p>Check out the subtyping chapter from the
<a href="https://doc.rust-lang.org/nomicon/subtyping.html">Rust Nomicon</a>.</p>
<p>See the <a href="rustc-guide/appendix/../variance.html">variance</a> chapter of this guide for more info on how
the type checker handles variance.</p>
<p><a name="free-vs-bound"></a></p>
<h2><a class="header" href="#what-is-a-free-region-or-a-free-variable-what-about-bound-region" id="what-is-a-free-region-or-a-free-variable-what-about-bound-region">What is a &quot;free region&quot; or a &quot;free variable&quot;? What about &quot;bound region&quot;?</a></h2>
<p>Let's describe the concepts of free vs bound in terms of program
variables, since that's the thing we're most familiar with.</p>
<ul>
<li>Consider this expression, which creates a closure: <code>|a, b| a + b</code>. Here, the <code>a</code> and <code>b</code> in <code>a + b</code> refer to the arguments
that the closure will be given when it is called. We say that the
<code>a</code> and <code>b</code> there are <strong>bound</strong> to the closure, and that the closure
signature <code>|a, b|</code> is a <strong>binder</strong> for the names <code>a</code> and <code>b</code>
(because any references to <code>a</code> or <code>b</code> within refer to the variables
that it introduces).</li>
<li>Consider this expression: <code>a + b</code>. In this expression, <code>a</code> and <code>b</code>
refer to local variables that are defined <em>outside</em> of the
expression. We say that those variables <strong>appear free</strong> in the
expression (i.e., they are <strong>free</strong>, not <strong>bound</strong> (tied up)).</li>
</ul>
<p>So there you have it: a variable &quot;appears free&quot; in some
expression/statement/whatever if it refers to something defined
outside of that expressions/statement/whatever. Equivalently, we can
then refer to the &quot;free variables&quot; of an expression – which is just
the set of variables that &quot;appear free&quot;.</p>
<p>So what does this have to do with regions? Well, we can apply the
analogous concept to type and regions. For example, in the type <code>&amp;'a u32</code>, <code>'a</code> appears free.  But in the type <code>for&lt;'a&gt; fn(&amp;'a u32)</code>, it
does not.</p>
<h1><a class="header" href="#appendix-c-glossary" id="appendix-c-glossary">Appendix C: Glossary</a></h1>
<p>The compiler uses a number of...idiosyncratic abbreviations and things. This
glossary attempts to list them and give you a few pointers for understanding
them better.</p>
<table><thead><tr><th>Term</th><th>Meaning</th></tr></thead><tbody>
<tr><td>AST</td><td>the abstract syntax tree produced by the syntax crate; reflects user syntax very closely.</td></tr>
<tr><td>binder</td><td>a &quot;binder&quot; is a place where a variable or type is declared; for example, the <code>&lt;T&gt;</code> is a binder for the generic type parameter <code>T</code> in <code>fn foo&lt;T&gt;(..)</code>, and |<code>a</code>|<code> ...</code> is a binder for the parameter <code>a</code>. See <a href="rustc-guide/appendix/./background.html#free-vs-bound">the background chapter for more</a></td></tr>
<tr><td>bound variable</td><td>a &quot;bound variable&quot; is one that is declared within an expression/term. For example, the variable <code>a</code> is bound within the closure expession |<code>a</code>|<code> a * 2</code>. See <a href="rustc-guide/appendix/./background.html#free-vs-bound">the background chapter for more</a></td></tr>
<tr><td>codegen</td><td>the code to translate MIR into LLVM IR.</td></tr>
<tr><td>codegen unit</td><td>when we produce LLVM IR, we group the Rust code into a number of codegen units. Each of these units is processed by LLVM independently from one another, enabling parallelism. They are also the unit of incremental re-use.</td></tr>
<tr><td>completeness</td><td>completeness is a technical term in type theory. Completeness means that every type-safe program also type-checks. Having both soundness and completeness is very hard, and usually soundness is more important. (see &quot;soundness&quot;).</td></tr>
<tr><td>control-flow graph</td><td>a representation of the control-flow of a program; see <a href="rustc-guide/appendix/./background.html#cfg">the background chapter for more</a></td></tr>
<tr><td>CTFE</td><td>Compile-Time Function Evaluation. This is the ability of the compiler to evaluate <code>const fn</code>s at compile time. This is part of the compiler's constant evaluation system. (<a href="rustc-guide/appendix/../const-eval.html">see more</a>)</td></tr>
<tr><td>cx</td><td>we tend to use &quot;cx&quot; as an abbreviation for context. See also <code>tcx</code>, <code>infcx</code>, etc.</td></tr>
<tr><td>DAG</td><td>a directed acyclic graph is used during compilation to keep track of dependencies between queries. (<a href="rustc-guide/appendix/../queries/incremental-compilation.html">see more</a>)</td></tr>
<tr><td>data-flow analysis</td><td>a static analysis that figures out what properties are true at each point in the control-flow of a program; see <a href="rustc-guide/appendix/./background.html#dataflow">the background chapter for more</a></td></tr>
<tr><td>DefId</td><td>an index identifying a definition (see <code>librustc/hir/def_id.rs</code>). Uniquely identifies a <code>DefPath</code>.</td></tr>
<tr><td>Double pointer</td><td>a pointer with additional metadata. See &quot;fat pointer&quot; for more.</td></tr>
<tr><td>drop glue</td><td>(internal) compiler-generated instructions that handle calling the destructors (<code>Drop</code>) for data types.</td></tr>
<tr><td>DST</td><td>Dynamically-Sized Type. A type for which the compiler cannot statically know the size in memory (e.g. <code>str</code> or <code>[u8]</code>). Such types don't implement <code>Sized</code> and cannot be allocated on the stack. They can only occur as the last field in a struct. They can only be used behind a pointer (e.g. <code>&amp;str</code> or <code>&amp;[u8]</code>).</td></tr>
<tr><td>early-bound lifetime</td><td>a lifetime region that is substituted at its definition site. Bound in an item's <code>Generics</code> and substituted using a <code>Substs</code>. Contrast with <strong>late-bound lifetime</strong>. (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/enum.RegionKind.html#bound-regions">see more</a>)</td></tr>
<tr><td>empty type</td><td>see &quot;uninhabited type&quot;.</td></tr>
<tr><td>Fat pointer</td><td>a two word value carrying the address of some value, along with some further information necessary to put the value to use. Rust includes two kinds of &quot;fat pointers&quot;: references to slices, and trait objects. A reference to a slice carries the starting address of the slice and its length. A trait object carries a value's address and a pointer to the trait's implementation appropriate to that value. &quot;Fat pointers&quot; are also known as &quot;wide pointers&quot;, and &quot;double pointers&quot;.</td></tr>
<tr><td>free variable</td><td>a &quot;free variable&quot; is one that is not bound within an expression or term; see <a href="rustc-guide/appendix/./background.html#free-vs-bound">the background chapter for more</a></td></tr>
<tr><td>generics</td><td>the set of generic type parameters defined on a type or item</td></tr>
<tr><td>HIR</td><td>the High-level IR, created by lowering and desugaring the AST (<a href="rustc-guide/appendix/../hir.html">see more</a>)</td></tr>
<tr><td>HirId</td><td>identifies a particular node in the HIR by combining a def-id with an &quot;intra-definition offset&quot;.</td></tr>
<tr><td>HIR Map</td><td>The HIR map, accessible via tcx.hir, allows you to quickly navigate the HIR and convert between various forms of identifiers.</td></tr>
<tr><td>ICE</td><td>internal compiler error. When the compiler crashes.</td></tr>
<tr><td>ICH</td><td>incremental compilation hash. ICHs are used as fingerprints for things such as HIR and crate metadata, to check if changes have been made. This is useful in incremental compilation to see if part of a crate has changed and should be recompiled.</td></tr>
<tr><td>inference variable</td><td>when doing type or region inference, an &quot;inference variable&quot; is a kind of special type/region that represents what you are trying to infer. Think of X in algebra. For example, if we are trying to infer the type of a variable in a program, we create an inference variable to represent that unknown type.</td></tr>
<tr><td>infcx</td><td>the inference context (see <code>librustc/infer</code>)</td></tr>
<tr><td>intern</td><td>interning refers to storing certain frequently-used constant data, such as strings, and then referring to the data by an identifier (e.g. a <code>Symbol</code>) rather than the data itself, to reduce memory usage.</td></tr>
<tr><td>IR</td><td>Intermediate Representation. A general term in compilers. During compilation, the code is transformed from raw source (ASCII text) to various IRs. In Rust, these are primarily HIR, MIR, and LLVM IR. Each IR is well-suited for some set of computations. For example, MIR is well-suited for the borrow checker, and LLVM IR is well-suited for codegen because LLVM accepts it.</td></tr>
<tr><td>IRLO</td><td><code>IRLO</code> or <code>irlo</code> is sometimes used as an abbreviation for <a href="https://internals.rust-lang.org">internals.rust-lang.org</a>.</td></tr>
<tr><td>item</td><td>a kind of &quot;definition&quot; in the language, such as a static, const, use statement, module, struct, etc. Concretely, this corresponds to the <code>Item</code> type.</td></tr>
<tr><td>lang item</td><td>items that represent concepts intrinsic to the language itself, such as special built-in traits like <code>Sync</code> and <code>Send</code>; or traits representing operations such as <code>Add</code>; or functions that are called by the compiler. (<a href="https://doc.rust-lang.org/1.9.0/book/lang-items.html">see more</a>)</td></tr>
<tr><td>late-bound lifetime</td><td>a lifetime region that is substituted at its call site. Bound in a HRTB and substituted by specific functions in the compiler, such as <code>liberate_late_bound_regions</code>. Contrast with <strong>early-bound lifetime</strong>. (<a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/enum.RegionKind.html#bound-regions">see more</a>)</td></tr>
<tr><td>local crate</td><td>the crate currently being compiled.</td></tr>
<tr><td>LTO</td><td>Link-Time Optimizations. A set of optimizations offered by LLVM that occur just before the final binary is linked. These include optimizations like removing functions that are never used in the final program, for example. <em>ThinLTO</em> is a variant of LTO that aims to be a bit more scalable and efficient, but possibly sacrifices some optimizations. You may also read issues in the Rust repo about &quot;FatLTO&quot;, which is the loving nickname given to non-Thin LTO. LLVM documentation: <a href="https://llvm.org/docs/LinkTimeOptimization.html">here</a> and <a href="https://clang.llvm.org/docs/ThinLTO.html">here</a></td></tr>
<tr><td><a href="https://llvm.org/">LLVM</a></td><td>(actually not an acronym :P) an open-source compiler backend. It accepts LLVM IR and outputs native binaries. Various languages (e.g. Rust) can then implement a compiler front-end that output LLVM IR and use LLVM to compile to all the platforms LLVM supports.</td></tr>
<tr><td>memoize</td><td>memoization is the process of storing the results of (pure) computations (such as pure function calls) to avoid having to repeat them in the future. This is typically a trade-off between execution speed and memory usage.</td></tr>
<tr><td>MIR</td><td>the Mid-level IR that is created after type-checking for use by borrowck and codegen (<a href="rustc-guide/appendix/../mir/index.html">see more</a>)</td></tr>
<tr><td>miri</td><td>an interpreter for MIR used for constant evaluation (<a href="rustc-guide/appendix/../miri.html">see more</a>)</td></tr>
<tr><td>normalize</td><td>a general term for converting to a more canonical form, but in the case of rustc typically refers to <a href="rustc-guide/appendix/../traits/associated-types.html#normalize">associated type normalization</a></td></tr>
<tr><td>newtype</td><td>a &quot;newtype&quot; is a wrapper around some other type (e.g., <code>struct Foo(T)</code> is a &quot;newtype&quot; for <code>T</code>). This is commonly used in Rust to give a stronger type for indices.</td></tr>
<tr><td>NLL</td><td><a href="rustc-guide/appendix/../borrow_check/region_inference.html">non-lexical lifetimes</a>, an extension to Rust's borrowing system to make it be based on the control-flow graph.</td></tr>
<tr><td>node-id or NodeId</td><td>an index identifying a particular node in the AST or HIR; gradually being phased out and replaced with <code>HirId</code>.</td></tr>
<tr><td>obligation</td><td>something that must be proven by the trait system (<a href="rustc-guide/appendix/../traits/resolution.html">see more</a>)</td></tr>
<tr><td>point</td><td>used in the NLL analysis to refer to some particular location in the MIR; typically used to refer to a node in the control-flow graph.</td></tr>
<tr><td>projection</td><td>a general term for a &quot;relative path&quot;, e.g. <code>x.f</code> is a &quot;field projection&quot;, and <code>T::Item</code> is an <a href="rustc-guide/appendix/../traits/goals-and-clauses.html#trait-ref">&quot;associated type projection&quot;</a></td></tr>
<tr><td>promoted constants</td><td>constants extracted from a function and lifted to static scope; see <a href="rustc-guide/appendix/../mir/index.html#promoted">this section</a> for more details.</td></tr>
<tr><td>provider</td><td>the function that executes a query (<a href="rustc-guide/appendix/../query.html">see more</a>)</td></tr>
<tr><td>quantified</td><td>in math or logic, existential and universal quantification are used to ask questions like &quot;is there any type T for which is true?&quot; or &quot;is this true for all types T?&quot;; see <a href="rustc-guide/appendix/./background.html#quantified">the background chapter for more</a></td></tr>
<tr><td>query</td><td>perhaps some sub-computation during compilation (<a href="rustc-guide/appendix/../query.html">see more</a>)</td></tr>
<tr><td>region</td><td>another term for &quot;lifetime&quot; often used in the literature and in the borrow checker.</td></tr>
<tr><td>rib</td><td>a data structure in the name resolver that keeps track of a single scope for names. (<a href="rustc-guide/appendix/../name-resolution.html">see more</a>)</td></tr>
<tr><td>sess</td><td>the compiler session, which stores global data used throughout compilation</td></tr>
<tr><td>side tables</td><td>because the AST and HIR are immutable once created, we often carry extra information about them in the form of hashtables, indexed by the id of a particular node.</td></tr>
<tr><td>sigil</td><td>like a keyword but composed entirely of non-alphanumeric tokens. For example, <code>&amp;</code> is a sigil for references.</td></tr>
<tr><td>placeholder</td><td><strong>NOTE: skolemization is deprecated by placeholder</strong> a way of handling subtyping around &quot;for-all&quot; types (e.g., <code>for&lt;'a&gt; fn(&amp;'a u32)</code>) as well as solving higher-ranked trait bounds (e.g., <code>for&lt;'a&gt; T: Trait&lt;'a&gt;</code>). See <a href="rustc-guide/appendix/../borrow_check/region_inference.html#placeholders-and-universes">the chapter on placeholder and universes</a> for more details.</td></tr>
<tr><td>soundness</td><td>soundness is a technical term in type theory. Roughly, if a type system is sound, then if a program type-checks, it is type-safe; i.e. I can never (in safe rust) force a value into a variable of the wrong type. (see &quot;completeness&quot;).</td></tr>
<tr><td>span</td><td>a location in the user's source code, used for error reporting primarily. These are like a file-name/line-number/column tuple on steroids: they carry a start/end point, and also track macro expansions and compiler desugaring. All while being packed into a few bytes (really, it's an index into a table). See the Span datatype for more.</td></tr>
<tr><td>substs</td><td>the substitutions for a given generic type or item (e.g. the <code>i32</code>, <code>u32</code> in <code>HashMap&lt;i32, u32&gt;</code>)</td></tr>
<tr><td>tcx</td><td>the &quot;typing context&quot;, main data structure of the compiler (<a href="rustc-guide/appendix/../ty.html">see more</a>)</td></tr>
<tr><td>'tcx</td><td>the lifetime of the allocation arena (<a href="rustc-guide/appendix/../ty.html">see more</a>)</td></tr>
<tr><td>trait reference</td><td>the name of a trait along with a suitable set of input type/lifetimes (<a href="rustc-guide/appendix/../traits/goals-and-clauses.html#trait-ref">see more</a>)</td></tr>
<tr><td>token</td><td>the smallest unit of parsing. Tokens are produced after lexing (<a href="rustc-guide/appendix/../the-parser.html">see more</a>).</td></tr>
<tr><td><a href="https://llvm.org/docs/LangRef.html#thread-local-storage-models">TLS</a></td><td>Thread-Local Storage. Variables may be defined so that each thread has its own copy (rather than all threads sharing the variable). This has some interactions with LLVM. Not all platforms support TLS.</td></tr>
<tr><td>trans</td><td>the code to translate MIR into LLVM IR. Renamed to codegen.</td></tr>
<tr><td>trait reference</td><td>a trait and values for its type parameters (<a href="rustc-guide/appendix/../ty.html">see more</a>).</td></tr>
<tr><td>ty</td><td>the internal representation of a type (<a href="rustc-guide/appendix/../ty.html">see more</a>).</td></tr>
<tr><td>UFCS</td><td>Universal Function Call Syntax. An unambiguous syntax for calling a method (<a href="rustc-guide/appendix/../type-checking.html">see more</a>).</td></tr>
<tr><td>uninhabited type</td><td>a type which has <em>no</em> values. This is not the same as a ZST, which has exactly 1 value. An example of an uninhabited type is <code>enum Foo {}</code>, which has no variants, and so, can never be created. The compiler can treat code that deals with uninhabited types as dead code, since there is no such value to be manipulated. <code>!</code> (the never type) is an uninhabited type. Uninhabited types are also called &quot;empty types&quot;.</td></tr>
<tr><td>upvar</td><td>a variable captured by a closure from outside the closure.</td></tr>
<tr><td>variance</td><td>variance determines how changes to a generic type/lifetime parameter affect subtyping; for example, if <code>T</code> is a subtype of <code>U</code>, then <code>Vec&lt;T&gt;</code> is a subtype <code>Vec&lt;U&gt;</code> because <code>Vec</code> is <em>covariant</em> in its generic parameter. See <a href="rustc-guide/appendix/./background.html#variance">the background chapter</a> for a more general explanation. See the <a href="rustc-guide/appendix/../variance.html">variance chapter</a> for an explanation of how type checking handles variance.</td></tr>
<tr><td>Wide pointer</td><td>a pointer with additional metadata. See &quot;fat pointer&quot; for more.</td></tr>
<tr><td>ZST</td><td>Zero-Sized Type. A type whose values have size 0 bytes. Since <code>2^0 = 1</code>, such types can have exactly one value. For example, <code>()</code> (unit) is a ZST. <code>struct Foo;</code> is also a ZST. The compiler can do some nice optimizations around ZSTs.</td></tr>
</tbody></table>
<h1><a class="header" href="#appendix-d-code-index" id="appendix-d-code-index">Appendix D: Code Index</a></h1>
<p>rustc has a lot of important data structures. This is an attempt to give some
guidance on where to learn more about some of the key data structures of the
compiler.</p>
<table><thead><tr><th>Item</th><th>Kind</th><th>Short description</th><th>Chapter</th><th>Declaration</th></tr></thead><tbody>
<tr><td><code>BodyId</code></td><td>struct</td><td>One of four types of HIR node identifiers</td><td><a href="rustc-guide/appendix/../hir.html#hir-id">Identifiers in the HIR</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.BodyId.html">src/librustc/hir/mod.rs</a></td></tr>
<tr><td><code>Compiler</code></td><td>struct</td><td>Represents a compiler session and can be used to drive a compilation.</td><td><a href="rustc-guide/appendix/../rustc-driver.html">The Rustc Driver and Interface</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/interface/struct.Compiler.html">src/librustc_interface/interface.rs</a></td></tr>
<tr><td><code>ast::Crate</code></td><td>struct</td><td>A syntax-level representation of a parsed crate</td><td><a href="rustc-guide/appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.Crate.html">src/librustc/hir/mod.rs</a></td></tr>
<tr><td><code>hir::Crate</code></td><td>struct</td><td>A more abstract, compiler-friendly form of a crate's AST</td><td><a href="rustc-guide/appendix/../hir.html">The Hir</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.Crate.html">src/librustc/hir/mod.rs</a></td></tr>
<tr><td><code>DefId</code></td><td>struct</td><td>One of four types of HIR node identifiers</td><td><a href="rustc-guide/appendix/../hir.html#hir-id">Identifiers in the HIR</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/def_id/struct.DefId.html">src/librustc/hir/def_id.rs</a></td></tr>
<tr><td><code>DiagnosticBuilder</code></td><td>struct</td><td>A struct for building up compiler diagnostics, such as errors or lints</td><td><a href="rustc-guide/appendix/../diagnostics.html">Emitting Diagnostics</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_errors/struct.DiagnosticBuilder.html">src/librustc_errors/diagnostic_builder.rs</a></td></tr>
<tr><td><code>DocContext</code></td><td>struct</td><td>A state container used by rustdoc when crawling through a crate to gather its documentation</td><td><a href="rustc-guide/appendix/../rustdoc.html">Rustdoc</a></td><td><a href="https://github.com/rust-lang/rust/blob/master/src/librustdoc/core.rs">src/librustdoc/core.rs</a></td></tr>
<tr><td><code>HirId</code></td><td>struct</td><td>One of four types of HIR node identifiers</td><td><a href="rustc-guide/appendix/../hir.html#hir-id">Identifiers in the HIR</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/struct.HirId.html">src/librustc/hir/mod.rs</a></td></tr>
<tr><td><code>NodeId</code></td><td>struct</td><td>One of four types of HIR node identifiers. Being phased out</td><td><a href="rustc-guide/appendix/../hir.html#hir-id">Identifiers in the HIR</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ast/struct.NodeId.html">src/libsyntax/ast.rs</a></td></tr>
<tr><td><code>P</code></td><td>struct</td><td>An owned immutable smart pointer. By contrast, <code>&amp;T</code> is not owned, and <code>Box&lt;T&gt;</code> is not immutable.</td><td>None</td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/ptr/struct.P.html">src/syntax/ptr.rs</a></td></tr>
<tr><td><code>ParamEnv</code></td><td>struct</td><td>Information about generic parameters or <code>Self</code>, useful for working with associated or generic items</td><td><a href="rustc-guide/appendix/../param_env.html">Parameter Environment</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/struct.ParamEnv.html">src/librustc/ty/mod.rs</a></td></tr>
<tr><td><code>ParseSess</code></td><td>struct</td><td>This struct contains information about a parsing session</td><td><a href="rustc-guide/appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/struct.ParseSess.html">src/libsyntax/parse/mod.rs</a></td></tr>
<tr><td><code>Query</code></td><td>struct</td><td>Represents the result of query to the <code>Compiler</code> interface and allows stealing, borrowing, and returning the results of compiler passes.</td><td><a href="rustc-guide/appendix/../rustc-driver.html">The Rustc Driver and Interface</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_interface/queries/struct.Query.html">src/librustc_interface/queries.rs</a></td></tr>
<tr><td><code>Rib</code></td><td>struct</td><td>Represents a single scope of names</td><td><a href="rustc-guide/appendix/../name-resolution.html">Name resolution</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/struct.Rib.html">src/librustc_resolve/lib.rs</a></td></tr>
<tr><td><code>Session</code></td><td>struct</td><td>The data associated with a compilation session</td><td><a href="rustc-guide/appendix/../the-parser.html">The parser</a>, <a href="rustc-guide/appendix/../rustc-driver.html">The Rustc Driver and Interface</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/session/struct.Session.html">src/librustc/session/mod.html</a></td></tr>
<tr><td><code>SourceFile</code></td><td>struct</td><td>Part of the <code>SourceMap</code>. Maps AST nodes to their source code for a single source file. Was previously called FileMap</td><td><a href="rustc-guide/appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.SourceFile.html">src/libsyntax_pos/lib.rs</a></td></tr>
<tr><td><code>SourceMap</code></td><td>struct</td><td>Maps AST nodes to their source code. It is composed of <code>SourceFile</code>s. Was previously called CodeMap</td><td><a href="rustc-guide/appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/source_map/struct.SourceMap.html">src/libsyntax/source_map.rs</a></td></tr>
<tr><td><code>Span</code></td><td>struct</td><td>A location in the user's source code, used for error reporting primarily</td><td><a href="rustc-guide/appendix/../diagnostics.html">Emitting Diagnostics</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax_pos/struct.Span.html">src/libsyntax_pos/span_encoding.rs</a></td></tr>
<tr><td><code>StringReader</code></td><td>struct</td><td>This is the lexer used during parsing. It consumes characters from the raw source code being compiled and produces a series of tokens for use by the rest of the parser</td><td><a href="rustc-guide/appendix/../the-parser.html">The parser</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/parse/lexer/struct.StringReader.html">src/libsyntax/parse/lexer/mod.rs</a></td></tr>
<tr><td><code>syntax::token_stream::TokenStream</code></td><td>struct</td><td>An abstract sequence of tokens, organized into <code>TokenTree</code>s</td><td><a href="rustc-guide/appendix/../the-parser.html">The parser</a>, <a href="rustc-guide/appendix/../macro-expansion.html">Macro expansion</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/syntax/tokenstream/struct.TokenStream.html">src/libsyntax/tokenstream.rs</a></td></tr>
<tr><td><code>TraitDef</code></td><td>struct</td><td>This struct contains a trait's definition with type information</td><td><a href="rustc-guide/appendix/../ty.html">The <code>ty</code> modules</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/trait_def/struct.TraitDef.html">src/librustc/ty/trait_def.rs</a></td></tr>
<tr><td><code>TraitRef</code></td><td>struct</td><td>The combination of a trait and its input types (e.g. <code>P0: Trait&lt;P1...Pn&gt;</code>)</td><td><a href="rustc-guide/appendix/../traits/goals-and-clauses.html#domain-goals">Trait Solving: Goals and Clauses</a>, <a href="rustc-guide/appendix/../traits/lowering-rules.html#lowering-impls">Trait Solving: Lowering impls</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/struct.TraitRef.html">src/librustc/ty/sty.rs</a></td></tr>
<tr><td><code>Ty&lt;'tcx&gt;</code></td><td>struct</td><td>This is the internal representation of a type used for type checking</td><td><a href="rustc-guide/appendix/../type-checking.html">Type checking</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/type.Ty.html">src/librustc/ty/mod.rs</a></td></tr>
<tr><td><code>TyCtxt&lt;'tcx&gt;</code></td><td>struct</td><td>The &quot;typing context&quot;. This is the central data structure in the compiler. It is the context that you use to perform all manner of queries</td><td><a href="rustc-guide/appendix/../ty.html">The <code>ty</code> modules</a></td><td><a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustc/ty/struct.TyCtxt.html">src/librustc/ty/context.rs</a></td></tr>
</tbody></table>
<h1><a class="header" href="#rust-bibliography" id="rust-bibliography">Rust Bibliography</a></h1>
<p>This is a reading list of material relevant to Rust. It includes prior
research that has - at one time or another - influenced the design of
Rust, as well as publications about Rust.</p>
<h2><a class="header" href="#type-system" id="type-system">Type system</a></h2>
<ul>
<li><a href="https://www.cs.umd.edu/projects/cyclone/papers/cyclone-regions.pdf">Region based memory management in Cyclone</a></li>
<li><a href="http://www.cs.umd.edu/projects/PL/cyclone/scp.pdf">Safe manual memory management in Cyclone</a></li>
<li><a href="http://www.ps.uni-sb.de/courses/typen-ws99/class.ps.gz">Typeclasses: making ad-hoc polymorphism less ad hoc</a></li>
<li><a href="https://www.cs.utah.edu/plt/publications/jfp12-draft-fcdf.pdf">Macros that work together</a></li>
<li><a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">Traits: composable units of behavior</a></li>
<li><a href="http://www.cs.uwm.edu/faculty/boyland/papers/unique-preprint.ps">Alias burying</a> - We tried something similar and abandoned it.</li>
<li><a href="http://www.cs.uu.nl/research/techreps/UU-CS-2002-048.html">External uniqueness is unique enough</a></li>
<li><a href="https://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf">Uniqueness and Reference Immutability for Safe Parallelism</a></li>
<li><a href="http://www.cs.ucla.edu/%7Epalsberg/tba/papers/tofte-talpin-iandc97.pdf">Region Based Memory Management</a></li>
</ul>
<h2><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h2>
<ul>
<li><a href="https://research.microsoft.com/pubs/69431/osr2007_rethinkingsoftwarestack.pdf">Singularity: rethinking the software stack</a></li>
<li><a href="https://research.microsoft.com/pubs/67482/singsharp.pdf">Language support for fast and reliable message passing in singularity OS</a></li>
<li><a href="http://supertech.csail.mit.edu/papers/steal.pdf">Scheduling multithreaded computations by work stealing</a></li>
<li><a href="http://www.eecis.udel.edu/%7Ecavazos/cisc879-spring2008/papers/arora98thread.pdf">Thread scheduling for multiprogramming multiprocessors</a></li>
<li><a href="http://www.aladdin.cs.cmu.edu/papers/pdfs/y2000/locality_spaa00.pdf">The data locality of work stealing</a></li>
<li><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.1097&amp;rep=rep1&amp;type=pdf">Dynamic circular work stealing deque</a> - The Chase/Lev deque</li>
<li><a href="http://www.cs.rice.edu/%7Eyguo/pubs/PID824943.pdf">Work-first and help-first scheduling policies for async-finish task parallelism</a> - More general than fully-strict work stealing</li>
<li><a href="http://www.coopsoft.com/ar/CalamityArticle.html">A Java fork/join calamity</a> - critique of Java's fork/join library, particularly its application of work stealing to non-strict computation</li>
<li><a href="http://www.stanford.edu/%7Eouster/cgi-bin/papers/coscheduling.pdf">Scheduling techniques for concurrent systems</a></li>
<li><a href="http://www.blagodurov.net/files/a8-blagodurov.pdf">Contention aware scheduling</a></li>
<li><a href="http://www.cse.ohio-state.edu/hpcs/WWW/HTML/publications/papers/TR-12-1.pdf">Balanced work stealing for time-sharing multicores</a></li>
<li><a href="http://dl.acm.org/citation.cfm?id=1953616&amp;dl=ACM&amp;coll=DL&amp;CFID=524387192&amp;CFTOKEN=44362705">Three layer cake for shared-memory programming</a></li>
<li><a href="http://www.cs.bgu.ac.il/%7Ehendlerd/papers/p280-hendler.pdf">Non-blocking steal-half work queues</a></li>
<li><a href="http://aturon.github.io/academic/reagents.pdf">Reagents: expressing and composing fine-grained concurrency</a></li>
<li><a href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">Algorithms for scalable synchronization of shared-memory multiprocessors</a></li>
<li><a href="https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-579.pdf">Epoch-based reclamation</a>.</li>
</ul>
<h2><a class="header" href="#others" id="others">Others</a></h2>
<ul>
<li><a href="https://www.usenix.org/legacy/events/hotos03/tech/full_papers/candea/candea.pdf">Crash-only software</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-pldi2001.pdf">Composing High-Performance Memory Allocators</a></li>
<li><a href="http://people.cs.umass.edu/%7Eemery/pubs/berger-oopsla2002.pdf">Reconsidering Custom Memory Allocation</a></li>
</ul>
<h2><a class="header" href="#papers-about-rust" id="papers-about-rust">Papers <em>about</em> Rust</a></h2>
<ul>
<li><a href="https://www.cs.indiana.edu/%7Eachauhan/Publications/Pubs/2013-hips-holk-rust.pdf">GPU Programming in Rust: Implementing High Level Abstractions in a Systems
Level
Language</a>.
Early GPU work by Eric Holk.</li>
<li><a href="https://www.usenix.org/conference/hotpar12/parallel-closures-new-twist-old-idea">Parallel closures: a new twist on an old
idea</a>
<ul>
<li>not exactly about Rust, but by nmatsakis</li>
</ul>
</li>
<li><a href="http://dada.cs.washington.edu/research/tr/2015/03/UW-CSE-15-03-02.pdf">Patina: A Formalization of the Rust Programming
Language</a>.
Early formalization of a subset of the type system, by Eric Reed.</li>
<li><a href="http://arxiv.org/abs/1505.07383">Experience Report: Developing the Servo Web Browser Engine using
Rust</a>. By Lars Bergstrom.</li>
<li><a href="https://michaelsproul.github.io/rust_radix_paper/rust-radix-sproul.pdf">Implementing a Generic Radix Trie in
Rust</a>. Undergrad
paper by Michael Sproul.</li>
<li><a href="http://scialex.github.io/reenix.pdf">Reenix: Implementing a Unix-Like Operating System in
Rust</a>. Undergrad paper by Alex
Light.</li>
<li><a href="http://octarineparrot.com/assets/mrfloya-thesis-ba.pdf">Evaluation of performance and productivity metrics of potential programming languages in the HPC environment</a>.
Bachelor's thesis by Florian Wilkens. Compares C, Go and Rust.</li>
<li><a href="http://spw15.langsec.org/papers/couprie-nom.pdf">Nom, a byte oriented, streaming, zero copy, parser combinators library
in Rust</a>. By
Geoffroy Couprie, research for VLC.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">Graph-Based Higher-Order Intermediate
Representation</a>. An
experimental IR implemented in Impala, a Rust-like language.</li>
<li><a href="http://compilers.cs.uni-saarland.de/papers/ppl14_web.pdf">Code Refinement of Stencil
Codes</a>. Another
paper using Impala.</li>
<li><a href="http://publications.lib.chalmers.se/records/fulltext/219016/219016.pdf">Parallelization in Rust with fork-join and
friends</a>. Linus
Farnstrand's master's thesis.</li>
<li><a href="http://munksgaard.me/papers/laumann-munksgaard-larsen.pdf">Session Types for
Rust</a>. Philip
Munksgaard's master's thesis. Research for Servo.</li>
<li><a href="http://amitlevy.com/papers/tock-plos2015.pdf">Ownership is Theft: Experiences Building an Embedded OS in Rust - Amit Levy, et. al.</a></li>
<li><a href="https://raw.githubusercontent.com/Gankro/thesis/master/thesis.pdf">You can't spell trust without Rust</a>. Alexis Beingessner's master's thesis.</li>
<li><a href="http://bioinformatics.oxfordjournals.org/content/early/2015/10/06/bioinformatics.btv573">Rust-Bio: a fast and safe bioinformatics library</a>. Johannes Köster</li>
<li><a href="https://octarineparrot.com/assets/msci_paper.pdf">Safe, Correct, and Fast Low-Level Networking</a>. Robert Clipsham's master's thesis.</li>
<li><a href="http://hdl.handle.net/2429/55609">Formalizing Rust traits</a>. Jonatan Milewski's master's thesis.</li>
<li><a href="http://users.cecs.anu.edu.au/%7Esteveb/downloads/pdf/rust-ismm-2016.pdf">Rust as a Language for High Performance GC Implementation</a></li>
<li><a href="https://github.com/Kha/electrolysis">Simple Verification of Rust Programs via Functional Purification</a>. Sebastian Ullrich's master's thesis.</li>
<li><a href="http://spw17.langsec.org/papers/chifflier-parsing-in-2017.pdf">Writing parsers like it is 2017</a> Pierre Chifflier and Geoffroy Couprie for the Langsec Workshop</li>
<li><a href="https://www.tockos.org/assets/papers/rust-kernel-apsys2017.pdf">The Case for Writing a Kernel in Rust</a></li>
<li><a href="https://plv.mpi-sws.org/rustbelt/popl18/">RustBelt: Securing the Foundations of the Rust Programming Language</a></li>
</ul>
<h1><a class="header" href="#ignore-me" id="ignore-me">Ignore me</a></h1>
<p>This file is a collection of links that are not link-checked by anyone else,
but we want them to work. For example, the stabilization guide link is often
posted to tracking issues on GitHub, which might break later if the guide is
changed.</p>
<p><a href="https://imgur.com/gallery/mSHi8">Skip this file. Or read it; I'm a book, not a cop.</a></p>
<p><a href="https://forge.rust-lang.org/stabilization-guide.html">link</a>
<a href="https://forge.rust-lang.org/stabilization-guide.html#updating-documentation">link</a>
<a href="https://forge.rust-lang.org/stabilization-guide.html#documentation-prs">link</a></p>
<p><a href="https://rust-lang.github.io/rustc-guide/stabilization_guide.html">link</a>
<a href="https://rust-lang.github.io/rustc-guide/stabilization_guide.html#updating-documentation">link</a>
<a href="https://rust-lang.github.io/rustc-guide/stabilization_guide.html#documentation-prs">link</a></p>
<h2><a class="header" href="#title-overview" id="title-overview">title: Overview</a></h2>
<p>This is based on the posts I wrote on <strong>Medium</strong>, https://medium.com/learning-rust</p>
<p><a href="https://medium.com/learning-rust"><img src="learningrust/images/learning_rust_medium.png" alt="Rust Playground" /></a></p>
<blockquote>
<p>🐣 I am a <strong>Sri Lankan</strong> 🇱🇰 Web Developer who lives in <strong>Vietnam</strong> 🇻🇳. So I am not a native English speaker and just learning Rust, If you found any mistake or something need to be changed, even a spelling or a grammar mistake, feel free to create a pull request. Thanks.</p>
</blockquote>
<h2><a class="header" href="#title-why-rust" id="title-why-rust">title: Why Rust?</a></h2>
<h2><a class="header" href="#history-of-rust" id="history-of-rust">History of Rust</a></h2>
<p>Rust was initially designed and developed by Mozilla employee <strong>Graydon Hoare</strong> as a personal project. Mozilla began sponsoring the project in 2009 and announced it in 2010. But the first stable release, Rust 1.0 was released on May 15, 2015.</p>
<h2><a class="header" href="#initial-goals" id="initial-goals">Initial Goals</a></h2>
<p>The goal of Rust is to be a good programming language for creating highly concurrent, safe and performant systems.</p>
<blockquote>
<p>&quot;Rust is a systems programming language focused on three goals: safety, speed, and concurrency.&quot;<br />
__ Rust Documentation</p>
</blockquote>
<p>Rust is very young and very modern language. It is a <strong>compiled programming language</strong> and it uses <a href="https://en.wikipedia.org/wiki/LLVM">LLVM</a> on the backend. Also, Rust is a <strong>multi-paradigm programming language</strong>, which supports imperative procedural, concurrent actor, object-oriented and pure functional styles. It also supports generic programming and metaprogramming, in both static and dynamic styles.</p>
<blockquote>
<p>🔎 One of Rust’s most unique and compelling features is <a href="learningrust/c1.ownership.html">Ownership</a>, which is used to achieve memory safety. Rust creates memory pointers optimistically, checks memory pointers’ limited accesses at compile-time with the usage of <a href="learningrust/c2.borrowing.html">References and Borrowing</a>. And it does automatic compile-time memory management by checking the <a href="learningrust/c3.lifetimes.html">Lifetimes</a>.</p>
</blockquote>
<h2><a class="header" href="#influences" id="influences">Influences</a></h2>
<p>Its design elements came from a wide range of sources.</p>
<ul>
<li>Abstract Machine Model: <strong>C</strong></li>
<li>Data types: <strong>C, SML, OCaml, Lisp, Limbo</strong></li>
<li>Optional Bindings: <strong>Swift</strong></li>
<li>Hygienic Macros: <strong>Scheme</strong></li>
<li>Functional Programming: <strong>Haskell, OCaml, F#</strong></li>
<li>Attributes: <strong>ECMA</strong>-335</li>
<li>Memory Model and Memory Management: <strong>C++, ML Kit, Cyclone</strong></li>
<li>Type Classes: <strong>Haskell</strong></li>
<li>Crate: Assembly in the <strong>ECMA</strong>-335 CLI model</li>
<li>Channels and Concurrency: <strong>Newsqueak, Alef, Limbo</strong></li>
<li>Message passing and Thread failure: <strong>Erlang</strong></li>
</ul>
<p>and etc.</p>
<p>Rust <strong>doesn't use an automated garbage collection</strong> system(GC) by default.</p>
<p>Rust compiler observes the code <strong>at compile-time</strong> and helps to <a href="https://doc.rust-lang.org/error-index.html"><strong>prevent many types of errors</strong></a> that are possible to write in C, C++ like programming languages.</p>
<h2><a class="header" href="#title-installation" id="title-installation">title: Installation</a></h2>
<h2><a class="header" href="#rustup" id="rustup">Rustup</a></h2>
<p>There are many ways to install Rust on your system. For the moment the official way to install Rust is using <a href="https://rustup.rs/">Rustup</a>.</p>
<p><a href="https://github.com/rust-lang-nursery/rustup.rs">📖</a> Rustup installs The Rust Programming Language from the official release channels, enabling you to easily switch between <strong>stable, beta, and nightly</strong> compilers and keep them updated. It makes <strong>cross-compiling</strong> simpler with binary builds of the standard library for common platforms.</p>
<p><a href="https://github.com/rust-lang-nursery/rustup.rs#installation">📖</a> Rustup installs <strong><code>rustc</code>, <code>cargo</code>, <code>rustup</code></strong> and other standard tools to Cargo's <code>bin</code> directory. On Unix it is located at <code>$HOME/.cargo/bin</code> and on Windows at <code>%USERPROFILE%\.cargo\bin</code>. This is the same directory that <code>cargo install</code> will install Rust programs and Cargo plugins.</p>
<p>💡 More information can be found on the <a href="https://github.com/rust-lang-nursery/rustup.rs">Github page of Rustup project</a>.</p>
<h3><a class="header" href="#for-mac-and-linux-users" id="for-mac-and-linux-users">For Mac and Linux Users</a></h3>
<pre><code class="language-bash">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<h3><a class="header" href="#for-windows-users" id="for-windows-users">For Windows Users</a></h3>
<p>Download <strong><code>rustup-init.exe</code></strong> from <a href="https://rustup.rs/">www.rustup.rs</a> and run.</p>
<blockquote>
<p>⭐ If you are on <strong>Microsoft Windows</strong>, you have to install <strong><a href="https://visualstudio.microsoft.com/visual-cpp-build-tools/">Visual C++ Build Tools</a></strong> 2015 or higher, which requires an additional 3–4 GBs.</p>
</blockquote>
<p>After installing Rust you can check the current version by typing <strong><code>rustc --version</code></strong> or <strong><code>rustc -V</code></strong> on your terminal to verify the success of the installation.</p>
<h2><a class="header" href="#title-hello-world" id="title-hello-world">title: Hello World</a></h2>
<h2><a class="header" href="#hello-world-2" id="hello-world-2">Hello, World!</a></h2>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p><code>fn</code> means function. The <code>main</code> function is the beginning of every Rust program.<br />
<code>println!</code> prints text to the console and its <em>!</em> indicates that it’s a <a href="https://doc.rust-lang.org/book/first-edition/macros.html">macro</a> rather than a function.</p>
<blockquote>
<p>💡 Rust files should have .rs file extension and if you’re using more than one word for the file name, follow the <a href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a>.</p>
</blockquote>
<ul>
<li>Save the above code in <code>file.rs</code> , but it can be any name with <code>.rs</code> extension.</li>
<li>Compile it with <code>rustc file.rs</code></li>
<li>Execute it with <code>./file</code> on Linux and Mac or <code>file.exe</code> on Windows</li>
</ul>
<h2><a class="header" href="#rust-playground" id="rust-playground">Rust Playground</a></h2>
<p><a href="https://play.rust-lang.org/">Rust Playground</a> is a web interface for running Rust code.</p>
<p><a href="https://play.rust-lang.org/"><img src="learningrust/images/rust_playground.png" alt="Rust Playground" /></a></p>
<h2><a class="header" href="#usages-of-println" id="usages-of-println">Usages of println!</a></h2>
<p>💯 These are the other usages of the <code>println!</code> macro,</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!
    println!(&quot;{0}, {1}!&quot;, &quot;Hello&quot;, &quot;world&quot;); // Hello, world!
    println!(&quot;{greeting}, {name}!&quot;, greeting=&quot;Hello&quot;, name=&quot;world&quot;); // Hello, world!

    println!(&quot;{:?}&quot;, [1,2,3]); // [1, 2, 3]
    println!(&quot;{:#?}&quot;, [1,2,3]);
    /*
        [
            1,
            2,
            3
        ]
    */

    // 🔎 The format! macro is used to store the formatted string.
    let x = format!(&quot;{}, {}!&quot;, &quot;Hello&quot;, &quot;world&quot;);
    println!(&quot;{}&quot;, x); // Hello, world!
}
</code></pre></pre>
<h2><a class="header" href="#title-cargo-crates-and-basic-project-structure" id="title-cargo-crates-and-basic-project-structure">title: Cargo, Crates and Basic Project Structure</a></h2>
<h2><a class="header" href="#cargo-2" id="cargo-2">Cargo</a></h2>
<p>Cargo is Rust’s built-in package manager and the build system. It can be used to,</p>
<ul>
<li>Create a new project: <code>cargo new</code></li>
<li>Build the project: <code>cargo build</code></li>
<li>Run the project: <code>cargo run</code></li>
<li>Update project dependencies: <code>cargo update</code></li>
<li>Run tests: <code>cargo test</code></li>
<li>Generate the project documentation via <a href="https://doc.rust-lang.org/stable/rustdoc/">rustdoc</a>: <code>cargo doc</code></li>
<li>Analyze the project to see it has any errors, without building it: <code>cargo check</code></li>
</ul>
<p>In addition, there are <code>cargo</code> commands to publish the project as a crate/ package to <strong>Rust's official crate registry, <a href="https://crates.io/">crates.io</a></strong>.</p>
<blockquote>
<p>💡 We need to get an API token from <a href="https://crates.io/">crates.io</a> to publish a crate to it. The API token can be found in the <a href="https://crates.io/me">Account Settings page</a>, after login to that site. We will discuss more about this under <a href="https://learning-rust.github.io/docs/d4.crates.html#c-Using-crates-io">code organization with crates</a>.</p>
</blockquote>
<ul>
<li>Log in to <a href="https://crates.io/">crates.io</a> with the API token: <code>cargo login</code></li>
<li>Make the local crate uploadable to <a href="https://crates.io/">crates.io</a>: <code>cargo package</code></li>
<li>Upload the crate to <a href="https://crates.io/">crates.io</a>: <code>cargo publish</code></li>
</ul>
<h2><a class="header" href="#crate" id="crate">Crate</a></h2>
<p>A crate is a package, which can be shared via <a href="https://crates.io/">crates.io</a>. A crate can produce an executable or a library. In other words, it can be a <strong>binary</strong> crate or a <strong>library</strong> crate.</p>
<ol>
<li><code>cargo new crate_name --bin</code> or <code>cargo new crate_name</code>: Produces an executable</li>
<li><code>cargo new crate_name --lib</code>: Produces a library</li>
</ol>
<p>The first one generates,</p>
<pre><code>├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>and the second one generates,</p>
<pre><code>├── Cargo.toml
└── src
    └── lib.rs
</code></pre>
<ul>
<li><strong>Cargo.toml</strong>(capital c) is the configuration file which contains all of the metadata that Cargo needs to compile your project.</li>
<li><strong>src</strong> folder is the place to store the source code.</li>
<li>Each crate has an implicit crate root/ entry point. <strong>main.rs</strong> is the crate root for a binary crate and <strong>lib.rs</strong> is the crate root for a library crate.</li>
</ul>
<blockquote>
<p>💡 When we build a binary crate via <code>cargo build</code> or <code>cargo run</code>, the executable file will be stored in <strong>target/debug/</strong> folder. But when building it via <code>cargo build --release</code> for a release it will be stored in <strong>target/release/</strong> folder.</p>
</blockquote>
<h2><a class="header" href="#project-structure" id="project-structure">Project Structure</a></h2>
<p>This is how <a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">Cargo Docs describes</a> about the recommended project layout,</p>
<pre><code>.
├── Cargo.lock
├── Cargo.toml
├── benches
│   └── large-input.rs
├── examples
│   └── simple.rs
├── src
│   ├── bin
│   │   └── another_executable.rs
│   ├── lib.rs
│   └── main.rs
└── tests
    └── some-integration-tests.rs
</code></pre>
<ul>
<li>The source code goes in the <code>src</code> directory.</li>
<li>The default library file is <code>src/lib.rs</code>.</li>
<li>The default executable file is <code>src/main.rs</code>.</li>
<li>Other executables can be placed in <code>src/bin/*.rs</code>.</li>
<li>Integration tests go in the <code>tests</code> directory (unit tests go in each file they're testing).</li>
<li>Examples go in the <code>examples</code> directory.</li>
<li>Benchmarks go in the <code>benches</code> directory.</li>
</ul>
<h2><a class="header" href="#title-comments-and-documenting-the-code" id="title-comments-and-documenting-the-code">title: Comments and Documenting the code</a></h2>
<h2><a class="header" href="#comments-2" id="comments-2">Comments</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Line comments
/* Block comments */
<span class="boring">}
</span></code></pre></pre>
<p>Nested block comments are supported.</p>
<p>💡 <strong>By convention, try to avoid block comments. Use line comments instead.</strong></p>
<h2><a class="header" href="#doc-comments-1" id="doc-comments-1">Doc Comments</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// Line comments; document the next item
/** Block comments; document the next item */

//! Line comments; document the enclosing item
/*! Block comments; document the enclosing item !*/
<span class="boring">}
</span></code></pre></pre>
<p>Doc comments support Markdown notations. Using <code>cargo doc</code>, the HTML documentation can be generated from these doc comments. Let’s see the difference between the two sets of doc comments.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// This module contains tests
mod test {
    // ...
}


mod test {
    //! This module contains tests

    // ...
}
<span class="boring">}
</span></code></pre></pre>
<p>As you can see both uses to document the same module. The first comment has been added before the module while the second one has been added inside the module.</p>
<p>💡 <strong>Only use //! to write crate and module-level documentation, nothing else. When using <code>mod</code> blocks, use /// outside of the block.</strong></p>
<h2><a class="header" href="#doc-attributes" id="doc-attributes">Doc Attributes</a></h2>
<p>We can also use <strong>doc attributes</strong> for documenting the code.</p>
<blockquote>
<p>🔎 An <a href="https://doc.rust-lang.org/reference.html#attributes">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to the name, convention, language and compiler version. Any item declaration may have an attribute applied to it.</p>
</blockquote>
<p>Here, for instance, each comment is equivalent to relevant data attributes.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>/// Foo
#[doc=&quot;Foo&quot;]

//! Foo
#![doc=&quot;Foo&quot;]
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#title-variable-bindings-constants--statics" id="title-variable-bindings-constants--statics">title: Variable bindings, Constants &amp; Statics</a></h2>
<p>⭐️ In Rust variables are <strong>immutable by default</strong>, so we call them <strong>Variable bindings</strong>. To make them mutable, the <code>mut</code> keyword is used.</p>
<p>⭐️ Rust is a <strong>statically typed</strong> language; it checks data types at compile-time. But it <strong>doesn’t require you to actually type it when declaring variable bindings</strong>. In that case, the compiler checks the usage and sets a better data type for it. But for <strong>constants and statics, you must annotate the type</strong>. Types come after a colon(:)</p>
<ul>
<li>
<h3><a class="header" href="#variable-bindings-1" id="variable-bindings-1">Variable bindings</a></h3>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = true;
let b: bool = true;

let (x, y) = (1, 2);

let mut z = 5;
z = 6;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<h3><a class="header" href="#constants-1" id="constants-1">Constants</a></h3>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>const N: i32 = 5;
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<h3><a class="header" href="#statics" id="statics">Statics</a></h3>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>static N: i32 = 5;
<span class="boring">}
</span></code></pre></pre>
<p>The <strong>let</strong> keyword is used in binding expressions. We can bind a name to a value or a function. Also, because the left-hand side of a let expression is a ‘pattern’, you can bind multiple names to a set of values or function values.</p>
<p>The <strong>const</strong> keyword is used to define constants. It lives for the entire lifetime of a program but has no fixed address in the memory. The <strong>static</strong> keyword is used to define a ‘global variable’ type facility. There is only one instance for each value, and it’s at a <strong>fixed location in memory</strong>.</p>
<p>💡 <strong>Always use const</strong>, instead of static. It’s pretty rare that you actually want a memory location associated with your constant, and using a const allows for optimizations like constant propagation not only in your crate but also in downstream crates.</p>
<p>💡 Usually, statics are placed at the top of the code file, outside the functions.</p>
<h2><a class="header" href="#title-functions" id="title-functions">title: Functions</a></h2>
<h2><a class="header" href="#named-functions" id="named-functions">Named functions</a></h2>
<ul>
<li>Named functions are declared with the keyword <strong><code>fn</code></strong></li>
<li>When using <strong>arguments</strong>, you <strong>must declare data types</strong>.</li>
<li>By default, functions <strong>return empty tuple/ <code>()</code></strong>. If you want to return a value, the <strong>return type must be specified</strong> after <strong><code>-&gt;</code></strong></li>
</ul>
<h3><a class="header" href="#i-hello-world" id="i-hello-world">i. Hello world</a></h3>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<h3><a class="header" href="#ii-passing-arguments" id="ii-passing-arguments">ii. Passing arguments</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn print_sum(a: i8, b: i8) {
    println!(&quot;sum is: {}&quot;, a + b);
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#iii-returning-values" id="iii-returning-values">iii. Returning values</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 01. Without the return keyword. Only last expression returns.
fn plus_one(a: i32) -&gt; i32 {
    a + 1
    // There is no ending ; in the above line. It means this is an expression which equals to `return a+1;`
}

// 02. With the return keyword.
fn plus_two(a: i32) -&gt; i32 {
    return a + 2; // Returns a+2. But, this's a bad practice.
    // Should use only on conditional returns, except in the last expression
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#iv-function-pointers-usage-as-a-data-type" id="iv-function-pointers-usage-as-a-data-type">iv. Function pointers, Usage as a Data Type</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 01. Without type declarations
let b = plus_one;
let c = b(5); //6

// 02. With type declarations
let b: fn(i32) -&gt; i32 = plus_one;
let c = b(5); //6
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#closures-1" id="closures-1">Closures</a></h2>
<ul>
<li>Also known as <strong>anonymous functions</strong> or <strong>lambda functions</strong>.</li>
<li>The <strong>data types of arguments and returns are optional</strong>.</li>
</ul>
<p>Example with a named function, before using closures.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let x = 2;
  println!(&quot;{}&quot;, get_square_value(x));
}

fn get_square_value(x: i32) -&gt; i32 {
    x * x
}
</code></pre></pre>
<h3><a class="header" href="#i-with-optional-type-declarations-of-input-and-return-types" id="i-with-optional-type-declarations-of-input-and-return-types">i. With optional type declarations of input and return types</a></h3>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2;
    let square = |x: i32| -&gt; i32 { // Input parameters are passed inside | | and expression body is wrapped within { }
        x * x 
    };
    println!(&quot;{}&quot;, square(x));
}
</code></pre></pre>
<h3><a class="header" href="#ii-without-type-declarations-of-input-and-return-types" id="ii-without-type-declarations-of-input-and-return-types">ii. Without type declarations of input and return types</a></h3>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2;
    let square = |x| x * x; // { } are optional for single-lined closures
    println!(&quot;{}&quot;, square(x));
}
</code></pre></pre>
<h2><a class="header" href="#title-primitive-data-types" id="title-primitive-data-types">title: Primitive Data Types</a></h2>
<ul>
<li>
<h2><a class="header" href="#bool" id="bool">bool</a></h2>
</li>
</ul>
<p>true or false</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = true;
let y: bool = false;

// ⭐️ no TRUE, FALSE, 1, 0
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<h2><a class="header" href="#char" id="char">char</a></h2>
</li>
</ul>
<p>A single Unicode scalar value</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 'x';
let y = '😎';

// ⭐️ no &quot;x&quot;, only single quotes
<span class="boring">}
</span></code></pre></pre>
<p>Because of Unicode support, char is not a single byte, but four.</p>
<ul>
<li>
<h2><a class="header" href="#i8-i16-i32-i64-i128" id="i8-i16-i32-i64-i128">i8, i16, i32, i64, i128</a></h2>
</li>
</ul>
<p>8, 16, 32, 64 and 128 bit fixed sized signed(+/-) integer types</p>
<table><thead><tr><th>DATA TYPE</th><th>MIN</th><th>MAX</th></tr></thead><tbody>
<tr><td>i8</td><td>-128</td><td>127</td></tr>
<tr><td>i16</td><td>-32768</td><td>32767</td></tr>
<tr><td>i32</td><td>-2147483648</td><td>2147483647</td></tr>
<tr><td>i64</td><td>-9223372036854775808</td><td>9223372036854775807</td></tr>
<tr><td>i128</td><td>-170141183460469231731687303715884105728</td><td>170141183460469231731687303715884105727</td></tr>
</tbody></table>
<p>💡 The min and max values are based on the following equation; <strong>from -(2ⁿ⁻¹) to 2ⁿ⁻¹-1</strong>. You can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>i8::min_value();</code></p>
<ul>
<li>
<h2><a class="header" href="#u8-u16-u32-u64-u128" id="u8-u16-u32-u64-u128">u8, u16, u32, u64, u128</a></h2>
</li>
</ul>
<p>8, 16, 32, 64 and 128 bit fixed sized unsigned(0/+) integer types</p>
<table><thead><tr><th>DATA TYPE</th><th>MIN</th><th>MAX</th></tr></thead><tbody>
<tr><td>u8</td><td>0</td><td>255</td></tr>
<tr><td>u16</td><td>0</td><td>65535</td></tr>
<tr><td>u32</td><td>0</td><td>4294967295</td></tr>
<tr><td>u64</td><td>0</td><td>18446744073709551615</td></tr>
<tr><td>u128</td><td>0</td><td>340282366920938463463374607431768211455</td></tr>
</tbody></table>
<p>💡 The min and max values are based on the following equation; <strong>from 0 to 2ⁿ-1</strong>. Same way you can use <strong>min_value()</strong> and <strong>max_value()</strong> functions to find min and max of each integer type. ex.<code>u8::max_value();</code></p>
<ul>
<li>
<h2><a class="header" href="#isize-usize" id="isize-usize">isize, usize</a></h2>
</li>
</ul>
<p>Pointer sized signed and unsigned integer types</p>
<p>The actual bit size depends on the computer architecture you are compiling your program for. By default, the sizes are equal to 32 bit on 32-bit platforms and 64 bit on 64-bit platforms.</p>
<blockquote>
<p>🔎 Search more about <a href="https://github.com/rust-lang/rustup.rs#cross-compilation">cross-compiling</a> and <a href="https://forge.rust-lang.org/platform-support.html">Supported Tiers</a> of Rust programs.</p>
</blockquote>
<ul>
<li>
<h2><a class="header" href="#f32-f64" id="f32-f64">f32, f64</a></h2>
</li>
</ul>
<p>32 and 64 bit sized floating point numbers(numbers with decimal points)</p>
<p>Rust follows IEEE Standard for Binary Floating-Point Arithmetic. The <code>f32</code> type is similar to float(<strong>Single precision</strong>) in other languages, while <code>f64</code> is similar to double(<strong>Double precision</strong>) in other languages.</p>
<p>💡 Should avoid using <code>f32</code>, unless you need to reduce memory consumption badly or if you are doing low-level optimization, when targeted hardware does not support for double-precision or when single-precision is faster than double-precision on it.</p>
<ul>
<li>
<h2><a class="header" href="#arrays" id="arrays">arrays</a></h2>
</li>
</ul>
<p>Fixed size list of elements of same data type</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3]; // a[0] = 1, a[1] = 2, a[2] = 3
let mut b = [1, 2, 3];

let c: [i32; 0] = []; //[Type; NO of elements] -&gt; [] /empty array
let d: [i32; 3] = [1, 2, 3];

let e = [&quot;my value&quot;; 3]; //[&quot;my value&quot;, &quot;my value&quot;, &quot;my value&quot;];

println!(&quot;{:?}&quot;, a); //[1, 2, 3]
println!(&quot;{:#?}&quot;, a);
//  [
//      1,
//      2,
//      3
//  ]
<span class="boring">}
</span></code></pre></pre>
<p>⭐️ Arrays are <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed</strong>.</p>
<blockquote>
<p>🔎 If you are looking for a dynamic/growable array, you can use <a href="learningrust/b1.vectors.html">vectors</a>. Vectors can contain any type of elements but all elements must be in the same data type.</p>
</blockquote>
<ul>
<li>
<h2><a class="header" href="#tuples-2" id="tuples-2">tuples</a></h2>
</li>
</ul>
<p>Fixed size ordered list of elements of different(or same) data types</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = (1, 1.5, true, 'a', &quot;Hello, world!&quot;);
// a.0 = 1, a.1 = 1.5, a.2 = true, a.3 = 'a', a.4 = &quot;Hello, world!&quot;

let b: (i32, f64) = (1, 1.5);

let (c, d) = b; // c = 1, d = 1.5
let (e, _, _, _, f) = a; //e = 1, f = &quot;Hello, world!&quot;, _ indicates not interested of that item

let g = (0,); //single-element tuple

let h = (b, (2, 4), 5); //((1, 1.5), (2, 4), 5)

println!(&quot;{:?}&quot;, a); //(1, 1.5, true, 'a', &quot;Hello, world!&quot;)
<span class="boring">}
</span></code></pre></pre>
<p>⭐️ Tuples are also <strong>immutable</strong> by default and <strong>even with <code>mut</code>, its element count cannot be changed. Also, if you want to change an element’s value, the new value should have the same data type of previous value</strong>.</p>
<ul>
<li>
<h2><a class="header" href="#slice" id="slice">slice</a></h2>
</li>
</ul>
<p>Dynamically-sized reference to another data structure</p>
<p>Think you want to get/pass a part of an array or any other data structure. Instead of copy it to another array (or same data structure), Rust allows creating a view/reference to access only that part of data. And it can be mutable or not.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a: [i32; 4] = [1, 2, 3, 4];//Parent Array

let b: &amp;[i32] = &amp;a; //Slicing whole array
let c = &amp;a[0..4]; // From 0th position to 4th(excluding)
let d = &amp;a[..]; //Slicing whole array

let e = &amp;a[1..3]; //[2, 3]
let f = &amp;a[1..]; //[2, 3, 4]
let g = &amp;a[..3]; //[1, 2, 3]
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<h2><a class="header" href="#str" id="str">str</a></h2>
</li>
</ul>
<p>Unsized UTF-8 sequence of Unicode string slices</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = &quot;Hello, world.&quot;; //a: &amp;'static str
let b: &amp;str = &quot;こんにちは, 世界!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>⭐️ It's an <strong>immutable/statically allocated slice</strong> holding an <strong>unknown sized sequence of UTF-8</strong> code points stored in somewhere in memory. <strong>&amp;str</strong> is used to borrow and assign the whole array to the given variable binding.</p>
<blockquote>
<p>🔎 A <a href="https://doc.rust-lang.org/std/string/struct.String.html">String</a> is a <strong>heap</strong>-allocated string. This string is growable and is also guaranteed to be UTF-8. They are commonly created by converting from a string slice using the <strong>to_string()</strong> or <strong>String::from()</strong> methods. ex: <code>“Hello”.to_string();</code>  <code>String::from(&quot;Hello&quot;);</code></p>
</blockquote>
<p>💡 In general, you should use <strong>String</strong> when you need <strong>ownership</strong>, and <strong><code>&amp;str</code></strong> when you just need to <strong>borrow a string</strong>.</p>
<ul>
<li>
<h2><a class="header" href="#functions-4" id="functions-4">functions</a></h2>
</li>
</ul>
<p>As we discussed on functions section, <code>b</code> is a function pointer, to <code>plus_one()</code> in the below code.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn plus_one(a: i32) -&gt; i32 {
    a + 1
}

let b: fn(i32) -&gt; i32 = plus_one;
let c = b(5); //6
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#title-operators" id="title-operators">title: Operators</a></h2>
<ul>
<li>
<h2><a class="header" href="#arithmetic-operators" id="arithmetic-operators">Arithmetic Operators</a></h2>
</li>
</ul>
<p>** + - * / %**</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 5;
let b = a + 1; //6
let c = a - 1; //4
let d = a * 2; //10
let e = a / 2; // ⭐️ 2 not 2.5
let f = a % 2; //1

let g = 5.0 / 2.0; //2.5
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>💡 Also <strong>+</strong> is used for <strong>array and string concatenation</strong>.</p>
</blockquote>
<ul>
<li>
<h2><a class="header" href="#comparison-operators" id="comparison-operators">Comparison Operators</a></h2>
</li>
</ul>
<p>== != &lt; &gt; &lt;= &gt;=</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 2;

let c = a == b; //false
let d = a != b; //true
let e = a &lt; b; //true
let f = a &gt; b; //false
let g = a &lt;= a; //true
let h = a &gt;= a; //true

// 🔎
let i = true &gt; false; //true
let j = 'a' &gt; 'A'; //true
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<h2><a class="header" href="#logical-operators" id="logical-operators">Logical Operators</a></h2>
</li>
</ul>
<p>! &amp;&amp; ||</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = true;
let b = false;

let c = !a; //false
let d = a &amp;&amp; b; //false
let e = a || b; //true
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>🔎 On integer types,<code>!</code> inverts the individual bits in the two’s complement representation of the value.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = !-2; //1
let b = !-1; //0
let c = !0; //-1
let d = !1; //-2
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<h2><a class="header" href="#bitwise-operators" id="bitwise-operators">Bitwise Operators</a></h2>
</li>
</ul>
<p>&amp; | ^ &lt;&lt; &gt;&gt;</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 2;

let c = a &amp; b;  //0  (01 &amp;&amp; 10 -&gt; 00)
let d = a | b;  //3  (01 || 10 -&gt; 11)
let e = a ^ b;  //3  (01 != 10 -&gt; 11)
let f = a &lt;&lt; b; //4  (Add b number of 0s to the end of a -&gt; '01'+'00' -&gt; 100)
let g = a &gt;&gt; b; //0  (Remove b number of bits from the end of a -&gt; o̶1̶ -&gt; 0)
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<h2><a class="header" href="#assignment-and-compound-assignment-operators" id="assignment-and-compound-assignment-operators">Assignment and Compound Assignment Operators</a></h2>
</li>
</ul>
<p>The = operator is used to assign a name to a value or a function. Compound Assignment Operators are created by composing one of + - * / % &amp; | ^ &lt;&lt; &gt;&gt; operators with = operator.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut a = 2;

a += 5; //2 + 5 = 7
a -= 2; //7 - 2 = 5
a *= 5; //5 * 5 = 25
a /= 2; //25 / 2 = 12 not 12.5
a %= 5; //12 % 5 = 2

a &amp;= 2; //10 &amp;&amp; 10 -&gt; 10 -&gt; 2
a |= 5; //010 || 101 -&gt; 111 -&gt; 7
a ^= 2; //111 != 010 -&gt; 101 -&gt; 5
a &lt;&lt;= 1; //'101'+'0' -&gt; 1010 -&gt; 10
a &gt;&gt;= 2; //101̶0̶ -&gt; 10 -&gt; 2
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<h2><a class="header" href="#type-casting-operator" id="type-casting-operator">Type Casting Operator</a></h2>
</li>
</ul>
<p>as</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = 15;
let b = (a as f64) / 2.0; //7.5
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<h2><a class="header" href="#borrowing-and-dereference-operators" id="borrowing-and-dereference-operators">Borrowing and Dereference Operators</a></h2>
</li>
</ul>
<p>&amp; &amp;mut *</p>
<p>The <strong>&amp; or &amp;mut</strong> operators are used for <strong>borrowing</strong> and ***** operator for <strong>Dereferencing</strong>.</p>
<blockquote>
<p>🔎 For more information, refer to <a href="learningrust/c1.ownership.html">Ownership</a>, <a href="learningrust/c2.borrowing.html">Borrowing</a> &amp; <a href="learningrust/c3.lifetimes.html">Lifetimes</a> sections.</p>
</blockquote>
<h2><a class="header" href="#title-control-flows" id="title-control-flows">title: Control Flows</a></h2>
<h1><a class="header" href="#if---else-if---else" id="if---else-if---else">if - else if - else</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Simplest Example
let team_size = 7;
if team_size &lt; 5 {
    println!(&quot;Small&quot;);
} else if team_size &lt; 10 {
    println!(&quot;Medium&quot;);
} else {
    println!(&quot;Large&quot;);
}

// partially refactored code
let team_size = 7;
let team_size_in_text;
if team_size &lt; 5 {
    team_size_in_text = &quot;Small&quot;;
} else if team_size &lt; 10 {
    team_size_in_text = &quot;Medium&quot;;
} else {
    team_size_in_text = &quot;Large&quot;;
}
println!(&quot;Current team size : {}&quot;, team_size_in_text);

//optimistic code
let team_size = 7;
let team_size_in_text = if team_size &lt; 5 {
    &quot;Small&quot; //⭐️no ;
} else if team_size &lt; 10 {
    &quot;Medium&quot;
} else {
    &quot;Large&quot;
};
println!(&quot;Current team size : {}&quot;, team_size_in_text);


let is_below_eighteen = if team_size &lt; 18 { true } else { false };
<span class="boring">}
</span></code></pre></pre>
<p>⭐️ <strong>Return data type should be the same on each block when using this as an expression.</strong></p>
<h1><a class="header" href="#match-1" id="match-1">match</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let tshirt_width = 20;
let tshirt_size = match tshirt_width {
    16 =&gt; &quot;S&quot;, // check 16
    17 | 18 =&gt; &quot;M&quot;, // check 17 and 18
    19 ... 21 =&gt; &quot;L&quot;, // check from 19 to 21 (19,20,21)
    22 =&gt; &quot;XL&quot;,
    _ =&gt; &quot;Not Available&quot;,
};
println!(&quot;{}&quot;, tshirt_size); // L


let is_allowed = false;
let list_type = match is_allowed {
    true =&gt; &quot;Full&quot;,
    false =&gt; &quot;Restricted&quot;
    // no default/ _ condition can be skipped
    // Because data type of is_allowed is boolean and all possibilities checked on conditions
};
println!(&quot;{}&quot;, list_type); // Restricted


let marks_paper_a: u8 = 25;
let marks_paper_b: u8 = 30;
let output = match (marks_paper_a, marks_paper_b) {
    (50, 50) =&gt; &quot;Full marks for both papers&quot;,
    (50, _) =&gt; &quot;Full marks for paper A&quot;,
    (_, 50) =&gt; &quot;Full marks for paper B&quot;,
    (x, y) if x &gt; 25 &amp;&amp; y &gt; 25 =&gt; &quot;Good&quot;,
    (_, _) =&gt; &quot;Work hard&quot;
};
println!(&quot;{}&quot;, output); // Work hard
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#while-1" id="while-1">while</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut a = 1;
while a &lt;= 10 {
	println!(&quot;Current value : {}&quot;, a);
	a += 1; //no ++ or -- on Rust
}

// Usage of break and continue
let mut b = 0;
while b &lt; 5 {
	if b == 0 {
		println!(&quot;Skip value : {}&quot;, b);
		b += 1;
		continue;
	} else if b == 2 {
		println!(&quot;Break At : {}&quot;, b);
		break;
	}
	println!(&quot;Current value : {}&quot;, b);
	b += 1;
}

// Outer break
let mut c1 = 1;
'outer_while: while c1 &lt; 6 { //set label outer_while
	let mut c2 = 1;
	'inner_while: while c2 &lt; 6 {
		println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);
		if c1 == 2 &amp;&amp; c2 == 2 { break 'outer_while; } //kill outer_while
		c2 += 1;
	}
	c1 += 1;
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#loop-1" id="loop-1">loop</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>loop {
	println!(&quot;Loop forever!&quot;);
}

// Usage of break and continue
let mut a = 0;
loop {
	if a == 0 {
		println!(&quot;Skip Value : {}&quot;, a);
		a += 1;
		continue;
	} else if a == 2 {
		println!(&quot;Break At : {}&quot;, a);
		break;
	}
	println!(&quot;Current Value : {}&quot;, a);
	a += 1;
}

// Outer break
let mut b1 = 1;
'outer_loop: loop { //set label outer_loop
  let mut b2 = 1;
  'inner_loop: loop {
    println!(&quot;Current Value : [{}][{}]&quot;, b1, b2);
    if b1 == 2 &amp;&amp; b2 == 2 {
        break 'outer_loop; // kill outer_loop
    } else if b2 == 5 {
    	break;
    }
    b2 += 1;
  }
  b1 += 1;
}
<span class="boring">}
</span></code></pre></pre>
<h1><a class="header" href="#for" id="for">for</a></h1>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for a in 0..10 { //(a = o; a &lt;10; a++) // 0 to 10(exclusive)
  println!(&quot;Current value : {}&quot;, a);
}

// Usage of break and continue
for b in 0..6 {
  if b == 0 {
    println!(&quot;Skip Value : {}&quot;, b);
    continue;
  } else if b == 2 {
    println!(&quot;Break At : {}&quot;, b);
    break;
  }
  println!(&quot;Current value : {}&quot;, b);
}

// Outer break
'outer_for: for c1 in 1..6 { //set label outer_for
  'inner_for: for c2 in 1..6 {
    println!(&quot;Current Value : [{}][{}]&quot;, c1, c2);
    if c1 == 2 &amp;&amp; c2 == 2 { break 'outer_for; } //kill outer_for
  }
}


// Working with arrays/vectors
let group : [&amp;str; 4] = [&quot;Mark&quot;, &quot;Larry&quot;, &quot;Bill&quot;, &quot;Steve&quot;];

for n in 0..group.len() { //group.len() = 4 -&gt; 0..4 👎 check group.len()on each iteration
  println!(&quot;Current Person : {}&quot;, group[n]);
}

for person in group.iter() { //👍 group.iter() turn the array into a simple iterator
  println!(&quot;Current Person : {}&quot;, person);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#title-vectors" id="title-vectors">title: Vectors</a></h2>
<p>If you remember, the array is a fixed-size list of elements, of the same data type. Even with mut, its element count cannot be changed. A vector is kind of <strong>a re-sizable array</strong> but <strong>all elements must be in the same type</strong>.</p>
<p>⭐️ It’s a generic type, written as <strong><code>Vec&lt;T&gt;</code></strong> . T can have any type, ex. The type of a Vec of i32s is <code>Vec&lt;i32&gt;</code>. Also, Vectors always allocate their data in a dynamically allocated heap.</p>
<h3><a class="header" href="#create-empty-vector" id="create-empty-vector">Create empty vector</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut a = Vec::new(); //1.With new() keyword
let mut b = vec![]; //2.Using the vec! macro
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#create-with-data-types" id="create-with-data-types">Create with data types</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut a2: Vec&lt;i32&gt; = Vec::new();
let mut b2: Vec&lt;i32&gt; = vec![];
let mut b3 = vec![1i32, 2, 3];//Sufixing 1st value with data type

let mut b4 = vec![1, 2, 3];
let mut b5: Vec&lt;i32&gt; = vec![1, 2, 3];
let mut b6  = vec![1i32, 2, 3];
let mut b7 = vec![0; 10]; //Ten zeroes
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#access-and-change-data" id="access-and-change-data">Access and change data</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>//Accessing and changing existing data
let mut c = vec![5, 4, 3, 2, 1];
c[0] = 1;
c[1] = 2;
//c[6] = 2; Cannot assign values this way, index out of bounds
println!(&quot;{:?}&quot;, c); //[1, 2, 3, 2, 1]

//push and pop
let mut d: Vec&lt;i32&gt; = Vec::new();
d.push(1); //[1] : Add an element to the end
d.push(2); //[1, 2]
d.pop(); //[1] : : Remove an element from the end


// 🔎 Capacity and reallocation
let mut e: Vec&lt;i32&gt; = Vec::with_capacity(10);
println!(&quot;Length: {}, Capacity : {}&quot;, e.len(), e.capacity()); //Length: 0, Capacity : 10

// These are all done without reallocating...
for i in 0..10 {
    e.push(i);
}
// ...but this may make the vector reallocate
e.push(11);
<span class="boring">}
</span></code></pre></pre>
<p>⭐️ Mainly a vector represent 3 things,</p>
<ul>
<li>A <strong>pointer</strong> to the data</li>
<li><strong>No of elements</strong> currently have(<strong>length</strong>)</li>
<li><strong>Capacity</strong> (Amount of space allocated for any future elements). </li>
</ul>
<p>If the length of a vector exceeds its capacity, its capacity will be increased automatically. But its elements will be reallocated(which can be slow). So always use Vec::<strong>with_capacity</strong> whenever it’s possible.</p>
<blockquote>
<p>💡 The <strong>String</strong> data type is a UTF-8 encoded vector. But you can not index into a String because of encoding.</p>
</blockquote>
<p>💯 Vectors can be used with iterators in three ways,</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5];

for i in &amp;v {
    println!(&quot;A reference to {}&quot;, i);
}

for i in &amp;mut v {
    println!(&quot;A mutable reference to {}&quot;, i);
}

for i in v {
    println!(&quot;Take ownership of the vector and its element {}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#title-structs" id="title-structs">title: Structs</a></h2>
<p>⭐️ Structs are used to <strong>encapsulate related properties</strong> into one unified data type.</p>
<p>💡 By convention, the name of the struct starts with a capital letter and follows <strong>CamelCase</strong>.</p>
<p>There are 3 variants of structs,</p>
<ol>
<li><strong>C-like structs</strong></li>
</ol>
<ul>
<li>One or more comma-separated name:value pairs</li>
<li>Brace-enclosed list</li>
<li>Similar to classes (without its methods) in OOP languages</li>
<li>Because fields have names, we can access them through dot notation</li>
</ul>
<ol start="2">
<li><strong>Tuple structs</strong></li>
</ol>
<ul>
<li>One or more comma-separated values</li>
<li>A parenthesized list like tuples</li>
<li>Looks like a named tuples</li>
</ul>
<ol start="3">
<li><strong>Unit structs</strong></li>
</ol>
<ul>
<li>A struct with no members at all</li>
<li>It defines a new type but it resembles an empty tuple, ()</li>
<li>Rarely in use, useful with generics</li>
</ul>
<p>⭐️ When regarding OOP in Rust, attributes and methods are placed separately on <strong>structs</strong> and <strong>traits</strong>. Structs contain only attributes, traits contain only methods. They are getting connected via <strong>impls</strong>.</p>
<blockquote>
<p>💡More complex examples can be found on <a href="learningrust/b5.impls_and_traits.html">impls &amp; traits</a>, <a href="learningrust/c3.lifetimes.html">lifetimes</a> and <a href="learningrust/d3.modules.html">modules</a> sections.</p>
</blockquote>
<h2><a class="header" href="#c-like-structs" id="c-like-structs">C-like structs</a></h2>
<pre><pre class="playpen"><code class="language-rust">// Struct Declaration
struct Color {
    red: u8,
    green: u8,
    blue: u8
}

fn main() {
  // Creating an instance
  let black = Color {red: 0, green: 0, blue: 0};

  // Accessing its fields using dot notation
  println!(&quot;Black = rgb({}, {}, {})&quot;, black.red, black.green, black.blue); //Black = rgb(0, 0, 0)

  // Structs are immutable by default, use `mut` to make it mutable but doesn't support field level mutability
  let mut link_color = Color {red: 0,green: 0,blue: 255};
  link_color.blue = 238;
  println!(&quot;Link Color = rgb({}, {}, {})&quot;, link_color.red, link_color.green, link_color.blue); //Link Color = rgb(0, 0, 238)

  // Copy elements from another instance
  let blue = Color {blue: 255, .. link_color};
  println!(&quot;Blue = rgb({}, {}, {})&quot;, blue.red, blue.green, blue.blue); //Blue = rgb(0, 0, 255)

  // Destructure the instance using a `let` binding, this will not destruct blue instance
  let Color {red: r, green: g, blue: b} = blue;
  println!(&quot;Blue = rgb({}, {}, {})&quot;, r, g, b); //Blue = rgb(0, 0, 255)

  // Creating an instance via functions &amp; accessing its fields
  let midnightblue = get_midnightblue_color();
  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, midnightblue.red, midnightblue.green, midnightblue.blue); //Midnight Blue = rgb(25, 25, 112)

  // Destructure the instance using a `let` binding
  let Color {red: r, green: g, blue: b} = get_midnightblue_color();
  println!(&quot;Midnight Blue = rgb({}, {}, {})&quot;, r, g, b); //Midnight Blue = rgb(25, 25, 112)
}

fn get_midnightblue_color() -&gt; Color {
    Color {red: 25, green: 25, blue: 112}
}
</code></pre></pre>
<h2><a class="header" href="#tuple-structs" id="tuple-structs">Tuple structs</a></h2>
<p>⭐️ When a tuple struct has only one element, we call it <strong>newtype pattern</strong>. Because it helps to create a new type.</p>
<pre><pre class="playpen"><code class="language-rust">struct Color(u8, u8, u8);
struct Kilometers(i32);

fn main() {
  // Creating an instance
  let black = Color(0, 0, 0);

  // Destructure the instance using a `let` binding, this will not destruct black instance
  let Color(r, g, b) = black;
  println!(&quot;Black = rgb({}, {}, {})&quot;, r, g, b); //black = rgb(0, 0, 0);

  // Newtype pattern
  let distance = Kilometers(20);
  // Destructure the instance using a `let` binding
  let Kilometers(distance_in_km) = distance;
  println!(&quot;The distance: {} km&quot;, distance_in_km); //The distance: 20 km
}
</code></pre></pre>
<h2><a class="header" href="#unit-structs" id="unit-structs">Unit structs</a></h2>
<p>This is rarely useful on its own. But in combination with other features, it can become useful.</p>
<blockquote>
<p><a href="https://doc.rust-lang.org/book/first-edition/structs.html">📖</a> ex: A library may ask you to create a structure that implements a certain trait to handle events. If you don’t have any data you need to store in the structure, you can create a unit-like struct.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">struct Electron;

fn main() {
  let x = Electron;
}
</code></pre></pre>
<h2><a class="header" href="#title-enums" id="title-enums">title: Enums</a></h2>
<p>⭐️ An <strong>enum</strong> is a single type. It contains <strong>variants</strong>, which are possible values of the enum at a given time. For example,</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Day {
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday
}

// The `Day` is the enum
// Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday are the variants
<span class="boring">}
</span></code></pre></pre>
<p>⭐️ Variants can be accessed through :: notation, ex. Day::Sunday</p>
<p>⭐️ Each enum <strong>variant</strong> can have,</p>
<ul>
<li>No data (unit variant)</li>
<li>Unnamed ordered data (tuple variant)</li>
<li>Named data (struct variant)</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">enum FlashMessage {
  Success, // A unit variant
  Warning{ category: i32, message: String }, // A struct variant
  Error(String) // A tuple variant
}

fn main() {
  let mut form_status = FlashMessage::Success;
  print_flash_message(form_status);

  form_status = FlashMessage::Warning {category: 2, message: String::from(&quot;Field X is required&quot;)};
  print_flash_message(form_status);

  form_status = FlashMessage::Error(String::from(&quot;Connection Error&quot;));
  print_flash_message(form_status);
}

fn print_flash_message(m : FlashMessage) {
  // Pattern matching with enum
  match m {
    FlashMessage::Success =&gt;
      println!(&quot;Form Submitted correctly&quot;),
    FlashMessage::Warning {category, message} =&gt; // Destructure, should use same field names
      println!(&quot;Warning : {} - {}&quot;, category, message),
    FlashMessage::Error(msg) =&gt;
      println!(&quot;Error : {}&quot;, msg)
  }
}
</code></pre></pre>
<h2><a class="header" href="#title-generics" id="title-generics">title: Generics</a></h2>
<blockquote>
<p><a href="https://doc.rust-lang.org/beta/book/first-edition/generics.html">📖</a> Sometimes, when writing a function or data type, we may want it to work for multiple types of arguments. In Rust, we can do this with generics.</p>
</blockquote>
<p>💭 The concept is, instead of declaring a specific data type we use an uppercase letter(or CamelCase identifier). ex, <strong>instead of x : u8</strong> we use <strong>x : T</strong> . but we have to inform to the compiler that T is a generic type(can be any type) by adding <code>&lt;T&gt;</code> at first.</p>
<h3><a class="header" href="#generalizing-functions" id="generalizing-functions">Generalizing functions</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn takes_anything&lt;T&gt;(x: T) { // x has type T, T is a generic type
}

fn takes_two_of_the_same_things&lt;T&gt;(x: T, y: T) { // Both x and y has the same type
}

fn takes_two_things&lt;T, U&gt;(x: T, y: U) { // Multiple types
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#generalizing-structs" id="generalizing-structs">Generalizing structs</a></h3>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
  x: T,
  y: T,
}

fn main() {
  let point_a = Point { x: 0, y: 0 }; // T is a int type
  let point_b = Point { x: 0.0, y: 0.0 }; // T is a float type
}

// 🔎 When adding an implementation for a generic struct, the type parameters should be declared after the impl as well
//   impl&lt;T&gt; Point&lt;T&gt; {
</code></pre></pre>
<h3><a class="header" href="#generalizing-enums" id="generalizing-enums">Generalizing enums</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}

enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>⭐️ Above <a href="https://doc.rust-lang.org/std/option/index.html">Option</a> and <a href="https://doc.rust-lang.org/std/result/index.html">Result</a> types are kind of special generic types which are already defined in Rust’s standard library. </p>
</blockquote>
<ul>
<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>
<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>
</ul>
<h4><a class="header" href="#usages-of-option" id="usages-of-option">Usages of Option</a></h4>
<pre><pre class="playpen"><code class="language-rust">// 01 - - - - - - - - - - - - - - - - - - - - - -
fn get_id_by_username(username: &amp;str) -&gt; Option&lt;usize&gt; {
    // if username can be found in the system, set userId
        return Some(userId);
    // else
        None
}

// 💭 So, on the above function, instead of setting return type as usize
//   set return type as Option&lt;usize&gt;
// Instead of return userId, return Some(userId)
//   else None (💡remember? last return statement no need return keyword and ending ;)

// 02 - - - - - - - - - - - - - - - - - - - - - -
struct Task {
    title: String,
    assignee: Option&lt;Person&gt;,
}

// 💭 Instead of assignee: Person, we use Option&lt;Person&gt;
// because the task has not been assigned to a specific person

// - - - - - - - - - - - - - - - - - - - - - - -
// When using Option types as return types on functions
// we can use pattern matching to catch the relevant return type(Some/None) when calling them

fn main() {
    let username = &quot;anonymous&quot;;
    match get_id_by_username(username) {
        None =&gt; println!(&quot;User not found&quot;),
        Some(i) =&gt; println!(&quot;User Id: {}&quot;, i)
    }
}
</code></pre></pre>
<h4><a class="header" href="#usages-of-result" id="usages-of-result">Usages of Result</a></h4>
<blockquote>
<p><a href="https://doc.rust-lang.org/book/first-edition/error-handling.html">📖</a> The Option type is a way to use Rust’s type system to express the possibility of absence. Result expresses the possibility of error.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">// - - - - - - - - - - - - - - - - - - - - - -
fn get_word_count_from_file(file_name: &amp;str) -&gt; Result&lt;u32, &amp;str&gt; {
  // if the file is not found on the system, return error
    return Err(&quot;File can not be found!&quot;)
  // else, count and return the word count
    // let mut word_count: u32; ....
    Ok(word_count)
}

// 💭 On the above function,
// instead panic(break) the app, when the file can not be found; return Err(something)
// or when it could get the relevant data; return Ok(data)


// - - - - - - - - - - - - - - - - - - - - - - -
// We can use pattern matching to catch the relevant return type(Ok/Err) when calling it

fn main() {
    let mut file_name = &quot;file_a&quot;;
    match get_word_count_from_file(file_name) {
        Ok(i) =&gt; println!(&quot;Word Count: {}&quot;, i),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e)
    }
}
</code></pre></pre>
<blockquote>
<p>🔎 Many useful methods have been implemented around Option and Result types. More information can be found on <a href="https://doc.rust-lang.org/std/option/enum.Option.html">std::option::Option</a> and <a href="https://doc.rust-lang.org/std/result/enum.Result.html">std::result::Result</a> pages on Rust doc.</p>
</blockquote>
<p>⭐️ Also <strong>more practical examples</strong> of options &amp; results can be found on <a href="https://doc.rust-lang.org/book/first-edition/error-handling.html">Error Handling</a> section in  Rust doc.</p>
<h2><a class="header" href="#title-impls--traits" id="title-impls--traits">title: Impls &amp; Traits</a></h2>
<p>💡 When we discussed about <strong>C-like structs</strong>, I mentioned that those are <strong>similar to classes</strong> in OOP languages <strong>but without their methods</strong>. <strong>impls</strong> are <strong>used to define methods</strong> for Rust structs and enums.</p>
<p>💡 <strong>Traits</strong> are kind of <strong>similar to interfaces</strong> in OOP languages. They are used to define the functionality a type must provide. Multiple traits can be implemented for a single type.</p>
<p>⭐️️ But traits <strong>can also include default implementations of methods</strong>. Default methods can be overridden when implementing types.</p>
<h3><a class="header" href="#impls-without-traits" id="impls-without-traits">Impls without traits</a></h3>
<pre><pre class="playpen"><code class="language-rust">struct Player {
    first_name: String,
    last_name: String,
}

impl Player {
    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;, self.first_name, self.last_name)
    }
}

fn main() {
    let player_1 = Player {
        first_name: &quot;Rafael&quot;.to_string(),
        last_name: &quot;Nadal&quot;.to_string(),
    };

    println!(&quot;Player 01: {}&quot;, player_1.full_name());
}

// ⭐️ Implementation must appear in the same crate as the self type

// 💡 And also in Rust, new traits can be implemented for existing types even for types like i8, f64 and etc.
// Same way existing traits can be implemented for new types you are creating.
// But we can not implement existing traits into existing types.
</code></pre></pre>
<h3><a class="header" href="#impls--traits-without-default-methods" id="impls--traits-without-default-methods">Impls &amp; traits, without default methods</a></h3>
<pre><pre class="playpen"><code class="language-rust">struct Player {
    first_name: String,
    last_name: String,
}

trait FullName {
    fn full_name(&amp;self) -&gt; String;
}

impl FullName for Player {
    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;, self.first_name, self.last_name)
    }
}

fn main() {
    let player_2 = Player {
        first_name: &quot;Roger&quot;.to_string(),
        last_name: &quot;Federer&quot;.to_string(),
    };

    println!(&quot;Player 02: {}&quot;, player_2.full_name());
}

// 🔎 Other than functions, traits can contain constants and types.
</code></pre></pre>
<h3><a class="header" href="#impls-traits--default-methods" id="impls-traits--default-methods">Impls, traits &amp; default methods</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Foo {
    fn bar(&amp;self);
    fn baz(&amp;self) { println!(&quot;We called baz.&quot;); }
}
<span class="boring">}
</span></code></pre></pre>
<p>⭐️ As you can see methods take a <strong>special first parameter</strong>, the type itself. It can be <strong>either self, &amp;self, or &amp;mut self</strong>; self if it’s a value on the stack (taking ownership), &amp;self if it’s a reference, and &amp;mut self if it’s a mutable reference.</p>
<h3><a class="header" href="#impls-with-associated-functions" id="impls-with-associated-functions">Impls with Associated functions</a></h3>
<p>Some other languages support <strong>static methods</strong>. At such times, we <strong>call a function directly</strong> through the class without creating an object. In Rust, we call them Associated Functions. we use <strong>::</strong>  instead of . when calling them from the struct.
ex. <code>Person::new(“Elon Musk Jr”);</code></p>
<pre><pre class="playpen"><code class="language-rust">struct Player {
    first_name: String,
    last_name: String,
}

impl Player {
    fn new(first_name: String, last_name: String) -&gt; Player {
        Player {
            first_name : first_name,
            last_name : last_name,
        }
    }

    fn full_name(&amp;self) -&gt; String {
        format!(&quot;{} {}&quot;, self.first_name, self.last_name)
    }
}

fn main() {
    let player_name = Player::new(&quot;Serena&quot;.to_string(), &quot;Williams&quot;.to_string()).full_name();
    println!(&quot;Player: {}&quot;, player_name);
}

// We have used :: notation for `new()` and . notation for `full_name()`

// 🔎 Also in here, instead of using new() and full_name() separately as two expressions, 
// we can use Method Chaining. ex. `player.add_points(2).get_point_count();`
</code></pre></pre>
<h3><a class="header" href="#traits-with-generics" id="traits-with-generics">Traits with generics</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait From&lt;T&gt; {
    fn from(T) -&gt; Self;
}
    impl From&lt;u8&gt; for u16 {
        //...
    }
    impl From&lt;u8&gt; for u32{
        //...
    }
    
// Should specify after the trait name like generic functions
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#traits-inheritance" id="traits-inheritance">Traits inheritance</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>trait Person {
    fn full_name(&amp;self) -&gt; String;
}

    trait Employee : Person { // Employee inherits from person trait
      fn job_title(&amp;self) -&gt; String;
    }

    trait ExpatEmployee : Employee + Expat { // ExpatEmployee inherits from Employee and Expat traits
      fn additional_tax(&amp;self) -&gt; f64;
    }
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#trait-objects" id="trait-objects">Trait objects</a></h3>
<p>🔎 While Rust favors static dispatch, it also supports dynamic dispatch through a mechanism called ‘trait objects.’</p>
<blockquote>
<p><a href="https://en.wikipedia.org/wiki/Dynamic_dispatch">🅆</a> <strong>Dynamic dispatch</strong> is the process of selecting which implementation of a polymorphic operation (method or function) to call at run time.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">trait GetSound {
    fn get_sound(&amp;self) -&gt; String;
}

struct Cat {
    sound: String,
}
    impl GetSound for Cat {
        fn get_sound(&amp;self) -&gt; String {
            self.sound.clone()
        }
    }

struct Bell {
    sound: String,
}
    impl GetSound for Bell {
        fn get_sound(&amp;self) -&gt; String {
            self.sound.clone()
        }
    }


fn make_sound&lt;T: GetSound&gt;(t: &amp;T) {
    println!(&quot;{}!&quot;, t.get_sound())
}

fn main() {
    let kitty = Cat { sound: &quot;Meow&quot;.to_string() };
    let the_bell = Bell { sound: &quot;Ding Dong&quot;.to_string() };

    make_sound(&amp;kitty); // Meow!
    make_sound(&amp;the_bell); // Ding Dong!
}
</code></pre></pre>
<h2><a class="header" href="#title-ownership" id="title-ownership">title: Ownership</a></h2>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3];
    let b = a;
    println!(&quot;{:?} {:?}&quot;, a, b); // [1, 2, 3] [1, 2, 3]
}

fn main() {
    let a = vec![1, 2, 3];
    let b = a;
    println!(&quot;{:?} {:?}&quot;, a, b); // Error; use of moved value: `a`
}
</code></pre></pre>
<p>In the above examples, we are just trying to <strong>assign the value of <code>a</code> to <code>b</code></strong> . Almost the same code in both code blocks, but having <strong>two different data types</strong>. And the second one gives an error. This is because of the <strong>Ownership</strong>.</p>
<h2><a class="header" href="#what-is-ownership-1" id="what-is-ownership-1">What is ownership?</a></h2>
<p>⭐️ Variable bindings have <strong>ownership</strong> of what they’re bound to. A piece of data can only have <strong>one owner at a time</strong>. When a binding goes out of scope, Rust will free the bound resources. This is how Rust achieves <strong>memory safety</strong>.</p>
<blockquote>
<p><a href="https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf">Ownership (noun)</a><br />
The act, state, or right of possessing something.</p>
</blockquote>
<h2><a class="header" href="#copy-types--move-types" id="copy-types--move-types">Copy types &amp; move types</a></h2>
<p>⭐️ <strong>When assigning</strong> a variable binding to another variable binding <strong>or when passing it to a function</strong>(Without referencing), if its data type is a</p>
<ol>
<li>
<p><strong>Copy Type</strong></p>
<ul>
<li>Bound resources are <strong>made a copy and assign</strong> or pass it to the function.</li>
<li>The ownership state of the original bindings is set to <strong>“copied” state</strong>.</li>
<li><strong>Mostly Primitive types</strong></li>
</ul>
</li>
<li>
<p><strong>Move type</strong></p>
<ul>
<li>Bound resources are <strong>moved</strong> to the new variable binding and we <strong>can not access the original variable binding</strong> anymore.</li>
<li>The ownership state of the original bindings is set to <strong>“moved” state</strong>.</li>
<li><strong>Non-primitive types</strong></li>
</ul>
</li>
</ol>
<blockquote>
<p>🔎 The functionality of a type is handled by the traits which have been implemented to it. By default, variable bindings have ‘move semantics.’ However, if a type implements <a href="https://doc.rust-lang.org/core/marker/trait.Copy.html"><strong><code>core::marker::Copy trait</code></strong></a> , it has a 'copy semantics'.</p>
</blockquote>
<p>💡 <strong>So in the above second example, ownership of the Vec object moves to <code>b</code> and <code>a</code> doesn’t have any ownership to access the resource.</strong></p>
<h2><a class="header" href="#title-borrowing" id="title-borrowing">title: Borrowing</a></h2>
<p>In real life applications, most of the times we have to pass variable bindings to other functions or assign them to other variable bindings. In this case, we are <strong>referencing</strong> the original binding; <strong>borrow</strong> the data of it.</p>
<h2><a class="header" href="#what-is-borrowing" id="what-is-borrowing">What is Borrowing?</a></h2>
<blockquote>
<p><a href="https://github.com/nikomatsakis/rust-tutorials-keynote/blob/master/Ownership%20and%20Borrowing.pdf">Borrow (verb)</a><br />
To receive something with the promise of returning it.</p>
</blockquote>
<h2><a class="header" href="#shared--mutable-borrowings" id="shared--mutable-borrowings">Shared &amp; Mutable borrowings</a></h2>
<p>⭐️ There are two types of Borrowing,</p>
<ol>
<li>
<p><strong>Shared Borrowing</strong> <code>(&amp;T)</code></p>
<ul>
<li>A piece of data can be <strong>borrowed by a single or multiple users</strong>, but <strong>data should not be altered</strong>.</li>
</ul>
</li>
<li>
<p><strong>Mutable Borrowing</strong> <code>(&amp;mut T)</code></p>
<ul>
<li>A piece of data can be <strong>borrowed and altered by a single user</strong>, but the data should not be accessible for any other users at that time.</li>
</ul>
</li>
</ol>
<h2><a class="header" href="#rules-for-borrowings" id="rules-for-borrowings">Rules for borrowings</a></h2>
<p>There are very important rules regarding borrowing,</p>
<ol>
<li>
<p>One piece of data can be borrowed <strong>either</strong> as a shared borrow <strong>or</strong> as a mutable borrow <strong>at a given time. But not both at the same time</strong>.</p>
</li>
<li>
<p>Borrowing <strong>applies for both copy types and move types</strong>.</p>
</li>
<li>
<p>The concept of <strong>Liveness</strong> ↴</p>
</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let mut a = vec![1, 2, 3];
  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here
                   //  ⁝
  // some code     //  ⁝
  // some code     //  ⁝
}                  //  &amp;mut borrow of `a` ends here


fn main() {
  let mut a = vec![1, 2, 3];
  let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here
  // some code

  println!(&quot;{:?}&quot;, a); // trying to access `a` as a shared borrow, so giving an error
}                  //  &amp;mut borrow of `a` ends here


fn main() {
  let mut a = vec![1, 2, 3];
  {
    let b = &amp;mut a;  //  &amp;mut borrow of `a` starts here
    // any other code
  }                  //  &amp;mut borrow of `a` ends here

  println!(&quot;{:?}&quot;, a); // allow borrowing `a` as a shared borrow
}
</code></pre></pre>
<p>💡 Let’s see how to use shared and mutable borrowings in examples.</p>
<h3><a class="header" href="#examples-for-shared-borrowing" id="examples-for-shared-borrowing">Examples for Shared Borrowing</a></h3>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3];
    let b = &amp;a;
    println!(&quot;{:?} {}&quot;, a, b[0]); // [1, 2, 3] 1
}


fn main() {
    let a = vec![1, 2, 3];
    let b = get_first_element(&amp;a);

    println!(&quot;{:?} {}&quot;, a, b); // [1, 2, 3] 1
}

fn get_first_element(a: &amp;Vec&lt;i32&gt;) -&gt; i32 {
    a[0]
}
</code></pre></pre>
<h3><a class="header" href="#examples-for-mutable-borrowing" id="examples-for-mutable-borrowing">Examples for Mutable Borrowing</a></h3>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut a = [1, 2, 3];
    let b = &amp;mut a;
    b[0] = 4;
    println!(&quot;{:?}&quot;, b); // [4, 2, 3]
}


fn main() {
    let mut a = [1, 2, 3];
    {
        let b = &amp;mut a;
        b[0] = 4;
    }

    println!(&quot;{:?}&quot;, a); // [4, 2, 3]
}


fn main() {
    let mut a = vec![1, 2, 3];
    let b = change_and_get_first_element(&amp;mut a);

    println!(&quot;{:?} {}&quot;, a, b); // [4, 2, 3] 4
}

fn change_and_get_first_element(a: &amp;mut Vec&lt;i32&gt;) -&gt; i32 {
    a[0] = 4;
    a[0]
}
</code></pre></pre>
<h2><a class="header" href="#title-lifetimes" id="title-lifetimes">title: Lifetimes</a></h2>
<p>When we are dealing with references, we have to make sure that the referencing data stay alive until we stop using the references.</p>
<p>Think,</p>
<ul>
<li>We have a <strong>variable binding</strong>, <code>a</code>.</li>
<li>We are <strong>referencing</strong> the value of <code>a</code>, <strong>from another variable binding</strong> <code>x</code>.
We have to make sure that <strong><code>a</code> lives until we stop using <code>x</code></strong>.</li>
</ul>
<blockquote>
<p>🔎 <strong>Memory management</strong> is a form of resource management applied to computer memory. Up until the mid-1990s, the majority of programming languages used <strong>Manual Memory Management</strong> which <strong>requires the programmer to give manual instructions</strong> to identify and deallocate unused objects/ garbage. Around 1959 John McCarthy invented <strong>Garbage collection</strong>(GC), a form of <strong>Automatic Memory Management</strong>(AMM). It determines what memory is no longer used and frees it automatically instead of relying on the programmer. However <strong>Objective-C and Swift</strong> provide similar functionality through <strong>Automatic Reference Counting</strong>(ARC).</p>
</blockquote>
<h2><a class="header" href="#what-is-lifetime" id="what-is-lifetime">What is Lifetime?</a></h2>
<p>In Rust,</p>
<ul>
<li>A resource can only have <strong>one owner</strong> at a time. When it goes <strong>out of the scope</strong>, Rust removes it from the Memory.</li>
<li>When we want to reuse the same resource, we are <strong>referencing</strong> it/ <strong>borrowing</strong> its content.</li>
<li>When dealing with <strong>references</strong>, we have to specify <strong>lifetime annotations</strong> to provide instructions for the <strong>compiler</strong> to set <strong>how long</strong> those referenced resources <strong>should be alive</strong>.</li>
<li>⭐ But because of lifetime annotations make the <strong>code more verbose</strong>, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong> in <code>fn</code> definitions. In this case, the compiler assigns lifetime annotations <strong>implicitly</strong>.</li>
</ul>
<p>Lifetime annotations are <strong>checked at compile-time</strong>. Compiler checks when a data is used for the first and the last times. According to that, Rust manages memory in <strong>run time</strong>. This is the major reason for <strong>slower compilation times</strong> in Rust.</p>
<blockquote>
<ul>
<li>Unlike C and C++, <strong>usually</strong>, Rust doesn’t explicitly drop values at all.</li>
<li>Unlike GC, Rust doesn’t place deallocation calls where the data is no longer referenced.</li>
<li>Rust places deallocation calls where the data is about to go out of the scope and then enforces that no references to that resource exist after that point.</li>
</ul>
</blockquote>
<h2><a class="header" href="#usage" id="usage">Usage</a></h2>
<p>Lifetimes are denoted with an apostrophe. By convention, a lowercase letter is used for naming. Usually <strong>starts with</strong> <code>'a</code> and <strong>follows alphabetic order</strong> when we need to add <strong>multiple lifetime</strong> annotations.</p>
<p>When using references,</p>
<h3><a class="header" href="#01-on-function-declaration" id="01-on-function-declaration">01. On Function Declaration</a></h3>
<ul>
<li>
<p>Input and output parameters with references should attach lifetimes after the <code>&amp;</code> sign.
ex. <code>..(x: &amp;'a str)</code> , <code>..(x: &amp;'a mut str)</code></p>
</li>
<li>
<p>After the function name, we should mention that the given lifetimes are generic types.
ex. <code>fn foo&lt;'a&gt;(..)</code> , <code>fn foo&lt;'a, 'b&gt;(..)</code></p>
</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// No inputs, return a reference
fn function&lt;'a&gt;() -&gt; &amp;'a str {}

// Single input
fn function&lt;'a&gt;(x: &amp;'a str) {}

// Single input and output, both have the same lifetime
// The output should live at least as long as input exists
fn function&lt;'a&gt;(x: &amp;'a str) -&gt; &amp;'a str {}

// Multiple inputs, only one input and the output share same lifetime
// The output should live at least as long as y exists
fn function&lt;'a&gt;(x: i32, y: &amp;'a str) -&gt; &amp;'a str {}

// Multiple inputs, both inputs and the output share same lifetime
// The output should live at least as long as x and y exist
fn function&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {}

// Multiple inputs, inputs can have different lifetimes 🔎
// The output should live at least as long as x exists
fn function&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;'a str {}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#02-on-struct-or-enum-declaration" id="02-on-struct-or-enum-declaration">02. On Struct or Enum Declaration</a></h3>
<ul>
<li>Elements with references should attach lifetimes after the <code>&amp;</code> sign.</li>
<li>After the name of the struct or enum, we should mention that the given lifetimes are generic types.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Single element
// Data of x should live at least as long as Struct exists
struct Struct&lt;'a&gt; {
    x: &amp;'a str
}

// Multiple elements
// Data of x and y should live at least as long as Struct exists
struct Struct&lt;'a&gt; {
    x: &amp;'a str,
    y: &amp;'a str
}


// Variant with a single element
// Data of the variant should live at least as long as Enum exists
enum Enum&lt;'a&gt; {
    Variant(&amp;'a Type)
}
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#03-with-impls-and-traits" id="03-with-impls-and-traits">03. With Impls and Traits</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Struct&lt;'a&gt; {
    x: &amp;'a str
}
    impl&lt;'a&gt; Struct&lt;'a&gt; {
        fn function&lt;'a&gt;(&amp;self) -&gt; &amp;'a str {
            self.x
        }
    }


struct Struct&lt;'a&gt; {
    x: &amp;'a str,
    y: &amp;'a str
}
    impl&lt;'a&gt; Struct&lt;'a&gt; {
        fn new(x: &amp;'a str, y: &amp;'a str) -&gt; Struct&lt;'a&gt; { // No need to specify &lt;'a&gt; after new; impl already has it
          Struct {
              x : x,
              y : y
          }
        }
    }


// 🔎
impl&lt;'a&gt; Trait&lt;'a&gt; for Type
impl&lt;'a&gt; Trait for Type&lt;'a&gt;
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#04-with-generic-types" id="04-with-generic-types">04. With Generic Types</a></h3>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// 🔎
fn function&lt;F&gt;(f: F) where for&lt;'a&gt; F: FnOnce(&amp;'a Type)
struct Struct&lt;F&gt; where for&lt;'a&gt; F: FnOnce(&amp;'a Type) { x: F }
enum Enum&lt;F&gt; where for&lt;'a&gt; F: FnOnce(&amp;'a Type) { Variant(F) }
impl&lt;F&gt; Struct&lt;F&gt; where for&lt;'a&gt; F: FnOnce(&amp;'a Type) { fn x(&amp;self) -&gt; &amp;F { &amp;self.x } }
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#lifetime-elision-1" id="lifetime-elision-1">Lifetime Elision</a></h2>
<p>As I mentioned earlier, in order to make <strong>common patterns</strong> more ergonomic, Rust allows lifetimes to be <strong>elided/omitted</strong>. This process is called <strong>Lifetime Elision</strong>.</p>
<p>💡 For the moment Rust supports Lifetime Elisions only on <code>fn</code> definitions. But in the future, it will support for <code>impl</code> headers as well.</p>
<p>Lifetime annotations of <code>fn</code> definitions can be elided<br />
if its <strong>parameter list</strong> has either,</p>
<ul>
<li><strong>only one input parameter passes by reference</strong>.</li>
<li>a parameter with <strong>either</strong> <code>&amp;self</code> <strong>or</strong> <strong>&amp;mut self</strong> reference.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn triple(x: &amp;u64) -&gt; u64 { // Only one input parameter passes by reference
    x * 3
}


fn filter(x: u8, y: &amp;str) -&gt; &amp;str { // Only one input parameter passes by reference
    if x &gt; 5 { y } else { &quot;invalid inputs&quot; }
}


struct Player&lt;'a&gt; {
    id: u8,
    name: &amp;'a str
}
    impl&lt;'a&gt; Player&lt;'a&gt; { // So far Lifetime Elisions are allowed only on fn definitions. But in the future, they might support on impl headers as well.
        fn new(id: u8, name: &amp;str) -&gt; Player { // Only one input parameter passes by reference
            Player {
                id : id,
                name : name
            }
        }

        fn heading_text(&amp;self) -&gt; String { // An fn definition with &amp;self (or &amp;mut self) reference
            format!(&quot;{}: {}&quot;, self.id, self.name)
        }
    }

fn main() {
    let player1 = Player::new(1, &quot;Serena Williams&quot;);
    let player1_heading_text = player1.heading_text()
    println!(&quot;{}&quot;, player1_heading_text);
}
</code></pre></pre>
<blockquote>
<p>💡 In the Lifetime Elision process of fn definitions,</p>
<ul>
<li>Each parameter passes by reference is got a distinct lifetime annotation.
ex. <code>..(x: &amp;str, y: &amp;str)</code> → <code>..&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str)</code></li>
<li>If the parameter list has only one parameter passes by reference, that lifetime is assigned to all elided lifetimes in the return values of that function.
ex. <code>..(x: i32, y: &amp;str) -&gt; &amp;str</code> → <code>..&lt;'a&gt;(x: i32, y: &amp;'a str) -&gt; &amp;'a str</code></li>
<li>Even it has multiple parameters pass by reference, if one of them has &amp;self or &amp;mut self, the lifetime of self is assigned to all elided output lifetimes.
ex. <code>impl Impl{ fn function(&amp;self, x: &amp;str) -&gt; &amp;str {} }</code> →
<code>impl&lt;'a&gt; Impl&lt;'a&gt;{ fn function(&amp;'a self, x: &amp;'b str) -&gt; &amp;'a str {} }</code></li>
<li>For all other cases, we have to write lifetime annotations manually.</li>
</ul>
</blockquote>
<h2><a class="header" href="#static-annotations" id="static-annotations"><code>'static</code> Annotations</a></h2>
<p><code>'static</code> lifetime annotation is a <strong>reserved</strong> lifetime annotation. These <strong>references are valid for the entire program</strong>. They are saved in the data segment of the binary and the data referred to will never go out of scope.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>static N: i32 = 5; // A constant with 'static lifetime

let a = &quot;Hello, world.&quot;; // a: &amp;'static str


fn index() -&gt; &amp;'static str { // No need to mention &lt;'static&gt; ; fn index ̶&lt;̶'̶s̶t̶a̶t̶i̶c̶&gt;̶ 
	&quot;Hello, world!&quot;
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#few-more-examples-about-the-usage-of-rust-lifetimes" id="few-more-examples-about-the-usage-of-rust-lifetimes">Few more examples about the usage of Rust lifetimes.</a></h2>
<pre><pre class="playpen"><code class="language-rust">fn greeting&lt;'a&gt;() -&gt; &amp;'a str {
  &quot;Hi!&quot;
}


fn fullname&lt;'a&gt;(fname: &amp;'a str, lname: &amp;'a str) -&gt; String {
  format!(&quot;{} {}&quot;, fname, lname)
}


struct Person&lt;'a&gt; {
    fname: &amp;'a str,
    lname: &amp;'a str
}
  impl&lt;'a&gt; Person&lt;'a&gt; {
      fn new(fname: &amp;'a str, lname: &amp;'a str) -&gt; Person&lt;'a&gt; { // No need to specify &lt;'a&gt; after new; impl already has it
          Person {
              fname : fname,
              lname : lname
          }
      }

      fn fullname(&amp;self) -&gt; String {
          format!(&quot;{} {}&quot;, self.fname , self.lname)
      }
  }

fn main() {
    let player = Person::new(&quot;Serena&quot;, &quot;Williams&quot;);
    let player_fullname = player.fullname();

    println!(&quot;Player: {}&quot;, player_fullname);
}
</code></pre></pre>
<h2><a class="header" href="#title-code-organization" id="title-code-organization">title: Code Organization</a></h2>
<p>When a single code block is getting larger, it should be decomposed into smaller pieces and should be organized in a proper manner. Rust supports different levels of code organization.</p>
<ol>
<li>
<h3><a class="header" href="#a-hreflearningrustd2functionshtmlfunctionsa" id="a-hreflearningrustd2functionshtmlfunctionsa"><a href="learningrust/d2.functions.html">Functions</a></a></h3>
</li>
<li>
<h3><a class="header" href="#a-hreflearningrustd3moduleshtmlmodulesa" id="a-hreflearningrustd3moduleshtmlmodulesa"><a href="learningrust/d3.modules.html">Modules</a></a></h3>
</li>
</ol>
<p>Can be mapped to a,</p>
<ul>
<li><strong>Inline module</strong></li>
<li><strong>File</strong> </li>
<li><strong>Directory hierarchy</strong></li>
</ul>
<ol start="3">
<li>
<h3><a class="header" href="#a-hreflearningrustd4crateshtmlcratesa" id="a-hreflearningrustd4crateshtmlcratesa"><a href="learningrust/d4.crates.html">Crates</a></a></h3>
</li>
</ol>
<p>Can be mapped to a, </p>
<ul>
<li>
<p><strong>lib.rs file on the same executable crate</strong></p>
</li>
<li>
<p><strong>Dependency crate specified on Cargo.toml</strong></p>
<p>Can be specified from,</p>
<ul>
<li><strong>Path</strong></li>
<li><strong>Git repository</strong></li>
<li><strong>crates.io</strong></li>
</ul>
</li>
</ul>
<ol start="4">
<li>
<h3><a class="header" href="#a-hreflearningrustd5workspaceshtmlworkspacesa" id="a-hreflearningrustd5workspaceshtmlworkspacesa"><a href="learningrust/d5.workspaces.html">Workspaces</a></a></h3>
</li>
</ol>
<p>Helps to manage multiple crates as a single project.</p>
<p>Let’s discuss one by one.</p>
<blockquote>
<p>💡 To make examples more simpler, we use a simple function which prints <code>“Hello, world!”</code>. But regarding writing testable codes, always try to return the <code>String</code> from the function and print it when calling it, instead of printing the <code>String</code> inside the function.</p>
</blockquote>
<h2><a class="header" href="#title-functions-1" id="title-functions-1">title: Functions</a></h2>
<p>Functions are the first line of organization in any program.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  greet(); // Do one thing
  ask_location(); // Do another thing
}

fn greet() {
  println!(&quot;Hello!&quot;);
}

fn ask_location() {
  println!(&quot;Where are you from?&quot;);
}
</code></pre></pre>
<p>We can add unit tests in the same file.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    greet();
}

fn greet() -&gt; String {
    &quot;Hello, world!&quot;.to_string()
}

#[test] // Test attribute indicates this is a test function
fn test_greet() {
    assert_eq!(&quot;Hello, world!&quot;, greet())
}

// 💡 Always put test functions inside a tests module with #[cfg(test)] attribute. 
// cfg(test) module compiles only when running tests. We discuss more about this in the next section.
</code></pre></pre>
<blockquote>
<p>💭 An <a href="https://doc.rust-lang.org/reference/attributes.html">attribute</a> is a general, free-form <strong>metadatum</strong> that is interpreted according to name, convention, and language and compiler version.</p>
</blockquote>
<h2><a class="header" href="#title-modules" id="title-modules">title: Modules</a></h2>
<h2><a class="header" href="#01-in-the-same-file" id="01-in-the-same-file">01. In the same file</a></h2>
<p>Related code and data are grouped into a module and stored in the same file.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
   greetings::hello();
}

mod greetings {
  // ⭐️ By default, everything inside a module is private
  pub fn hello() { // ⭐️ So function has to be public to access from outside
    println!(&quot;Hello, world!&quot;);
  }
}
</code></pre></pre>
<p>Modules can also be nested.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() { 
  phrases::greetings::hello();
}

mod phrases { 
  pub mod greetings { 
    pub fn hello() { 
      println!(&quot;Hello, world!&quot;);
    }
  }
}
</code></pre></pre>
<p>Private functions can be called from the same module or from a child module.</p>
<pre><pre class="playpen"><code class="language-rust">// 01. Calling private functions of the same module
fn main() {
  phrases::greet();
}

mod phrases {
  pub fn greet() {
    hello(); // Or `self::hello();`
  }
  
  fn hello() {
    println!(&quot;Hello, world!&quot;);
  }
}

// 02. Calling private functions of the parent module
fn main() {
  phrases::greetings::hello();
}

mod phrases {
  fn private_fn() {
    println!(&quot;Hello, world!&quot;);
  }
  
  pub mod greetings {
    pub fn hello() {
      super::private_fn();
    }
  }
}
</code></pre></pre>
<blockquote>
<p>💡 The <code>self</code> keyword is used to refer the same module, while the <code>super</code> keyword is used to refer parent module. Also, the <code>super</code> keyword can be used to access root functions from inside a module.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  greetings::hello();
}

fn hello() {
  println!(&quot;Hello, world!&quot;);
}

mod greetings {
  pub fn hello() {
    super::hello();
  }
}
</code></pre></pre>
<blockquote>
<p>🔎 When writing tests it’s a good practice to write tests inside a test module because they compile only when running tests.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn greet() -&gt; String {
    &quot;Hello, world!&quot;.to_string()
}

#[cfg(test)] // Only compiles when running tests
mod tests {
    use super::greet; // Import root greet function

    #[test]
    fn test_greet() {
        assert_eq!(&quot;Hello, world!&quot;, greet());
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#02-in-a-different-file-same-directory" id="02-in-a-different-file-same-directory">02. In a different file, same directory</a></h2>
<pre><pre class="playpen"><code class="language-rust">// ↳ main.rs
mod greetings; // Import greetings module

fn main() {
  greetings::hello();
}

// ↳ greetings.rs
// ⭐️ No need to wrap the code with a mod declaration. The file itself acts as a module.
pub fn hello() { // The function has to be public to access from outside
  println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>
<pre><pre class="playpen"><code class="language-rust">// ↳ main.rs
mod phrases;

fn main() {
  phrases::greetings::hello();
}

// ↳ phrases.rs
pub mod greetings { // ⭐️ The module has to be public to access from outside
  pub fn hello() {
    println!(&quot;Hello, world!&quot;);
  }
}
</code></pre></pre>
<h2><a class="header" href="#03-in-a-different-file-different-directory" id="03-in-a-different-file-different-directory">03. In a different file, different directory</a></h2>
<p><code>mod.rs</code> in the directory module root is the entry point to the directory module. All other files in that directory root, act as sub-modules of the directory module.</p>
<pre><pre class="playpen"><code class="language-rust">// ↳ main.rs
mod greetings;

fn main() {
  greetings::hello();
}

// ↳ greetings/mod.rs
pub fn hello() { // ⭐️ The function has to be public to access from outside
  println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>Again, If we wrap file content with a <code>mod</code> declaration, it will act as a nested module.</p>
<pre><pre class="playpen"><code class="language-rust">// ↳ main.rs
mod phrases;

fn main() {
  phrases::greetings::hello();
}

// ↳ phrases/mod.rs
pub mod greetings { // ⭐️ The module has to be public to access from outside
  pub fn hello() {
    println!(&quot;Hello, world!&quot;);
  }
}
</code></pre></pre>
<p>Other files in the directory module act as sub-modules for <code>mod.rs</code>.</p>
<pre><pre class="playpen"><code class="language-rust">// ↳ main.rs
mod phrases;

fn main() {
  phrases::hello()
}

// ↳ phrases/mod.rs
mod greetings;

pub fn hello() {
  greetings::hello()
}

// ↳ phrases/greetings.rs
pub fn hello() {
  println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>⭐️ If you need to access an element of <code>phrases/greetings.rs</code> from outside the module, you have to import the <code>greetings</code> module as a public module.</p>
<pre><pre class="playpen"><code class="language-rust">// ↳ main.rs
mod phrases;

fn main() {
    phrases::greetings::hello();
}

// ↳ phrases/mod.rs
pub mod greetings;  // ⭐️ `pub mod` instead `mod`

// ↳ phrases/greetings.rs
pub fn hello() {
  println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<blockquote>
<p>🔎 It’s unable to import child file modules of directory modules to <code>main.rs</code>, so you can’t use <code>mod phrases::greetings;</code> from <code>main.rs</code>. But there is a way to import <code>phrases::greetings::hello()</code> to <code>phrases</code> module by re-exporting <code>hello</code> to <code>phrases</code> module. So you can call it directly as <code>phrases::hello()</code>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">// ↳ phrases/greetings.rs
pub fn hello() {
  println!(&quot;Hello, world!&quot;);
}

// ↳ phrases/mod.rs
pub mod greetings;

pub use self::greetings::hello; // Re-export `greetings::hello` to phrases

// ↳ main.rs
mod phrases;

fn main() {
    phrases::hello(); // You can call `hello()` directly from phrases
}
</code></pre></pre>
<p>This allows you to present an external interface that <strong>may not directly map</strong> to your internal code organization. If still it is not clear, don’t worry; We discuss the usages of <code>use</code> on an upcoming section in this post.</p>
<h2><a class="header" href="#title-crates" id="title-crates">title: Crates</a></h2>
<p>💭 Crates are a bit similar to the packages in some other languages. Crates compile individually. If the crate has child file modules, those files will get merged with the crate file and compile as a single unit.</p>
<p>💭 A crate can produce an executable/ a binary or a library. <code>src/main.rs</code> is the crate root/ entry point for a binary crate and <code>src/lib.rs</code> is the entry point for a library crate.</p>
<h2><a class="header" href="#01-librs-on-executable-crate" id="01-librs-on-executable-crate">01. lib.rs on executable crate</a></h2>
<p>💡 When writing binary crates, we can move the main functionalities to <code>src/lib.rs</code> and use it as a library from <code>src/main.rs</code>. This pattern is quite common on executable crates.</p>
<pre><pre class="playpen"><code class="language-rust">// # Think we run,
cargo new greetings
touch greetings/src/lib.rs

// # It generates,
greetings
 ├── Cargo.toml
 └── src
    ├── lib.rs
    └── main.rs

// # Think we modify following files,

// 01. greetings/src/lib.rs
pub fn hello() {
    println!(&quot;Hello, world!&quot;);
}

// 02. greetings/src/main.rs
extern crate greetings;

fn main() {
    greetings::hello();
}
</code></pre></pre>
<blockquote>
<p>💯 As I mentioned earlier, in here we use simplest examples to reduce the complexity of learning materials. But this is how we need to write <code>greetings/src/lib.rs</code> to make the code more testable.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// greetings/src/lib.rs
pub fn hello() -&gt; String {
  //! This returns `Hello, world!` String
  (&quot;Hello, world!&quot;).to_string()
}

// 01. Tests for `hello()`
#[test] // Indicates that this is a test function
fn test_hello() {
  assert_eq!(hello(), &quot;Hello, world!&quot;);
}

// 02. Tests for `hello()`, Idiomatic way
#[cfg(test)] // Only compiles when running tests
mod tests { // Separates tests from code
  use super::hello; // Import root `hello()` function
  
    #[test]
    fn test_hello() {
        assert_eq!(hello(), &quot;Hello, world!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><a href="https://doc.rust-lang.org/book/first-edition/crates-and-modules.html">📖</a> When importing a crate that has dashes in its name “like-this”, which is not a valid Rust identifier, it will be converted by changing the dashes to underscores, so you would write <code>extern crate like_this;</code></p>
</blockquote>
<p><code>lib.rs</code> can link with multiple files.</p>
<pre><pre class="playpen"><code class="language-rust">// # Think we run,
cargo new phrases
touch phrases/src/lib.rs
touch phrases/src/greetings.rs

// # It generates,
phrases
 ├── Cargo.toml
 └── src
    ├── greetings.rs
    ├── lib.rs
    └── main.rs
   
// # Think we modify following files,

// 01. phrases/src/greetings.rs
pub fn hello() {
    println!(&quot;Hello, world!&quot;);
}

// 02. phrases/src/main.rs
extern crate phrases;

fn main() {
    phrases::greetings::hello();
}

// 03. phrases/src/lib.rs
pub mod greetings; // ⭐️ Import `greetings` module as a public module
</code></pre></pre>
<h2><a class="header" href="#02-dependency-crate-on-cargotoml" id="02-dependency-crate-on-cargotoml">02. Dependency crate on Cargo.toml</a></h2>
<p>When the code in the <code>lib.rs</code> file is getting larger, we can move those into a separate library crate and use it as a dependency of the main crate. As we mentioned earlier, a dependency can be specified from a folder path, git repository or by crates.io.</p>
<h3><a class="header" href="#a-using-folder-path" id="a-using-folder-path">a. Using folder path</a></h3>
<p>Let’s see how to create a nested crate and use it as a dependency using folder path,</p>
<pre><pre class="playpen"><code class="language-rust">// # Think we run,
cargo new phrases
cargo new phrases/greetings --lib

// # It generates,
phrases
 ├── Cargo.toml
 ├── greetings
 │  ├── Cargo.toml
 │  └── src
 │     └── lib.rs
 └── src
    └── main.rs

// # Think we modify following files,

// 01. phrases/Cargo.toml
[package]
name = &quot;phrases&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dumindu Madunuwan&quot;]

[dependencies]
greetings = { path = &quot;greetings&quot; }

// 02. phrases/greetings/src/lib.rs
pub fn hello() {
    println!(&quot;Hello, world!&quot;);
}

// 03. phrases/src/main.rs
extern crate greetings;

fn main() {
    greetings::hello();
}
</code></pre></pre>
<h3><a class="header" href="#b-using-git-repository" id="b-using-git-repository">b. Using git repository</a></h3>
<p>If you want to use a library crate on multiple projects, one way is moving crate code to a git repository and use it as a dependency when needed.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// -- Cargo.toml --
[dependencies]

// 01. Get the latest commit on the master branch
rocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot; }

// 02. Get the latest commit of a specific branch
rocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, branch = &quot;v0.3&quot; }

// 03. Get a specific tag
rocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, tag = &quot;v0.3.2&quot; }

// 04. Get a specific revision (on master or any branch, according to rev)
rocket = { git = &quot;https://github.com/SergioBenitez/Rocket&quot;, rev = &quot;8183f636305cef4adaa9525506c33cbea72d1745&quot; }
<span class="boring">}
</span></code></pre></pre>
<h3><a class="header" href="#c-using-cratesio" id="c-using-cratesio">c. Using crates.io</a></h3>
<p>The other way is uploading it to <a href="http://crates.io/">crates.io</a> and use it as a dependency when needed.</p>
<p>🚧 First, let’s <code>create</code> a simple “Hello world” crate <code>and upload</code> it to <a href="http://crates.io/">crates.io</a>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// # Think we run,
cargo new test_crate_hello_world --lib

// # It generates,
test_crate_hello_world
 ├── Cargo.toml
 └── src
    └── lib.rs
   
// # Think we modify following files,

// 01. test_crate_hello_world/Cargo.toml
[package]
name = &quot;test_crate_hello_world&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dumindu Madunuwan&quot;]

description = &quot;A Simple Hello World Crate&quot;
repository = &quot;https://github.com/dumindu/test_crate_hello_world&quot;
keywords = [&quot;hello&quot;, &quot;world&quot;]
license = &quot;Apache-2.0&quot;

[dependencies]

// 02. test_crate_hello_world/src/lib.rs
//! A Simple Hello World Crate

/// This function returns the greeting; `Hello, world!`
pub fn hello() -&gt; String {
    (&quot;Hello, world!&quot;).to_string()
}

#[cfg(test)]
mod tests {

    use super::hello;
    
    #[test]
    fn test_hello() {
        assert_eq!(hello(), &quot;Hello, world!&quot;);
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>💭 <strong>//! doc comments</strong> are used to write crate and module-level documentation. On other places, we have to use /// outside of the block. And when uploading a crate to <a href="http://crates.io/">crates.io</a>, cargo generates the documentation from these doc comments and host it on <a href="https://docs.rs/">docs.rs</a>.</p>
</blockquote>
<p>💡 We have to add the <strong>description</strong> and <strong>license</strong> fields to <code>Cargo.toml</code>. Otherwise, we will get <code>error: api errors: missing or empty metadata fields: description, license. Please see http://doc.crates.io/manifest.html</code></p>
<p>To upload this to crates.io,</p>
<ol>
<li>We have to create an account on crates.io to acquire an API token</li>
<li>Then run <code>cargo login &lt;token&gt;</code> with that API token and cargo publish</li>
</ol>
<p><a href="http://doc.crates.io/crates-io.html">📖</a> This is <a href="http://doc.crates.io/crates-io.html">how it describes on Cargo Docs</a> with more details.</p>
<blockquote>
<ul>
<li>You’ll need an account on crates.io to acquire an API token. To do so, <a href="https://crates.io/">visit the home page</a> and log in via a GitHub account (required for now). After this, visit your <a href="https://crates.io/me">Account Settings</a> page and run the <code>cargo login</code> command specified. 
Ex. <code>cargo login abcdefghijklmnopqrstuvwxyz012345</code></li>
</ul>
</blockquote>
<ul>
<li>The next step is to package up your crate into a format that can be uploaded to crates.io. For this we’ll use the <code>cargo package</code> sub-command.</li>
<li>Now, it can be uploaded to crates.io with the <code>cargo publish</code> command.</li>
<li>If you’d like to skip the <code>cargo package</code> step, the <code>cargo publish</code> sub-command will automatically package up the local crate if a copy isn’t found already.</li>
</ul>
<p>The name of our crate is <code>test_crate_hello_world</code>. So it can be found on,
📦 <a href="https://crates.io/crates/test_crate_hello_world">https://<strong>crates.io/crates</strong>/test_crate_hello_world</a>
📑 <a href="https://docs.rs/test_crate_hello_world">https://<strong>docs.rs</strong>/test_crate_hello_world</a></p>
<blockquote>
<p>💯 crates.io supports readme files as well. To enable it, we have to add the readme field to Cargo.toml. Ex: <code>readme=&quot;README.md&quot;</code></p>
</blockquote>
<p>🏗️ Okay then, Let’s see how we can <strong>use this from another crate</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">// # Think we run,
cargo new greetings

// # It generates,
greetings
 ├── Cargo.toml
 └── src
    └── main.rs

// # Think we modify following files,

// 01. greetings/Cargo.toml
[package]
name = &quot;greetings&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dumindu Madunuwan&quot;]

[dependencies]
test_crate_hello_world = &quot;0.1.0&quot;

// 02. greetings/src/main.rs
extern crate test_crate_hello_world;

fn main() {
    println!(&quot;{}&quot;, test_crate_hello_world::hello());
}
</code></pre></pre>
<p>By default, Cargo looks dependencies on <a href="https://crates.io/">crates.io</a>. So we have to add only the crate name and a version string to <strong><code>Cargo.toml</code></strong> and then run <code>cargo build</code> to fetch the dependencies and compile them.</p>
<h2><a class="header" href="#title-workspaces" id="title-workspaces">title: Workspaces</a></h2>
<p>When the code base is getting larger, you might need to work with <strong>multiple crates on the same project</strong>. Rust supports this via Workspaces. You can <strong>analyze (<code>cargo check</code>), build, run tests or generate docs for all crates</strong> at once by running <code>cargo</code> commands from the project root.</p>
<p>⭐️ When working on multiple crates same time, there is a higher possibility of having shared dependencies on crates. To prevent downloading and compiling the same dependency multiple times, Rust uses a <strong>shared build directory</strong> under the project root, while running <code>cargo build</code> from the project root.</p>
<p>Let's create a library crate with a simple hello world function and a binary crate which uses the library crate.</p>
<p>Assume we run,</p>
<pre><code class="language-bash">mkdir greetings
touch greetings/Cargo.toml
cargo new greetings/lib --lib
cargo new greetings/examples/hello
</code></pre>
<p>That generates,</p>
<pre><code>greetings
 ├── Cargo.toml
 ├── examples
 │  └── hello
 │     ├── Cargo.toml
 │     └── src
 │        └── main.rs
 └── lib
    ├── Cargo.toml
    └── src
       └── lib.rs
</code></pre>
<p>We have to modify the following files,</p>
<pre><pre class="playpen"><code class="language-rust">// 01. greetings/Cargo.toml to mark as a workspace and to add members
[workspace]
members = [
    &quot;lib&quot;,
    &quot;examples/hello&quot;
]

// 02.1 greetings/lib/Cargo.toml to change the package name to greetings
[package]
name = &quot;greetings&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dumindu Madunuwan&quot;]

[dependencies]

// 02.2 greetings/lib/src/lib.rs to add a simple hello world function
pub fn hello() {
    println!(&quot;Hello, world!&quot;);
}

// 03.1 greetings/examples/hello/Cargo.toml to add the `greetings` lib as a dependency
[package]
name = &quot;hello&quot;
version = &quot;0.1.0&quot;
authors = [&quot;Dumindu Madunuwan&quot;]

[dependencies]
greetings = { path = &quot;../../lib&quot; }

// 03.2 greetings/examples/hello/src/main.rs to import the `greetings` lib and call its hello world function
extern crate greetings;

fn main() {
    greetings::hello();
}
</code></pre></pre>
<p>💡 On Linux and Mac, you can run <code>cargo</code> commands on each carets without changing the working directory all the times via Subshells (A command list embedded between parentheses). For example, if you are in the <code>greetings</code> directory, even you run <code>(cd examples/hello &amp;&amp; cargo run)</code> your working directory will be kept  as same in <code>greetings</code> folder.</p>
<blockquote>
<p>🔎 <a href="https://github.com/rust-lang/rust/tree/master/src">rust-lang/rust source folder</a> is a good example for a workspace.</p>
</blockquote>
<h2><a class="header" href="#title-use" id="title-use">title: Use</a></h2>
<p>Let's see the main usages of the <code>use</code> keyword.</p>
<h2><a class="header" href="#01-bind-a-full-path-to-a-new-name" id="01-bind-a-full-path-to-a-new-name">01. Bind a full path to a new name</a></h2>
<p>Mainly <code>use</code> keyword is used to bind a full path of an element to a new name. So the user doesn’t want to repeat the full path each time.</p>
<pre><pre class="playpen"><code class="language-rust">// -- Initial code without the `use` keyword --
mod phrases { 
  pub mod greetings { 
    pub fn hello() { 
      println!(&quot;Hello, world!&quot;);
    }
  }
}

fn main() { 
  phrases::greetings::hello(); // Using full path
}


// -- Usage of the `use` keyword --
// 01. Create an alias for module
use phrases::greetings;
fn main() { 
  greetings::hello();
}

// 02. Create an alias for module elements
use phrases::greetings::hello;
fn main() { 
  hello();
}

// 03. Customize names with the `as` keyword
use phrases::greetings::hello as greet;
fn main() { 
  greet();
}
</code></pre></pre>
<h2><a class="header" href="#02-import-elements-to-scope" id="02-import-elements-to-scope">02. Import elements to scope</a></h2>
<p>Another common usage of <code>use</code> is importing elements to scope. Remember that, this is also a bit similar to creating an alias and using it instead of using the full path.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn hello() -&gt; String {
  &quot;Hello, world!&quot;.to_string()
}

#[cfg(test)]
mod tests {
  use super::hello; // Import the `hello()` function into the scope
    
  #[test]
  fn test_hello() {
    assert_eq!(&quot;Hello, world!&quot;, hello()); // If not using the above `use` statement, we can run same via `super::hello()`
  }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>💡 By default, <code>use</code> declarations use absolute paths, starting from the crate root. But <code>self</code> and <code>super</code> declarations make that path relative to the current module.</p>
</blockquote>
<p>Same way the <code>use</code> keyword is used to import the elements of other crates including the <code>std</code>, Rust’s <a href="https://github.com/rust-lang/rust/tree/master/src/libstd">Standard Library</a>.</p>
<pre><pre class="playpen"><code class="language-rust">// -- 01. Importing elements --
use std::fs::File;

fn main() {
    File::create(&quot;empty.txt&quot;).expect(&quot;Can not create the file!&quot;);
}


// -- 02. Importing module and elements --
std::fs::{self, File} // `use std::fs; use std::fs::File;`

fn main() {
    fs::create_dir(&quot;some_dir&quot;).expect(&quot;Can not create the directry!&quot;);
    File::create(&quot;some_dir/empty.txt&quot;).expect(&quot;Can not create the file!&quot;);
}


// -- 03. Importing multiple elements --
use std::fs::File;
use std::io::{BufReader, BufRead}; // `use std::io::BufReader; use std::io::BufRead;`

fn main() {
    let file = File::open(&quot;src/hello.txt&quot;).expect(&quot;file not found&quot;);
    let buf_reader = BufReader::new(file);

    for line in buf_reader.lines() {
        println!(&quot;{}&quot;, line.unwrap());
    }
}
</code></pre></pre>
<blockquote>
<p>We <strong>don’t need</strong> to use <code>extern crate std;</code> when using the <code>std</code> library. We will discuss more about this under the Standard Library section.</p>
</blockquote>
<p>💡 <code>use</code> statements import only what we’ve specified into the scope, instead of importing all elements of a module or crate. So it improves the efficiency of the program.</p>
<h2><a class="header" href="#03-re-exporting" id="03-re-exporting">03. Re-exporting</a></h2>
<p>Another special case is <code>pub use</code>. When creating a module, you can export things from another module into your module. So after that, they can be accessed directly from your module. This is called <strong>re-exporting</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">// ↳ main.rs
mod phrases;

fn main() {
    phrases::hello(); // Not directly map
}

// ↳ phrases/mod.rs
pub mod greetings;

pub use self::greetings::hello; // Re-export `greetings::hello` to phrases

// ↳ phrases/greetings.rs
pub fn hello() {
  println!(&quot;Hello, world!&quot;);
}
</code></pre></pre>
<p>This pattern is quite common in large libraries. It helps to hide the complexity of the internal module structure of the library from users. Because users don’t need to know/follow the whole directory map of the elements of the library while working with them.</p>
<h2><a class="header" href="#title-standard-library-primitives-and-preludes" id="title-standard-library-primitives-and-preludes">title: Standard Library, Primitives and Preludes</a></h2>
<p>⭐️ In Rust, language elements are implemented by not only <strong><code>std</code> library</strong> crate but also <strong>compiler</strong> as well. Examples,</p>
<ul>
<li><strong><a href="https://doc.rust-lang.org/std/#primitives">Primitives</a></strong>: Defined by the compiler and methods are implemented by <code>std</code> library directly on primitives.</li>
<li><strong><a href="https://doc.rust-lang.org/std/#macros">Standard Macros</a></strong>: Defined by both compiler and <code>std</code></li>
</ul>
<p>The <strong><code>std</code></strong> library has been divided into <strong><a href="https://doc.rust-lang.org/std/#modules">modules</a></strong>, according to the main areas each covered.</p>
<p>⭐️ While primitives are implemented by the <strong>compiler</strong>, the standard library implements the <strong>most useful methods</strong> directly on the primitive types. But some <strong>rarely useful language elements</strong> of some primitives are stored on relevant <strong><code>std</code> modules</strong>. This is why you can see <code>char</code>, <code>str</code> and integer types on both <a href="https://doc.rust-lang.org/std/#primitives">primitives</a> and <a href="https://doc.rust-lang.org/std/#modules"><code>std</code> modules</a>.</p>
<h2><a class="header" href="#primitives-1" id="primitives-1">Primitives</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Primitives: Defined by the compiler and methods are directly implemented by std
bool, char, slice, str

i8, i16, i32, i64, i128, isize
u8, u16, u32, u64, u128, usize

f32, f64

array, tuple

pointer, fn, reference
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#standard-macros" id="standard-macros">Standard Macros</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Standard Macros also defined by both compiler and std
print, println, eprint, eprintln
format, format_args
write, writeln

concat, concat_idents, stringify // concat_idents: nightly-only experimental API

include, include_bytes, include_str

assert, assert_eq, assert_ne
debug_assert, debug_assert_eq, debug_assert_ne

try, panic, compile_error, unreachable, unimplemented

file, line, column, module_path
env, option_env
cfg

select, thread_local // select: nightly-only experimental API

vec
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#std-modules" id="std-modules">Std Modules</a></h2>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// std modules
char, str

i8, i16, i32, i64, i128, isize
u8, u16, u32 ,u64, u128, usize
f32, f64
num

vec, slice, hash, heap, collections // heap: nightly-only experimental API

string, ascii, fmt

default

marker, clone, convert, cmp, iter

ops, ffi

option, result, panic, error

io
fs, path
mem, thread, sync
process, env
net
time
os

ptr, boxed, borrow, cell, any, rc

prelude

intrinsics // intrinsics: nightly-only experimental API
raw // raw: nightly-only experimental API
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>🔎 When examining <a href="https://github.com/rust-lang/rust">Rust’s source code</a>, you can see that the <a href="https://github.com/rust-lang/rust/tree/master/src"><code>src</code> directory</a> is a <strong>workspace</strong>. Even though it is having many library crates, by examining <a href="https://github.com/rust-lang/rust/blob/master/src/Cargo.toml">root <code>Cargo.toml</code></a> file you can easily identify that main crates are <strong><a href="https://github.com/rust-lang/rust/tree/master/src/rustc">rustc</a></strong>(compiler) and <strong><a href="https://github.com/rust-lang/rust/tree/master/src/libstd">libstd</a></strong> (std). In libstd/lib.rs std modules have been <strong>re-exported</strong> via <code>pub use</code> and the original location of most of the <code>std</code> modules is <a href="https://github.com/rust-lang/rust/tree/master/src/libcore"><code>src/libcore</code></a>.</p>
</blockquote>
<p><strong>Few important <code>std</code> modules are,</strong></p>
<ul>
<li><code>std::io</code> - Core <strong>I/O</strong> functionality </li>
<li><code>std::fs</code> - <strong>Filesystem</strong> specific functionality</li>
<li><code>std::path</code> - <strong>Cross-platform path</strong> specific functionality</li>
<li><code>std::env</code> - <strong>Process’s environment</strong> related functionality</li>
<li><code>std::mem</code> - <strong>Memory</strong> related functionality</li>
<li><code>std::net</code> - <strong>TCP/UDP</strong> communication</li>
<li><code>std::os</code> - <strong>OS</strong> specific functionality</li>
<li><code>std::thread</code> - Native <strong>threads</strong> specific functionality</li>
<li><code>std::collections</code> - Core <strong>Collection types</strong></li>
</ul>
<blockquote>
<p>💯 Refer <a href="https://doc.rust-lang.org/std/">Rust Standard Library Documentation</a> for more details.</p>
</blockquote>
<h2><a class="header" href="#preludes" id="preludes">Preludes</a></h2>
<p>Even though Rust <code>std</code> contains many modules, by default it doesn’t load each and everything of <code>std</code> library on every rust program. Instead, it loads only the <strong>smallest list of things which require for almost every single Rust program</strong>. These are called <strong><a href="https://doc.rust-lang.org/std/prelude/">preludes</a></strong>. They import only,</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Reexported core operators
pub use marker::{Copy, Send, Sized, Sync};
pub use ops::{Drop, Fn, FnMut, FnOnce};

// Reexported functions
pub use mem::drop;

// Reexported types and traits
pub use boxed::Box;
pub use borrow::ToOwned;
pub use clone::Clone;
pub use cmp::{PartialEq, PartialOrd, Eq, Ord};
pub use convert::{AsRef, AsMut, Into, From};
pub use default::Default;
pub use iter::{Iterator, Extend, IntoIterator};
pub use iter::{DoubleEndedIterator, ExactSizeIterator};
pub use option::Option::{self, Some, None};
pub use result::Result::{self, Ok, Err};
pub use slice::SliceConcatExt;
pub use string::{String, ToString};
pub use vec::Vec;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Preludes have been imported explicitly on <a href="https://github.com/rust-lang/rust/blob/master/src/libstd/lib.rs#L353"><code>libstd/lib.rs</code></a> and the whole list can be seen on <a href="https://github.com/rust-lang/rust/blob/master/src/libstd/prelude/v1.rs"><code>libstd/prelude/v1.rs</code></a>.</p>
</blockquote>
<p>⭐️ So technically, Rust inserts,</p>
<ul>
<li><code>extern crate std;</code> : into the <strong>crate root of every crate</strong></li>
<li><code>use std::prelude::v1::*;</code> : into <strong>every module</strong>
So you don’t need to import these each time.</li>
</ul>
<p>The concept of preludes is quite common on Rust libraries. Even some modules inside <code>std</code> crate (ex.<a href="https://github.com/rust-lang/rust/blob/master/src/libstd/io/prelude.rs"><code>std::io</code></a>) and many libraries (ex. <a href="https://github.com/diesel-rs/diesel/blob/master/diesel/src/lib.rs#L324">Diesel</a>) are having their own <code>prelude</code> modules.</p>
<p>⭐️ But <strong>preludes</strong> are used to <strong>create a single place to import all important components</strong> which are <strong>required while using the library</strong>. They <strong>do not load automatically</strong> unless you imported them manually. Only <code>std::prelude</code> imports automatically in every Rust programs.</p>
<h2><a class="header" href="#title-smart-compiler" id="title-smart-compiler">title: Smart Compiler</a></h2>
<h2><a class="header" href="#why-compiler" id="why-compiler">Why Compiler?</a></h2>
<p>The Rust compiler does the most significant job to prevent errors in Rust programs. It <strong>analyzes the code at compile-time</strong> and issues warnings, if the code does not follow memory management rules or lifetime annotations correctly. </p>
<p>For example,</p>
<pre><pre class="playpen"><code class="language-rust">#[allow(unused_variables)] //💡 A lint attribute used to suppress the warning; unused variable: `b`
fn main() {
    let a = vec![1, 2, 3];
    let b = a;

    println!(&quot;{:?}&quot;, a);
}


// ------ Compile-time error ------
error[E0382]: use of moved value: `a`
 --&gt; src/main.rs:6:22
  |
3 |     let b = a;
  |         - value moved here
4 |
5 |     println!(&quot;{:?}&quot;, a);
  |                      ^ value used here after move
  |
  = note: move occurs because `a` has type `std::vec::Vec&lt;i32&gt;`, which does not implement the `Copy` trait

error: aborting due to previous error
For more information about this error, try `rustc --explain E0382`.

// ⭐ instead using #[allow(unused_variables)], consider using &quot;let _b = a;&quot; in line 4. 
// Also you can use &quot;let _ =&quot; to completely ignore return values
</code></pre></pre>
<blockquote>
<p>💭 In the previous sections, we have discussed memory management concepts like <a href="learningrust/c1.ownership.html">ownership</a>, <a href="learningrust/c2.borrowing.html">borrowing</a>, <a href="learningrust/c3.lifetimes.html">lifetimes</a> and etc.</p>
</blockquote>
<p>Rust compiler checks not only issues related with lifetimes or memory management and also common coding mistakes, like the following code.</p>
<pre><pre class="playpen"><code class="language-rust">struct Color {
    r: u8,
    g: u8,
    b: u8,
}

fn main() {
    let yellow = Color {
        r: 255,
        g: 255,
        d: 0,
    };

    println!(&quot;Yellow = rgb({},{},{})&quot;, yellow.r, yellow.g, yellow.b);
}


// ------------ Compile-time error ------------
error[E0560]: struct `Color` has no field named `d`
  --&gt; src/main.rs:11:9
   |
11 |         d: 0,
   |         ^ field does not exist - did you mean `b`?

error: aborting due to previous error
For more information about this error, try `rustc --explain E0560`.
</code></pre></pre>
<h2><a class="header" href="#explain-error-codes" id="explain-error-codes">Explain Error Codes</a></h2>
<p>Above error messages are very descriptive and we can easily see where is the error. But while we can not identify the issue via the error message, <strong><code>rustc --explain</code></strong> commands help us <strong>to identify the error type and how to solve</strong> it, by showing <strong>simple code samples</strong> which express the same problem and the solution we have to use. </p>
<p>For example, <code>rustc --explain E0571</code> shows the following output in the console.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>A `break` statement with an argument appeared in a non-`loop` loop.

Example of erroneous code:
｀｀｀
let result = while true {
    if satisfied(i) {
        break 2*i; // error: `break` with value from a `while` loop
    }
    i += 1;
};
｀｀｀

The `break` statement can take an argument (which will be the value of the loop
expression if the `break` statement is executed) in `loop` loops, but not
`for`, `while`, or `while let` loops.

Make sure `break value;` statements only occur in `loop` loops:
｀｀｀
let result = loop { // ok!
    if satisfied(i) {
        break 2*i;
    }
    i += 1;
};
｀｀｀
<span class="boring">}
</span></code></pre></pre>
<p>💡 Also you can read the same explanations via <a href="https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Ferror-index.html">Rust Compiler Error Index</a>. For example to check the explanation of <code>E0571</code> error, you can use https://doc.rust-lang.org/error-index.html#E0571.</p>
<h2><a class="header" href="#title-panicking" id="title-panicking">title: Panicking</a></h2>
<h2><a class="header" href="#panic-2" id="panic-2">panic!()</a></h2>
<ul>
<li>In some cases, while an error happens we can not do anything to handle it, <strong>if the error is something, which should not be happened</strong>. In other words, if it’s an <strong>unrecoverable error</strong>.</li>
<li>Also <strong>when we are not using a feature-rich debugger or proper logs</strong>, sometimes we need to <strong>debug the code by quitting the program from a specific line of code</strong> by printing out a specific message or a value of a variable binding to understand the current flow of the program.
For above cases, we can use <code>panic!</code> macro.</li>
</ul>
<p>⭐ <code>panic!()</code> runs <strong>thread based</strong>. One thread can be panicked, while other threads are running.</p>
<h3><a class="header" href="#01-quit-from-a-specific-line" id="01-quit-from-a-specific-line">01. Quit from a specific line.</a></h3>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // some code

    // if we need to debug in here
    panic!();
}

// -------------- Compile-time error --------------
thread 'main' panicked at 'explicit panic', src/main.rs:5:5
</code></pre></pre>
<h3><a class="header" href="#02-quit-with-a-custom-error-message" id="02-quit-with-a-custom-error-message">02. Quit with a custom error message.</a></h3>
<pre><pre class="playpen"><code class="language-rust">#[allow(unused_mut)] // 💡 A lint attribute used to suppress the warning; username variable does not need to be mutable
fn main() {
    let mut username = String::new();

    // some code to get the name
  
    if username.is_empty() {
        panic!(&quot;Username is empty!&quot;);
    }

    println!(&quot;{}&quot;, username);
}

// -------------- Compile-time error --------------
thread 'main' panicked at 'Username is empty!', src/main.rs:8:9
</code></pre></pre>
<h3><a class="header" href="#03-quit-with-the-value-of-code-elements" id="03-quit-with-the-value-of-code-elements">03. Quit with the value of code elements.</a></h3>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)] // 💡 A lint attribute which use to implement `std::fmt::Debug` to Color
struct Color {
    r: u8,
    g: u8,
    b: u8,
}

#[allow(unreachable_code)] // 💡 A lint attribute used to suppress the warning; unreachable statement
fn main() {
    let some_color: Color;
    
    // some code to get the color. ex
    some_color = Color {r: 255, g: 255, b: 0};

    // if we need to debug in here
    panic!(&quot;{:?}&quot;, some_color);

    println!(
        &quot;The color = rgb({},{},{})&quot;,
        some_color.r, some_color.g, some_color.b
    );
}

// -------------- Compile-time error --------------
thread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:16:5
</code></pre></pre>
<p>As you can see in the above examples <code>panic!()</code> supports <a href="learningrust/a3.hello_world.html#Usages-of-println"><code>println!()</code> type style arguments</a>. By default, it prints the <strong>error message, file path and line &amp; column numbers</strong> where the error happens.</p>
<h2><a class="header" href="#unimplemented" id="unimplemented">unimplemented!()</a></h2>
<p>💡 If your code is having <strong>unfinished code sections</strong>, there is a standardized macro as <code>unimplemented!()</code> to mark those routes. The program will be panicked with a <strong>“not yet implemented”</strong> error message, if the program runs through those routes.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// error messages with panic!()
thread 'main' panicked at 'explicit panic', src/main.rs:6:5
thread 'main' panicked at 'Username is empty!', src/main.rs:9:9
thread 'main' panicked at 'Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5

// error messages with unimplemented!()
thread 'main' panicked at 'not yet implemented', src/main.rs:6:5
thread 'main' panicked at 'not yet implemented: Username is empty!', src/main.rs:9:9
thread 'main' panicked at 'not yet implemented: Color { r: 255, g: 255, b: 0 }', src/main.rs:17:5
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#unreachable" id="unreachable">unreachable!()</a></h2>
<p>This is the standard macro to mark <strong>routes that the program should not enter</strong>. The program will be panicked with a <strong>“'internal error: entered unreachable code'”</strong> error message, if the program entered those routes.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let level = 22;
    let stage = match level {
        1...5 =&gt; &quot;beginner&quot;,
        6...10 =&gt; &quot;intermediate&quot;,
        11...20 =&gt; &quot;expert&quot;,
        _ =&gt; unreachable!(),
    };
    
    println!(&quot;{}&quot;, stage);
}


// -------------- Compile-time error --------------
thread 'main' panicked at 'internal error: entered unreachable code', src/main.rs:7:20
</code></pre></pre>
<p>We can set custom error messages for this as well.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// --- with a custom message ---
_ =&gt; unreachable!(&quot;Custom message&quot;),
// -------------- Compile-time error --------------
thread 'main' panicked at 'internal error: entered unreachable code: Custom message', src/main.rs:7:20


// --- with debug data ---
_ =&gt; unreachable!(&quot;level is {}&quot;, level),
// -------------- Compile-time error --------------
thread 'main' panicked at 'internal error: entered unreachable code: level is 22', src/main.rs:7:14
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#assert-assert_eq-assert_ne" id="assert-assert_eq-assert_ne">assert!(), assert_eq!(), assert_ne!()</a></h2>
<p>These are standard macros which usually use with test assertions.</p>
<ul>
<li><code>assert!()</code> ensures that a boolean expression is true. It panics if the expression is false.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let f = false;
    
    assert!(f)
}


// -------------- Compile-time error --------------
thread 'main' panicked at 'assertion failed: f', src/main.rs:4:5
</code></pre></pre>
<ul>
<li><code>assert_eq!()</code> ensures that two expressions are equal. It panics if the expressions are not equal.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = 10;
    let b = 20;
    
    assert_eq!(a, b);
}


// -------------- Compile-time error --------------
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `10`,
 right: `20`', src/main.rs:5:5
</code></pre></pre>
<ul>
<li><code>assert_ne!()</code> ensures that two expressions are not equal. It panics if the expressions are equal.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = 10;
    let b = 10;
    
    assert_ne!(a, b);
}


// -------------- Compile-time error --------------
thread 'main' panicked at 'assertion failed: `(left != right)`
  left: `10`,
 right: `10`', src/main.rs:5:5
</code></pre></pre>
<blockquote>
<p>⭐ Expressions which use with <code>assert_eq!()</code> and <code>assert_ne!()</code> should return same data type.</p>
</blockquote>
<p>We can set custom error messages for these macros as well. For examples,</p>
<ol>
<li>With a custom message for <code>assert_eq!()</code></li>
</ol>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = 10;
    let b = 20;
    
    assert_eq!(a, b, &quot;a and b should be equal&quot;);
}


// -------------- Compile-time error --------------
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `10`,
 right: `20`: a and b should be equal', src/main.rs:5:5
</code></pre></pre>
<ol start="2">
<li><code>assert_eq!()</code> with debug data</li>
</ol>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = 10;
    let b = 20;

    let c = 40;
    
    assert_eq!(a+b, c, &quot;a = {} ; b = {}&quot;, a, b);
}

// -------------- Compile-time error --------------
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `30`,
 right: `40`: a = 10 ; b = 20', src/main.rs:7:5
</code></pre></pre>
<h2><a class="header" href="#debug_assert-debug_assert_eq-debug_assert_ne" id="debug_assert-debug_assert_eq-debug_assert_ne">debug_assert!(), debug_assert_eq!(), debug_assert_ne!()</a></h2>
<p>🔎 These are similar to above <code>assert</code> macros. But these statements are only enabled in non optimized builds by default. All these <code>debug_assert</code> macros will be omitted in release builds, unless we pass <code>-C debug-assertions</code> to the compiler.</p>
<h2><a class="header" href="#title-option-and-result" id="title-option-and-result">title: Option and Result</a></h2>
<h2><a class="header" href="#why-option-and-result" id="why-option-and-result">Why Option and Result?</a></h2>
<p>Many languages use <strong><code>null</code>\ <code>nil</code>\ <code>undefined</code> types</strong> to represent empty outputs, and <strong><code>Exceptions</code></strong> to handle errors. Rust skips using both, especially to prevent issues like <strong>null pointer exceptions, sensitive data leakages through exceptions</strong> and etc. Instead, Rust provides two special <strong>generic enums</strong>;<code>Option</code> and <code>Result</code> to deal with above cases.</p>
<blockquote>
<p>💭 In the previous sections, we have discussed about the basics of <a href="learningrust/b3.enums.html">enums</a>, <a href="learningrust/b4.generics.html">generics</a> and <a href="learningrust/b4.generics.html#Generalizing-enums"><code>Result</code> &amp; <code>Option</code> types</a>.</p>
</blockquote>
<p>As you know,</p>
<ul>
<li>An <strong>optional value</strong> can have either <strong>Some</strong> value or no value/ <strong>None</strong>.</li>
<li>A <strong>result</strong> can represent either success/ <strong>Ok</strong> or failure/ <strong>Err</strong></li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// An output can have either Some value or no value/ None.
enum Option&lt;T&gt; { // T is a generic and it can contain any type of value.
    Some(T),
    None,
}

// A result can represent either success/ Ok or failure/ Err.
enum Result&lt;T, E&gt; { // T and E are generics. T can contain any type of value, E can be any error.
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>💭 Also as we discussed in <a href="learningrust/d7.std_primitives_and_preludes.html#Preludes">preludes</a>, not only <code>Option</code> and <code>Result</code>, and also their variants are in preludes. So, we can use them directly without using namespaces in the code.</p>
<h2><a class="header" href="#basic-usages-of-option" id="basic-usages-of-option">Basic usages of Option</a></h2>
<p>When writing a function or data type, </p>
<ul>
<li>if an <strong>argument</strong> of the function is optional,</li>
<li>If the function is non-void and if the output it <strong>returns</strong> can be empty,</li>
<li>If the value, of a <strong>property of the data type</strong> can be empty,
We have to use their data type as an <code>Option</code> type</li>
</ul>
<p>For example, if the function outputs a <code>&amp;str</code> value and the output can be empty, the return type of the function should set as <code>Option&lt;&amp;str&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn get_an_optional_value() -&gt; Option&lt;&amp;str&gt; {

    //if the optional value is not empty
    return Some(&quot;Some value&quot;);
    
    //else
    None
}
<span class="boring">}
</span></code></pre></pre>
<p>Same way, if the value of a property of a data type can be empty or optional like the <code>middle_name</code> of <code>Name</code> data type in the following example, we should set its data type as an <code>Option</code> type.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Name {
  first_name: String,
  middle_name: Option&lt;String&gt;, // middle_name can be empty
  last_name: String,
}
<span class="boring">}
</span></code></pre></pre>
<p>💭 As you know, we can use pattern matching to catch the relevant return type (<code>Some</code>/ <code>None</code>) via <code>match</code>. There is a function to get the current user’s home directory in <strong><code>std::env</code></strong> as <strong><a href="https://doc.rust-lang.org/std/env/fn.home_dir.html"><code>home_dir()</code></a></strong>. Because of all users doesn’t have a home directory in the systems like Linux, home directory of the user can be optional. So it returns an <code>Option</code> type; <a href="https://doc.rust-lang.org/std/path/struct.PathBuf.html"><code>Option&lt;PathBuf&gt;</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let home_path = env::home_dir();
    match home_path {
        Some(p) =&gt; println!(&quot;{:?}&quot;, p), // This prints &quot;/root&quot;, if you run this in Rust playground
        None =&gt; println!(&quot;Can not find the home directory!&quot;),
    }
}
</code></pre></pre>
<p>⭐ However, when using optional arguments with functions, we have to pass <code>None</code> values for empty arguments while calling the function.</p>
<pre><pre class="playpen"><code class="language-rust">fn get_full_name(fname: &amp;str, lname: &amp;str, mname: Option&lt;&amp;str&gt;) -&gt; String { // middle name can be empty
  match mname {
    Some(n) =&gt; format!(&quot;{} {} {}&quot;, fname, n, lname),
    None =&gt; format!(&quot;{} {}&quot;, fname, lname),
  }
}

fn main() {
  println!(&quot;{}&quot;, get_full_name(&quot;Galileo&quot;, &quot;Galilei&quot;, None));
  println!(&quot;{}&quot;, get_full_name(&quot;Leonardo&quot;, &quot;Vinci&quot;, Some(&quot;Da&quot;)));
}

// 💡 Better create a struct as Person with fname, lname, mname fields and create a impl function as full_name()
</code></pre></pre>
<p>🔎 Other than that, <code>Option</code> types are used with <strong>nullable pointers</strong> in Rust. Because of there is <strong>no null pointers in Rust</strong>, the pointer types should point to a valid location. So if a pointer can be nullable, we have use <code>Option&lt;Box&lt;T&gt;&gt;</code> .</p>
<h2><a class="header" href="#basic-usages-of-result" id="basic-usages-of-result">Basic usages of Result</a></h2>
<p>If a function can produce an error, we have to use a <code>Result</code> type by <strong>combining the data type of the valid output and the data type of the error</strong>. For example, if the data type of the valid output is <code>u64</code> and error type is <code>String</code>, return type should be <code>Result&lt;u64, String&gt;</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn function_with_error() -&gt; Result&lt;u64, String&gt; {
  
    //if error happens
    return Err(&quot;The error message&quot;.to_string());

    // else, return valid output
    Ok(255)
}
<span class="boring">}
</span></code></pre></pre>
<p>💭 As you know, we can use the pattern matching to catch the relevant return types (<code>Ok</code>/<code>Err</code>) via <code>match</code>. There is a function to fetch the value of any environment variable in <strong><code>std::env</code></strong> as <strong><a href="https://doc.rust-lang.org/std/env/fn.var.html"><code>var()</code></a></strong> . Its input is the environment variable name. This can produce an error, if we passes a wrong environment variable or the program can not extract the value of the environment variable while running. So, its return type is a <code>Result</code> type; <a href="https://doc.rust-lang.org/std/env/enum.VarError.html"><code>Result&lt;String, VarError&gt;</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">use std::env;

fn main() {
    let key = &quot;HOME&quot;;
    match env::var(key) {
        Ok(v) =&gt; println!(&quot;{}&quot;, v), // This prints &quot;/root&quot;, if you run this in Rust playground
        Err(e) =&gt; println!(&quot;{}&quot;, e), // This prints &quot;environment variable not found&quot;, if you give a nonexistent environment variable
    }
}
</code></pre></pre>
<h2><a class="header" href="#is_some-is_none-is_ok-is_err" id="is_some-is_none-is_ok-is_err">is_some(), is_none(), is_ok(), is_err()</a></h2>
<p>Other than <code>match</code> expressions, Rust provides <code>is_some()</code> , <code>is_none()</code> and <code>is_ok()</code> , <code>is_err()</code> functions to identify the return type.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: Option&lt;&amp;str&gt; = Some(&quot;Hello, world!&quot;);
    assert_eq!(x.is_some(), true);
    assert_eq!(x.is_none(), false);

    let y: Result&lt;i8, &amp;str&gt; = Ok(10);
    assert_eq!(y.is_ok(), true);
    assert_eq!(y.is_err(), false);
}
</code></pre></pre>
<h2><a class="header" href="#ok-err-for-result-types" id="ok-err-for-result-types">ok(), err() for Result types</a></h2>
<p>In addition to that Rust provides <code>ok()</code> and <code>err()</code> for <code>Result</code> types. They convert the <code>Ok&lt;T&gt;</code> and <code>Err&lt;E&gt;</code> values of a <strong><code>Result</code> type to <code>Option</code> types</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let o: Result&lt;i8, &amp;str&gt; = Ok(8);
    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;message&quot;);
    
    assert_eq!(o.ok(), Some(8)); // Ok(v) ok = Some(v)
    assert_eq!(e.ok(), None);    // Err(v) ok = None
    
    assert_eq!(o.err(), None);            // Ok(v) err = None
    assert_eq!(e.err(), Some(&quot;message&quot;)); // Err(v) err = Some(v)
}
</code></pre></pre>
<h2><a class="header" href="#title-unwrap-and-expect" id="title-unwrap-and-expect">title: Unwrap and Expect</a></h2>
<h2><a class="header" href="#unwrap" id="unwrap">unwrap()</a></h2>
<ul>
<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>
<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>program panics</strong>; If <code>Err</code>, panics with the error message.</li>
</ul>
<p>The functionality is bit similar to the following codes, which are using <code>match</code> instead <code>unwrap()</code>.</p>
<p>Example with <code>Option</code> and <code>match</code>, before using <code>unwrap()</code></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x;
    match get_an_optional_value() {
        Some(v) =&gt; x = v, // if Some(&quot;abc&quot;), set x to &quot;abc&quot;
        None =&gt; panic!(), // if None, panic without any message
    }

    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 14 `false` to `true`
}

fn get_an_optional_value() -&gt; Option&lt;&amp;'static str&gt; {

    //if the optional value is not empty
    if false {
        return Some(&quot;abc&quot;);
    }
    
    //else
    None
}


// --------------- Compile-time error ---------------
thread 'main' panicked at 'explicit panic', src/main.rs:5:17
</code></pre></pre>
<p>Example with <code>Result</code> and <code>match</code>, before using <code>unwrap()</code></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x;
    match function_with_error() {
        Ok(v) =&gt; x = v, // if Ok(255), set x to 255
        Err(e) =&gt; panic!(e), // if Err(&quot;some message&quot;), panic with error message &quot;some message&quot;
    }

    println!(&quot;{}&quot;, x); // 255 ; if you change line 13 `true` to `false`
}

fn function_with_error() -&gt; Result&lt;u64, String&gt; {
    //if error happens
    if true {
        return Err(&quot;some message&quot;.to_string());
    }

    // else, return valid output
    Ok(255)
}


// ---------- Compile-time error ----------
thread 'main' panicked at 'some message', src/main.rs:5:19
</code></pre></pre>
<p>Same codes in above <code>main</code> functions can be written with <code>unwrap()</code> using two lines.</p>
<pre><pre class="playpen"><code class="language-rust">// 01. unwrap error message for None
fn main() {
    let x = get_an_optional_value().unwrap();

    println!(&quot;{}&quot;, x);
}

// --------------- Compile-time error ---------------
thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', libcore/option.rs:345:21


// 02. unwrap error message for Err
fn main() {
    let x = function_with_error().unwrap();

    println!(&quot;{}&quot;, x);
}

// --------------- Compile-time error ---------------
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: &quot;some message&quot;', libcore/result.rs:945:5
</code></pre></pre>
<p>⭐ But as you can see, when using <code>unwrap()</code> error messages are not showing the exact line numbers where the panic happens.</p>
<h2><a class="header" href="#expect" id="expect">expect()</a></h2>
<p>Similar to <code>unwrap()</code> but can set a custom message for the panics.</p>
<pre><pre class="playpen"><code class="language-rust">// 01. expect error message for None
fn main() {
    let n: Option&lt;i8&gt; = None;
    
    n.expect(&quot;empty value returned&quot;);
}

// --------------- Compile-time error ---------------
thread 'main' panicked at 'empty value returned', libcore/option.rs:989:5


// 02. expect error message for Err
fn main() {
    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;some message&quot;);

    e.expect(&quot;expect error message&quot;);
}

// --------------- Compile-time error ---------------
thread 'main' panicked at 'expect error message: &quot;some message&quot;', libcore/result.rs:945:5
</code></pre></pre>
<h2><a class="header" href="#unwrap_err-and-expect_err-for-result-types" id="unwrap_err-and-expect_err-for-result-types">unwrap_err() and expect_err() for Result types</a></h2>
<p>The opposite case of <code>unwrap()</code> and <code>expect()</code>; Panics with <code>Ok</code> values, instead <code>Err</code>. Both print the value inside <code>Ok</code> on the error message.</p>
<p>💡 Usually use with tests.</p>
<pre><pre class="playpen"><code class="language-rust">// 01. unwrap_err error message for Ok
fn main() {
    let o: Result&lt;i8, &amp;str&gt; = Ok(8);

    o.unwrap_err();
}

// ---------- Compile-time error ----------
thread 'main' panicked at 'called `Result::unwrap_err()` on an `Ok` value: 8', libcore/result.rs:945:5


// 02. expect_err error message for Ok
fn main() {
    let o: Result&lt;i8, &amp;str&gt; = Ok(8);

    o.expect_err(&quot;Should not get Ok value&quot;);
}

// ---------- Compile-time error ----------
thread 'main' panicked at 'Should not get Ok value: 8', libcore/result.rs:945:5
</code></pre></pre>
<h2><a class="header" href="#unwrap_or-unwrap_or_default-and-unwrap_or_else" id="unwrap_or-unwrap_or_default-and-unwrap_or_else">unwrap_or(), unwrap_or_default() and unwrap_or_else()</a></h2>
<blockquote>
<p>💡 These are bit similar to <code>unwrap()</code>, If an <code>Option</code> type has <code>Some</code> value or a <code>Result</code> type has a <code>Ok</code> value, the value inside them passes to the next step. But when having <code>None</code> or <code>Err</code>, the functionalities are bit different.</p>
</blockquote>
<ul>
<li><code>unwrap_or()</code> : With <code>None</code> or <code>Err</code>, <strong>the value you passes to <code>unwrap_or()</code></strong> is passing to the next step. But the data type of the value you passes  should match with the data type of the relevant <code>Some</code> or <code>Ok</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let v1 = 8;
    let v2 = 16;

    let s_v1 = Some(8);
    let n = None;

    assert_eq!(s_v1.unwrap_or(v2), v1); // Some(v1) unwrap_or v2 = v1
    assert_eq!(n.unwrap_or(v2), v2);    // None unwrap_or v2 = v2

    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);
    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);

    assert_eq!(o_v1.unwrap_or(v2), v1); // Ok(v1) unwrap_or v2 = v1
    assert_eq!(e.unwrap_or(v2), v2);    // Err unwrap_or v2 = v2
}
</code></pre></pre>
<ul>
<li><code>unwrap_or_default()</code> :  With <code>None</code> or <code>Err</code>, <strong>the default value of the data type of the relevant <code>Some</code> or <code>Ok</code></strong>, is passing to the next step.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let v = 8;
    let v_default = 0;

    let s_v: Option&lt;i8&gt; = Some(8);
    let n: Option&lt;i8&gt; = None;

    assert_eq!(s_v.unwrap_or_default(), v);       // Some(v) unwrap_or_default = v
    assert_eq!(n.unwrap_or_default(), v_default); // None unwrap_or_default = default value of v

    let o_v: Result&lt;i8, &amp;str&gt; = Ok(8);
    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);

    assert_eq!(o_v.unwrap_or_default(), v);       // Ok(v) unwrap_or_default = v
    assert_eq!(e.unwrap_or_default(), v_default); // Err unwrap_or_default = default value of v
}
</code></pre></pre>
<ul>
<li><code>unwrap_or_else()</code> : Similar to <code>unwrap_or()</code>. The only difference is, instead of passing a value, you have to pass a <strong><a href="learningrust/a7.functions.html#Closures">closure</a></strong> which returns a value with the same data type of the relevant <code>Some</code> or <code>Ok</code>.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let v1 = 8;
    let v2 = 16;

    let s_v1 = Some(8);
    let n = None;
    let fn_v2_for_option = || 16;

    assert_eq!(s_v1.unwrap_or_else(fn_v2_for_option), v1); // Some(v1) unwrap_or_else fn_v2 = v1
    assert_eq!(n.unwrap_or_else(fn_v2_for_option), v2);    // None unwrap_or_else fn_v2 = v2

    let o_v1: Result&lt;i8, &amp;str&gt; = Ok(8);
    let e: Result&lt;i8, &amp;str&gt; = Err(&quot;error&quot;);
    let fn_v2_for_result = |_| 16;

    assert_eq!(o_v1.unwrap_or_else(fn_v2_for_result), v1); // Ok(v1) unwrap_or_else fn_v2 = v1
    assert_eq!(e.unwrap_or_else(fn_v2_for_result), v2);    // Err unwrap_or_else fn_v2 = v2
}
</code></pre></pre>
<h2><a class="header" href="#title-error-and-none-propagation" id="title-error-and-none-propagation">title: Error and None Propagation</a></h2>
<p>We should use panics like <code>panic!()</code>, <code>unwrap()</code>, <code>expect()</code> only if we can not handle the situation in a better way. Also if a function contains expressions which can produce either <code>None</code> or <code>Err</code>, </p>
<ul>
<li>we can handle them inside the same function. Or,</li>
<li>we can return <code>None</code> and <code>Err</code> types immediately to the caller. So the caller can decide how to handle them.</li>
</ul>
<p>💡 <code>None</code> types no need to handle by the caller of the function always. But Rusts’ convention to handle <strong><code>Err</code></strong> types is, <strong>return them immediately to the caller to give more control to the caller to decide how to handle them.</strong></p>
<h2><a class="header" href="#-operator" id="-operator">? Operator</a></h2>
<ul>
<li>If an <code>Option</code> type has <strong><code>Some</code></strong> value or a <code>Result</code> type has a <strong><code>Ok</code></strong> value, <strong>the value inside them</strong> passes to the next step.</li>
<li>If the <code>Option</code> type has <strong><code>None</code></strong> value or the <code>Result</code> type has <strong><code>Err</code></strong> value, <strong>return them immediately</strong> to the caller of the function.</li>
</ul>
<p>Example with <code>Option</code> type,</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    if complex_function().is_none() {
        println!(&quot;X not exists!&quot;);
    }
}

fn complex_function() -&gt; Option&lt;&amp;'static str&gt; {
    let x = get_an_optional_value()?; // if None, returns immidiately; if Some(&quot;abc&quot;), set x to &quot;abc&quot;

    // some other code, ex
    println!(&quot;{}&quot;, x); // &quot;abc&quot; ; if you change line 19 `false` to `true` 

    Some(&quot;&quot;)
}

fn get_an_optional_value() -&gt; Option&lt;&amp;'static str&gt; {

    //if the optional value is not empty
    if false {
        return Some(&quot;abc&quot;);
    }
    
    //else
    None
}
</code></pre></pre>
<p>Example with <code>Result</code> Type,</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // `main` function is the caller of `complex_function` function
    // So we handle errors of complex_function(), inside main()
    if complex_function().is_err() {
        println!(&quot;Can not calculate X!&quot;);
    }
}

fn complex_function() -&gt; Result&lt;u64, String&gt; {
    let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255

    // some other code, ex
    println!(&quot;{}&quot;, x); // 255 ; if you change line 20 `true` to `false`

    Ok(0)
}

fn function_with_error() -&gt; Result&lt;u64, String&gt; {
    //if error happens
    if true {
        return Err(&quot;some message&quot;.to_string());
    }

    // else, return valid output
    Ok(255)
}
</code></pre></pre>
<h2><a class="header" href="#try-1" id="try-1">try!()</a></h2>
<p>⭐ <code>?</code> operator was added in Rust version 1.13. <code>try!()</code> macro is the old way to propagate errors before that. So we <strong>should avoid</strong> using this now.</p>
<ul>
<li>If a <code>Result</code> type has <strong><code>Ok</code></strong> value, <strong>the value inside it</strong> passes to the next step. If it has <strong><code>Err</code></strong> value, <strong>returns it immediately</strong> to the caller of the function.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// using `?`
let x = function_with_error()?; // if Err, returns immidiately; if Ok(255), set x to 255

// using `try!()`
let x = try!(function_with_error());
<span class="boring">}
</span></code></pre></pre>
<h2><a class="header" href="#error-propagation-from-main" id="error-propagation-from-main">Error propagation from main()</a></h2>
<p>Before Rust version 1.26, we couldn't propagate <code>Result</code> and <code>Option</code> types from the <code>main()</code> function. But now, we <strong>can propagate <code>Result</code> types</strong> from the <code>main()</code> function and it prints the <strong><code>Debug</code> representation of the <code>Err</code></strong>.</p>
<p>💡 We are going to discuss about <code>Debug</code> representations under <a href="learningrust/e7.custom_error_types.html#Error-trait">Error trait section</a>.</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() -&gt; std::io::Result&lt;()&gt; {
    let _ = File::open(&quot;not-existing-file.txt&quot;)?;

    Ok(()) // Because of the default return value of Rust functions is an empty tuple/ ()
}

// Because of the program can not find not-existing-file.txt , it produces,
//    Err(Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; })
// While propagating error, the program prints,
//    Error: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }
</code></pre></pre>
<blockquote>
<p>💯 If you want to know about the all kind of errors <code>std::fs::File::open()</code> can produce, check the <a href="https://doc.rust-lang.org/std/fs/struct.OpenOptions.html#errors">error list on <code>std::fs::OpenOptions</code></a>.</p>
</blockquote>
<h2><a class="header" href="#title-combinators" id="title-combinators">title: Combinators</a></h2>
<h2><a class="header" href="#what-is-a-combinator" id="what-is-a-combinator">What is a combinator?</a></h2>
<ul>
<li>
<p>One meaning of “combinator” is a more informal sense referring to the <strong>combinator pattern</strong>, a style of organizing libraries centered around the idea of combining things. Usually there is <strong>some type T</strong>, some <strong>functions for constructing “primitive” values of type T</strong>, and some “<strong>combinators</strong>” which can <strong>combine values of type T</strong> in various ways to <strong>build up more complex values of type T</strong>. The other definition is <strong>&quot;function with no free variables&quot;</strong>.
__ <a href="https://wiki.haskell.org/Combinator">wiki.haskell.org</a></p>
</li>
<li>
<p>A combinator is <strong>a function</strong> which <strong>builds program fragments from program fragments</strong>; in a sense the programmer using combinators constructs much of the desired program automatically, rather that writing every detail by hand. 
__ John Hughes—<a href="http://www.cse.chalmers.se/%7Erjmh/Papers/arrows.pdf">Generalizing Monads to Arrows</a> via <a href="https://github.com/caiorss/Functional-Programming/blob/master/haskell/Functional_Programming_Concepts.org">Functional Programming Concepts</a></p>
</li>
</ul>
<p>The exact definition of &quot;combinators&quot; in Rust ecosystem is bit unclear. </p>
<ul>
<li>
<p><code>or()</code>, <code>and()</code>, <code>or_else()</code>, <code>and_then()</code> 
▸ <strong>Combine two values of type T</strong> and <strong>return same type T</strong>.</p>
</li>
<li>
<p><code>filter()</code> for <code>Option</code> types
▸ <strong>Filter type T</strong> by using a closure as a conditional function
▸ <strong>Return same type T</strong></p>
</li>
<li>
<p><code>map()</code>, <code>map_err()</code> 
▸ <strong>Convert type T by applying a closure</strong>. 
▸ The <strong>data type of the value inside T can be changed</strong>. 
ex. <code>Some&lt;&amp;str&gt;</code> can be converted to <code>Some&lt;usize&gt;</code> or <code>Err&lt;&amp;str&gt;</code> to <code>Err&lt;isize&gt;</code> and etc.</p>
</li>
<li>
<p><code>map_or()</code>, <code>map_or_else()</code>
▸ <strong>Transform type T by applying a closure</strong> &amp; <strong>return the value inside type T</strong>.
▸ For <strong><code>None</code> and <code>Err</code>, a default value or another closure</strong> is applied.</p>
</li>
<li>
<p><code>ok_or()</code>, <code>ok_or_else()</code> for <code>Option</code> types
▸ <strong>Transform <code>Option</code> type into a <code>Result</code> type</strong>.</p>
</li>
<li>
<p><code>as_ref()</code>, <code>as_mut()</code> 
▸ <strong>Transform type T into a reference or a mutable reference</strong>.</p>
</li>
</ul>
<h2><a class="header" href="#or-and-and" id="or-and-and">or() and and()</a></h2>
<p>While combining two expressions, which return either <code>Option</code>/ <code>Result</code></p>
<ul>
<li><code>or()</code>: If either one got <code>Some</code> or <code>Ok</code>, that value returns immediately.</li>
<li><code>and()</code>: If both got <code>Some</code> or <code>Ok</code>, the value in the second expression returns. If either one got <code>None</code> or <code>Err</code> that value returns immediately.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
  let s1 = Some(&quot;some1&quot;);
  let s2 = Some(&quot;some2&quot;);
  let n: Option&lt;&amp;str&gt; = None;

  let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);
  let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);
  let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);
  let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);

  assert_eq!(s1.or(s2), s1); // Some1 or Some2 = Some1
  assert_eq!(s1.or(n), s1);  // Some or None = Some
  assert_eq!(n.or(s1), s1);  // None or Some = Some
  assert_eq!(n.or(n), n);    // None1 or None2 = None2

  assert_eq!(o1.or(o2), o1); // Ok1 or Ok2 = Ok1
  assert_eq!(o1.or(e1), o1); // Ok or Err = Ok
  assert_eq!(e1.or(o1), o1); // Err or Ok = Ok
  assert_eq!(e1.or(e2), e2); // Err1 or Err2 = Err2

  assert_eq!(s1.and(s2), s2); // Some1 and Some2 = Some2
  assert_eq!(s1.and(n), n);   // Some and None = None
  assert_eq!(n.and(s1), n);   // None and Some = None
  assert_eq!(n.and(n), n);    // None1 and None2 = None1
  
  assert_eq!(o1.and(o2), o2); // Ok1 and Ok2 = Ok2
  assert_eq!(o1.and(e1), e1); // Ok and Err = Err
  assert_eq!(e1.and(o1), e1); // Err and Ok = Err
  assert_eq!(e1.and(e2), e1); // Err1 and Err2 = Err1
}
</code></pre></pre>
<blockquote>
<p>🔎 Rust nightly support <a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.xor"><code>xor()</code></a> for <code>Option</code> types, which returns <code>Some</code> only if one expression got <code>Some</code>, but not both.</p>
</blockquote>
<h2><a class="header" href="#or_else" id="or_else">or_else()</a></h2>
<p>Similar to <code>or()</code>. The only difference is, the second expression should be a <strong><a href="learningrust/a7.functions.html#Closures">closure</a></strong> which returns same type T.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // or_else with Option
    let s1 = Some(&quot;some1&quot;);
    let s2 = Some(&quot;some2&quot;);
    let fn_some = || Some(&quot;some2&quot;); // similar to: let fn_some = || -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };

    let n: Option&lt;&amp;str&gt; = None;
    let fn_none = || None;

    assert_eq!(s1.or_else(fn_some), s1);  // Some1 or_else Some2 = Some1
    assert_eq!(s1.or_else(fn_none), s1);  // Some or_else None = Some
    assert_eq!(n.or_else(fn_some), s2);   // None or_else Some = Some
    assert_eq!(n.or_else(fn_none), None); // None1 or_else None2 = None2

    // or_else with Result
    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);
    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);
    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };

    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);
    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);
    let fn_err = |_| Err(&quot;error2&quot;);

    assert_eq!(o1.or_else(fn_ok), o1);  // Ok1 or_else Ok2 = Ok1
    assert_eq!(o1.or_else(fn_err), o1); // Ok or_else Err = Ok
    assert_eq!(e1.or_else(fn_ok), o2);  // Err or_else Ok = Ok
    assert_eq!(e1.or_else(fn_err), e2); // Err1 or_else Err2 = Err2
}
</code></pre></pre>
<h2><a class="header" href="#and_then" id="and_then">and_then()</a></h2>
<p>Similar to <code>and()</code>. The only difference is, the second expression should be a <strong><a href="learningrust/a7.functions.html#Closures">closure</a></strong> which returns same type T.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // and_then with Option
    let s1 = Some(&quot;some1&quot;);
    let s2 = Some(&quot;some2&quot;);
    let fn_some = |_| Some(&quot;some2&quot;); // similar to: let fn_some = |_| -&gt; Option&lt;&amp;str&gt; { Some(&quot;some2&quot;) };

    let n: Option&lt;&amp;str&gt; = None;
    let fn_none = |_| None;

    assert_eq!(s1.and_then(fn_some), s2); // Some1 and_then Some2 = Some2
    assert_eq!(s1.and_then(fn_none), n);  // Some and_then None = None
    assert_eq!(n.and_then(fn_some), n);   // None and_then Some = None
    assert_eq!(n.and_then(fn_none), n);   // None1 and_then None2 = None1

    // and_then with Result
    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok1&quot;);
    let o2: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;ok2&quot;);
    let fn_ok = |_| Ok(&quot;ok2&quot;); // similar to: let fn_ok = |_| -&gt; Result&lt;&amp;str, &amp;str&gt; { Ok(&quot;ok2&quot;) };

    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error1&quot;);
    let e2: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error2&quot;);
    let fn_err = |_| Err(&quot;error2&quot;);

    assert_eq!(o1.and_then(fn_ok), o2);  // Ok1 and_then Ok2 = Ok2
    assert_eq!(o1.and_then(fn_err), e2); // Ok and_then Err = Err
    assert_eq!(e1.and_then(fn_ok), e1);  // Err and_then Ok = Err
    assert_eq!(e1.and_then(fn_err), e1); // Err1 and_then Err2 = Err1
}
</code></pre></pre>
<h2><a class="header" href="#filter" id="filter">filter()</a></h2>
<blockquote>
<p>💡 Usually in programming languages <code>filter</code> functions are used with arrays or iterators to create a new array/ iterator by filtering own elements via a function/ closure. Rust also provides <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>filter()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>filter()</code> with <code>Option</code> types.</p>
</blockquote>
<p>The same <code>Some</code> type is returned, only if we pass a <code>Some</code> value and the given closure returned true for it. <code>None</code> is returned, if <code>None</code> type passed or the closure returned false. The closure uses the value inside <code>Some</code> as an argument. Still Rust support <code>filter()</code> only for <code>Option</code> types.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = Some(3);
    let s2 = Some(6);
    let n = None;

    let fn_is_even = |x: &amp;i8| x % 2 == 0;

    assert_eq!(s1.filter(fn_is_even), n);  // Some(3) -&gt; 3 is not even -&gt; None
    assert_eq!(s2.filter(fn_is_even), s2); // Some(6) -&gt; 6 is even -&gt; Some(6)
    assert_eq!(n.filter(fn_is_even), n);   // None -&gt; no value -&gt; None
}
</code></pre></pre>
<h2><a class="header" href="#map-and-map_err" id="map-and-map_err">map() and map_err()</a></h2>
<blockquote>
<p>💡 Usually in programming languages <code>map()</code> functions are used with arrays or iterators, <strong>to apply a closure on each element</strong> of the array or iterator. Rust also provides <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.map"><code>map()</code> <strong>as an iterator adaptor</strong></a> to apply a closure on each element of an iterator to transform it into another iterator. However in here we are talking about the functionality of <code>map()</code> with <code>Option</code> and <code>Result</code> types. </p>
</blockquote>
<ul>
<li><code>map()</code> : Convert type T by applying a closure. <strong>The data type of <code>Some</code> or <code>Ok</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;U&gt;</code>, <code>Result&lt;T, E&gt;</code> to <code>Result&lt;U, E&gt;</code></li>
</ul>
<p>⭐ Via <code>map()</code>, only <code>Some</code> and <code>Ok</code> values are getting changed. No affect to the values inside <code>Err</code> (<code>None</code> doesn’t contain any value at all).</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = Some(&quot;abcde&quot;);
    let s2 = Some(5);

    let n1: Option&lt;&amp;str&gt; = None;
    let n2: Option&lt;usize&gt; = None;

    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let o2: Result&lt;usize, &amp;str&gt; = Ok(5);
    
    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;abcde&quot;);
    let e2: Result&lt;usize, &amp;str&gt; = Err(&quot;abcde&quot;);
    
    let fn_character_count = |s: &amp;str| s.chars().count();

    assert_eq!(s1.map(fn_character_count), s2); // Some1 map = Some2
    assert_eq!(n1.map(fn_character_count), n2); // None1 map = None2

    assert_eq!(o1.map(fn_character_count), o2); // Ok1 map = Ok2
    assert_eq!(e1.map(fn_character_count), e2); // Err1 map = Err2
}
</code></pre></pre>
<ul>
<li><code>map_err()</code> for <code>Result</code> types : <strong>The data type of <code>Err</code> blocks can be changed</strong> according to the return type of the closure. Convert <code>Result&lt;T, E&gt;</code> to <code>Result&lt;T, F&gt;</code>.</li>
</ul>
<p>⭐ Via <code>map_err()</code>, only <code>Err</code> values are getting changed. No affect to the values inside <code>Ok</code>.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let o1: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let o2: Result&lt;&amp;str, isize&gt; = Ok(&quot;abcde&quot;);

    let e1: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;404&quot;);
    let e2: Result&lt;&amp;str, isize&gt; = Err(404);

    let fn_character_count = |s: &amp;str| -&gt; isize { s.parse().unwrap() }; // convert str to isize

    assert_eq!(o1.map_err(fn_character_count), o2); // Ok1 map = Ok2
    assert_eq!(e1.map_err(fn_character_count), e2); // Err1 map = Err2
}
</code></pre></pre>
<h2><a class="header" href="#map_or-and-map_or_else" id="map_or-and-map_or_else">map_or() and map_or_else()</a></h2>
<p>Hope you remember the functionality of <a href="learningrust/e4.unwrap_and_expect.html#unwrap-or-unwrap-or-default-and-unwrap-or-else"><code>unwrap_or()</code> and <code>unwrap_or_else()</code></a> functions. These functions also bit similar to them. But <code>map_or()</code> and <code>map_or_else()</code> apply a closure on <code>Some</code> and <code>Ok</code> values and <strong>return the value inside type T</strong>.</p>
<ul>
<li><code>map_or()</code> : Support only for <code>Option</code> types (not supporting <code>Result</code>). Apply the closure to the value inside <code>Some</code> and return the output according to the closure. The given default value is returned for <code>None</code> types.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    const V_DEFAULT: i8 = 1;
    
    let s = Some(10);
    let n: Option&lt;i8&gt; = None;
    let fn_closure = |v: i8| v + 2;

    assert_eq!(s.map_or(V_DEFAULT, fn_closure), 12);
    assert_eq!(n.map_or(V_DEFAULT, fn_closure), V_DEFAULT);
}
</code></pre></pre>
<ul>
<li><code>map_or_else()</code> : Support for both <code>Option</code> and <code>Result</code> types (<code>Result</code> still nightly only). Similar to <code>map_or()</code> but should provide another closure instead a default value for the first parameter.</li>
</ul>
<p>⭐ <code>None</code> types doesn’t contain any value. So no need to pass anything to the closure as input with <code>Option</code> types. But <code>Err</code> types contain some value inside it. So default closure should able to read it as an input, while using this with <code>Result</code> types.</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(result_map_or_else)] // enable unstable library feature 'result_map_or_else' on nightly
fn main() {
    let s = Some(10);
    let n: Option&lt;i8&gt; = None;

    let fn_closure = |v: i8| v + 2;
    let fn_default = || 1; // None doesn't contain any value. So no need to pass anything to closure as input.

    assert_eq!(s.map_or_else(fn_default, fn_closure), 12);
    assert_eq!(n.map_or_else(fn_default, fn_closure), 1);

    let o = Ok(10);
    let e = Err(5);
    let fn_default_for_result = |v: i8| v + 1; // Err contain some value inside it. So default closure should able to read it as input

    assert_eq!(o.map_or_else(fn_default_for_result, fn_closure), 12);
    assert_eq!(e.map_or_else(fn_default_for_result, fn_closure), 6);
}
</code></pre></pre>
<h2><a class="header" href="#ok_or-and-ok_or_else" id="ok_or-and-ok_or_else">ok_or() and ok_or_else()</a></h2>
<p>As mentioned earlier, <code>ok_or()</code>, <code>ok_or_else()</code> transform <code>Option</code> type into <code>Result</code> type. <strong><code>Some</code> to <code>Ok</code> and <code>None</code> to <code>Err</code></strong>.</p>
<ul>
<li><code>ok_or()</code> : A default <code>Err</code> message should pass as argument.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    const ERR_DEFAULT: &amp;str = &quot;error message&quot;;

    let s = Some(&quot;abcde&quot;);
    let n: Option&lt;&amp;str&gt; = None;

    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let e: Result&lt;&amp;str, &amp;str&gt; = Err(ERR_DEFAULT);

    assert_eq!(s.ok_or(ERR_DEFAULT), o); // Some(T) -&gt; Ok(T)
    assert_eq!(n.ok_or(ERR_DEFAULT), e); // None -&gt; Err(default)
}
</code></pre></pre>
<ul>
<li><code>ok_or_else()</code> : Similar to <code>ok_or()</code>. A closure should be passed as the argument.</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = Some(&quot;abcde&quot;);
    let n: Option&lt;&amp;str&gt; = None;
    let fn_err_message = || &quot;error message&quot;;

    let o: Result&lt;&amp;str, &amp;str&gt; = Ok(&quot;abcde&quot;);
    let e: Result&lt;&amp;str, &amp;str&gt; = Err(&quot;error message&quot;);

    assert_eq!(s.ok_or_else(fn_err_message), o); // Some(T) -&gt; Ok(T)
    assert_eq!(n.ok_or_else(fn_err_message), e); // None -&gt; Err(default)
}
</code></pre></pre>
<h2><a class="header" href="#as_ref-and-as_mut" id="as_ref-and-as_mut">as_ref() and as_mut()</a></h2>
<p>🔎 As mentioned earlier, these functions are used to <strong>borrow type T as a reference or as a mutable reference</strong>.</p>
<ul>
<li><code>as_ref()</code> : Convert <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;T, &amp;E&gt;</code> </li>
<li><code>as_mut()</code> : Converts <code>Option&lt;T&gt;</code> to <code>Option&lt;&amp;mut T&gt;</code> and <code>Result&lt;T, E&gt;</code> to <code>Result&lt;&amp;mut T, &amp;mut E&gt;</code></li>
</ul>
<h2><a class="header" href="#title-custom-error-types" id="title-custom-error-types">title: Custom Error Types</a></h2>
<p>Rust allow us to create our own <code>Err</code> types. We call them “<em>Custom Error Types</em>”.</p>
<h2><a class="header" href="#error-trait" id="error-trait">Error trait</a></h2>
<p>As you know <strong>traits define the functionality a type must provide</strong>. But we don’t need to define new traits for common functionalities always, because Rust <strong>standard library provides some reusable traits</strong> which can be implemented on our own types. While creating custom error types <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>std::error::Error</code> trait</a> help us to convert any type to an <code>Err</code> type.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt::{Debug, Display};

pub trait Error: Debug + Display {
    fn source(&amp;self) -&gt; Option&lt;&amp;(Error + 'static)&gt; { ... }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>As we discussed under <a href="learningrust/b5.impls_and_traits.html#Traits-inheritance">traits inheritance</a>, a trait can be inherited from another traits. <code>trait Error: Debug + Display</code> means <code>Error</code> trait inherits from <code>fmt::Debug</code> and <code>fmt::Display</code> traits.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// traits inside Rust standard library core fmt module/ std::fmt
pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;
}

pub trait Debug {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; Result&lt;(), Error&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li>
<p><code>Display</code></p>
<ul>
<li>How should the end user see this error as a message/ user-facing output.</li>
<li>Usually print via <code>println!(&quot;{}&quot;)</code> or <code>eprintln!(&quot;{}&quot;)</code></li>
</ul>
</li>
<li>
<p><code>Debug</code></p>
<ul>
<li>How should display the <code>Err</code> while debugging/ programmer-facing output.</li>
<li>Usually print via <code>println!(&quot;{:?}&quot;)</code> or <code>eprintln!(&quot;{:?}&quot;)</code></li>
<li>To pretty-print, <code>println!(&quot;{:#?}&quot;)</code> or <code>eprintln!(&quot;{:#?}&quot;)</code> can be used.</li>
</ul>
</li>
<li>
<p><code>source()</code></p>
<ul>
<li>The lower-level source of this error, if any.</li>
<li>Optional.</li>
</ul>
</li>
</ul>
<p>First, let’s see how to implement <code>std::error::Error</code> trait on a simplest custom error type.</p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

// Custom error type; can be any type which defined in the current crate
// 💡 In here, we use a simple &quot;unit struct&quot; to simplify the example
struct AppError;

// Implement std::fmt::Display for AppError
impl fmt::Display for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;An Error Occurred, Please Try Again!&quot;) // user-facing output
    }
}

// Implement std::fmt::Debug for AppError
impl fmt::Debug for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{{ file: {}, line: {} }}&quot;, file!(), line!()) // programmer-facing output
    }
}

// A sample function to produce an AppError Err
fn produce_error() -&gt; Result&lt;(), AppError&gt; {
    Err(AppError)
}

fn main() {
    match produce_error() {
        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // An Error Occurred, Please Try Again!
        _ =&gt; println!(&quot;No error&quot;),
    }

    eprintln!(&quot;{:?}&quot;, produce_error()); // Err({ file: src/main.rs, line: 17 })
}
</code></pre></pre>
<p>Hope you understood the main points. Now, let’s see some custom error type with <strong>an error code and an error message</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

struct AppError {
    code: usize,
    message: String,
}

// Different error messages according to AppError.code
impl fmt::Display for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let err_msg = match self.code {
            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,
            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,
        };

        write!(f, &quot;{}&quot;, err_msg)
    }
}

// A unique format for dubugging output
impl fmt::Debug for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(
            f,
            &quot;AppError {{ code: {}, message: {} }}&quot;,
            self.code, self.message
        )
    }
}

fn produce_error() -&gt; Result&lt;(), AppError&gt; {
    Err(AppError {
        code: 404,
        message: String::from(&quot;Page not found&quot;),
    })
}

fn main() {
    match produce_error() {
        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!
        _ =&gt; println!(&quot;No error&quot;),
    }

    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })

    eprintln!(&quot;{:#?}&quot;, produce_error());
    // Err(
    //     AppError { code: 404, message: Page not found }
    // )
}
</code></pre></pre>
<p>⭐️ Rust standard library provides not only reusable traits and also it facilitates to <strong>magically generate implementations for few traits</strong> via <code>#[derive]</code> attribute. Rust support <code>derive</code> <code>std::fmt::Debug</code>, to provide a default format for debug messages. So we <strong>can skip <code>std::fmt::Debug</code> implementation</strong> for custom error types and use <code>#[derive(Debug)]</code> before <code>struct</code> declaration.</p>
<blockquote>
<p>For a struct <code>#[derive(Debug)]</code> prints, the name of the <code>struct</code> , <code>{</code> , comma-separated list of each field’s name and debug value and <code>}</code>.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">use std::fmt;

#[derive(Debug)] // derive std::fmt::Debug on AppError
struct AppError {
    code: usize,
    message: String,
}

impl fmt::Display for AppError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        let err_msg = match self.code {
            404 =&gt; &quot;Sorry, Can not find the Page!&quot;,
            _ =&gt; &quot;Sorry, something is wrong! Please Try Again!&quot;,
        };

        write!(f, &quot;{}&quot;, err_msg)
    }
}

fn produce_error() -&gt; Result&lt;(), AppError&gt; {
    Err(AppError {
        code: 404,
        message: String::from(&quot;Page not found&quot;),
    })
}

fn main() {
    match produce_error() {
        Err(e) =&gt; eprintln!(&quot;{}&quot;, e), // Sorry, Can not find the Page!
        _ =&gt; println!(&quot;No error&quot;),
    }

    eprintln!(&quot;{:?}&quot;, produce_error()); // Err(AppError { code: 404, message: Page not found })

    eprintln!(&quot;{:#?}&quot;, produce_error());
    // Err(
    //     AppError {
    //         code: 404,
    //         message: &quot;Page not found&quot;
    //     }
    // )
}
</code></pre></pre>
<h2><a class="header" href="#from-trait" id="from-trait">From trait</a></h2>
<p>When writing real programs, mostly we have to deal with different modules, different <code>std</code> and third party crates at the same time. But each crate uses their own error types and if we are using our own error type, we should convert those errors into our error type. There is a standardized trait we can use for these conversions, <code>std::convert::From</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// traits inside Rust standard library core convert module/ std::convert
pub trait From&lt;T&gt;: Sized {
  fn from(_: T) -&gt; Self;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>💡 As you know, <code>String::from()</code> function is used to create a <code>String</code> from <code>&amp;str</code> data type. Actually this also an implementation of <code>std::convert::From</code> trait.</p>
</blockquote>
<p>Let’s see how to implement <code>std::convert::From</code> trait on a custom error type.</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io;

#[derive(Debug)]
struct AppError {
    kind: String,    // type of the error
    message: String, // error message
}

// Implement std::convert::From for AppError; from io::Error
impl From&lt;io::Error&gt; for AppError {
    fn from(error: io::Error) -&gt; Self {
        AppError {
            kind: String::from(&quot;io&quot;),
            message: error.to_string(),
        }
    }
}

fn main() -&gt; Result&lt;(), AppError&gt; {
    let _file = File::open(&quot;nonexistent_file.txt&quot;)?; // This generates an io::Error. But because of return type is Result&lt;(), AppError&gt;, it converts to AppError

    Ok(())
}


// --------------- Run time error ---------------
Error: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }
</code></pre></pre>
<p>In the above example, <code>File::open(“nonexistent.txt”)?</code> produces <code>std::io::Error</code>. But because of the return type is <code>Result&lt;(), AppError&gt;</code>, it converts to an <code>AppError</code>. Because of we are propagating the error from <code>main()</code> function, it prints the <code>Debug</code> representation of the <code>Err</code>.</p>
<p>In the above example we deal with only one <code>std</code> error type, <code>std::io::Error</code>. Let’s see some example which handles multiple <code>std</code> error types.</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::{self, Read};
use std::num;

#[derive(Debug)]
struct AppError {
    kind: String,
    message: String,
}

// Implement std::convert::From for AppError; from io::Error
impl From&lt;io::Error&gt; for AppError {
    fn from(error: io::Error) -&gt; Self {
        AppError {
            kind: String::from(&quot;io&quot;),
            message: error.to_string(),
        }
    }
}

// Implement std::convert::From for AppError; from num::ParseIntError
impl From&lt;num::ParseIntError&gt; for AppError {
    fn from(error: num::ParseIntError) -&gt; Self {
        AppError {
            kind: String::from(&quot;parse&quot;),
            message: error.to_string(),
        }
    }
}

fn main() -&gt; Result&lt;(), AppError&gt; {
    let mut file = File::open(&quot;hello_world.txt&quot;)?; // generates an io::Error, if can not open the file and converts to an AppError

    let mut content = String::new();
    file.read_to_string(&amp;mut content)?; // generates an io::Error, if can not read file content and converts to an AppError

    let _number: usize;
    _number = content.parse()?; // generates num::ParseIntError, if can not convert file content to usize and converts to an AppError

    Ok(())
}


// --------------- Few possible run time errors ---------------

// 01. If hello_world.txt is a nonexistent file
Error: AppError { kind: &quot;io&quot;, message: &quot;No such file or directory (os error 2)&quot; }

// 02. If user doesn't have relevant permission to access hello_world.txt
Error: AppError { kind: &quot;io&quot;, message: &quot;Permission denied (os error 13)&quot; }

// 03. If hello_world.txt contains non-numeric content. ex Hello, world!
Error: AppError { kind: &quot;parse&quot;, message: &quot;invalid digit found in string&quot; }
</code></pre></pre>
<blockquote>
<p>🔎 Search about the implementation of <a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html"><code>std::io::ErrorKind</code></a>, to see how to organize error types further.</p>
</blockquote>
<h1><a class="header" href="#cookin-with-rust" id="cookin-with-rust">Cookin' with Rust</a></h1>
<p>This <em>Rust Cookbook</em> is a collection of
simple examples that demonstrate good practices to accomplish common
programming tasks, using the crates of the Rust ecosystem.</p>
<p><a href="rustcookbook/about.html">Read more about <em>Rust Cookbook</em></a>, including tips for
how to read the book, how to use the examples, and notes on conventions.</p>
<h2><a class="header" href="#contributing" id="contributing">Contributing</a></h2>
<p>This project is intended to be easy for new Rust programmers to
contribute to, and an easy way to get involved with the Rust
community. It needs and welcomes help. For details see
<a href="https://github.com/rust-lang-nursery/rust-cookbook/blob/master/CONTRIBUTING.md">CONTRIBUTING.md</a>.</p>
<h1><a class="header" href="#algorithms" id="algorithms">Algorithms</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/algorithms/randomness.html#generate-random-numbers">Generate random numbers</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#generate-random-numbers-within-a-range">Generate random numbers within a range</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#generate-random-numbers-with-given-distribution">Generate random numbers with given distribution</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#generate-random-values-of-a-custom-type">Generate random values of a custom type</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#create-random-passwords-from-a-set-of-alphanumeric-characters">Create random passwords from a set of alphanumeric characters</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#create-random-passwords-from-a-set-of-user-defined-characters">Create random passwords from a set of user-defined characters</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/sorting.html#sort-a-vector-of-integers">Sort a Vector of Integers</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/sorting.html#sort-a-vector-of-floats">Sort a Vector of Floats</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/sorting.html#sort-a-vector-of-structs">Sort a Vector of Structs</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#command-line" id="command-line">Command Line</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/cli/arguments.html#parse-command-line-arguments">Parse command line arguments</a></td><td><a href="https://docs.rs/clap/"><img src="https://badge-cache.kominick.com/crates/v/clap.svg?label=clap" alt="clap-badge" /></a></td><td><a href="https://crates.io/categories/command-line-interface"><img src="https://badge-cache.kominick.com/badge/command_line--x.svg?style=social" alt="cat-command-line-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/cli/ansi_terminal.html#ansi-terminal">ANSI Terminal</a></td><td><a href="https://docs.rs/ansi_term/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=ansi_term" alt="ansi_term-badge" /></a></td><td><a href="https://crates.io/categories/command-line-interface"><img src="https://badge-cache.kominick.com/badge/command_line--x.svg?style=social" alt="cat-command-line-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#compression" id="compression">Compression</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/compression/tar.html#decompress-a-tarball">Decompress a tarball</a></td><td><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a></td><td><a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/compression/tar.html#compress-a-directory-into-tarball">Compress a directory into a tarball</a></td><td><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a></td><td><a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/compression/tar.html#decompress-a-tarball-while-removing-a-prefix-from-the-paths">Decompress a tarball while removing a prefix from the paths</a></td><td><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a></td><td><a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#concurrency-1" id="concurrency-1">Concurrency</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/concurrency/threads.html#spawn-a-short-lived-thread">Spawn a short-lived thread</a></td><td><a href="https://docs.rs/crossbeam/"><img src="https://badge-cache.kominick.com/crates/v/crossbeam.svg?label=crossbeam" alt="crossbeam-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/threads.html#maintain-global-mutable-state">Maintain global mutable state</a></td><td><a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/threads.html#calculate-sha1-sum-of-iso-files-concurrently">Calculate SHA1 sum of *.iso files concurrently</a></td><td><a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/threads.html#draw-fractal-dispatching-work-to-a-thread-pool">Draw fractal dispatching work to a thread pool</a></td><td><a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a><a href="https://crates.io/categories/rendering"><img src="https://badge-cache.kominick.com/badge/rendering--x.svg?style=social" alt="cat-rendering-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#mutate-the-elements-of-an-array-in-parallel">Mutate the elements of an array in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#test-in-parallel-if-any-or-all-elements-of-a-collection-match-a-given-predicate">Test in parallel if any or all elements of a collection match a given predicate</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#search-items-using-given-predicate-in-parallel">Search items using given predicate in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#sort-a-vector-in-parallel">Sort a vector in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#map-reduce-in-parallel">Map-reduce in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#generate-jpg-thumbnails-in-parallel">Generate jpg thumbnails in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#cryptography" id="cryptography">Cryptography</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/cryptography/hashing.html#calculate-the-sha-256-digest-of-a-file">Calculate the SHA-256 digest of a file</a></td><td><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a></td><td><a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/cryptography/hashing.html#sign-and-verify-a-message-with-hmac-digest">Sign and verify a message with an HMAC digest</a></td><td><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a></td><td><a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/cryptography/encryption.html#salt-and-hash-a-password-with-pbkdf2">Salt and hash a password with PBKDF2</a></td><td><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a></td><td><a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#data-structures" id="data-structures">Data Structures</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/data_structures/bitfield.html#define-and-operate-on-a-type-represented-as-a-bitfield">Define and operate on a type represented as a bitfield</a></td><td><a href="https://docs.rs/bitflags/"><img src="https://badge-cache.kominick.com/crates/v/bitflags.svg?label=bitflags" alt="bitflags-badge" /></a></td><td><a href="https://crates.io/categories/no-std"><img src="https://badge-cache.kominick.com/badge/no_std--x.svg?style=social" alt="cat-no-std-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#database" id="database">Database</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/database/sqlite.html#create-a-sqlite-database">Create a SQLite database</a></td><td><a href="https://crates.io/crates/rusqlite/"><img src="https://badge-cache.kominick.com/crates/v/rusqlite.svg?label=rusqlite" alt="rusqlite-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/database/sqlite.html#insert-and-select-data">Insert and Query data</a></td><td><a href="https://crates.io/crates/rusqlite/"><img src="https://badge-cache.kominick.com/crates/v/rusqlite.svg?label=rusqlite" alt="rusqlite-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/database/postgres.html#create-tables-in-a-postgres-database">Create tables in a Postgres database</a></td><td><a href="https://docs.rs/postgres/0.15.2/postgres/"><img src="https://badge-cache.kominick.com/crates/v/postgres.svg?label=postgres" alt="postgres-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/database/postgres.html#insert-and-query-data">Insert and Query data</a></td><td><a href="https://docs.rs/postgres/0.15.2/postgres/"><img src="https://badge-cache.kominick.com/crates/v/postgres.svg?label=postgres" alt="postgres-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/database/postgres.html#aggregate-data">Aggregate data</a></td><td><a href="https://docs.rs/postgres/0.15.2/postgres/"><img src="https://badge-cache.kominick.com/crates/v/postgres.svg?label=postgres" alt="postgres-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#date-and-time" id="date-and-time">Date and Time</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/datetime/duration.html#measure-the-elapsed-time-between-two-code-sections">Measure elapsed time</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/time--x.svg?style=social" alt="cat-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/duration.html#perform-checked-date-and-time-calculations">Perform checked date and time calculations</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/duration.html#convert-a-local-time-to-another-timezone">Convert a local time to another timezone</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/parse.html#examine-the-date-and-time">Examine the date and time</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/parse.html#convert-date-to-unix-timestamp-and-vice-versa">Convert date to UNIX timestamp and vice versa</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/parse.html#display-formatted-date-and-time">Display formatted date and time</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/parse.html#parse-string-into-datetime-struct">Parse string into DateTime struct</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#development-tools" id="development-tools">Development Tools</a></h1>
<h2><a class="header" href="#debugging" id="debugging">Debugging</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-a-debug-message-to-the-console">Log a debug message to the console</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-an-error-message-to-the-console">Log an error message to the console</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-to-stdout-instead-of-stderr">Log to stdout instead of stderr</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-messages-with-a-custom-logger">Log messages with a custom logger</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-to-the-unix-syslog">Log to the Unix syslog</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://badge-cache.kominick.com/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/config_log.html#enable-log-levels-per-module">Enable log levels per module</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/config_log.html#use-a-custom-environment-variable-to-set-up-logging">Use a custom environment variable to set up logging</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/config_log.html#include-timestamp-in-log-messages">Include timestamp in log messages</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/config_log.html#log-messages-to-a-custom-location">Log messages to a custom location</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/log4rs/"><img src="https://badge-cache.kominick.com/crates/v/log4rs.svg?label=log4rs" alt="log4rs-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h2><a class="header" href="#versioning" id="versioning">Versioning</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/development_tools/versioning.html#parse-and-increment-a-version-string">Parse and increment a version string</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/versioning.html#parse-a-complex-version-string">Parse a complex version string</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/versioning.html#check-if-given-version-is-pre-release">Check if given version is pre-release</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/versioning.html#find-the-latest-version-satisfying-given-range">Find the latest version satisfying given range</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/versioning.html#check-external-command-version-for-compatibility">Check external command version for compatibility</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
</tbody></table>
<h2><a class="header" href="#build-time" id="build-time">Build Time</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/development_tools/build_tools.html#compile-and-link-statically-to-a-bundled-c-library">Compile and link statically to a bundled C library</a></td><td><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a></td><td><a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/build_tools.html#compile-and-link-statically-to-a-bundled-c-library-1">Compile and link statically to a bundled C++ library</a></td><td><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a></td><td><a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/build_tools.html#compile-a-c-library-while-setting-custom-defines">Compile a C library while setting custom defines</a></td><td><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a></td><td><a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#encoding" id="encoding">Encoding</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/encoding/strings.html#percent-encode-a-string">Percent-encode a string</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/strings.html#encode-a-string-as-applicationx-www-form-urlencoded">Encode a string as application/x-www-form-urlencoded</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/strings.html#encode-and-decode-hex">Encode and decode hex</a></td><td><a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/strings.html#encode-and-decode-base64">Encode and decode base64</a></td><td><a href="https://docs.rs/base64/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=base64" alt="base64-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#read-csv-records">Read CSV records</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#read-csv-records-with-different-delimiter">Read CSV records with different delimiter</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#filter-csv-records-matching-a-predicate">Filter CSV records matching a predicate</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#handle-invalid-csv-data-with-serde">Handle invalid CSV data with Serde</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#serialize-records-to-csv">Serialize records to CSV</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#serialize-records-to-csv-using-serde">Serialize records to CSV using Serde</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#transform-csv-column">Transform one column of a CSV file</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/complex.html#serialize-and-deserialize-unstructured-json">Serialize and deserialize unstructured JSON</a></td><td><a href="https://docs.rs/serde_json/*/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/complex.html#deserialize-a-toml-configuration-file">Deserialize a TOML configuration file</a></td><td><a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/complex.html#read-and-write-integers-in-little-endian-byte-order">Read and write integers in little-endian byte order</a></td><td><a href="https://docs.rs/byteorder/"><img src="https://badge-cache.kominick.com/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#file-system" id="file-system">File System</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/file/read-write.html#read-lines-of-strings-from-a-file">Read lines of strings from a file</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/read-write.html#avoid-writing-and-reading-from-a-same-file">Avoid writing and reading from a same file</a></td><td><a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/read-write.html#access-a-file-randomly-using-a-memory-map">Access a file randomly using a memory map</a></td><td><a href="https://docs.rs/memmap/"><img src="https://badge-cache.kominick.com/crates/v/memmap.svg?label=memmap" alt="memmap-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#file-names-that-have-been-modified-in-the-last-24-hours">File names that have been modified in the last 24 hours</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#find-loops-for-a-given-path">Find loops for a given path</a></td><td><a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#recursively-find-duplicate-file-names">Recursively find duplicate file names</a></td><td><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#recursively-find-all-files-with-given-predicate">Recursively find all files with given predicate</a></td><td><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#traverse-directories-while-skipping-dotfiles">Traverse directories while skipping dotfiles</a></td><td><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#recursively-calculate-file-sizes-at-given-depth">Recursively calculate file sizes at given depth</a></td><td><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#find-all-png-files-recursively">Find all png files recursively</a></td><td><a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#find-all-files-with-given-pattern-ignoring-filename-case">Find all files with given pattern ignoring filename case</a></td><td><a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#hardware-support" id="hardware-support">Hardware Support</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/hardware/processor.html#check-number-of-logical-cpu-cores">Check number of logical cpu cores</a></td><td><a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a></td><td><a href="https://crates.io/categories/hardware-support"><img src="https://badge-cache.kominick.com/badge/hardware_support--x.svg?style=social" alt="cat-hardware-support-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#memory-management" id="memory-management">Memory Management</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/mem/global_static.html#declare-lazily-evaluated-constant">Declare lazily evaluated constant</a></td><td><a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/caching"><img src="https://badge-cache.kominick.com/badge/caching--x.svg?style=social" alt="cat-caching-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#networking" id="networking">Networking</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/net/server.html#listen-on-unused-port-tcpip">Listen on unused port TCP/IP</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#operating-system" id="operating-system">Operating System</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/os/external.html#run-an-external-command-and-process-stdout">Run an external command and process stdout</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/os/external.html#run-an-external-command-passing-it-stdin-and-check-for-an-error-code">Run an external command passing it stdin and check for an error code</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/os/external.html#run-piped-external-commands">Run piped external commands</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/os/external.html#redirect-both-stdout-and-stderr-of-child-process-to-the-same-file">Redirect both stdout and stderr of child process to the same file</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/os/external.html#continuously-process-child-process-outputs">Continuously process child process' outputs</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#science" id="science">Science</a></h1>
<h2><a class="header" href="#mathematics" id="mathematics">Mathematics</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#vector-sum">Vector Sum</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#vector-norm">Vector Norm</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#adding-matrices">Adding matrices</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#multiplying-matrices">Multiplying matrices</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#multiply-a-scalar-with-a-vector-with-a-matrix">Multiply a scalar with a vector with a matrix</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#invert-matrix">Invert marix</a></td><td><a href="https://docs.rs/nalgebra"><img src="https://badge-cache.kominick.com/crate/nalgebra.svg?label=nalgebra" alt="nalgebra-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/trigonometry.html#calculating-the-side-length-of-a-triangle">Calculating the side length of a triangle</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/trigonometry.html#verifying-tan-is-equal-to-sin-divided-by-cos">Verifying tan is equal to sin divided by cos</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/trigonometry.html#distance-between-two-points-on-the-earth">Distance between two points on the Earth</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/complex_numbers.html#creating-complex-numbers">Creating complex numbers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/complex_numbers.html#adding-complex-numbers">Adding complex numbers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/complex_numbers.html#mathematical-functions">Mathematical functions on complex numbers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/statistics.html#measures-of-central-tendency">Measures of central tendency</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/statistics.html#standard-deviation">Computing standard deviation</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/miscellaneous.html#big-integers">Big integers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#text-processing" id="text-processing">Text Processing</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/text/string_parsing.html#collect-unicode-graphemes">Collect Unicode Graphemes</a></td><td><a href="https://docs.rs/unicode-segmentation/"><img src="https://badge-cache.kominick.com/crates/v/unicode-segmentation.svg?label=unicode-segmentation" alt="unicode-segmentation-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#verify-and-extract-login-from-an-email-address">Verify and extract login from an email address</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#extract-a-list-of-unique-hashtags-from-a-text">Extract a list of unique #Hashtags from a text</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#extract-phone-numbers-from-text">Extract phone numbers from text</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#filter-a-log-file-by-matching-multiple-regular-expressions">Filter a log file by matching multiple regular expressions</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#replace-all-occurrences-of-one-text-pattern-with-another-pattern">Replace all occurrences of one text pattern with another pattern.</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/string_parsing.html#implement-the-fromstr-trait-for-a-custom-struct">Implement the <code>FromStr</code> trait for a custom <code>struct</code></a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#web-programming" id="web-programming">Web Programming</a></h1>
<h2><a class="header" href="#scraping-web-pages" id="scraping-web-pages">Scraping Web Pages</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/web/scraping.html#extract-all-links-from-a-webpage-html">Extract all links from a webpage HTML</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/scraping.html#check-a-webpage-for-broken-links">Check webpage for broken links</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/scraping.html#extract-all-unique-links-from-a-mediawiki-markup">Extract all unique links from a MediaWiki markup</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
</tbody></table>
<h2><a class="header" href="#uniform-resource-locations-url" id="uniform-resource-locations-url">Uniform Resource Locations (URL)</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/web/url.html#parse-a-url-from-a-string-to-a-url-type">Parse a URL from a string to a <code>Url</code> type</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/url.html#create-a-base-url-by-removing-path-segments">Create a base URL by removing path segments</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/url.html#create-new-urls-from-a-base-url">Create new URLs from a base URL</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/url.html#extract-the-url-origin-scheme--host--port">Extract the URL origin (scheme / host / port)</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/url.html#remove-fragment-identifiers-and-query-pairs-from-a-url">Remove fragment identifiers and query pairs from a URL</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
</tbody></table>
<h2><a class="header" href="#media-types-mime" id="media-types-mime">Media Types (MIME)</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/web/mime.html#get-mime-type-from-string">Get MIME type from string</a></td><td><a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/mime.html#get-mime-type-from-filename">Get MIME type from filename</a></td><td><a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/mime.html#parse-the-mime-type-of-a-http-response">Parse the MIME type of a HTTP response</a></td><td><a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
</tbody></table>
<h2><a class="header" href="#clients" id="clients">Clients</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/web/clients/requests.html#make-a-http-get-request">Make a HTTP GET request</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/apis.html#query-the-github-api">Query the GitHub API</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/apis.html#check-if-an-api-resource-exists">Check if an API resource exists</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/apis.html#create-and-delete-gist-with-github-api">Create and delete Gist with GitHub API</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/apis.html#consume-a-paginated-restful-api">Consume a paginated RESTful API</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/download.html#download-a-file-to-a-temporary-directory">Download a file to a temporary directory</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://badge-cache.kominick.com/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/download.html#make-a-partial-download-with-http-range-headers">Make a partial download with HTTP range headers</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/download.html#post-a-file-to-paste-rs">POST a file to paste-rs</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#algorithms-1" id="algorithms-1">Algorithms</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/algorithms/randomness.html#generate-random-numbers">Generate random numbers</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#generate-random-numbers-within-a-range">Generate random numbers within a range</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#generate-random-numbers-with-given-distribution">Generate random numbers with given distribution</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#generate-random-values-of-a-custom-type">Generate random values of a custom type</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#create-random-passwords-from-a-set-of-alphanumeric-characters">Create random passwords from a set of alphanumeric characters</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/randomness.html#create-random-passwords-from-a-set-of-user-defined-characters">Create random passwords from a set of user-defined characters</a></td><td><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/sorting.html#sort-a-vector-of-integers">Sort a Vector of Integers</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/sorting.html#sort-a-vector-of-floats">Sort a Vector of Floats</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/algorithms/sorting.html#sort-a-vector-of-structs">Sort a Vector of Structs</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#generate-random-values" id="generate-random-values">Generate Random Values</a></h1>
<h2><a class="header" href="#generate-random-numbers" id="generate-random-numbers">Generate random numbers</a></h2>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Generates random numbers with help of random-number
generator <a href="https://docs.rs/rand/*/rand/trait.Rng.html"><code>rand::Rng</code></a> obtained via <a href="https://docs.rs/rand/*/rand/fn.thread_rng.html"><code>rand::thread_rng</code></a>. Each thread has an
initialized generator. Integers are uniformly distributed over the range of the
type, and floating point numbers are uniformly distributed from 0 up to but not
including 1.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();

    let n1: u8 = rng.gen();
    let n2: u16 = rng.gen();
    println!(&quot;Random u8: {}&quot;, n1);
    println!(&quot;Random u16: {}&quot;, n2);
    println!(&quot;Random u32: {}&quot;, rng.gen::&lt;u32&gt;());
    println!(&quot;Random i32: {}&quot;, rng.gen::&lt;i32&gt;());
    println!(&quot;Random float: {}&quot;, rng.gen::&lt;f64&gt;());
}
</code></pre></pre>
<h2><a class="header" href="#generate-random-numbers-within-a-range" id="generate-random-numbers-within-a-range">Generate random numbers within a range</a></h2>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Generates a random value within half-open <code>[0, 10)</code> range (not including <code>10</code>) with <a href="https://doc.rust-lang.org/rand/*/rand/trait.Rng.html#method.gen_range"><code>Rng::gen_range</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();
    println!(&quot;Integer: {}&quot;, rng.gen_range(0, 10));
    println!(&quot;Float: {}&quot;, rng.gen_range(0.0, 10.0));
}
</code></pre></pre>
<p><a href="https://docs.rs/rand/*/rand/distributions/uniform/struct.Uniform.html"><code>Uniform</code></a> can obtain values with <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">uniform distribution</a>.
This has the same effect, but may be faster when repeatedly generating numbers
in the same range.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;


use rand::distributions::{Distribution, Uniform};

fn main() {
    let mut rng = rand::thread_rng();
    let die = Uniform::from(1..7);

    loop {
        let throw = die.sample(&amp;mut rng);
        println!(&quot;Roll the die: {}&quot;, throw);
        if throw == 6 {
            break;
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#generate-random-numbers-with-given-distribution" id="generate-random-numbers-with-given-distribution">Generate random numbers with given distribution</a></h2>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>By default, random numbers have <a href="https://en.wikipedia.org/wiki/Uniform_distribution_(continuous)">uniform distribution</a>.
To generate numbers with other distributions you instantiate a
distribution, then sample from that distribution using
<a href="https://docs.rs/rand/*/rand/distributions/trait.Distribution.html#tymethod.sample"><code>Distribution::sample</code></a> with help of a random-number
generator <a href="https://docs.rs/rand/*/rand/trait.Rng.html"><code>rand::Rng</code></a>.</p>
<p>The <a href="https://docs.rs/rand/*/rand/distributions/index.html">distributions available are documented here</a>. An example using the
<a href="https://docs.rs/rand/*/rand/distributions/normal/struct.Normal.html"><code>Normal</code></a> distribution is shown below.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::distributions::{Normal, Distribution};

fn main() {
  let mut rng = rand::thread_rng();
  let normal = Normal::new(2.0, 3.0);
  let v = normal.sample(&amp;mut rng);
  println!(&quot;{} is from a N(2, 9) distribution&quot;, v)
}
</code></pre></pre>
<h2><a class="header" href="#generate-random-values-of-a-custom-type" id="generate-random-values-of-a-custom-type">Generate random values of a custom type</a></h2>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Randomly generates a tuple <code>(i32, bool, f64)</code> and variable of user defined type <code>Point</code>.
Implements the <a href="https://docs.rs/rand/*/rand/distributions/trait.Distribution.html"><code>Distribution</code></a> trait on type Point for <a href="https://docs.rs/rand/*/rand/distributions/struct.Standard.html"><code>Standard</code></a> in order to allow random generation.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::Rng;
use rand::distributions::{Distribution, Standard};

#[derive(Debug)]
struct Point {
    x: i32,
    y: i32,
}

impl Distribution&lt;Point&gt; for Standard {
    fn sample&lt;R: Rng + ?Sized&gt;(&amp;self, rng: &amp;mut R) -&gt; Point {
        let (rand_x, rand_y) = rng.gen();
        Point {
            x: rand_x,
            y: rand_y,
        }
    }
}

fn main() {
    let mut rng = rand::thread_rng();
    let rand_tuple = rng.gen::&lt;(i32, bool, f64)&gt;();
    let rand_point: Point = rng.gen();
    println!(&quot;Random tuple: {:?}&quot;, rand_tuple);
    println!(&quot;Random Point: {:?}&quot;, rand_point);
}
</code></pre></pre>
<h2><a class="header" href="#create-random-passwords-from-a-set-of-alphanumeric-characters" id="create-random-passwords-from-a-set-of-alphanumeric-characters">Create random passwords from a set of alphanumeric characters</a></h2>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Randomly generates a string of given length ASCII characters in the range <code>A-Z, a-z, 0-9</code>, with <a href="https://docs.rs/rand/*/rand/distributions/struct.Alphanumeric.html"><code>Alphanumeric</code></a> sample.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

use rand::{thread_rng, Rng};
use rand::distributions::Alphanumeric;

fn main() {
    let rand_string: String = thread_rng()
        .sample_iter(&amp;Alphanumeric)
        .take(30)
        .collect();

    println!(&quot;{}&quot;, rand_string);
}
</code></pre></pre>
<h2><a class="header" href="#create-random-passwords-from-a-set-of-user-defined-characters" id="create-random-passwords-from-a-set-of-user-defined-characters">Create random passwords from a set of user-defined characters</a></h2>
<p><a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Randomly generates a string of given length ASCII characters with custom
user-defined bytestring, with <a href="https://docs.rs/rand/*/rand/trait.Rng.html#method.gen_range"><code>gen_range</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;

fn main() {
    use rand::Rng;
    const CHARSET: &amp;[u8] = b&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ\
                            abcdefghijklmnopqrstuvwxyz\
                            0123456789)(*&amp;^%$#@!~&quot;;
    const PASSWORD_LEN: usize = 30;
    let mut rng = rand::thread_rng();

    let password: String = (0..PASSWORD_LEN)
        .map(|_| {
            let idx = rng.gen_range(0, CHARSET.len());
            // This is safe because `idx` is in range of `CHARSET`
            char::from(unsafe { *CHARSET.get_unchecked(idx) })
        })
        .collect();

    println!(&quot;{:?}&quot;, password);
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#sorting-vectors" id="sorting-vectors">Sorting Vectors</a></h1>
<h2><a class="header" href="#sort-a-vector-of-integers" id="sort-a-vector-of-integers">Sort a Vector of Integers</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>This example sorts a Vector of integers via <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort"><code>vec::sort</code></a>. Alternative would
be to use <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort_unstable"><code>vec::sort_unstable</code></a> which can be faster, but does not preserve
the order of equal elements.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut vec = vec![1, 5, 10, 2, 15];
    
    vec.sort();

    assert_eq!(vec, vec![1, 2, 5, 10, 15]);
}
</code></pre></pre>
<h2><a class="header" href="#sort-a-vector-of-floats" id="sort-a-vector-of-floats">Sort a Vector of Floats</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>A Vector of f32 or f64 can be sorted with <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.sort_by"><code>vec::sort_by</code></a> and <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html#tymethod.partial_cmp"><code>PartialOrd::partial_cmp</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut vec = vec![1.1, 1.15, 5.5, 1.123, 2.0];

    vec.sort_by(|a, b| a.partial_cmp(b).unwrap());

    assert_eq!(vec, vec![1.1, 1.123, 1.15, 2.0, 5.5]);
}
</code></pre></pre>
<h2><a class="header" href="#sort-a-vector-of-structs" id="sort-a-vector-of-structs">Sort a Vector of Structs</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Sorts a Vector of Person structs with properties <code>name</code> and <code>age</code> by its natural
order (By name and age). In order to make Person sortable you need four traits <a href="https://doc.rust-lang.org/std/cmp/trait.Eq.html"><code>Eq</code></a>,
<a href="https://doc.rust-lang.org/std/cmp/trait.PartialEq.html"><code>PartialEq</code></a>, <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code>Ord</code></a> and <a href="https://doc.rust-lang.org/std/cmp/trait.PartialOrd.html"><code>PartialOrd</code></a>. These traits can be simply derived.
You can also provide a custom comparator function using a <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort_by"><code>vec:sort_by</code></a> method and sort only by age.</p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug, Eq, Ord, PartialEq, PartialOrd)]
struct Person {
    name: String,
    age: u32
}

impl Person {
    pub fn new(name: String, age: u32) -&gt; Self {
        Person {
            name,
            age
        }
    }
}

fn main() {
    let mut people = vec![
        Person::new(&quot;Zoe&quot;.to_string(), 25),
        Person::new(&quot;Al&quot;.to_string(), 60),
        Person::new(&quot;John&quot;.to_string(), 1),
    ];

    // Sort people by derived natural order (Name and age)
    people.sort();

    assert_eq!(
        people,
        vec![
            Person::new(&quot;Al&quot;.to_string(), 60),
            Person::new(&quot;John&quot;.to_string(), 1),
            Person::new(&quot;Zoe&quot;.to_string(), 25),
        ]);

    // Sort people by age
    people.sort_by(|a, b| b.age.cmp(&amp;a.age));

    assert_eq!(
        people,
        vec![
            Person::new(&quot;Al&quot;.to_string(), 60),
            Person::new(&quot;Zoe&quot;.to_string(), 25),
            Person::new(&quot;John&quot;.to_string(), 1),
        ]);

}

</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#command-line-1" id="command-line-1">Command Line</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/cli/arguments.html#parse-command-line-arguments">Parse command line arguments</a></td><td><a href="https://docs.rs/clap/"><img src="https://badge-cache.kominick.com/crates/v/clap.svg?label=clap" alt="clap-badge" /></a></td><td><a href="https://crates.io/categories/command-line-interface"><img src="https://badge-cache.kominick.com/badge/command_line--x.svg?style=social" alt="cat-command-line-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/cli/ansi_terminal.html#ansi-terminal">ANSI Terminal</a></td><td><a href="https://docs.rs/ansi_term/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=ansi_term" alt="ansi_term-badge" /></a></td><td><a href="https://crates.io/categories/command-line-interface"><img src="https://badge-cache.kominick.com/badge/command_line--x.svg?style=social" alt="cat-command-line-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#clap-basic" id="clap-basic">Clap basic</a></h1>
<h2><a class="header" href="#parse-command-line-arguments" id="parse-command-line-arguments">Parse command line arguments</a></h2>
<p><a href="https://docs.rs/clap/"><img src="https://badge-cache.kominick.com/crates/v/clap.svg?label=clap" alt="clap-badge" /></a> <a href="https://crates.io/categories/command-line-interface"><img src="https://badge-cache.kominick.com/badge/command_line--x.svg?style=social" alt="cat-command-line-badge" /></a></p>
<p>This application describes the structure of its command-line interface using
<code>clap</code>'s builder style. The <a href="https://docs.rs/clap/">documentation</a> gives two other possible ways to
instantiate an application.</p>
<p>In the builder style, <code>with_name</code> is the unique identifier that <code>value_of</code> will
use to retrieve the value passed. The <code>short</code> and <code>long</code> options control the
flag the user will be expected to type; short flags look like <code>-f</code> and long
flags look like <code>--file</code>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate clap;

use clap::{Arg, App};

fn main() {
    let matches = App::new(&quot;My Test Program&quot;)
        .version(&quot;0.1.0&quot;)
        .author(&quot;Hackerman Jones &lt;hckrmnjones@hack.gov&gt;&quot;)
        .about(&quot;Teaches argument parsing&quot;)
        .arg(Arg::with_name(&quot;file&quot;)
                 .short(&quot;f&quot;)
                 .long(&quot;file&quot;)
                 .takes_value(true)
                 .help(&quot;A cool file&quot;))
        .arg(Arg::with_name(&quot;num&quot;)
                 .short(&quot;n&quot;)
                 .long(&quot;number&quot;)
                 .takes_value(true)
                 .help(&quot;Five less than your favorite number&quot;))
        .get_matches();

    let myfile = matches.value_of(&quot;file&quot;).unwrap_or(&quot;input.txt&quot;);
    println!(&quot;The file passed is: {}&quot;, myfile);

    let num_str = matches.value_of(&quot;num&quot;);
    match num_str {
        None =&gt; println!(&quot;No idea what your favorite number is.&quot;),
        Some(s) =&gt; {
            match s.parse::&lt;i32&gt;() {
                Ok(n) =&gt; println!(&quot;Your favorite number must be {}.&quot;, n + 5),
                Err(_) =&gt; println!(&quot;That's not a number! {}&quot;, s),
            }
        }
    }
}
</code></pre></pre>
<p>Usage information is generated by <code>clap</code>. The usage for the example application
looks like this.</p>
<pre><code>My Test Program 0.1.0
Hackerman Jones &lt;hckrmnjones@hack.gov&gt;
Teaches argument parsing

USAGE:
    testing [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
    -f, --file &lt;file&gt;     A cool file
    -n, --number &lt;num&gt;    Five less than your favorite number
</code></pre>
<p>We can test the application by running a command like the following.</p>
<pre><code>$ cargo run -- -f myfile.txt -n 251
</code></pre>
<p>The output is:</p>
<pre><code>The file passed is: myfile.txt
Your favorite number must be 256.
</code></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#ansi-terminal" id="ansi-terminal">ANSI Terminal</a></h1>
<h2><a class="header" href="#ansi-terminal-1" id="ansi-terminal-1">ANSI Terminal</a></h2>
<p><a href="https://docs.rs/ansi_term/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=ansi_term" alt="ansi_term-badge" /></a> <a href="https://crates.io/categories/command-line-interface"><img src="https://badge-cache.kominick.com/badge/command_line--x.svg?style=social" alt="cat-command-line-badge" /></a></p>
<p>This program depicts the use of <a href="https://crates.io/crates/ansi_term"><code>ansi_term</code> crate</a> and how it is used for controlling colours and formatting, such as blue bold text or yellow underlined text, on ANSI terminals.</p>
<p>There are two main data structures in [<code>ansi_term</code>]: <a href="https://docs.rs/ansi_term/*/ansi_term/type.ANSIString.html"><code>ANSIString</code></a> and <a href="https://docs.rs/ansi_term/*/ansi_term/struct.Style.html"><code>Style</code></a>. A <a href="https://docs.rs/ansi_term/*/ansi_term/struct.Style.html"><code>Style</code></a> holds stylistic information: colours, whether the text should be bold, or blinking, or whatever. There are also Colour variants that represent simple foreground colour styles. An <a href="https://docs.rs/ansi_term/*/ansi_term/type.ANSIString.html"><code>ANSIString</code></a> is a string paired with a <a href="https://docs.rs/ansi_term/*/ansi_term/struct.Style.html"><code>Style</code></a>.</p>
<p><strong>Note:</strong> British English uses <em>Colour</em> instead of <em>Color</em>, don't get confused</p>
<h3><a class="header" href="#printing-colored-text-to-the-terminal" id="printing-colored-text-to-the-terminal">Printing colored text to the Terminal</a></h3>
<pre><pre class="playpen"><code class="language-rust">extern crate ansi_term;

use ansi_term::Colour;

fn main() {
    println!(&quot;This is {} in color, {} in color and {} in color&quot;,
             Colour::Red.paint(&quot;red&quot;),
             Colour::Blue.paint(&quot;blue&quot;),
             Colour::Green.paint(&quot;green&quot;));
}
</code></pre></pre>
<h3><a class="header" href="#bold-text-in-terminal" id="bold-text-in-terminal">Bold text in Terminal</a></h3>
<p>For anything more complex than plain foreground colour changes, the code
needs to construct <code>Style</code> struct. <a href="https://docs.rs/ansi_term/0.11.0/ansi_term/struct.Style.html#method.new"><code>Style::new()</code></a> creates the struct,
and properties chained.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate ansi_term;

use ansi_term::Style;

fn main() {
    println!(&quot;{} and this is not&quot;,
             Style::new().bold().paint(&quot;This is Bold&quot;));
}
</code></pre></pre>
<h3><a class="header" href="#bold-and-colored-text-in-terminal" id="bold-and-colored-text-in-terminal">Bold and colored text in terminal</a></h3>
<p><code>Colour</code> implements many similar functions as <code>Style</code> and can chain methods.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate ansi_term;

use ansi_term::Colour;
use ansi_term::Style;

fn main(){
    println!(&quot;{}, {} and {}&quot;,
             Colour::Yellow.paint(&quot;This is colored&quot;),
             Style::new().bold().paint(&quot;this is bold&quot;),
             Colour::Yellow.bold().paint(&quot;this is bold and colored&quot;));
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#compression-1" id="compression-1">Compression</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/compression/tar.html#decompress-a-tarball">Decompress a tarball</a></td><td><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a></td><td><a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/compression/tar.html#compress-a-directory-into-tarball">Compress a directory into a tarball</a></td><td><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a></td><td><a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/compression/tar.html#decompress-a-tarball-while-removing-a-prefix-from-the-paths">Decompress a tarball while removing a prefix from the paths</a></td><td><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a></td><td><a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#working-with-tarballs" id="working-with-tarballs">Working with Tarballs</a></h1>
<h2><a class="header" href="#decompress-a-tarball" id="decompress-a-tarball">Decompress a tarball</a></h2>
<p><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></p>
<p>Decompress (<a href="https://docs.rs/flate2/*/flate2/read/struct.GzDecoder.html"><code>GzDecoder</code></a>) and
extract (<a href="https://docs.rs/tar/*/tar/struct.Archive.html#method.unpack"><code>Archive::unpack</code></a>) all files from a compressed tarball
named <code>archive.tar.gz</code> located in the current working directory
to the same location.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate flate2;
extern crate tar;

use std::fs::File;
use flate2::read::GzDecoder;
use tar::Archive;

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let path = &quot;archive.tar.gz&quot;;

    let tar_gz = File::open(path)?;
    let tar = GzDecoder::new(tar_gz);
    let mut archive = Archive::new(tar);
    archive.unpack(&quot;.&quot;)?;

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#compress-a-directory-into-tarball" id="compress-a-directory-into-tarball">Compress a directory into tarball</a></h2>
<p><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></p>
<p>Compress <code>/var/log</code> directory into <code>archive.tar.gz</code>.</p>
<p>Creates a <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> wrapped in <a href="https://docs.rs/flate2/*/flate2/write/struct.GzEncoder.html"><code>GzEncoder</code></a>
and <a href="https://docs.rs/tar/*/tar/struct.Builder.html"><code>tar::Builder</code></a>. </br>Adds contents of <code>/var/log</code> directory recursively into the archive
under <code>backup/logs</code>path with <a href="https://docs.rs/tar/*/tar/struct.Builder.html#method.append_dir_all"><code>Builder::append_dir_all</code></a>.
<a href="https://docs.rs/flate2/*/flate2/write/struct.GzEncoder.html"><code>GzEncoder</code></a> is responsible for transparently compressing the
data prior to writing it into <code>archive.tar.gz</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate tar;
extern crate flate2;

use std::fs::File;
use flate2::Compression;
use flate2::write::GzEncoder;

fn main() -&gt; Result&lt;(), std::io::Error&gt; {
    let tar_gz = File::create(&quot;archive.tar.gz&quot;)?;
    let enc = GzEncoder::new(tar_gz, Compression::default());
    let mut tar = tar::Builder::new(enc);
    tar.append_dir_all(&quot;backup/logs&quot;, &quot;/var/log&quot;)?;
    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#decompress-a-tarball-while-removing-a-prefix-from-the-paths" id="decompress-a-tarball-while-removing-a-prefix-from-the-paths">Decompress a tarball while removing a prefix from the paths</a></h2>
<p><a href="https://docs.rs/flate2/"><img src="https://badge-cache.kominick.com/crates/v/flate2.svg?label=flate2" alt="flate2-badge" /></a> <a href="https://docs.rs/tar/"><img src="https://badge-cache.kominick.com/crates/v/tar.svg?label=tar" alt="tar-badge" /></a> <a href="https://crates.io/categories/compression"><img src="https://badge-cache.kominick.com/badge/compression--x.svg?style=social" alt="cat-compression-badge" /></a></p>
<p>Iterate over the <a href="https://docs.rs/tar/*/tar/struct.Archive.html#method.entries"><code>Archive::entries</code></a>.  Use <a href="https://doc.rust-lang.org/std/path/struct.Path.html#method.strip_prefix"><code>Path::strip_prefix</code></a> to remove
the specified path prefix (<code>bundle/logs</code>).  Finally, extract the <a href="https://docs.rs/tar/*/tar/struct.Entry.html"><code>tar::Entry</code></a>
via <a href="https://docs.rs/tar/*/tar/struct.Entry.html#method.unpack"><code>Entry::unpack</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate flate2;
extern crate tar;

use std::fs::File;
use std::path::PathBuf;
use flate2::read::GzDecoder;
use tar::Archive;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">  foreign_links {
</span><span class="boring">    Io(std::io::Error);
</span><span class="boring">    StripPrefixError(::std::path::StripPrefixError);
</span><span class="boring">  }
</span><span class="boring">}
</span>
fn main() -&gt; Result&lt;()&gt; {
    let file = File::open(&quot;archive.tar.gz&quot;)?;
    let mut archive = Archive::new(GzDecoder::new(file));
    let prefix = &quot;bundle/logs&quot;;

    println!(&quot;Extracted the following files:&quot;);
    archive
        .entries()?
        .filter_map(|e| e.ok())
        .map(|mut entry| -&gt; Result&lt;PathBuf&gt; {
            let path = entry.path()?.strip_prefix(prefix)?.to_owned();
            entry.unpack(&amp;path)?;
            Ok(path)
        })
        .filter_map(|e| e.ok())
        .for_each(|x| println!(&quot;&gt; {}&quot;, x.display()));

    Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#concurrency-2" id="concurrency-2">Concurrency</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/concurrency/threads.html#spawn-a-short-lived-thread">Spawn a short-lived thread</a></td><td><a href="https://docs.rs/crossbeam/"><img src="https://badge-cache.kominick.com/crates/v/crossbeam.svg?label=crossbeam" alt="crossbeam-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/threads.html#maintain-global-mutable-state">Maintain global mutable state</a></td><td><a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/threads.html#calculate-sha1-sum-of-iso-files-concurrently">Calculate SHA1 sum of *.iso files concurrently</a></td><td><a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/threads.html#draw-fractal-dispatching-work-to-a-thread-pool">Draw fractal dispatching work to a thread pool</a></td><td><a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a><a href="https://crates.io/categories/rendering"><img src="https://badge-cache.kominick.com/badge/rendering--x.svg?style=social" alt="cat-rendering-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#mutate-the-elements-of-an-array-in-parallel">Mutate the elements of an array in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#test-in-parallel-if-any-or-all-elements-of-a-collection-match-a-given-predicate">Test in parallel if any or all elements of a collection match a given predicate</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#search-items-using-given-predicate-in-parallel">Search items using given predicate in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#sort-a-vector-in-parallel">Sort a vector in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#map-reduce-in-parallel">Map-reduce in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/concurrency/parallel.html#generate-jpg-thumbnails-in-parallel">Generate jpg thumbnails in parallel</a></td><td><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a></td><td><a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#threads-1" id="threads-1">Threads</a></h1>
<h2><a class="header" href="#spawn-a-short-lived-thread" id="spawn-a-short-lived-thread">Spawn a short-lived thread</a></h2>
<p><a href="https://docs.rs/crossbeam/"><img src="https://badge-cache.kominick.com/crates/v/crossbeam.svg?label=crossbeam" alt="crossbeam-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>The example uses the <a href="https://docs.rs/crossbeam/">crossbeam</a> crate, which provides data structures and functions
for concurrent and parallel programming. <a href="https://docs.rs/crossbeam/*/crossbeam/thread/struct.Scope.html#method.spawn"><code>Scope::spawn</code></a> spawns a new scoped thread that is guaranteed
to terminate before returning from the closure that passed into <a href="https://docs.rs/crossbeam/*/crossbeam/fn.scope.html"><code>crossbeam::scope</code></a> function, meaning that
you can reference data from the calling function.</p>
<p>This example splits the array in half and performs the work in separate threads.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate crossbeam;

fn main() {
    let arr = &amp;[1, 25, -4, 10];
    let max = find_max(arr);
    assert_eq!(max, Some(25));
}

fn find_max(arr: &amp;[i32]) -&gt; Option&lt;i32&gt; {
    const THRESHOLD: usize = 2;
  
    if arr.len() &lt;= THRESHOLD {
        return arr.iter().cloned().max();
    }

    let mid = arr.len() / 2;
    let (left, right) = arr.split_at(mid);
  
    crossbeam::scope(|s| {
        let thread_l = s.spawn(|_| find_max(left));
        let thread_r = s.spawn(|_| find_max(right));
  
        let min_l = thread_l.join().unwrap()?;
        let min_r = thread_r.join().unwrap()?;
  
        Some(min_l.max(min_r))
    }).unwrap()
}
</code></pre></pre>
<h2><a class="header" href="#maintain-global-mutable-state" id="maintain-global-mutable-state">Maintain global mutable state</a></h2>
<p><a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p>Declare global state using <a href="https://docs.rs/lazy_static/">lazy_static</a>. <a href="https://docs.rs/lazy_static/">lazy_static</a>
creates a globally available <code>static ref</code> which requires a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>
to allow mutation (also see <a href="https://doc.rust-lang.org/std/sync/struct.RwLock.html"><code>RwLock</code></a>). The <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a> wrap ensures
the state cannot be simultaneously accessed by multiple threads, preventing
race conditions. A <a href="https://doc.rust-lang.org/std/sync/struct.MutexGuard.html"><code>MutexGuard</code></a> must be acquired to read or mutate the
value stored in a <a href="https://doc.rust-lang.org/std/sync/struct.Mutex.html"><code>Mutex</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>#[macro_use]
extern crate lazy_static;

use std::sync::Mutex;
<span class="boring">
</span><span class="boring">error_chain!{ }
</span>
lazy_static! {
    static ref FRUIT: Mutex&lt;Vec&lt;String&gt;&gt; = Mutex::new(Vec::new());
}

fn insert(fruit: &amp;str) -&gt; Result&lt;()&gt; {
    let mut db = FRUIT.lock().map_err(|_| &quot;Failed to acquire MutexGuard&quot;)?;
    db.push(fruit.to_string());
    Ok(())
}

fn run() -&gt; Result&lt;()&gt; {
    insert(&quot;apple&quot;)?;
    insert(&quot;orange&quot;)?;
    insert(&quot;peach&quot;)?;
    {
        let db = FRUIT.lock().map_err(|_| &quot;Failed to acquire MutexGuard&quot;)?;

        db.iter().enumerate().for_each(|(i, item)| println!(&quot;{}: {}&quot;, i, item));
    }
    insert(&quot;grape&quot;)?;
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#calculate-sha1-sum-of-iso-files-concurrently" id="calculate-sha1-sum-of-iso-files-concurrently">Calculate SHA1 sum of iso files concurrently</a></h2>
<p><a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>This example calculates the SHA1 for every file with iso extension in the
current directory. A threadpool generates threads equal to the number of cores
present in the system found with <a href="https://docs.rs/num_cpus/*/num_cpus/fn.get.html"><code>num_cpus::get</code></a>.  <a href="https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.new"><code>Walkdir::new</code></a> iterates
the current directory and calls <a href="https://docs.rs/threadpool/*/threadpool/struct.ThreadPool.html#method.execute"><code>execute</code></a> to perform the operations of reading
and computing SHA1 hash.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate walkdir;
extern crate ring;
extern crate num_cpus;
extern crate threadpool;

use walkdir::WalkDir;
use std::fs::File;
use std::io::{BufReader, Read, Error};
use std::path::Path;
use threadpool::ThreadPool;
use std::sync::mpsc::channel;
use ring::digest::{Context, Digest, SHA1};

<span class="boring">// Verify the iso extension
</span><span class="boring">fn is_iso(entry: &amp;Path) -&gt; bool {
</span><span class="boring">    match entry.extension() {
</span><span class="boring">        Some(e) if e.to_string_lossy().to_lowercase() == &quot;iso&quot; =&gt; true,
</span><span class="boring">        _ =&gt; false,
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn compute_digest&lt;P: AsRef&lt;Path&gt;&gt;(filepath: P) -&gt; Result&lt;(Digest, P), Error&gt; {
    let mut buf_reader = BufReader::new(File::open(&amp;filepath)?);
    let mut context = Context::new(&amp;SHA1);
    let mut buffer = [0; 1024];

    loop {
        let count = buf_reader.read(&amp;mut buffer)?;
        if count == 0 {
            break;
        }
        context.update(&amp;buffer[..count]);
    }

    Ok((context.finish(), filepath))
}

fn main() -&gt; Result&lt;(), Error&gt; {
    let pool = ThreadPool::new(num_cpus::get());

    let (tx, rx) = channel();

    for entry in WalkDir::new(&quot;/home/user/Downloads&quot;)
        .follow_links(true)
        .into_iter()
        .filter_map(|e| e.ok())
        .filter(|e| !e.path().is_dir() &amp;&amp; is_iso(e.path())) {
            let path = entry.path().to_owned();
            let tx = tx.clone();
            pool.execute(move || {
                let digest = compute_digest(path);
                tx.send(digest).expect(&quot;Could not send data!&quot;);
            });
        }

    drop(tx);
    for t in rx.iter() {
        let (sha, path) = t?;
        println!(&quot;{:?} {:?}&quot;, sha, path);
    }
    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#draw-fractal-dispatching-work-to-a-thread-pool" id="draw-fractal-dispatching-work-to-a-thread-pool">Draw fractal dispatching work to a thread pool</a></h2>
<p><a href="https://docs.rs/threadpool/"><img src="https://badge-cache.kominick.com/crates/v/threadpool.svg?label=threadpool" alt="threadpool-badge" /></a> <a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a><a href="https://crates.io/categories/rendering"><img src="https://badge-cache.kominick.com/badge/rendering--x.svg?style=social" alt="cat-rendering-badge" /></a></p>
<p>This example generates an image by drawing a fractal from the <a href="https://en.wikipedia.org/wiki/Julia_set">Julia set</a>
with a thread pool for distributed computation.</p>
<p><a href="https://cloud.githubusercontent.com/assets/221000/26546700/9be34e80-446b-11e7-81dc-dd9871614ea1.png"><img src="https://cloud.githubusercontent.com/assets/221000/26546700/9be34e80-446b-11e7-81dc-dd9871614ea1.png" width="150" /></a></p>
<p>Allocate memory for output image of given width and height with <a href="https://docs.rs/image/*/image/struct.ImageBuffer.html#method.new"><code>ImageBuffer::new</code></a>.
<a href="https://docs.rs/image/*/image/struct.Rgb.html#method.from_channels"><code>Rgb::from_channels</code></a> calculates RGB pixel values.
Create <a href="https://docs.rs/threadpool/*/threadpool/struct.ThreadPool.html"><code>ThreadPool</code></a> with thread count equal to number of cores with <a href="https://docs.rs/num_cpus/*/num_cpus/fn.get.html"><code>num_cpus::get</code></a>.
<a href="https://docs.rs/threadpool/*/threadpool/struct.ThreadPool.html#method.execute"><code>ThreadPool::execute</code></a> receives each pixel as a separate job.</p>
<p><a href="https://doc.rust-lang.org/std/sync/mpsc/fn.channel.html"><code>mpsc::channel</code></a> receives the jobs and <a href="https://doc.rust-lang.org/std/sync/mpsc/struct.Receiver.html#method.recv"><code>Receiver::recv</code></a> retrieves them.
<a href="https://docs.rs/image/*/image/struct.ImageBuffer.html#method.put_pixel"><code>ImageBuffer::put_pixel</code></a> uses the data to set the pixel color.
<a href="https://docs.rs/image/*/image/struct.ImageBuffer.html#method.save"><code>ImageBuffer::save</code></a> writes the image to <code>output.png</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate threadpool;
extern crate num;
extern crate num_cpus;
extern crate image;

use std::sync::mpsc::{channel, RecvError};
use threadpool::ThreadPool;
use num::complex::Complex;
use image::{ImageBuffer, Pixel, Rgb};
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        MpscRecv(RecvError);
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Function converting intensity values to RGB
</span><span class="boring">// Based on http://www.efg2.com/Lab/ScienceAndEngineering/Spectra.htm
</span><span class="boring">fn wavelength_to_rgb(wavelength: u32) -&gt; Rgb&lt;u8&gt; {
</span><span class="boring">    let wave = wavelength as f32;
</span><span class="boring">
</span><span class="boring">    let (r, g, b) = match wavelength {
</span><span class="boring">        380...439 =&gt; ((440. - wave) / (440. - 380.), 0.0, 1.0),
</span><span class="boring">        440...489 =&gt; (0.0, (wave - 440.) / (490. - 440.), 1.0),
</span><span class="boring">        490...509 =&gt; (0.0, 1.0, (510. - wave) / (510. - 490.)),
</span><span class="boring">        510...579 =&gt; ((wave - 510.) / (580. - 510.), 1.0, 0.0),
</span><span class="boring">        580...644 =&gt; (1.0, (645. - wave) / (645. - 580.), 0.0),
</span><span class="boring">        645...780 =&gt; (1.0, 0.0, 0.0),
</span><span class="boring">        _ =&gt; (0.0, 0.0, 0.0),
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let factor = match wavelength {
</span><span class="boring">        380...419 =&gt; 0.3 + 0.7 * (wave - 380.) / (420. - 380.),
</span><span class="boring">        701...780 =&gt; 0.3 + 0.7 * (780. - wave) / (780. - 700.),
</span><span class="boring">        _ =&gt; 1.0,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let (r, g, b) = (normalize(r, factor), normalize(g, factor), normalize(b, factor));
</span><span class="boring">    Rgb::from_channels(r, g, b, 0)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Maps Julia set distance estimation to intensity values
</span><span class="boring">fn julia(c: Complex&lt;f32&gt;, x: u32, y: u32, width: u32, height: u32, max_iter: u32) -&gt; u32 {
</span><span class="boring">    let width = width as f32;
</span><span class="boring">    let height = height as f32;
</span><span class="boring">
</span><span class="boring">    let mut z = Complex {
</span><span class="boring">        // scale and translate the point to image coordinates
</span><span class="boring">        re: 3.0 * (x as f32 - 0.5 * width) / width,
</span><span class="boring">        im: 2.0 * (y as f32 - 0.5 * height) / height,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    let mut i = 0;
</span><span class="boring">    for t in 0..max_iter {
</span><span class="boring">        if z.norm() &gt;= 2.0 {
</span><span class="boring">            break;
</span><span class="boring">        }
</span><span class="boring">        z = z * z + c;
</span><span class="boring">        i = t;
</span><span class="boring">    }
</span><span class="boring">    i
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// Normalizes color intensity values within RGB range
</span><span class="boring">fn normalize(color: f32, factor: f32) -&gt; u8 {
</span><span class="boring">    ((color * factor).powf(0.8) * 255.) as u8
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let (width, height) = (1920, 1080);
    let mut img = ImageBuffer::new(width, height);
    let iterations = 300;

    let c = Complex::new(-0.8, 0.156);

    let pool = ThreadPool::new(num_cpus::get());
    let (tx, rx) = channel();

    for y in 0..height {
        let tx = tx.clone();
        pool.execute(move || for x in 0..width {
                         let i = julia(c, x, y, width, height, iterations);
                         let pixel = wavelength_to_rgb(380 + i * 400 / iterations);
                         tx.send((x, y, pixel)).expect(&quot;Could not send data!&quot;);
                     });
    }

    for _ in 0..(width * height) {
        let (x, y, pixel) = rx.recv()?;
        img.put_pixel(x, y, pixel);
    }
    let _ = img.save(&quot;output.png&quot;)?;
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#parallel-tasks" id="parallel-tasks">Parallel Tasks</a></h1>
<h2><a class="header" href="#mutate-the-elements-of-an-array-in-parallel" id="mutate-the-elements-of-an-array-in-parallel">Mutate the elements of an array in parallel</a></h2>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>The example uses the <code>rayon</code> crate, which is a data parallelism library for Rust.
<code>rayon</code> provides the <a href="https://docs.rs/rayon/*/rayon/iter/trait.IntoParallelRefMutIterator.html#tymethod.par_iter_mut"><code>par_iter_mut</code></a> method for any parallel iterable data type.
This is an iterator-like chain that potentially executes in parallel.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

fn main() {
    let mut arr = [0, 7, 9, 11];
    arr.par_iter_mut().for_each(|p| *p -= 1);
    println!(&quot;{:?}&quot;, arr);
}
</code></pre></pre>
<h2><a class="header" href="#test-in-parallel-if-any-or-all-elements-of-a-collection-match-a-given-predicate" id="test-in-parallel-if-any-or-all-elements-of-a-collection-match-a-given-predicate">Test in parallel if any or all elements of a collection match a given predicate</a></h2>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>This example demonstrates using the <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.any"><code>rayon::any</code></a> and <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.all"><code>rayon::all</code></a> methods, which are parallelized counterparts to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.any"><code>std::any</code></a> and <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.all"><code>std::all</code></a>. <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.any"><code>rayon::any</code></a> checks in parallel whether any element of the iterator matches the predicate, and returns as soon as one is found. <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.all"><code>rayon::all</code></a> checks in parallel whether all elements of the iterator match the predicate, and returns as soon as a non-matching element is found.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

fn main() {
    let mut vec = vec![2, 4, 6, 8];

    assert!(!vec.par_iter().any(|n| (*n % 2) != 0));
    assert!(vec.par_iter().all(|n| (*n % 2) == 0));
    assert!(!vec.par_iter().any(|n| *n &gt; 8 ));
    assert!(vec.par_iter().all(|n| *n &lt;= 8 ));

    vec.push(9);

    assert!(vec.par_iter().any(|n| (*n % 2) != 0));
    assert!(!vec.par_iter().all(|n| (*n % 2) == 0));
    assert!(vec.par_iter().any(|n| *n &gt; 8 ));
    assert!(!vec.par_iter().all(|n| *n &lt;= 8 )); 
}
</code></pre></pre>
<h2><a class="header" href="#search-items-using-given-predicate-in-parallel" id="search-items-using-given-predicate-in-parallel">Search items using given predicate in parallel</a></h2>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>This example uses <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.find_any"><code>rayon::find_any</code></a> and <a href="https://docs.rs/rayon/*/rayon/iter/trait.IntoParallelRefIterator.html#tymethod.par_iter"><code>par_iter</code></a> to search a vector in
parallel for an element satisfying the predicate in the given closure.</p>
<p>If there are multiple elements satisfying the predicate defined in the closure
argument of <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.find_any"><code>rayon::find_any</code></a>, <code>rayon</code> returns the first one found, not
necessarily the first one.</p>
<p>Also note that the argument to the closure is a reference to a reference
(<code>&amp;&amp;x</code>). See the discussion on <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.find"><code>std::find</code></a> for additional details.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

fn main() {
    let v = vec![6, 2, 1, 9, 3, 8, 11];

    let f1 = v.par_iter().find_any(|&amp;&amp;x| x == 9);
    let f2 = v.par_iter().find_any(|&amp;&amp;x| x % 2 == 0 &amp;&amp; x &gt; 6);
    let f3 = v.par_iter().find_any(|&amp;&amp;x| x &gt; 8);

    assert_eq!(f1, Some(&amp;9));
    assert_eq!(f2, Some(&amp;8));
    assert!(f3 &gt; Some(&amp;8));
}
</code></pre></pre>
<h2><a class="header" href="#sort-a-vector-in-parallel" id="sort-a-vector-in-parallel">Sort a vector in parallel</a></h2>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/rand/"><img src="https://badge-cache.kominick.com/crates/v/rand.svg?label=rand" alt="rand-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>This example will sort in parallel a vector of Strings.</p>
<p>Allocate a vector of empty Strings. <code>par_iter_mut().for_each</code> populates random
values in parallel.  Although <a href="https://docs.rs/rayon/*/rayon/slice/trait.ParallelSliceMut.html">multiple options</a>
exist to sort an enumerable data type, <a href="https://docs.rs/rayon/*/rayon/slice/trait.ParallelSliceMut.html#method.par_sort_unstable"><code>par_sort_unstable</code></a>
is usually faster than <a href="https://docs.rs/rayon/*/rayon/slice/trait.ParallelSliceMut.html#method.par_sort">stable sorting</a> algorithms.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rand;
extern crate rayon;

use rand::{Rng, thread_rng};
use rand::distributions::Alphanumeric;
use rayon::prelude::*;

fn main() {
  let mut vec = vec![String::new(); 100_000];
  vec.par_iter_mut().for_each(|p| {
    let mut rng = thread_rng();
    *p = (0..5).map(|_| rng.sample(&amp;Alphanumeric)).collect()
  });
  vec.par_sort_unstable();
}
</code></pre></pre>
<h2><a class="header" href="#map-reduce-in-parallel" id="map-reduce-in-parallel">Map-reduce in parallel</a></h2>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a></p>
<p>This example uses <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.filter"><code>rayon::filter</code></a>, <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.map"><code>rayon::map</code></a>, and <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.reduce"><code>rayon::reduce</code></a>
to calculate the average age of <code>Person</code> objects whose age is over 30.</p>
<p><a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.filter"><code>rayon::filter</code></a> returns elements from a collection that satisfy the given
predicate.  <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.map"><code>rayon::map</code></a> performs an operation on every element, creating a
new iteration, and <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.reduce"><code>rayon::reduce</code></a> performs an operation given the previous
reduction and the current element.  Also shows use of <a href="https://docs.rs/rayon/*/rayon/iter/trait.ParallelIterator.html#method.sum"><code>rayon::sum</code></a>,
which has the same result as the reduce operation in this example.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate rayon;

use rayon::prelude::*;

struct Person {
    age: u32,
}

fn main() {
    let v: Vec&lt;Person&gt; = vec![
        Person { age: 23 },
        Person { age: 19 },
        Person { age: 42 },
        Person { age: 17 },
        Person { age: 17 },
        Person { age: 31 },
        Person { age: 30 },
    ];

    let num_over_30 = v.par_iter().filter(|&amp;x| x.age &gt; 30).count() as f32;
    let sum_over_30 = v.par_iter()
        .map(|x| x.age)
        .filter(|&amp;x| x &gt; 30)
        .reduce(|| 0, |x, y| x + y);

    let alt_sum_30: u32 = v.par_iter()
        .map(|x| x.age)
        .filter(|&amp;x| x &gt; 30)
        .sum();

    let avg_over_30 = sum_over_30 as f32 / num_over_30;
    let alt_avg_over_30 = alt_sum_30 as f32/ num_over_30;

    assert!((avg_over_30 - alt_avg_over_30).abs() &lt; std::f32::EPSILON);
    println!(&quot;The average age of people older than 30 is {}&quot;, avg_over_30);
}
</code></pre></pre>
<h2><a class="header" href="#generate-jpg-thumbnails-in-parallel" id="generate-jpg-thumbnails-in-parallel">Generate jpg thumbnails in parallel</a></h2>
<p><a href="https://docs.rs/rayon/"><img src="https://badge-cache.kominick.com/crates/v/rayon.svg?label=rayon" alt="rayon-badge" /></a> <a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://docs.rs/image/"><img src="https://badge-cache.kominick.com/crates/v/image.svg?label=image" alt="image-badge" /></a> <a href="https://crates.io/categories/concurrency"><img src="https://badge-cache.kominick.com/badge/concurrency--x.svg?style=social" alt="cat-concurrency-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>This example generates thumbnails for all .jpg files in the current directory
then saves them in a new folder called <code>thumbnails</code>.</p>
<p><a href="https://docs.rs/glob/*/glob/fn.glob_with.html"><code>glob::glob_with</code></a> finds jpeg files in current directory. <code>rayon</code> resizes
images in parallel using <a href="https://docs.rs/rayon/*/rayon/iter/trait.IntoParallelRefIterator.html#tymethod.par_iter"><code>par_iter</code></a> calling  <a href="https://docs.rs/image/*/image/enum.DynamicImage.html#method.resize"><code>DynamicImage::resize</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate glob;
extern crate image;
extern crate rayon;

use std::path::Path;
use std::fs::create_dir_all;

<span class="boring">use error_chain::ChainedError;
</span>use glob::{glob_with, MatchOptions};
use image::{FilterType, ImageError};
use rayon::prelude::*;

<span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Image(ImageError);
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        Glob(glob::PatternError);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let options: MatchOptions = Default::default();
    let files: Vec&lt;_&gt; = glob_with(&quot;*.jpg&quot;, &amp;options)?
        .filter_map(|x| x.ok())
        .collect();

    if files.len() == 0 {
        bail!(&quot;No .jpg files found in current directory&quot;);
    }

    let thumb_dir = &quot;thumbnails&quot;;
    create_dir_all(thumb_dir)?;

    println!(&quot;Saving {} thumbnails into '{}'...&quot;, files.len(), thumb_dir);

    let image_failures: Vec&lt;_&gt; = files
        .par_iter()
        .map(|path| {
            make_thumbnail(path, thumb_dir, 300)
                .map_err(|e| e.chain_err(|| path.display().to_string()))
        })
        .filter_map(|x| x.err())
        .collect();

    image_failures.iter().for_each(|x| println!(&quot;{}&quot;, x.display_chain()));

    println!(&quot;{} thumbnails saved successfully&quot;, files.len() - image_failures.len());
    Ok(())
}

fn make_thumbnail&lt;PA, PB&gt;(original: PA, thumb_dir: PB, longest_edge: u32) -&gt; Result&lt;()&gt;
where
    PA: AsRef&lt;Path&gt;,
    PB: AsRef&lt;Path&gt;,
{
    let img = image::open(original.as_ref())?;
    let file_path = thumb_dir.as_ref().join(original);

    Ok(img.resize(longest_edge, longest_edge, FilterType::Nearest)
        .save(file_path)?)
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#cryptography-1" id="cryptography-1">Cryptography</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/cryptography/hashing.html#calculate-the-sha-256-digest-of-a-file">Calculate the SHA-256 digest of a file</a></td><td><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a></td><td><a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/cryptography/hashing.html#sign-and-verify-a-message-with-hmac-digest">Sign and verify a message with an HMAC digest</a></td><td><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a></td><td><a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/cryptography/encryption.html#salt-and-hash-a-password-with-pbkdf2">Salt and hash a password with PBKDF2</a></td><td><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a></td><td><a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#hashing" id="hashing">Hashing</a></h1>
<h2><a class="header" href="#calculate-the-sha-256-digest-of-a-file" id="calculate-the-sha-256-digest-of-a-file">Calculate the SHA-256 digest of a file</a></h2>
<p><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></p>
<p>Writes some data to a file, then calculates the SHA-256 <a href="https://briansmith.org/rustdoc/ring/digest/struct.Digest.html"><code>digest::Digest</code></a> of
the file's contents using <a href="https://briansmith.org/rustdoc/ring/digest/struct.Context.html"><code>digest::Context</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate data_encoding;
extern crate ring;

use data_encoding::HEXUPPER;
use ring::digest::{Context, Digest, SHA256};
use std::fs::File;
use std::io::{BufReader, Read, Write};
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        Decode(data_encoding::DecodeError);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn sha256_digest&lt;R: Read&gt;(mut reader: R) -&gt; Result&lt;Digest&gt; {
    let mut context = Context::new(&amp;SHA256);
    let mut buffer = [0; 1024];

    loop {
        let count = reader.read(&amp;mut buffer)?;
        if count == 0 {
            break;
        }
        context.update(&amp;buffer[..count]);
    }

    Ok(context.finish())
}

fn run() -&gt; Result&lt;()&gt; {
    let path = &quot;file.txt&quot;;

    let mut output = File::create(path)?;
    write!(output, &quot;We will generate a digest of this text&quot;)?;

    let input = File::open(path)?;
    let reader = BufReader::new(input);
    let digest = sha256_digest(reader)?;

    println!(&quot;SHA-256 digest is {}&quot;, HEXUPPER.encode(digest.as_ref()));

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#sign-and-verify-a-message-with-hmac-digest" id="sign-and-verify-a-message-with-hmac-digest">Sign and verify a message with HMAC digest</a></h2>
<p><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></p>
<p>Uses <a href="https://briansmith.org/rustdoc/ring/hmac/"><code>ring::hmac</code></a> to creates a <a href="https://briansmith.org/rustdoc/ring/hmac/struct.Signature.html"><code>hmac::Signature</code></a> of a string then verifies the signature is correct.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate ring;

use ring::{digest, hmac, rand};
use ring::rand::SecureRandom;
use ring::error::Unspecified;

fn main() -&gt; Result&lt;(), Unspecified&gt; {
    let mut key_value = [0u8; 48];
    let rng = rand::SystemRandom::new();
    rng.fill(&amp;mut key_value)?;
    let key = hmac::SigningKey::new(&amp;digest::SHA256, &amp;key_value);

    let message = &quot;Legitimate and important message.&quot;;
    let signature = hmac::sign(&amp;key, message.as_bytes());
    hmac::verify_with_own_key(&amp;key, message.as_bytes(), signature.as_ref())?;

    Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#encryption" id="encryption">Encryption</a></h1>
<p><a name="ex-pbkdf2"></a></p>
<h2><a class="header" href="#salt-and-hash-a-password-with-pbkdf2" id="salt-and-hash-a-password-with-pbkdf2">Salt and hash a password with PBKDF2</a></h2>
<p><a href="https://briansmith.org/rustdoc/ring/"><img src="https://badge-cache.kominick.com/crates/v/ring.svg?label=ring" alt="ring-badge" /></a> <a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> <a href="https://crates.io/categories/cryptography"><img src="https://badge-cache.kominick.com/badge/cryptography--x.svg?style=social" alt="cat-cryptography-badge" /></a></p>
<p>Uses <a href="https://briansmith.org/rustdoc/ring/pbkdf2/index.html"><code>ring::pbkdf2</code></a> to hash a salted password using the PBKDF2 key derivation
function <a href="https://briansmith.org/rustdoc/ring/pbkdf2/fn.derive.html"><code>pbkdf2::derive</code></a>.  Verifies the hash is correct with
<a href="https://briansmith.org/rustdoc/ring/pbkdf2/fn.verify.html"><code>pbkdf2::verify</code></a>. The salt is generated using
<a href="https://briansmith.org/rustdoc/ring/rand/trait.SecureRandom.html#tymethod.fill"><code>SecureRandom::fill</code></a>, which fills the salt byte array with
securely generated random numbers.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate ring;
extern crate data_encoding;

use data_encoding::HEXUPPER;
use ring::error::Unspecified;
use ring::rand::SecureRandom;
use ring::{digest, pbkdf2, rand};

fn main() -&gt; Result&lt;(), Unspecified&gt; {
    const CREDENTIAL_LEN: usize = digest::SHA512_OUTPUT_LEN;
    const N_ITER: u32 = 100_000;
    let rng = rand::SystemRandom::new();

    let mut salt = [0u8; CREDENTIAL_LEN];
    rng.fill(&amp;mut salt)?;

    let password = &quot;Guess Me If You Can!&quot;;
    let mut pbkdf2_hash = [0u8; CREDENTIAL_LEN];
    pbkdf2::derive(
        &amp;digest::SHA512,
        N_ITER,
        &amp;salt,
        password.as_bytes(),
        &amp;mut pbkdf2_hash,
    );
    println!(&quot;Salt: {}&quot;, HEXUPPER.encode(&amp;salt));
    println!(&quot;PBKDF2 hash: {}&quot;, HEXUPPER.encode(&amp;pbkdf2_hash));

    let should_succeed = pbkdf2::verify(
        &amp;digest::SHA512,
		N_ITER,
        &amp;salt,
        password.as_bytes(),
        &amp;pbkdf2_hash,
    );
    let wrong_password = &quot;Definitely not the correct password&quot;;
    let should_fail = pbkdf2::verify(
        &amp;digest::SHA512,
        N_ITER,
        &amp;salt,
        wrong_password.as_bytes(),
        &amp;pbkdf2_hash,
    );

    assert!(should_succeed.is_ok());
    assert!(!should_fail.is_ok());

    Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#data-structures-1" id="data-structures-1">Data Structures</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/data_structures/bitfield.html#define-and-operate-on-a-type-represented-as-a-bitfield">Define and operate on a type represented as a bitfield</a></td><td><a href="https://docs.rs/bitflags/"><img src="https://badge-cache.kominick.com/crates/v/bitflags.svg?label=bitflags" alt="bitflags-badge" /></a></td><td><a href="https://crates.io/categories/no-std"><img src="https://badge-cache.kominick.com/badge/no_std--x.svg?style=social" alt="cat-no-std-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#custom-1" id="custom-1">Custom</a></h1>
<h2><a class="header" href="#define-and-operate-on-a-type-represented-as-a-bitfield" id="define-and-operate-on-a-type-represented-as-a-bitfield">Define and operate on a type represented as a bitfield</a></h2>
<p><a href="https://docs.rs/bitflags/"><img src="https://badge-cache.kominick.com/crates/v/bitflags.svg?label=bitflags" alt="bitflags-badge" /></a> <a href="https://crates.io/categories/no-std"><img src="https://badge-cache.kominick.com/badge/no_std--x.svg?style=social" alt="cat-no-std-badge" /></a></p>
<p>Creates type safe bitfield type <code>MyFlags</code> with help of <a href="https://docs.rs/bitflags/*/bitflags/macro.bitflags.html"><code>bitflags!</code></a> macro
and implements elementary <code>clear</code> operation as well as <a href="https://doc.rust-lang.org/std/fmt/trait.Display.html"><code>Display</code></a> trait for it.
Subsequently, shows basic bitwise operations and formatting.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate bitflags;

use std::fmt;

bitflags! {
    struct MyFlags: u32 {
        const FLAG_A       = 0b00000001;
        const FLAG_B       = 0b00000010;
        const FLAG_C       = 0b00000100;
        const FLAG_ABC     = Self::FLAG_A.bits
                           | Self::FLAG_B.bits
                           | Self::FLAG_C.bits;
    }
}

impl MyFlags {
    pub fn clear(&amp;mut self) -&gt; &amp;mut MyFlags {
        self.bits = 0;  
        self
    }
}

impl fmt::Display for MyFlags {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;{:032b}&quot;, self.bits)
    }
}

fn main() {
    let e1 = MyFlags::FLAG_A | MyFlags::FLAG_C;
    let e2 = MyFlags::FLAG_B | MyFlags::FLAG_C;
    assert_eq!((e1 | e2), MyFlags::FLAG_ABC);   
    assert_eq!((e1 &amp; e2), MyFlags::FLAG_C);    
    assert_eq!((e1 - e2), MyFlags::FLAG_A);    
    assert_eq!(!e2, MyFlags::FLAG_A);           

    let mut flags = MyFlags::FLAG_ABC;
    assert_eq!(format!(&quot;{}&quot;, flags), &quot;00000000000000000000000000000111&quot;);
    assert_eq!(format!(&quot;{}&quot;, flags.clear()), &quot;00000000000000000000000000000000&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, MyFlags::FLAG_B), &quot;FLAG_B&quot;);
    assert_eq!(format!(&quot;{:?}&quot;, MyFlags::FLAG_A | MyFlags::FLAG_B), &quot;FLAG_A | FLAG_B&quot;);
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#database-1" id="database-1">Database</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/database/sqlite.html#create-a-sqlite-database">Create a SQLite database</a></td><td><a href="https://crates.io/crates/rusqlite/"><img src="https://badge-cache.kominick.com/crates/v/rusqlite.svg?label=rusqlite" alt="rusqlite-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/database/sqlite.html#insert-and-select-data">Insert and Query data</a></td><td><a href="https://crates.io/crates/rusqlite/"><img src="https://badge-cache.kominick.com/crates/v/rusqlite.svg?label=rusqlite" alt="rusqlite-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/database/postgres.html#create-tables-in-a-postgres-database">Create tables in a Postgres database</a></td><td><a href="https://docs.rs/postgres/0.15.2/postgres/"><img src="https://badge-cache.kominick.com/crates/v/postgres.svg?label=postgres" alt="postgres-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/database/postgres.html#insert-and-query-data">Insert and Query data</a></td><td><a href="https://docs.rs/postgres/0.15.2/postgres/"><img src="https://badge-cache.kominick.com/crates/v/postgres.svg?label=postgres" alt="postgres-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/database/postgres.html#aggregate-data">Aggregate data</a></td><td><a href="https://docs.rs/postgres/0.15.2/postgres/"><img src="https://badge-cache.kominick.com/crates/v/postgres.svg?label=postgres" alt="postgres-badge" /></a></td><td><a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#sqlite" id="sqlite">SQLite</a></h1>
<h2><a class="header" href="#create-a-sqlite-database" id="create-a-sqlite-database">Create a SQLite database</a></h2>
<p><a href="https://crates.io/crates/rusqlite/"><img src="https://badge-cache.kominick.com/crates/v/rusqlite.svg?label=rusqlite" alt="rusqlite-badge" /></a> <a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></p>
<p>Use the <code>rusqlite</code> crate to open SQLite databases. See
<a href="https://github.com/jgallagher/rusqlite#user-content-notes-on-building-rusqlite-and-libsqlite3-sys">crate</a> for compiling on Windows.</p>
<p><a href="https://docs.rs/rusqlite/*/rusqlite/struct.Connection.html#method.open"><code>Connection::open</code></a> will create the database if it doesn't already exist.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate rusqlite;

use rusqlite::{Connection, Result};
use rusqlite::NO_PARAMS;

fn main() -&gt; Result&lt;()&gt; {
    let conn = Connection::open(&quot;cats.db&quot;)?;

    conn.execute(
        &quot;create table if not exists cat_colors (
             id integer primary key,
             name text not null unique
         )&quot;,
        NO_PARAMS,
    )?;
    conn.execute(
        &quot;create table if not exists cats (
             id integer primary key,
             name text not null,
             color_id integer not null references cat_colors(id)
         )&quot;,
        NO_PARAMS,
    )?;

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#insert-and-select-data" id="insert-and-select-data">Insert and Select data</a></h2>
<p><a href="https://crates.io/crates/rusqlite/"><img src="https://badge-cache.kominick.com/crates/v/rusqlite.svg?label=rusqlite" alt="rusqlite-badge" /></a> <a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></p>
<p><a href="https://docs.rs/rusqlite/*/rusqlite/struct.Connection.html#method.open"><code>Connection::open</code></a> will open the database <code>cats</code> created in the earlier recipe.
This recipe inserts data into <code>cat_colors</code> and <code>cats</code> tables using the <a href="https://docs.rs/rusqlite/*/rusqlite/struct.Connection.html#method.execute"><code>execute</code></a> method of <code>Connection</code>. First, the data is inserted into the <code>cat_colors</code> table. After a record for a color is inserted, <a href="https://docs.rs/rusqlite/*/rusqlite/struct.Connection.html#method.last_insert_rowid"><code>last_insert_rowid</code></a> method of <code>Connection</code> is used to get <code>id</code> of the last color inserted. This <code>id</code> is used while inserting data into the <code>cats</code> table. Then, the select query is prepared using the <a href="https://docs.rs/rusqlite/*/rusqlite/struct.Connection.html#method.prepare"><code>prepare</code></a> method which gives a <a href="https://docs.rs/rusqlite/*/rusqlite/struct.Statement.html"><code>statement</code></a> struct. Then, query is executed using <a href="https://docs.rs/rusqlite/*/rusqlite/struct.Statement.html#method.query_map"><code>query_map</code></a> method of <a href="https://docs.rs/rusqlite/*/rusqlite/struct.Statement.html"><code>statement</code></a>.</p>
<pre><code>eextern crate rusqlite;

use rusqlite::{Connection, Result};
use rusqlite::NO_PARAMS;
use std::collections::HashMap;


#[derive(Debug)]
struct Cat {
    name: String,
    color: String
}

fn main() -&gt; Result&lt;()&gt; {	
    let conn = Connection::open(&quot;cats.db&quot;)?;
    
    let mut cat_colors = HashMap::new();
    cat_colors.insert(String::from(&quot;Blue&quot;), vec![&quot;Tigger&quot;, &quot;Sammy&quot;]);
    cat_colors.insert(String::from(&quot;Black&quot;), vec![&quot;Oreo&quot;, &quot;Biscuit&quot;]);

    for (color, catnames) in &amp;cat_colors{
        conn.execute(
            &quot;INSERT INTO cat_colors (name) values (?1)&quot;,
            &amp;[&amp;color.to_string()],
        )?;
    let last_id : String = conn.last_insert_rowid().to_string();

    for cat in catnames{
        conn.execute(
            &quot;INSERT INTO cats (name, color_id) values (?1, ?2)&quot;,
            &amp;[&amp;cat.to_string(), &amp;last_id],
        )?;
        }
    }
    let mut stmt = conn.prepare(&quot;SELECT c.name, cc.name from cats c 
                                 INNER JOIN cat_colors cc ON cc.id = c.color_id;&quot;)?;
    
	let cats = stmt
        .query_map(NO_PARAMS, |row| 
			Ok( 
                Cat {
					name: row.get(0)?,
					color: row.get(1)?,
				}
			)
		)?;	
    
    for cat in cats {
        println!(&quot;Found cat {:?}&quot;, cat);
    }

    Ok(())
}

</code></pre>
<h2><a class="header" href="#using-transactions" id="using-transactions">Using transactions</a></h2>
<p><a href="https://crates.io/crates/rusqlite/"><img src="https://badge-cache.kominick.com/crates/v/rusqlite.svg?label=rusqlite" alt="rusqlite-badge" /></a> <a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></p>
<p><a href="https://docs.rs/rusqlite/*/rusqlite/struct.Connection.html#method.open"><code>Connection::open</code></a> will open the <code>cats.db</code> database from the top recipe.</p>
<p>Begin a transaction with <a href="https://docs.rs/rusqlite/*/rusqlite/struct.Connection.html#method.transaction"><code>Connection::transaction</code></a>. Transactions will
roll back unless committed explicitly with <a href="https://docs.rs/rusqlite/*/rusqlite/struct.Transaction.html#method.commit"><code>Transaction::commit</code></a>.</p>
<p>In the following example, colors add to a table having
a unique constraint on the color name. When an attempt to insert
a duplicate color is made, the transaction rolls back.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate rusqlite;

use rusqlite::{Connection, Result, NO_PARAMS};

fn main() -&gt; Result&lt;()&gt; {
    let mut conn = Connection::open(&quot;cats.db&quot;)?;

    successful_tx(&amp;mut conn)?;

    let res = rolled_back_tx(&amp;mut conn);
    assert!(res.is_err());

    Ok(())
}

fn successful_tx(conn: &amp;mut Connection) -&gt; Result&lt;()&gt; {
    let tx = conn.transaction()?;

    tx.execute(&quot;delete from cat_colors&quot;, NO_PARAMS)?;
    tx.execute(&quot;insert into cat_colors (name) values (?1)&quot;, &amp;[&amp;&quot;lavender&quot;])?;
    tx.execute(&quot;insert into cat_colors (name) values (?1)&quot;, &amp;[&amp;&quot;blue&quot;])?;

    tx.commit()
}

fn rolled_back_tx(conn: &amp;mut Connection) -&gt; Result&lt;()&gt; {
    let tx = conn.transaction()?;

    tx.execute(&quot;delete from cat_colors&quot;, NO_PARAMS)?;
    tx.execute(&quot;insert into cat_colors (name) values (?1)&quot;, &amp;[&amp;&quot;lavender&quot;])?;
    tx.execute(&quot;insert into cat_colors (name) values (?1)&quot;, &amp;[&amp;&quot;blue&quot;])?;
    tx.execute(&quot;insert into cat_colors (name) values (?1)&quot;, &amp;[&amp;&quot;lavender&quot;])?;

    tx.commit()
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#working-with-postgres" id="working-with-postgres">Working with Postgres</a></h1>
<h2><a class="header" href="#create-tables-in-a-postgres-database" id="create-tables-in-a-postgres-database">Create tables in a Postgres database</a></h2>
<p><a href="https://docs.rs/postgres/0.15.2/postgres/"><img src="https://badge-cache.kominick.com/crates/v/postgres.svg?label=postgres" alt="postgres-badge" /></a> <a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></p>
<p>Use the <a href="https://docs.rs/postgres/0.15.2/postgres/"><code>postgres</code></a> crate to create tables in a Postgres database.</p>
<p><a href="https://docs.rs/postgres/0.15.2/postgres/struct.Connection.html#method.connect"><code>Connection::connect</code></a> helps in connecting to an existing database. The recipe uses a URL string format with <code>Connection::connect</code>. It assumes an existing database named <code>library</code>, the username is <code>postgres</code> and the password is <code>postgres</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate postgres;

use postgres::{Connection, TlsMode, Error};

fn main() -&gt; Result&lt;(), Error&gt; {
    let conn = Connection::connect(&quot;postgresql://postgres:postgres@localhost/library&quot;, 
                                    TlsMode::None)?;
    
     conn.execute(&quot;CREATE TABLE IF NOT EXISTS author (
                    id              SERIAL PRIMARY KEY,
                    name            VARCHAR NOT NULL,
                    country         VARCHAR NOT NULL
                  )&quot;, &amp;[])?;

    conn.execute(&quot;CREATE TABLE IF NOT EXISTS book  (
                    id              SERIAL PRIMARY KEY,
                    title           VARCHAR NOT NULL,
                    author_id       INTEGER NOT NULL REFERENCES author
                )&quot;, &amp;[])?;

    Ok(())

}
</code></pre></pre>
<h2><a class="header" href="#insert-and-query-data" id="insert-and-query-data">Insert and Query data</a></h2>
<p><a href="https://docs.rs/postgres/0.15.2/postgres/"><img src="https://badge-cache.kominick.com/crates/v/postgres.svg?label=postgres" alt="postgres-badge" /></a> <a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></p>
<p>The recipe inserts data into the <code>author</code> table using <a href="https://docs.rs/postgres/0.15.2/postgres/struct.Connection.html#method.execute"><code>execute</code></a> method of <code>Connection</code>. Then, displays the data from the <code>author</code> table  using <a href="https://docs.rs/postgres/0.15.2/postgres/struct.Connection.html#method.query"><code>query</code></a> method of <code>Connection</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate postgres;

use postgres::{Connection, TlsMode, Error};
use std::collections::HashMap;

struct Author {
    id: i32,
    name: String,
    country: String
}

fn main() -&gt; Result&lt;(), Error&gt; {
    let conn = Connection::connect(&quot;postgresql://postgres:postgres@localhost/library&quot;, 
                                    TlsMode::None)?;
    
    let mut authors = HashMap::new();
    authors.insert(String::from(&quot;Chinua Achebe&quot;), &quot;Nigeria&quot;);
    authors.insert(String::from(&quot;Rabindranath Tagore&quot;), &quot;India&quot;);
    authors.insert(String::from(&quot;Anita Nair&quot;), &quot;India&quot;);

    for (key, value) in &amp;authors {
        let author = Author {
            id: 0,
            name: key.to_string(),
            country: value.to_string()
        };

        conn.execute(&quot;INSERT INTO author (name, country) VALUES ($1, $2)&quot;,
                 &amp;[&amp;author.name, &amp;author.country])?;
    }

    for row in &amp;conn.query(&quot;SELECT id, name, country FROM author&quot;, &amp;[])? {
        let author = Author {
            id: row.get(0),
            name: row.get(1),
            country: row.get(2),
        };
        println!(&quot;Author {} is from {}&quot;, author.name, author.country);
    }

    Ok(())

}
</code></pre></pre>
<h2><a class="header" href="#aggregate-data" id="aggregate-data">Aggregate data</a></h2>
<p><a href="https://docs.rs/postgres/0.15.2/postgres/"><img src="https://badge-cache.kominick.com/crates/v/postgres.svg?label=postgres" alt="postgres-badge" /></a> <a href="https://crates.io/categories/database"><img src="https://badge-cache.kominick.com/badge/database--x.svg?style=social" alt="cat-database-badge" /></a></p>
<p>This recipe lists the nationalities of the first 7999 artists in the database of the <a href="https://github.com/MuseumofModernArt/collection/blob/master/Artists.csv"><code>Museum of Modern Art</code></a> in descending order.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate postgres;
use postgres::{Connection, Error, TlsMode};

struct Nation {
    nationality: String,
    count: i64,
}

fn main() -&gt; Result&lt;(), Error&gt; {
    let conn = Connection::connect(
        &quot;postgresql://postgres:postgres@127.0.0.1/moma&quot;,
        TlsMode::None,
    )?;

    for row in &amp;conn.query 
	(&quot;SELECT nationality, COUNT(nationality) AS count 
	FROM artists GROUP BY nationality ORDER BY count DESC&quot;, &amp;[])? {
        
        let (nationality, count) : (Option&lt;String&gt;, Option&lt;i64&gt;) 
		= (row.get (0), row.get (1));
        
        if nationality.is_some () &amp;&amp; count.is_some () {

            let nation = Nation{
                nationality: nationality.unwrap(),
                count: count.unwrap(),
        };
            println!(&quot;{} {}&quot;, nation.nationality, nation.count);
            
        }
    }

    Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#date-and-time-1" id="date-and-time-1">Date and Time</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/datetime/duration.html#measure-the-elapsed-time-between-two-code-sections">Measure elapsed time</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/time--x.svg?style=social" alt="cat-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/duration.html#perform-checked-date-and-time-calculations">Perform checked date and time calculations</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/duration.html#convert-a-local-time-to-another-timezone">Convert a local time to another timezone</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/parse.html#examine-the-date-and-time">Examine the date and time</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/parse.html#convert-date-to-unix-timestamp-and-vice-versa">Convert date to UNIX timestamp and vice versa</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/parse.html#display-formatted-date-and-time">Display formatted date and time</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/datetime/parse.html#parse-string-into-datetime-struct">Parse string into DateTime struct</a></td><td><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#duration-and-calculation" id="duration-and-calculation">Duration and Calculation</a></h1>
<h2><a class="header" href="#measure-the-elapsed-time-between-two-code-sections" id="measure-the-elapsed-time-between-two-code-sections">Measure the elapsed time between two code sections</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/time--x.svg?style=social" alt="cat-time-badge" /></a></p>
<p>Measures <a href="https://doc.rust-lang.org/std/time/struct.Instant.html#method.elapsed"><code>time::Instant::elapsed</code></a> since <a href="https://doc.rust-lang.org/std/time/struct.Instant.html#method.now"><code>time::Instant::now</code></a>.</p>
<p>Calling <a href="https://doc.rust-lang.org/std/time/struct.Instant.html#method.elapsed"><code>time::Instant::elapsed</code></a> returns a <a href="https://doc.rust-lang.org/std/time/struct.Duration.html"><code>time::Duration</code></a> that we print at the end of the example.
This method will not mutate or reset the <a href="https://doc.rust-lang.org/std/time/struct.Instant.html"><code>time::Instant</code></a> object.</p>
<pre><pre class="playpen"><code class="language-rust">use std::time::{Duration, Instant};
<span class="boring">use std::thread;
</span><span class="boring">
</span><span class="boring">fn expensive_function() {
</span><span class="boring">    thread::sleep(Duration::from_secs(1));
</span><span class="boring">}
</span>
fn main() {
    let start = Instant::now();
    expensive_function();
    let duration = start.elapsed();

    println!(&quot;Time elapsed in expensive_function() is: {:?}&quot;, duration);
}
</code></pre></pre>
<h2><a class="header" href="#perform-checked-date-and-time-calculations" id="perform-checked-date-and-time-calculations">Perform checked date and time calculations</a></h2>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Calculates and displays the date and time two weeks from now using
<a href="https://docs.rs/chrono/*/chrono/struct.Date.html#method.checked_add_signed"><code>DateTime::checked_add_signed</code></a> and the date of the day before that using
<a href="https://docs.rs/chrono/*/chrono/struct.Date.html#method.checked_sub_signed"><code>DateTime::checked_sub_signed</code></a>. The methods return None if the date and time
cannot be calculated.</p>
<p>Escape sequences that are available for the
<a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.format"><code>DateTime::format</code></a> can be found at <a href="https://docs.rs/chrono/*/chrono/format/strftime/index.html"><code>chrono::format::strftime</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::{DateTime, Duration, Utc};

fn day_earlier(date_time: DateTime&lt;Utc&gt;) -&gt; Option&lt;DateTime&lt;Utc&gt;&gt; {
    date_time.checked_sub_signed(Duration::days(1))
}

fn main() {
    let now = Utc::now();
    println!(&quot;{}&quot;, now);

    let almost_three_weeks_from_now = now.checked_add_signed(Duration::weeks(2))
            .and_then(|in_2weeks| in_2weeks.checked_add_signed(Duration::weeks(1)))
            .and_then(day_earlier);

    match almost_three_weeks_from_now {
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; eprintln!(&quot;Almost three weeks from now overflows!&quot;),
    }

    match now.checked_add_signed(Duration::max_value()) {
        Some(x) =&gt; println!(&quot;{}&quot;, x),
        None =&gt; eprintln!(&quot;We can't use chrono to tell the time for the Solar System to complete more than one full orbit around the galactic center.&quot;),
    }
}
</code></pre></pre>
<h2><a class="header" href="#convert-a-local-time-to-another-timezone" id="convert-a-local-time-to-another-timezone">Convert a local time to another timezone</a></h2>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Gets the local time and displays it using <a href="https://docs.rs/chrono/*/chrono/offset/struct.Local.html#method.now"><code>offset::Local::now</code></a> and then converts it to the UTC standard using the <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.from_utc"><code>DateTime::from_utc</code></a> struct method. A time is then converted using the <a href="https://docs.rs/chrono/*/chrono/offset/struct.FixedOffset.html"><code>offset::FixedOffset</code></a> struct and the UTC time is then converted to UTC+8 and UTC-2.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;

use chrono::{DateTime, FixedOffset, Local, Utc};

fn main() {
    let local_time = Local::now();
    let utc_time = DateTime::&lt;Utc&gt;::from_utc(local_time.naive_utc(), Utc);
    let china_timezone = FixedOffset::east(8 * 3600);
    let rio_timezone = FixedOffset::west(2 * 3600);
    println!(&quot;Local time now is {}&quot;, local_time);
    println!(&quot;UTC time now is {}&quot;, utc_time);
    println!(
        &quot;Time in Hong Kong now is {}&quot;,
        utc_time.with_timezone(&amp;china_timezone)
    );
    println!(&quot;Time in Rio de Janeiro now is {}&quot;, utc_time.with_timezone(&amp;rio_timezone));
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#parsing-and-displaying" id="parsing-and-displaying">Parsing and Displaying</a></h1>
<h2><a class="header" href="#examine-the-date-and-time" id="examine-the-date-and-time">Examine the date and time</a></h2>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Gets the current UTC <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html"><code>DateTime</code></a> and its hour/minute/second via <a href="https://docs.rs/chrono/*/chrono/trait.Timelike.html"><code>Timelike</code></a>
and its year/month/day/weekday via <a href="https://docs.rs/chrono/*/chrono/trait.Datelike.html"><code>Datelike</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::{Datelike, Timelike, Utc};

fn main() {
    let now = Utc::now();

    let (is_pm, hour) = now.hour12();
    println!(
        &quot;The current UTC time is {:02}:{:02}:{:02} {}&quot;,
        hour,
        now.minute(),
        now.second(),
        if is_pm { &quot;PM&quot; } else { &quot;AM&quot; }
    );
    println!(
        &quot;And there have been {} seconds since midnight&quot;,
        now.num_seconds_from_midnight()
    );

    let (is_common_era, year) = now.year_ce();
    println!(
        &quot;The current UTC date is {}-{:02}-{:02} {:?} ({})&quot;,
        year,
        now.month(),
        now.day(),
        now.weekday(),
        if is_common_era { &quot;CE&quot; } else { &quot;BCE&quot; }
    );
    println!(
        &quot;And the Common Era began {} days ago&quot;,
        now.num_days_from_ce()
    );
}
</code></pre></pre>
<h2><a class="header" href="#convert-date-to-unix-timestamp-and-vice-versa" id="convert-date-to-unix-timestamp-and-vice-versa">Convert date to UNIX timestamp and vice versa</a></h2>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Converts a date given by <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDate.html#method.from_ymd"><code>NaiveDate::from_ymd</code></a> and <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveTime.html#method.from_hms"><code>NaiveTime::from_hms</code></a>
to <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX timestamp</a> using <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDateTime.html#method.timestamp"><code>NaiveDateTime::timestamp</code></a>.
Then it calculates what was the date after one billion seconds
since January 1, 1970 0:00:00 UTC, using <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDateTime.html#method.from_timestamp"><code>NaiveDateTime::from_timestamp</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;

use chrono::{NaiveDate, NaiveDateTime};

fn main() {
    let date_time: NaiveDateTime = NaiveDate::from_ymd(2017, 11, 12).and_hms(17, 33, 44);
    println!(
        &quot;Number of seconds between 1970-01-01 00:00:00 and {} is {}.&quot;,
        date_time, date_time.timestamp());

    let date_time_after_a_billion_seconds = NaiveDateTime::from_timestamp(1_000_000_000, 0);
    println!(
        &quot;Date after a billion seconds since 1970-01-01 00:00:00 was {}.&quot;,
        date_time_after_a_billion_seconds);
}
</code></pre></pre>
<h2><a class="header" href="#display-formatted-date-and-time" id="display-formatted-date-and-time">Display formatted date and time</a></h2>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Gets and displays the current time in UTC using <a href="https://docs.rs/chrono/*/chrono/offset/struct.Utc.html#method.now"><code>Utc::now</code></a>. Formats the
current time in the well-known formats <a href="https://www.ietf.org/rfc/rfc2822.txt">RFC 2822</a> using <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.to_rfc2822"><code>DateTime::to_rfc2822</code></a>
and <a href="https://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a> using <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.to_rfc3339"><code>DateTime::to_rfc3339</code></a>, and in a custom format using
<a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.format"><code>DateTime::format</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::{DateTime, Utc};

fn main() {
    let now: DateTime&lt;Utc&gt; = Utc::now();

    println!(&quot;UTC now is: {}&quot;, now);
    println!(&quot;UTC now in RFC 2822 is: {}&quot;, now.to_rfc2822());
    println!(&quot;UTC now in RFC 3339 is: {}&quot;, now.to_rfc3339());
    println!(&quot;UTC now in a custom format is: {}&quot;, now.format(&quot;%a %b %e %T %Y&quot;));
}
</code></pre></pre>
<h2><a class="header" href="#parse-string-into-datetime-struct" id="parse-string-into-datetime-struct">Parse string into DateTime struct</a></h2>
<p><a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/date-and-time"><img src="https://badge-cache.kominick.com/badge/date_and_time--x.svg?style=social" alt="cat-date-and-time-badge" /></a></p>
<p>Parses a <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html"><code>DateTime</code></a> struct from strings representing the well-known formats
<a href="https://www.ietf.org/rfc/rfc2822.txt">RFC 2822</a>, <a href="https://www.ietf.org/rfc/rfc3339.txt">RFC 3339</a>, and a custom format, using
<a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_rfc2822"><code>DateTime::parse_from_rfc2822</code></a>, <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_rfc3339"><code>DateTime::parse_from_rfc3339</code></a>, and
<a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_str"><code>DateTime::parse_from_str</code></a> respectively.</p>
<p>Escape sequences that are available for the <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_str"><code>DateTime::parse_from_str</code></a> can be
found at <a href="https://docs.rs/chrono/*/chrono/format/strftime/index.html"><code>chrono::format::strftime</code></a>. Note that the <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.parse_from_str"><code>DateTime::parse_from_str</code></a>
requires that such a DateTime struct must be creatable that it uniquely
identifies a date and a time. For parsing dates and times without timezones use
<a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDate.html"><code>NaiveDate</code></a>, <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveTime.html"><code>NaiveTime</code></a>, and <a href="https://docs.rs/chrono/*/chrono/naive/struct.NaiveDateTime.html"><code>NaiveDateTime</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate chrono;
use chrono::{DateTime, NaiveDate, NaiveDateTime, NaiveTime};
use chrono::format::ParseError;


fn main() -&gt; Result&lt;(), ParseError&gt; {
    let rfc2822 = DateTime::parse_from_rfc2822(&quot;Tue, 1 Jul 2003 10:52:37 +0200&quot;)?;
    println!(&quot;{}&quot;, rfc2822);

    let rfc3339 = DateTime::parse_from_rfc3339(&quot;1996-12-19T16:39:57-08:00&quot;)?;
    println!(&quot;{}&quot;, rfc3339);

    let custom = DateTime::parse_from_str(&quot;5.8.1994 8:00 am +0000&quot;, &quot;%d.%m.%Y %H:%M %P %z&quot;)?;
    println!(&quot;{}&quot;, custom);

    let time_only = NaiveTime::parse_from_str(&quot;23:56:04&quot;, &quot;%H:%M:%S&quot;)?;
    println!(&quot;{}&quot;, time_only);

    let date_only = NaiveDate::parse_from_str(&quot;2015-09-05&quot;, &quot;%Y-%m-%d&quot;)?;
    println!(&quot;{}&quot;, date_only);

    let no_timezone = NaiveDateTime::parse_from_str(&quot;2015-09-05 23:56:04&quot;, &quot;%Y-%m-%d %H:%M:%S&quot;)?;
    println!(&quot;{}&quot;, no_timezone);

    Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#development-tools-1" id="development-tools-1">Development Tools</a></h1>
<h2><a class="header" href="#debugging-1" id="debugging-1">Debugging</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-a-debug-message-to-the-console">Log a debug message to the console</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-an-error-message-to-the-console">Log an error message to the console</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-to-stdout-instead-of-stderr">Log to stdout instead of stderr</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-messages-with-a-custom-logger">Log messages with a custom logger</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/log.html#log-to-the-unix-syslog">Log to the Unix syslog</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://badge-cache.kominick.com/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/config_log.html#enable-log-levels-per-module">Enable log levels per module</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/config_log.html#use-a-custom-environment-variable-to-set-up-logging">Use a custom environment variable to set up logging</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/config_log.html#include-timestamp-in-log-messages">Include timestamp in log messages</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/debugging/config_log.html#log-messages-to-a-custom-location">Log messages to a custom location</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/log4rs/"><img src="https://badge-cache.kominick.com/crates/v/log4rs.svg?label=log4rs" alt="log4rs-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h2><a class="header" href="#versioning-1" id="versioning-1">Versioning</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/development_tools/versioning.html#parse-and-increment-a-version-string">Parse and increment a version string</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/versioning.html#parse-a-complex-version-string">Parse a complex version string</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/versioning.html#check-if-given-version-is-pre-release">Check if given version is pre-release</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/versioning.html#find-the-latest-version-satisfying-given-range">Find the latest version satisfying given range</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/versioning.html#check-external-command-version-for-compatibility">Check external command version for compatibility</a></td><td><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
</tbody></table>
<h2><a class="header" href="#build-time-1" id="build-time-1">Build Time</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/development_tools/build_tools.html#compile-and-link-statically-to-a-bundled-c-library">Compile and link statically to a bundled C library</a></td><td><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a></td><td><a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/build_tools.html#compile-and-link-statically-to-a-bundled-c-library-1">Compile and link statically to a bundled C++ library</a></td><td><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a></td><td><a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/build_tools.html#compile-a-c-library-while-setting-custom-defines">Compile a C library while setting custom defines</a></td><td><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a></td><td><a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h2><a class="header" href="#debugging-2" id="debugging-2">Debugging</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/development_tools/development_tools/debugging/log.html#log-a-debug-message-to-the-console">Log a debug message to the console</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/development_tools/debugging/log.html#log-an-error-message-to-the-console">Log an error message to the console</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/development_tools/debugging/log.html#log-to-stdout-instead-of-stderr">Log to stdout instead of stderr</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/development_tools/debugging/log.html#log-messages-with-a-custom-logger">Log messages with a custom logger</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/development_tools/debugging/log.html#log-to-the-unix-syslog">Log to the Unix syslog</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://badge-cache.kominick.com/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/development_tools/debugging/config_log.html#enable-log-levels-per-module">Enable log levels per module</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/development_tools/debugging/config_log.html#use-a-custom-environment-variable-to-set-up-logging">Use a custom environment variable to set up logging</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/development_tools/debugging/config_log.html#include-timestamp-in-log-messages">Include timestamp in log messages</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/development_tools/development_tools/debugging/config_log.html#log-messages-to-a-custom-location">Log messages to a custom location</a></td><td><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/log4rs/"><img src="https://badge-cache.kominick.com/crates/v/log4rs.svg?label=log4rs" alt="log4rs-badge" /></a></td><td><a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#log-messages" id="log-messages">Log Messages</a></h1>
<h2><a class="header" href="#log-a-debug-message-to-the-console" id="log-a-debug-message-to-the-console">Log a debug message to the console</a></h2>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>The <code>log</code> crate provides logging utilities. The <code>env_logger</code> crate configures
logging via an environment variable.  The <a href="https://docs.rs/log/*/log/macro.debug.html"><code>debug!</code></a> macro works like other
<a href="https://doc.rust-lang.org/std/fmt/"><code>std::fmt</code></a> formatted strings.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

fn execute_query(query: &amp;str) {
    debug!(&quot;Executing query: {}&quot;, query);
}

fn main() {
    env_logger::init();

    execute_query(&quot;DROP TABLE students&quot;);
}
</code></pre></pre>
<p>No output prints when running this code. By default, the
log level is <code>error</code>, and any lower levels are dropped.</p>
<p>Set the <code>RUST_LOG</code> environment variable to print the message:</p>
<pre><code>$ RUST_LOG=debug cargo run
</code></pre>
<p>Cargo prints debugging information then the
following line at the very end of the output:</p>
<pre><code>DEBUG:main: Executing query: DROP TABLE students
</code></pre>
<h2><a class="header" href="#log-an-error-message-to-the-console" id="log-an-error-message-to-the-console">Log an error message to the console</a></h2>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Proper error handling considers exceptions exceptional.  Here, an error logs
to stderr with <code>log</code>'s convenience macro <a href="https://docs.rs/log/*/log/macro.error.html"><code>error!</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

fn execute_query(_query: &amp;str) -&gt; Result&lt;(), &amp;'static str&gt; {
    Err(&quot;I'm afraid I can't do that&quot;)
}

fn main() {
    env_logger::init();

    let response = execute_query(&quot;DROP TABLE students&quot;);
    if let Err(err) = response {
        error!(&quot;Failed to execute query: {}&quot;, err);
    }
}
</code></pre></pre>
<h2><a class="header" href="#log-to-stdout-instead-of-stderr" id="log-to-stdout-instead-of-stderr">Log to stdout instead of stderr</a></h2>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Creates a custom logger configuration using the <a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html#method.target"><code>Builder::target</code></a> to set the target of the log output to <a href="https://docs.rs/env_logger/*/env_logger/fmt/enum.Target.html"><code>Target::Stdout</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

use env_logger::{Builder, Target};

fn main() {
    Builder::new()
        .target(Target::Stdout)
        .init();

    error!(&quot;This error has been printed to Stdout&quot;);
}
</code></pre></pre>
<h2><a class="header" href="#log-messages-with-a-custom-logger" id="log-messages-with-a-custom-logger">Log messages with a custom logger</a></h2>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Implements a custom logger <code>ConsoleLogger</code> which prints to stdout.
In order to use the logging macros, <code>ConsoleLogger</code> implements
the <a href="https://docs.rs/log/*/log/trait.Log.html"><code>log::Log</code></a> trait and <a href="https://docs.rs/log/*/log/fn.set_logger.html"><code>log::set_logger</code></a> installs it.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;

use log::{Record, Level, Metadata, LevelFilter, SetLoggerError};

static CONSOLE_LOGGER: ConsoleLogger = ConsoleLogger;

struct ConsoleLogger;

impl log::Log for ConsoleLogger {
  fn enabled(&amp;self, metadata: &amp;Metadata) -&gt; bool {
     metadata.level() &lt;= Level::Info
    }

    fn log(&amp;self, record: &amp;Record) {
        if self.enabled(record.metadata()) {
            println!(&quot;Rust says: {} - {}&quot;, record.level(), record.args());
        }
    }

    fn flush(&amp;self) {}
}

fn main() -&gt; Result&lt;(), SetLoggerError&gt; {
    log::set_logger(&amp;CONSOLE_LOGGER)?;
    log::set_max_level(LevelFilter::Info);

    info!(&quot;hello log&quot;);
    warn!(&quot;warning&quot;);
    error!(&quot;oops&quot;);
    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#log-to-the-unix-syslog" id="log-to-the-unix-syslog">Log to the Unix syslog</a></h2>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/syslog/"><img src="https://badge-cache.kominick.com/crates/v/syslog.svg?label=syslog" alt="syslog-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Logs messages to <a href="https://www.gnu.org/software/libc/manual/html_node/Overview-of-Syslog.html">UNIX syslog</a>. Initializes logger backend
with <a href="https://docs.rs/syslog/*/syslog/fn.init.html"><code>syslog::init</code></a>. <a href="https://docs.rs/syslog/*/syslog/enum.Facility.html"><code>syslog::Facility</code></a> records the program submitting
the log entry's classification, <a href="https://docs.rs/log/*/log/enum.LevelFilter.html"><code>log::LevelFilter</code></a> denotes allowed log verbosity
and <code>Option&lt;&amp;str&gt;</code> holds optional application name.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
<span class="boring">#[cfg(target_os = &quot;linux&quot;)]
</span>extern crate syslog;

<span class="boring">#[cfg(target_os = &quot;linux&quot;)]
</span>use syslog::{Facility, Error};

<span class="boring">#[cfg(target_os = &quot;linux&quot;)]
</span>fn main() -&gt; Result&lt;(), Error&gt; {
    syslog::init(Facility::LOG_USER,
                 log::LevelFilter::Debug,
                 Some(&quot;My app name&quot;))?;
    debug!(&quot;this is a debug {}&quot;, &quot;message&quot;);
    error!(&quot;this is an error!&quot;);
    Ok(())
}

<span class="boring">#[cfg(not(target_os = &quot;linux&quot;))]
</span><span class="boring">fn main() {
</span><span class="boring">    println!(&quot;So far, only Linux systems are supported.&quot;);
</span><span class="boring">}
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#configure-logging" id="configure-logging">Configure Logging</a></h1>
<h2><a class="header" href="#enable-log-levels-per-module" id="enable-log-levels-per-module">Enable log levels per module</a></h2>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Creates two modules <code>foo</code> and nested <code>foo::bar</code> with logging directives
controlled separately with <a href="https://docs.rs/env_logger/*/env_logger/#enabling-logging"><code>RUST_LOG</code></a> environmental variable.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

mod foo {
    mod bar {
        pub fn run() {
            warn!(&quot;[bar] warn&quot;);
            info!(&quot;[bar] info&quot;);
            debug!(&quot;[bar] debug&quot;);
        }
    }

    pub fn run() {
        warn!(&quot;[foo] warn&quot;);
        info!(&quot;[foo] info&quot;);
        debug!(&quot;[foo] debug&quot;);
        bar::run();
    }
}

fn main() {
    env_logger::init();
    warn!(&quot;[root] warn&quot;);
    info!(&quot;[root] info&quot;);
    debug!(&quot;[root] debug&quot;);
    foo::run();
}
</code></pre></pre>
<p><a href="https://docs.rs/env_logger/*/env_logger/#enabling-logging"><code>RUST_LOG</code></a> environment variable controls <a href="https://docs.rs/env_logger/"><code>env_logger</code></a> output.
Module declarations take comma separated entries formatted like
<code>path::to::module=log_level</code>. Run the <code>test</code> application as follows:</p>
<pre><code class="language-bash">RUST_LOG=&quot;warn,test::foo=info,test::foo::bar=debug&quot; ./test
</code></pre>
<p>Sets the default <a href="https://docs.rs/log/*/log/enum.Level.html"><code>log::Level</code></a> to <code>warn</code>, module <code>foo</code> and module <code>foo::bar</code>
to <code>info</code> and <code>debug</code>.</p>
<pre><code class="language-bash">WARN:test: [root] warn
WARN:test::foo: [foo] warn
INFO:test::foo: [foo] info
WARN:test::foo::bar: [bar] warn
INFO:test::foo::bar: [bar] info
DEBUG:test::foo::bar: [bar] debug
</code></pre>
<h2><a class="header" href="#use-a-custom-environment-variable-to-set-up-logging" id="use-a-custom-environment-variable-to-set-up-logging">Use a custom environment variable to set up logging</a></h2>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p><a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html"><code>Builder</code></a> configures logging.</p>
<p><a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html#method.parse"><code>Builder::parse</code></a> parses <code>MY_APP_LOG</code>
environment variable contents in the form of <a href="https://docs.rs/env_logger/*/env_logger/#enabling-logging"><code>RUST_LOG</code></a> syntax.
Then, <a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html#method.init"><code>Builder::init</code></a> initializes the logger.
All these steps are normally done internally by <a href="https://docs.rs/env_logger/*/env_logger/fn.init.html"><code>env_logger::init</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate env_logger;

use std::env;
use env_logger::Builder;

fn main() {
    Builder::new()
        .parse(&amp;env::var(&quot;MY_APP_LOG&quot;).unwrap_or_default())
        .init();

    info!(&quot;informational message&quot;);
    warn!(&quot;warning message&quot;);
    error!(&quot;this is an error {}&quot;, &quot;message&quot;);
}
</code></pre></pre>
<h2><a class="header" href="#include-timestamp-in-log-messages" id="include-timestamp-in-log-messages">Include timestamp in log messages</a></h2>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/env_logger/"><img src="https://badge-cache.kominick.com/crates/v/env_logger.svg?label=env_logger" alt="env_logger-badge" /></a> <a href="https://docs.rs/chrono/"><img src="https://badge-cache.kominick.com/crates/v/chrono.svg?label=chrono" alt="chrono-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p>Creates a custom logger configuration with <a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html"><code>Builder</code></a>.
Each log entry calls <a href="https://docs.rs/chrono/*/chrono/offset/struct.Local.html#method.now"><code>Local::now</code></a> to get the current <a href="https://docs.rs/chrono/*/chrono/datetime/struct.DateTime.html"><code>DateTime</code></a> in local
timezone and uses <a href="https://docs.rs/chrono/*/chrono/struct.DateTime.html#method.format"><code>DateTime::format</code></a> with <a href="https://docs.rs/chrono/*/chrono/format/strftime/index.html#specifiers"><code>strftime::specifiers</code></a> to format
a timestamp used in the final log.</p>
<p>The example calls <a href="https://docs.rs/env_logger/*/env_logger/struct.Builder.html#method.format"><code>Builder::format</code></a> to set a closure which formats each
message text with timestamp, <a href="https://docs.rs/log/*/log/struct.Record.html#method.level"><code>Record::level</code></a> and body (<a href="https://docs.rs/log/*/log/struct.Record.html#method.args"><code>Record::args</code></a>).</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate log;
extern crate chrono;
extern crate env_logger;

use std::io::Write;
use chrono::Local;
use env_logger::Builder;
use log::LevelFilter;

fn main() {
    Builder::new()
        .format(|buf, record| {
            writeln!(buf,
                &quot;{} [{}] - {}&quot;,
                Local::now().format(&quot;%Y-%m-%dT%H:%M:%S&quot;),
                record.level(),
                record.args()
            )
        })
        .filter(None, LevelFilter::Info)
        .init();

    warn!(&quot;warn&quot;);
    info!(&quot;info&quot;);
    debug!(&quot;debug&quot;);
}
</code></pre></pre>
<p>stderr output will contain</p>
<pre><code>2017-05-22T21:57:06 [WARN] - warn
2017-05-22T21:57:06 [INFO] - info
</code></pre>
<h2><a class="header" href="#log-messages-to-a-custom-location" id="log-messages-to-a-custom-location">Log messages to a custom location</a></h2>
<p><a href="https://docs.rs/log/"><img src="https://badge-cache.kominick.com/crates/v/log.svg?label=log" alt="log-badge" /></a> <a href="https://docs.rs/log4rs/"><img src="https://badge-cache.kominick.com/crates/v/log4rs.svg?label=log4rs" alt="log4rs-badge" /></a> <a href="https://crates.io/categories/debugging"><img src="https://badge-cache.kominick.com/badge/debugging--x.svg?style=social" alt="cat-debugging-badge" /></a></p>
<p><a href="https://docs.rs/log4rs/">log4rs</a> configures log output to a custom location. <a href="https://docs.rs/log4rs/">log4rs</a> can use either an
external YAML file or a builder configuration.</p>
<p>Create the log configuration with <a href="https://docs.rs/log4rs/*/log4rs/append/file/struct.FileAppender.html"><code>log4rs::append::file::FileAppender</code></a>. An
appender defines the logging destination.  The configuration continues with
encoding using a custom pattern from <a href="https://docs.rs/log4rs/*/log4rs/encode/pattern/index.html"><code>log4rs::encode::pattern</code></a>.
Assigns the configuration to <a href="https://docs.rs/log4rs/*/log4rs/config/struct.Config.html"><code>log4rs::config::Config</code></a> and sets the default
<a href="https://docs.rs/log/*/log/enum.LevelFilter.html"><code>log::LevelFilter</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>#[macro_use]
extern crate log;
extern crate log4rs;

use log::LevelFilter;
use log4rs::append::file::FileAppender;
use log4rs::encode::pattern::PatternEncoder;
use log4rs::config::{Appender, Config, Root};
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        LogConfig(log4rs::config::Errors);
</span><span class="boring">        SetLogger(log::SetLoggerError);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let logfile = FileAppender::builder()
        .encoder(Box::new(PatternEncoder::new(&quot;{l} - {m}\n&quot;)))
        .build(&quot;log/output.log&quot;)?;

    let config = Config::builder()
        .appender(Appender::builder().build(&quot;logfile&quot;, Box::new(logfile)))
        .build(Root::builder()
                   .appender(&quot;logfile&quot;)
                   .build(LevelFilter::Info))?;

    log4rs::init_config(config)?;

    info!(&quot;Hello, world!&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#versioning-2" id="versioning-2">Versioning</a></h1>
<h2><a class="header" href="#parse-and-increment-a-version-string" id="parse-and-increment-a-version-string">Parse and increment a version string.</a></h2>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></p>
<p>Constructs a <a href="https://docs.rs/semver/*/semver/struct.Version.html"><code>semver::Version</code></a> from a string literal using <a href="https://docs.rs/semver/*/semver/struct.Version.html#method.parse"><code>Version::parse</code></a>,
then increments it by patch, minor, and major version number one by one.</p>
<p>Note that in accordance with the <a href="http://semver.org/">Semantic Versioning Specification</a>,
incrementing the minor version number resets the patch version number to 0 and
incrementing the major version number resets both the minor and patch version
numbers to 0.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate semver;

use semver::{Version, SemVerError};

fn main() -&gt; Result&lt;(), SemVerError&gt; {
    let mut parsed_version = Version::parse(&quot;0.2.6&quot;)?;

    assert_eq!(
        parsed_version,
        Version {
            major: 0,
            minor: 2,
            patch: 6,
            pre: vec![],
            build: vec![],
        }
    );

    parsed_version.increment_patch();
    assert_eq!(parsed_version.to_string(), &quot;0.2.7&quot;);
    println!(&quot;New patch release: v{}&quot;, parsed_version);

    parsed_version.increment_minor();
    assert_eq!(parsed_version.to_string(), &quot;0.3.0&quot;);
    println!(&quot;New minor release: v{}&quot;, parsed_version);

    parsed_version.increment_major();
    assert_eq!(parsed_version.to_string(), &quot;1.0.0&quot;);
    println!(&quot;New major release: v{}&quot;, parsed_version);

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#parse-a-complex-version-string" id="parse-a-complex-version-string">Parse a complex version string.</a></h2>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></p>
<p>Constructs a <a href="https://docs.rs/semver/*/semver/struct.Version.html"><code>semver::Version</code></a> from a complex version string using <a href="https://docs.rs/semver/*/semver/struct.Version.html#method.parse"><code>Version::parse</code></a>. The string
contains pre-release and build metadata as defined in the <a href="http://semver.org/">Semantic Versioning Specification</a>.</p>
<p>Note that, in accordance with the Specification, build metadata is parsed but not considered when
comparing versions. In other words, two versions may be equal even if their build strings differ.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate semver;

use semver::{Identifier, Version, SemVerError};

fn main() -&gt; Result&lt;(), SemVerError&gt; {
    let version_str = &quot;1.0.49-125+g72ee7853&quot;;
    let parsed_version = Version::parse(version_str)?;

    assert_eq!(
        parsed_version,
        Version {
            major: 1,
            minor: 0,
            patch: 49,
            pre: vec![Identifier::Numeric(125)],
            build: vec![],
        }
    );
    assert_eq!(
        parsed_version.build,
        vec![Identifier::AlphaNumeric(String::from(&quot;g72ee7853&quot;))]
    );

    let serialized_version = parsed_version.to_string();
    assert_eq!(&amp;serialized_version, version_str);

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#check-if-given-version-is-pre-release" id="check-if-given-version-is-pre-release">Check if given version is pre-release.</a></h2>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></p>
<p>Given two versions, <a href="https://docs.rs/semver/*/semver/struct.Version.html#method.is_prerelease"><code>is_prerelease</code></a> asserts that one is pre-release and the other is not.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate semver;

use semver::{Version, SemVerError};

fn main() -&gt; Result&lt;(), SemVerError&gt; {
    let version_1 = Version::parse(&quot;1.0.0-alpha&quot;)?;
    let version_2 = Version::parse(&quot;1.0.0&quot;)?;

    assert!(version_1.is_prerelease());
    assert!(!version_2.is_prerelease());

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#find-the-latest-version-satisfying-given-range" id="find-the-latest-version-satisfying-given-range">Find the latest version satisfying given range</a></h2>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/config"><img src="https://badge-cache.kominick.com/badge/config--x.svg?style=social" alt="cat-config-badge" /></a></p>
<p>Given a list of version &amp;strs, finds the latest <a href="https://docs.rs/semver/*/semver/struct.Version.html"><code>semver::Version</code></a>.
<a href="https://docs.rs/semver/*/semver/struct.VersionReq.html"><code>semver::VersionReq</code></a> filters the list with <a href="https://docs.rs/semver/*/semver/struct.VersionReq.html#method.matches"><code>VersionReq::matches</code></a>.
Also demonstrates <code>semver</code> pre-release preferences.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate semver;

use semver::{Version, VersionReq};
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        SemVer(semver::SemVerError);
</span><span class="boring">        SemVerReq(semver::ReqParseError);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn find_max_matching_version&lt;'a, I&gt;(version_req_str: &amp;str, iterable: I) -&gt; Result&lt;Option&lt;Version&gt;&gt;
where
    I: IntoIterator&lt;Item = &amp;'a str&gt;,
{
    let vreq = VersionReq::parse(version_req_str)?;

    Ok(
        iterable
            .into_iter()
            .filter_map(|s| Version::parse(s).ok())
            .filter(|s| vreq.matches(s))
            .max(),
    )
}

fn run() -&gt; Result&lt;()&gt; {
    assert_eq!(
        find_max_matching_version(&quot;&lt;= 1.0.0&quot;, vec![&quot;0.9.0&quot;, &quot;1.0.0&quot;, &quot;1.0.1&quot;])?,
        Some(Version::parse(&quot;1.0.0&quot;)?)
    );

    assert_eq!(
        find_max_matching_version(
            &quot;&gt;1.2.3-alpha.3&quot;,
            vec![
                &quot;1.2.3-alpha.3&quot;,
                &quot;1.2.3-alpha.4&quot;,
                &quot;1.2.3-alpha.10&quot;,
                &quot;1.2.3-beta.4&quot;,
                &quot;3.4.5-alpha.9&quot;,
            ]
        )?,
        Some(Version::parse(&quot;1.2.3-beta.4&quot;)?)
    );

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#check-external-command-version-for-compatibility" id="check-external-command-version-for-compatibility">Check external command version for compatibility</a></h2>
<p><a href="https://docs.rs/semver/"><img src="https://badge-cache.kominick.com/crates/v/semver.svg?label=semver" alt="semver-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Runs <code>git --version</code> using <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a>, then parses the version number into a
<a href="https://docs.rs/semver/*/semver/struct.Version.html"><code>semver::Version</code></a> using <a href="https://docs.rs/semver/*/semver/struct.Version.html#method.parse"><code>Version::parse</code></a>. <a href="https://docs.rs/semver/*/semver/struct.VersionReq.html#method.matches"><code>VersionReq::matches</code></a> compares
<a href="https://docs.rs/semver/*/semver/struct.VersionReq.html"><code>semver::VersionReq</code></a> to the parsed version.  The command output resembles
&quot;git version x.y.z&quot;.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate semver;

use std::process::Command;
use semver::{Version, VersionReq};
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        Utf8(std::string::FromUtf8Error);
</span><span class="boring">        SemVer(semver::SemVerError);
</span><span class="boring">        SemVerReq(semver::ReqParseError);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let version_constraint = &quot;&gt; 1.12.0&quot;;
    let version_test = VersionReq::parse(version_constraint)?;
    let output = Command::new(&quot;git&quot;).arg(&quot;--version&quot;).output()?;

    if !output.status.success() {
        bail!(&quot;Command executed with failing error code&quot;);
    }

    let stdout = String::from_utf8(output.stdout)?;
    let version = stdout.split(&quot; &quot;).last().ok_or_else(|| {
        &quot;Invalid command output&quot;
    })?;
    let parsed_version = Version::parse(version)?;

    if !version_test.matches(&amp;parsed_version) {
        bail!(&quot;Command version lower than minimum supported version (found {}, need {})&quot;,
            parsed_version, version_constraint);
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#build-time-tooling" id="build-time-tooling">Build Time Tooling</a></h1>
<p>This section covers &quot;build-time&quot; tooling, or code that is run prior to compiling a crate's source code.
Conventionally, build-time code lives in a <strong>build.rs</strong> file and is commonly referred to as a &quot;build script&quot;.
Common use cases include rust code generation and compilation of bundled C/C++/asm code.
See crates.io's <a href="http://doc.crates.io/build-script.html">documentation on the matter</a> for more information.</p>
<h2><a class="header" href="#compile-and-link-statically-to-a-bundled-c-library" id="compile-and-link-statically-to-a-bundled-c-library">Compile and link statically to a bundled C library</a></h2>
<p><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></p>
<p>To accommodate scenarios where additional C, C++, or assembly is required in a project, the <a href="https://docs.rs/cc"><strong>cc</strong></a> crate
offers a simple api for compiling bundled C/C++/asm code into static libraries (<strong>.a</strong>) that can be statically linked to by <strong>rustc</strong>.</p>
<p>The following example has some bundled C code (<strong>src/hello.c</strong>) that will be used from rust.
Before compiling rust source code, the &quot;build&quot; file (<strong>build.rs</strong>) specified in <strong>Cargo.toml</strong> runs.
Using the <a href="https://docs.rs/cc"><strong>cc</strong></a> crate, a static library file will be produced (in this case, <strong>libhello.a</strong>, see
<a href="https://docs.rs/cc/*/cc/struct.Build.html#method.compile"><code>compile</code> docs</a>) which can then be used from rust by declaring the external function signatures in an <code>extern</code> block.</p>
<p>Since the bundled C is very simple, only a single source file needs to be passed to <a href="https://docs.rs/cc/*/cc/struct.Build.html"><code>cc::Build</code></a>.
For more complex build requirements, <a href="https://docs.rs/cc/*/cc/struct.Build.html"><code>cc::Build</code></a> offers a full suite of builder methods for specifying
<a href="https://docs.rs/cc/*/cc/struct.Build.html#method.include"><code>include</code></a> paths and extra compiler <a href="https://docs.rs/cc/*/cc/struct.Build.html#method.flag"><code>flag</code></a>s.</p>
<h3><a class="header" href="#cargotoml" id="cargotoml"><code>Cargo.toml</code></a></h3>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;

[build-dependencies]
cc = &quot;1&quot;

[dependencies]
error-chain = &quot;0.11&quot;
</code></pre>
<h3><a class="header" href="#buildrs" id="buildrs"><code>build.rs</code></a></h3>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate cc;

fn main() {
    cc::Build::new()
        .file(&quot;src/hello.c&quot;)
        .compile(&quot;hello&quot;);   // outputs `libhello.a`
}
</code></pre></pre>
<h3><a class="header" href="#srchelloc" id="srchelloc"><code>src/hello.c</code></a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;


void hello() {
    printf(&quot;Hello from C!\n&quot;);
}

void greet(const char* name) {
    printf(&quot;Hello, %s!\n&quot;, name);
}
</code></pre>
<h3><a class="header" href="#srcmainrs" id="srcmainrs"><code>src/main.rs</code></a></h3>
<pre><code class="language-rust ignore"><span class="boring">#[macro_use] extern crate error_chain;
</span>use std::ffi::CString;
use std::os::raw::c_char;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        NulError(::std::ffi::NulError);
</span><span class="boring">        Io(::std::io::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn prompt(s: &amp;str) -&gt; Result&lt;String&gt; {
</span><span class="boring">    use std::io::Write;
</span><span class="boring">    print!(&quot;{}&quot;, s);
</span><span class="boring">    std::io::stdout().flush()?;
</span><span class="boring">    let mut input = String::new();
</span><span class="boring">    std::io::stdin().read_line(&amp;mut input)?;
</span><span class="boring">    Ok(input.trim().to_string())
</span><span class="boring">}
</span>
extern {
    fn hello();
    fn greet(name: *const c_char);
}

fn run() -&gt; Result&lt;()&gt; {
    unsafe { hello() }
    let name = prompt(&quot;What's your name? &quot;)?;
    let c_name = CString::new(name)?;
    unsafe { greet(c_name.as_ptr()) }
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre>
<h2><a class="header" href="#compile-and-link-statically-to-a-bundled-c-library-1" id="compile-and-link-statically-to-a-bundled-c-library-1">Compile and link statically to a bundled C++ library</a></h2>
<p><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></p>
<p>Linking a bundled C++ library is very similar to linking a bundled C library. The two core differences when compiling and statically linking a bundled C++ library are specifying a C++ compiler via the builder method <a href="https://docs.rs/cc/*/cc/struct.Build.html#method.cpp"><code>cpp(true)</code></a> and preventing name mangling by the C++ compiler by adding the <code>extern &quot;C&quot;</code> section at the top of our C++ source file.</p>
<h3><a class="header" href="#cargotoml-1" id="cargotoml-1"><code>Cargo.toml</code></a></h3>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;

[build-dependencies]
cc = &quot;1&quot;
</code></pre>
<h3><a class="header" href="#buildrs-1" id="buildrs-1"><code>build.rs</code></a></h3>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate cc;

fn main() {
    cc::Build::new()
        .cpp(true)
        .file(&quot;src/foo.cpp&quot;)
        .compile(&quot;foo&quot;);   
}
</code></pre></pre>
<h3><a class="header" href="#srcfoocpp" id="srcfoocpp"><code>src/foo.cpp</code></a></h3>
<pre><code class="language-cpp">extern &quot;C&quot; {
    int multiply(int x, int y);
}

int multiply(int x, int y) {
    return x*y;
}
</code></pre>
<h3><a class="header" href="#srcmainrs-1" id="srcmainrs-1"><code>src/main.rs</code></a></h3>
<pre><code class="language-rust ignore">extern {
    fn multiply(x : i32, y : i32) -&gt; i32;
}

fn main(){
    unsafe {
        println!(&quot;{}&quot;, multiply(5,7));
    }   
}
</code></pre>
<h2><a class="header" href="#compile-a-c-library-while-setting-custom-defines" id="compile-a-c-library-while-setting-custom-defines">Compile a C library while setting custom defines</a></h2>
<p><a href="https://docs.rs/cc"><img src="https://badge-cache.kominick.com/crates/v/cc.svg?label=cc" alt="cc-badge" /></a> <a href="https://crates.io/categories/development-tools"><img src="https://badge-cache.kominick.com/badge/development_tools--x.svg?style=social" alt="cat-development-tools-badge" /></a></p>
<p>It is simple to build bundled C code with custom defines using <a href="https://docs.rs/cc/*/cc/struct.Build.html#method.define"><code>cc::Build::define</code></a>.
The method takes an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code>Option</code></a> value, so it is possible to create defines such as <code>#define APP_NAME &quot;foo&quot;</code>
as well as <code>#define WELCOME</code> (pass <code>None</code> as the value for a value-less define). This example builds
a bundled C file with dynamic defines set in <code>build.rs</code> and prints &quot;<strong>Welcome to foo - version 1.0.2</strong>&quot;
when run. Cargo sets some <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html">environment variables</a> which may be useful for some custom defines.</p>
<h3><a class="header" href="#cargotoml-2" id="cargotoml-2"><code>Cargo.toml</code></a></h3>
<pre><code class="language-toml">[package]
...
version = &quot;1.0.2&quot;
build = &quot;build.rs&quot;

[build-dependencies]
cc = &quot;1&quot;
</code></pre>
<h3><a class="header" href="#buildrs-2" id="buildrs-2"><code>build.rs</code></a></h3>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate cc;

fn main() {
    cc::Build::new()
        .define(&quot;APP_NAME&quot;, &quot;\&quot;foo\&quot;&quot;)
        .define(&quot;VERSION&quot;, format!(&quot;\&quot;{}\&quot;&quot;, env!(&quot;CARGO_PKG_VERSION&quot;)).as_str())
        .define(&quot;WELCOME&quot;, None)
        .file(&quot;src/foo.c&quot;)
        .compile(&quot;foo&quot;);
}
</code></pre></pre>
<h3><a class="header" href="#srcfooc" id="srcfooc"><code>src/foo.c</code></a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void print_app_info() {
#ifdef WELCOME
    printf(&quot;Welcome to &quot;);
#endif
    printf(&quot;%s - version %s\n&quot;, APP_NAME, VERSION);
}
</code></pre>
<h3><a class="header" href="#srcmainrs-2" id="srcmainrs-2"><code>src/main.rs</code></a></h3>
<pre><code class="language-rust ignore">extern {
    fn print_app_info();
}

fn main(){
    unsafe {
        print_app_info();
    }   
}
</code></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#encoding-1" id="encoding-1">Encoding</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/encoding/strings.html#percent-encode-a-string">Percent-encode a string</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/strings.html#encode-a-string-as-applicationx-www-form-urlencoded">Encode a string as application/x-www-form-urlencoded</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/strings.html#encode-and-decode-hex">Encode and decode hex</a></td><td><a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/strings.html#encode-and-decode-base64">Encode and decode base64</a></td><td><a href="https://docs.rs/base64/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=base64" alt="base64-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#read-csv-records">Read CSV records</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#read-csv-records-with-different-delimiter">Read CSV records with different delimiter</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#filter-csv-records-matching-a-predicate">Filter CSV records matching a predicate</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#handle-invalid-csv-data-with-serde">Handle invalid CSV data with Serde</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#serialize-records-to-csv">Serialize records to CSV</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#serialize-records-to-csv-using-serde">Serialize records to CSV using Serde</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/csv.html#transform-csv-column">Transform one column of a CSV file</a></td><td><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/complex.html#serialize-and-deserialize-unstructured-json">Serialize and deserialize unstructured JSON</a></td><td><a href="https://docs.rs/serde_json/*/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/complex.html#deserialize-a-toml-configuration-file">Deserialize a TOML configuration file</a></td><td><a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/encoding/complex.html#read-and-write-integers-in-little-endian-byte-order">Read and write integers in little-endian byte order</a></td><td><a href="https://docs.rs/byteorder/"><img src="https://badge-cache.kominick.com/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#character-sets" id="character-sets">Character Sets</a></h1>
<h2><a class="header" href="#percent-encode-a-string" id="percent-encode-a-string">Percent-encode a string</a></h2>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Encode an input string with <a href="https://en.wikipedia.org/wiki/Percent-encoding">percent-encoding</a> using the <a href="https://docs.rs/percent-encoding/*/percent_encoding/fn.utf8_percent_encode.html"><code>utf8_percent_encode</code></a>
function from the <code>url</code> crate. Then decode using the <a href="https://docs.rs/percent-encoding/*/percent_encoding/fn.percent_decode.html"><code>percent_decode</code></a>
function.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;

use url::percent_encoding::{utf8_percent_encode, percent_decode, DEFAULT_ENCODE_SET};
use std::str::Utf8Error;

fn main() -&gt; Result&lt;(), Utf8Error&gt; {
    let input = &quot;confident, productive systems programming&quot;;

    let iter = utf8_percent_encode(input, DEFAULT_ENCODE_SET);
    let encoded: String = iter.collect();
    assert_eq!(encoded, &quot;confident,%20productive%20systems%20programming&quot;);

    let iter = percent_decode(encoded.as_bytes());
    let decoded = iter.decode_utf8()?;
    assert_eq!(decoded, &quot;confident, productive systems programming&quot;);

    Ok(())
}
</code></pre></pre>
<p>The encode set defines which bytes (in addition to non-ASCII and controls) need
to be percent-encoded. The choice of this set depends on context. For example,
<code>url</code> encodes <code>?</code> in a URL path but not in a query string.</p>
<p>The return value of encoding is an iterator of <code>&amp;str</code> slices which collect into
a <code>String</code>.</p>
<h2><a class="header" href="#encode-a-string-as-applicationx-www-form-urlencoded" id="encode-a-string-as-applicationx-www-form-urlencoded">Encode a string as application/x-www-form-urlencoded</a></h2>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Encodes a string into <a href="https://url.spec.whatwg.org/#application/x-www-form-urlencoded">application/x-www-form-urlencoded</a> syntax
using the <a href="https://docs.rs/url/*/url/form_urlencoded/fn.byte_serialize.html"><code>form_urlencoded::byte_serialize</code></a> and subsequently
decodes it with <a href="https://docs.rs/url/*/url/form_urlencoded/fn.parse.html"><code>form_urlencoded::parse</code></a>. Both functions return iterators
that collect into a <code>String</code>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;
use url::form_urlencoded::{byte_serialize, parse};

fn main() {
    let urlencoded: String = byte_serialize(&quot;What is ❤?&quot;.as_bytes()).collect();
    assert_eq!(urlencoded, &quot;What+is+%E2%9D%A4%3F&quot;);
    println!(&quot;urlencoded:'{}'&quot;, urlencoded);

    let decoded: String = parse(urlencoded.as_bytes())
        .map(|(key, val)| [key, val].concat())
        .collect();
    assert_eq!(decoded, &quot;What is ❤?&quot;);
    println!(&quot;decoded:'{}'&quot;, decoded);
}
</code></pre></pre>
<h2><a class="header" href="#encode-and-decode-hex" id="encode-and-decode-hex">Encode and decode hex</a></h2>
<p><a href="https://docs.rs/data-encoding/"><img src="https://badge-cache.kominick.com/crates/v/data-encoding.svg?label=data-encoding" alt="data-encoding-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The <a href="https://docs.rs/data-encoding/*/data_encoding/"><code>data_encoding</code></a> crate provides a <code>HEXUPPER::encode</code> method which
takes a <code>&amp;[u8]</code> and returns a <code>String</code> containing the hexadecimal
representation of the data.</p>
<p>Similarly, a <code>HEXUPPER::decode</code> method is provided which takes a <code>&amp;[u8]</code> and
returns a <code>Vec&lt;u8&gt;</code> if the input data is successfully decoded.</p>
<p>The example below coverts <code>&amp;[u8]</code> data to hexadecimal equivalent.  Compares this
value to the expected value.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate data_encoding;

use data_encoding::{HEXUPPER, DecodeError};

fn main() -&gt; Result&lt;(), DecodeError&gt; {
    let original = b&quot;The quick brown fox jumps over the lazy dog.&quot;;
    let expected = &quot;54686520717569636B2062726F776E20666F78206A756D7073206F76\
        657220746865206C617A7920646F672E&quot;;

    let encoded = HEXUPPER.encode(original);
    assert_eq!(encoded, expected);

    let decoded = HEXUPPER.decode(&amp;encoded.into_bytes())?;
    assert_eq!(&amp;decoded[..], &amp;original[..]);

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#encode-and-decode-base64" id="encode-and-decode-base64">Encode and decode base64</a></h2>
<p><a href="https://docs.rs/base64/"><img src="https://badge-cache.kominick.com/crates/v/base64.svg?label=base64" alt="base64-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Encodes byte slice into <code>base64</code> String using <a href="https://docs.rs/base64/*/base64/fn.encode.html"><code>encode</code></a>
and decodes it with <a href="https://docs.rs/base64/*/base64/fn.decode.html"><code>decode</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate base64;

use std::str;
use base64::{encode, decode};
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Base64(base64::DecodeError);
</span><span class="boring">        Utf8Error(str::Utf8Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let hello = b&quot;hello rustaceans&quot;;
    let encoded = encode(hello);
    let decoded = decode(&amp;encoded)?;

    println!(&quot;origin: {}&quot;, str::from_utf8(hello)?);
    println!(&quot;base64 encoded: {}&quot;, encoded);
    println!(&quot;back to origin: {}&quot;, str::from_utf8(&amp;decoded)?);

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#csv-processing" id="csv-processing">CSV processing</a></h1>
<h2><a class="header" href="#read-csv-records" id="read-csv-records">Read CSV records</a></h2>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Reads standard CSV records into <a href="https://docs.rs/csv/*/csv/struct.StringRecord.html"><code>csv::StringRecord</code></a> — a weakly typed
data representation which expects valid UTF-8 rows. Alternatively,
<a href="https://docs.rs/csv/*/csv/struct.ByteRecord.html"><code>csv::ByteRecord</code></a> makes no assumptions about UTF-8.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate csv;
use csv::Error;

fn main() -&gt; Result&lt;(), Error&gt; {
    let csv = &quot;year,make,model,description
		1948,Porsche,356,Luxury sports car
		1967,Ford,Mustang fastback 1967,American car&quot;;

    let mut reader = csv::Reader::from_reader(csv.as_bytes());
    for record in reader.records() {
        let record = record?;
        println!(
            &quot;In {}, {} built the {} model. It is a {}.&quot;,
            &amp;record[0],
            &amp;record[1],
            &amp;record[2],
            &amp;record[3]
        );
    }

    Ok(())
}
</code></pre></pre>
<p>Serde deserializes data into strongly type structures. See the
<a href="https://docs.rs/csv/*/csv/struct.Reader.html#method.deserialize"><code>csv::Reader::deserialize</code></a> method.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate csv;
<span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>#[macro_use]
extern crate serde_derive;

<span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Reader(csv::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(Deserialize)]
struct Record {
    year: u16,
    make: String,
    model: String,
    description: String,
}

fn run() -&gt; Result&lt;()&gt; {
    let csv = &quot;year,make,model,description
1948,Porsche,356,Luxury sports car
1967,Ford,Mustang fastback 1967,American car&quot;;

    let mut reader = csv::Reader::from_reader(csv.as_bytes());

    for record in reader.deserialize() {
        let record: Record = record?;
        println!(
            &quot;In {}, {} built the {} model. It is a {}.&quot;,
            record.year,
            record.make,
            record.model,
            record.description
        );
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#read-csv-records-with-different-delimiter" id="read-csv-records-with-different-delimiter">Read CSV records with different delimiter</a></h2>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Reads CSV records with a tab <a href="https://docs.rs/csv/1.0.0-beta.3/csv/struct.ReaderBuilder.html#method.delimiter"><code>delimiter</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate csv;
use csv::Error;
#[macro_use]
extern crate serde_derive;

#[derive(Debug, Deserialize)]
struct Record {
    name: String,
    place: String,
    #[serde(deserialize_with = &quot;csv::invalid_option&quot;)]
    id: Option&lt;u64&gt;,
}

use csv::ReaderBuilder;

fn main() -&gt; Result&lt;(), Error&gt; {
    let data = &quot;name\tplace\tid
		Mark\tMelbourne\t46
		Ashley\tZurich\t92&quot;;

    let mut reader = ReaderBuilder::new().delimiter(b'\t').from_reader(data.as_bytes());
    for result in reader.deserialize::&lt;Record&gt;() {
        println!(&quot;{:?}&quot;, result?);
    }

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#filter-csv-records-matching-a-predicate" id="filter-csv-records-matching-a-predicate">Filter CSV records matching a predicate</a></h2>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Returns <em>only</em> the rows from <code>data</code> with a field that matches <code>query</code>.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate csv;

use std::io;
<span class="boring">
</span><span class="boring">error_chain!{
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        CsvError(csv::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let query = &quot;CA&quot;;
    let data = &quot;\
City,State,Population,Latitude,Longitude
Kenai,AK,7610,60.5544444,-151.2583333
Oakman,AL,,33.7133333,-87.3886111
Sandfort,AL,,32.3380556,-85.2233333
West Hollywood,CA,37031,34.0900000,-118.3608333&quot;;

    let mut rdr = csv::ReaderBuilder::new().from_reader(data.as_bytes());
    let mut wtr = csv::Writer::from_writer(io::stdout());

    wtr.write_record(rdr.headers()?)?;

    for result in rdr.records() {
        let record = result?;
        if record.iter().any(|field| field == query) {
            wtr.write_record(&amp;record)?;
        }
    }

    wtr.flush()?;
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<p><em>Disclaimer: this example has been adapted from <a href="https://docs.rs/csv/*/csv/tutorial/index.html#filter-by-search">the csv crate tutorial</a></em>.</p>
<h2><a class="header" href="#handle-invalid-csv-data-with-serde" id="handle-invalid-csv-data-with-serde">Handle invalid CSV data with Serde</a></h2>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>CSV files often contain invalid data. For these cases, the <code>csv</code> crate
provides a custom deserializer, <a href="https://docs.rs/csv/*/csv/fn.invalid_option.html"><code>csv::invalid_option</code></a>, which automatically
converts invalid data to None values.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate csv;
use csv::Error;
#[macro_use]
extern crate serde_derive;

#[derive(Debug, Deserialize)]
struct Record {
    name: String,
    place: String,
    #[serde(deserialize_with = &quot;csv::invalid_option&quot;)]
    id: Option&lt;u64&gt;,
}

fn main() -&gt; Result&lt;(), Error&gt; {
    let data = &quot;name,place,id
mark,sydney,46.5
ashley,zurich,92
akshat,delhi,37
alisha,colombo,xyz&quot;;

    let mut rdr = csv::Reader::from_reader(data.as_bytes());
    for result in rdr.deserialize() {
        let record: Record = result?;
        println!(&quot;{:?}&quot;, record);
    }

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#serialize-records-to-csv" id="serialize-records-to-csv">Serialize records to CSV</a></h2>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>This example shows how to serialize a Rust tuple. <a href="https://docs.rs/csv/*/csv/struct.Writer.html"><code>csv::writer</code></a> supports automatic
serialization from Rust types into CSV records. <a href="https://docs.rs/csv/*/csv/struct.Writer.html#method.write_record"><code>write_record</code></a> writes
a simple record containing string data only. Data with more complex values
such as numbers, floats, and options use <a href="https://docs.rs/csv/*/csv/struct.Writer.html#method.serialize"><code>serialize</code></a>. Since CSV
writer uses internal buffer, always explicitly <a href="https://docs.rs/csv/*/csv/struct.Writer.html#method.flush"><code>flush</code></a> when done.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate csv;

use std::io;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        CSVError(csv::Error);
</span><span class="boring">        IOError(std::io::Error);
</span><span class="boring">   }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let mut wtr = csv::Writer::from_writer(io::stdout());

    wtr.write_record(&amp;[&quot;Name&quot;, &quot;Place&quot;, &quot;ID&quot;])?;

    wtr.serialize((&quot;Mark&quot;, &quot;Sydney&quot;, 87))?;
    wtr.serialize((&quot;Ashley&quot;, &quot;Dublin&quot;, 32))?;
    wtr.serialize((&quot;Akshat&quot;, &quot;Delhi&quot;, 11))?;

    wtr.flush()?;
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#serialize-records-to-csv-using-serde" id="serialize-records-to-csv-using-serde">Serialize records to CSV using Serde</a></h2>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The following example shows how to serialize custom structs as CSV records using
the <a href="https://docs.rs/serde/">serde</a> crate.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate csv;
#[macro_use]
extern crate serde_derive;

use std::io;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">   foreign_links {
</span><span class="boring">       IOError(std::io::Error);
</span><span class="boring">       CSVError(csv::Error);
</span><span class="boring">   }
</span><span class="boring">}
</span>
#[derive(Serialize)]
struct Record&lt;'a&gt; {
    name: &amp;'a str,
    place: &amp;'a str,
    id: u64,
}

fn run() -&gt; Result&lt;()&gt; {
    let mut wtr = csv::Writer::from_writer(io::stdout());

    let rec1 = Record { name: &quot;Mark&quot;, place: &quot;Melbourne&quot;, id: 56};
    let rec2 = Record { name: &quot;Ashley&quot;, place: &quot;Sydney&quot;, id: 64};
    let rec3 = Record { name: &quot;Akshat&quot;, place: &quot;Delhi&quot;, id: 98};

    wtr.serialize(rec1)?;
    wtr.serialize(rec2)?;
    wtr.serialize(rec3)?;

    wtr.flush()?;

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#transform-csv-column" id="transform-csv-column">Transform CSV column</a></h2>
<p><a href="https://docs.rs/csv/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=csv" alt="csv-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Transform a CSV file containing a color name and a hex color into one with a
color name and an rgb color.  Utilizes the <a href="https://docs.rs/csv/">csv</a> crate to read and write the
csv file, and <a href="https://docs.rs/serde/">serde</a> to deserialize and serialize the rows to and from bytes.</p>
<p>See <a href="https://docs.rs/csv/*/csv/struct.Reader.html#method.deserialize"><code>csv::Reader::deserialize</code></a>, <a href="https://docs.rs/serde/*/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>, and <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>std::str::FromStr</code></a></p>
<pre><pre class="playpen"><code class="language-rust">extern crate csv;
<span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>#[macro_use]
extern crate serde_derive;
extern crate serde;

use csv::{Reader, Writer};
use serde::{de, Deserialize, Deserializer};
use std::str::FromStr;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">   foreign_links {
</span><span class="boring">       CsvError(csv::Error);
</span><span class="boring">       ParseInt(std::num::ParseIntError);
</span><span class="boring">       CsvInnerError(csv::IntoInnerError&lt;Writer&lt;Vec&lt;u8&gt;&gt;&gt;);
</span><span class="boring">       IO(std::fmt::Error);
</span><span class="boring">       UTF8(std::string::FromUtf8Error);
</span><span class="boring">   }
</span><span class="boring">}
</span>
#[derive(Debug)]
struct HexColor {
    red: u8,
    green: u8,
    blue: u8,
}

#[derive(Debug, Deserialize)]
struct Row {
    color_name: String,
    color: HexColor,
}

impl FromStr for HexColor {
    type Err = Error;

    fn from_str(hex_color: &amp;str) -&gt; std::result::Result&lt;Self, Self::Err&gt; {
        let trimmed = hex_color.trim_matches('#');
        if trimmed.len() != 6 {
            Err(&quot;Invalid length of hex string&quot;.into())
        } else {
            Ok(HexColor {
                red: u8::from_str_radix(&amp;trimmed[..2], 16)?,
                green: u8::from_str_radix(&amp;trimmed[2..4], 16)?,
                blue: u8::from_str_radix(&amp;trimmed[4..6], 16)?,
            })
        }
    }
}

impl&lt;'de&gt; Deserialize&lt;'de&gt; for HexColor {
    fn deserialize&lt;D&gt;(deserializer: D) -&gt; std::result::Result&lt;Self, D::Error&gt;
    where
        D: Deserializer&lt;'de&gt;,
    {
        let s = String::deserialize(deserializer)?;
        FromStr::from_str(&amp;s).map_err(de::Error::custom)
    }
}

fn run() -&gt; Result&lt;()&gt; {
    let data = &quot;color_name,color
red,#ff0000
green,#00ff00
blue,#0000FF
periwinkle,#ccccff
magenta,#ff00ff&quot;
        .to_owned();
    let mut out = Writer::from_writer(vec![]);
    let mut reader = Reader::from_reader(data.as_bytes());
    for result in reader.deserialize::&lt;Row&gt;() {
        let res = result?;
        out.serialize((
            res.color_name,
            res.color.red,
            res.color.green,
            res.color.blue,
        ))?;
    }
    let written = String::from_utf8(out.into_inner()?)?;
    assert_eq!(Some(&quot;magenta,255,0,255&quot;), written.lines().last());
    println!(&quot;{}&quot;, written);
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#structured-data" id="structured-data">Structured Data</a></h1>
<h2><a class="header" href="#serialize-and-deserialize-unstructured-json" id="serialize-and-deserialize-unstructured-json">Serialize and deserialize unstructured JSON</a></h2>
<p><a href="https://docs.rs/serde_json/*/serde_json/"><img src="https://badge-cache.kominick.com/crates/v/serde_json.svg?label=serde_json" alt="serde-json-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The <a href="https://docs.serde.rs/serde_json/"><code>serde_json</code></a> crate provides a <a href="https://docs.serde.rs/serde_json/fn.from_str.html"><code>from_str</code></a> function to parse a <code>&amp;str</code> of
JSON.</p>
<p>Unstructured JSON can be parsed into a universal <a href="https://docs.serde.rs/serde_json/enum.Value.html"><code>serde_json::Value</code></a> type that
is able to represent any valid JSON data.</p>
<p>The example below shows a <code>&amp;str</code> of JSON being parsed.  The expected value is declared using the <a href="https://docs.serde.rs/serde_json/macro.json.html"><code>json!</code></a> macro.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate serde_json;

use serde_json::{Value, Error};

fn main() -&gt; Result&lt;(), Error&gt; {
    let j = r#&quot;{
                 &quot;userid&quot;: 103609,
                 &quot;verified&quot;: true,
                 &quot;access_privileges&quot;: [
                   &quot;user&quot;,
                   &quot;admin&quot;
                 ]
               }&quot;#;

    let parsed: Value = serde_json::from_str(j)?;

    let expected = json!({
        &quot;userid&quot;: 103609,
        &quot;verified&quot;: true,
        &quot;access_privileges&quot;: [
            &quot;user&quot;,
            &quot;admin&quot;
        ]
    });

    assert_eq!(parsed, expected);

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#deserialize-a-toml-configuration-file" id="deserialize-a-toml-configuration-file">Deserialize a TOML configuration file</a></h2>
<p><a href="https://docs.rs/toml/"><img src="https://badge-cache.kominick.com/crates/v/toml.svg?label=toml" alt="toml-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Parse some TOML into a universal <code>toml::Value</code> that is able to represent any
valid TOML data.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate toml;

use toml::{Value, de::Error};

fn main() -&gt; Result&lt;(), Error&gt; {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Value = toml::from_str(toml_content)?;

    assert_eq!(package_info[&quot;dependencies&quot;][&quot;serde&quot;].as_str(), Some(&quot;1.0&quot;));
    assert_eq!(package_info[&quot;package&quot;][&quot;name&quot;].as_str(),
               Some(&quot;your_package&quot;));

    Ok(())
}
</code></pre></pre>
<p>Parse TOML into your own structs using <a href="https://docs.rs/serde/">Serde</a>.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>#[macro_use]
extern crate serde_derive;
extern crate toml;

use std::collections::HashMap;

#[derive(Deserialize)]
struct Config {
    package: Package,
    dependencies: HashMap&lt;String, String&gt;,
}

#[derive(Deserialize)]
struct Package {
    name: String,
    version: String,
    authors: Vec&lt;String&gt;,
}
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Toml(toml::de::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let toml_content = r#&quot;
          [package]
          name = &quot;your_package&quot;
          version = &quot;0.1.0&quot;
          authors = [&quot;You! &lt;you@example.org&gt;&quot;]

          [dependencies]
          serde = &quot;1.0&quot;
          &quot;#;

    let package_info: Config = toml::from_str(toml_content)?;

    assert_eq!(package_info.package.name, &quot;your_package&quot;);
    assert_eq!(package_info.package.version, &quot;0.1.0&quot;);
    assert_eq!(package_info.package.authors, vec![&quot;You! &lt;you@example.org&gt;&quot;]);
    assert_eq!(package_info.dependencies[&quot;serde&quot;], &quot;1.0&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#read-and-write-integers-in-little-endian-byte-order" id="read-and-write-integers-in-little-endian-byte-order">Read and write integers in little-endian byte order</a></h2>
<p><a href="https://docs.rs/byteorder/"><img src="https://badge-cache.kominick.com/crates/v/byteorder.svg?label=byteorder" alt="byteorder-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p><code>byteorder</code> can reverse the significant bytes of structured data.  This may
be necessary when receiving information over the network, such that bytes
received are from another system.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate byteorder;

use byteorder::{LittleEndian, ReadBytesExt, WriteBytesExt};
use std::io::Error;

#[derive(Default, PartialEq, Debug)]
struct Payload {
    kind: u8,
    value: u16,
}

fn main() -&gt; Result&lt;(), Error&gt; {
    let original_payload = Payload::default();
    let encoded_bytes = encode(&amp;original_payload)?;
    let decoded_payload = decode(&amp;encoded_bytes)?;
    assert_eq!(original_payload, decoded_payload);
    Ok(())
}

fn encode(payload: &amp;Payload) -&gt; Result&lt;Vec&lt;u8&gt;, Error&gt; {
    let mut bytes = vec![];
    bytes.write_u8(payload.kind)?;
    bytes.write_u16::&lt;LittleEndian&gt;(payload.value)?;
    Ok(bytes)
}

fn decode(mut bytes: &amp;[u8]) -&gt; Result&lt;Payload, Error&gt; {
    let payload = Payload {
        kind: bytes.read_u8()?,
        value: bytes.read_u16::&lt;LittleEndian&gt;()?,
    };
    Ok(payload)
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#error-handling-2" id="error-handling-2">Error Handling</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/errors/handle.html#handle-errors-correctly-in-main">Handle errors correctly in main</a></td><td><a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a></td><td><a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/errors/handle.html#avoid-discarding-errors-during-error-conversions">Avoid discarding errors during error conversions</a></td><td><a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a></td><td><a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/errors/handle.html#obtain-backtrace-of-complex-error-scenarios">Obtain backtrace of complex error scenarios</a></td><td><a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a></td><td><a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#error-handling-3" id="error-handling-3">Error Handling</a></h1>
<h2><a class="header" href="#handle-errors-correctly-in-main" id="handle-errors-correctly-in-main">Handle errors correctly in main</a></h2>
<p><a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p>Handles error that occur when trying to open a file that does not
exist. It is achieved by using <a href="https://docs.rs/error-chain/">error-chain</a>, a library that takes
care of a lot of boilerplate code needed in order to <a href="https://doc.rust-lang.org/book/second-edition/ch09-00-error-handling.html">handle errors in Rust</a>.</p>
<p><code>Io(std::io::Error)</code> inside <a href="https://docs.rs/error-chain/*/error_chain/#foreign-links"><code>foreign_links</code></a> allows automatic
conversion from <a href="https://doc.rust-lang.org/std/io/struct.Error.html"><code>std::io::Error</code></a> into <a href="https://docs.rs/error-chain/*/error_chain/macro.error_chain.html"><code>error_chain!</code></a> defined type
implementing the <a href="https://doc.rust-lang.org/std/error/trait.Error.html"><code>Error</code></a> trait.</p>
<p>The below recipe will tell how long the system has been running by
opening the Unix file <code>/proc/uptime</code> and parse the content to get the
first number. Returns uptime unless there is an error.</p>
<p>Other recipes in this book will hide the <a href="https://docs.rs/error-chain/">error-chain</a> boilerplate, and can be
seen by expanding the code with the ⤢ button.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;

use std::fs::File;
use std::io::Read;

error_chain!{
    foreign_links {
        Io(std::io::Error);
        ParseInt(::std::num::ParseIntError);
    }
}

fn read_uptime() -&gt; Result&lt;u64&gt; {
    let mut uptime = String::new();
    File::open(&quot;/proc/uptime&quot;)?.read_to_string(&amp;mut uptime)?;

    Ok(uptime
        .split('.')
        .next()
        .ok_or(&quot;Cannot parse uptime data&quot;)?
        .parse()?)
}

fn main() {
    match read_uptime() {
        Ok(uptime) =&gt; println!(&quot;uptime: {} seconds&quot;, uptime),
        Err(err) =&gt; eprintln!(&quot;error: {}&quot;, err),
    };
}
</code></pre></pre>
<h2><a class="header" href="#avoid-discarding-errors-during-error-conversions" id="avoid-discarding-errors-during-error-conversions">Avoid discarding errors during error conversions</a></h2>
<p><a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p>The  <a href="https://docs.rs/error-chain/">error-chain</a> crate makes <a href="https://docs.rs/error-chain/*/error_chain/#matching-errors">matching</a> on different error types returned by
a function possible and relatively compact. <a href="https://docs.rs/error-chain/*/error_chain/example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> determines the error
type.</p>
<p>Uses <a href="https://docs.rs/reqwest/">reqwest</a> to query a random integer generator web service.  Converts
the string response into an integer. The Rust standard library,
<a href="https://docs.rs/reqwest/">reqwest</a>, and the web service can all generate errors. Well defined Rust errors
use <a href="https://docs.rs/error-chain/*/error_chain/#foreign-links"><code>foreign_links</code></a>. An additional <a href="https://docs.rs/error-chain/*/error_chain/example_generated/enum.ErrorKind.html"><code>ErrorKind</code></a> variant for the web service
error uses <code>errors</code> block of the <code>error_chain!</code> macro.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate error_chain;
extern crate reqwest;

use std::io::Read;

error_chain! {
    foreign_links {
        Io(std::io::Error);
        Reqwest(reqwest::Error);
        ParseIntError(std::num::ParseIntError);
    }

    errors { RandomResponseError(t: String) }
}

fn parse_response(mut response: reqwest::Response) -&gt; Result&lt;u32&gt; {
    let mut body = String::new();
    response.read_to_string(&amp;mut body)?;
    body.pop();
    body.parse::&lt;u32&gt;()
        .chain_err(|| ErrorKind::RandomResponseError(body))
}

fn run() -&gt; Result&lt;()&gt; {
    let url =
        format!(&quot;https://www.random.org/integers/?num=1&amp;min=0&amp;max=10&amp;col=1&amp;base=10&amp;format=plain&quot;);
    let response = reqwest::get(&amp;url)?;
    let random_value: u32 = parse_response(response)?;

    println!(&quot;a random number between 0 and 10: {}&quot;, random_value);

    Ok(())
}

fn main() {
    if let Err(error) = run() {
        match *error.kind() {
            ErrorKind::Io(_) =&gt; println!(&quot;Standard IO error: {:?}&quot;, error),
            ErrorKind::Reqwest(_) =&gt; println!(&quot;Reqwest error: {:?}&quot;, error),
            ErrorKind::ParseIntError(_) =&gt; println!(&quot;Standard parse int error: {:?}&quot;, error),
            ErrorKind::RandomResponseError(_) =&gt; println!(&quot;User defined error: {:?}&quot;, error),
            _ =&gt; println!(&quot;Other error: {:?}&quot;, error),
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#obtain-backtrace-of-complex-error-scenarios" id="obtain-backtrace-of-complex-error-scenarios">Obtain backtrace of complex error scenarios</a></h2>
<p><a href="https://docs.rs/error-chain/"><img src="https://badge-cache.kominick.com/crates/v/error-chain.svg?label=error-chain" alt="error-chain-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p>This recipe shows how to handle a complex error scenario and then
print a backtrace. It relies on <a href="https://docs.rs/error-chain/*/error_chain/index.html#chaining-errors"><code>chain_err</code></a> to extend errors by
appending new errors. The error stack can be unwound, thus providing
a better context to understand why an error was raised.</p>
<p>The below recipes attempts to deserialize the value <code>256</code> into a
<code>u8</code>. An error will bubble up from Serde then csv and finally up to the
user code.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">extern crate csv;
</span>#[macro_use]
extern crate error_chain;
<span class="boring">#[macro_use]
</span><span class="boring">extern crate serde_derive;
</span><span class="boring">
</span><span class="boring">use std::fmt;
</span><span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Reader(csv::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
#[derive(Debug, Deserialize)]
struct Rgb {
    red: u8,
    blue: u8,
    green: u8,
}

impl Rgb {
    fn from_reader(csv_data: &amp;[u8]) -&gt; Result&lt;Rgb&gt; {
        let color: Rgb = csv::Reader::from_reader(csv_data)
            .deserialize()
            .nth(0)
            .ok_or(&quot;Cannot deserialize the first CSV record&quot;)?
            .chain_err(|| &quot;Cannot deserialize RGB color&quot;)?;

        Ok(color)
    }
}

<span class="boring">impl fmt::UpperHex for Rgb {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
</span><span class="boring">        let hexa = u32::from(self.red) &lt;&lt; 16 | u32::from(self.blue) &lt;&lt; 8 | u32::from(self.green);
</span><span class="boring">        write!(f, &quot;{:X}&quot;, hexa)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run() -&gt; Result&lt;()&gt; {
    let csv = &quot;red,blue,green
102,256,204&quot;;

    let rgb = Rgb::from_reader(csv.as_bytes()).chain_err(|| &quot;Cannot read CSV data&quot;)?;
    println!(&quot;{:?} to hexadecimal #{:X}&quot;, rgb, rgb);

    Ok(())
}

fn main() {
    if let Err(ref errors) = run() {
        eprintln!(&quot;Error level - description&quot;);
        errors
            .iter()
            .enumerate()
            .for_each(|(index, error)| eprintln!(&quot;└&gt; {} - {}&quot;, index, error));

        if let Some(backtrace) = errors.backtrace() {
            eprintln!(&quot;{:?}&quot;, backtrace);
        }
<span class="boring">
</span><span class="boring">        // In a real use case, errors should handled. For example:
</span><span class="boring">        // ::std::process::exit(1);
</span>    }
}
</code></pre></pre>
<p>Backtrace error rendered:</p>
<pre><code class="language-text">Error level - description
└&gt; 0 - Cannot read CSV data
└&gt; 1 - Cannot deserialize RGB color
└&gt; 2 - CSV deserialize error: record 1 (line: 2, byte: 15): field 1: number too large to fit in target type
└&gt; 3 - field 1: number too large to fit in target type
</code></pre>
<p>Run the recipe with <code>RUST_BACKTRACE=1</code> to display a detailed <a href="https://docs.rs/error-chain/*/error_chain/trait.ChainedError.html#tymethod.backtrace"><code>backtrace</code></a> associated with this error.</p>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#file-system-1" id="file-system-1">File System</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/file/read-write.html#read-lines-of-strings-from-a-file">Read lines of strings from a file</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/read-write.html#avoid-writing-and-reading-from-a-same-file">Avoid writing and reading from a same file</a></td><td><a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/read-write.html#access-a-file-randomly-using-a-memory-map">Access a file randomly using a memory map</a></td><td><a href="https://docs.rs/memmap/"><img src="https://badge-cache.kominick.com/crates/v/memmap.svg?label=memmap" alt="memmap-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#file-names-that-have-been-modified-in-the-last-24-hours">File names that have been modified in the last 24 hours</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#find-loops-for-a-given-path">Find loops for a given path</a></td><td><a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#recursively-find-duplicate-file-names">Recursively find duplicate file names</a></td><td><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#recursively-find-all-files-with-given-predicate">Recursively find all files with given predicate</a></td><td><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#traverse-directories-while-skipping-dotfiles">Traverse directories while skipping dotfiles</a></td><td><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#recursively-calculate-file-sizes-at-given-depth">Recursively calculate file sizes at given depth</a></td><td><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#find-all-png-files-recursively">Find all png files recursively</a></td><td><a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/file/dir.html#find-all-files-with-given-pattern-ignoring-filename-case">Find all files with given pattern ignoring filename case</a></td><td><a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a></td><td><a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#read--write" id="read--write">Read &amp; Write</a></h1>
<h2><a class="header" href="#read-lines-of-strings-from-a-file" id="read-lines-of-strings-from-a-file">Read lines of strings from a file</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Writes a three-line message to a file, then reads it back a line at a
time with the <a href="https://doc.rust-lang.org/std/io/struct.Lines.html"><code>Lines</code></a> iterator created by
<a href="https://doc.rust-lang.org/std/io/trait.BufRead.html#method.lines"><code>BufRead::lines</code></a>. <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> implements <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>Read</code></a> which provides <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a>
trait.  <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.create"><code>File::create</code></a> opens a <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> for writing, <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.open"><code>File::open</code></a> for
reading.</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::{Write, BufReader, BufRead, Error};

fn main() -&gt; Result&lt;(), Error&gt; {
    let path = &quot;lines.txt&quot;;

    let mut output = File::create(path)?;
    write!(output, &quot;Rust\n💖\nFun&quot;)?;

    let input = File::open(path)?;
    let buffered = BufReader::new(input);

    for line in buffered.lines() {
        println!(&quot;{}&quot;, line?);
    }

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#avoid-writing-and-reading-from-a-same-file" id="avoid-writing-and-reading-from-a-same-file">Avoid writing and reading from a same file</a></h2>
<p><a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Use <a href="https://docs.rs/same-file/*/same_file/struct.Handle.html"><code>same_file::Handle</code></a> to a file that can be tested for equality with
other handles. In this example, the handles of file to be read from and
to be written to are tested for equality.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate same_file;

use same_file::Handle;
use std::fs::File;
use std::io::{BufRead, BufReader, Error, ErrorKind};
use std::path::Path;

fn main() -&gt; Result&lt;(), Error&gt; {
    let path_to_read = Path::new(&quot;new.txt&quot;);

    let stdout_handle = Handle::stdout()?;
    let handle = Handle::from_path(path_to_read)?;

    if stdout_handle == handle {
        return Err(Error::new(
            ErrorKind::Other,
            &quot;You are reading and writing to the same file&quot;,
        ));
    } else {
        let file = File::open(&amp;path_to_read)?;
        let file = BufReader::new(file);
        for (num, line) in file.lines().enumerate() {
            println!(&quot;{} : {}&quot;, num, line?.to_uppercase());
        }
    }

    Ok(())
}
</code></pre></pre>
<pre><code class="language-bash">cargo run
</code></pre>
<p>displays the contents of the file new.txt.</p>
<pre><code class="language-bash">cargo run &gt;&gt; ./new.txt
</code></pre>
<p>errors because the two files are same.</p>
<h2><a class="header" href="#access-a-file-randomly-using-a-memory-map" id="access-a-file-randomly-using-a-memory-map">Access a file randomly using a memory map</a></h2>
<p><a href="https://docs.rs/memmap/"><img src="https://badge-cache.kominick.com/crates/v/memmap.svg?label=memmap" alt="memmap-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Creates a memory map of a file using <a href="https://docs.rs/memmap/">memmap</a> and simulates some non-sequential
reads from the file. Using a memory map means you just index into a slice rather
than dealing with <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.seek"><code>seek</code></a> to navigate a File.</p>
<p>The <a href="https://docs.rs/memmap/*/memmap/struct.Mmap.html#method.map"><code>Mmap::map</code></a> function assumes the file
behind the memory map is not being modified at the same time by another process
or else a <a href="https://en.wikipedia.org/wiki/Race_condition#File_systems">race condition</a> occurs.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate memmap;

use memmap::Mmap;
use std::fs::File;
use std::io::{Write, Error};

fn main() -&gt; Result&lt;(), Error&gt; {
<span class="boring">    write!(File::create(&quot;content.txt&quot;)?, &quot;My hovercraft is full of eels!&quot;)?;
</span><span class="boring">
</span>    let file = File::open(&quot;content.txt&quot;)?;
    let map = unsafe { Mmap::map(&amp;file)? };

    let random_indexes = [0, 1, 2, 19, 22, 10, 11, 29];
    assert_eq!(&amp;map[3..13], b&quot;hovercraft&quot;);
    let random_bytes: Vec&lt;u8&gt; = random_indexes.iter()
        .map(|&amp;idx| map[idx])
        .collect();
    assert_eq!(&amp;random_bytes[..], b&quot;My loaf!&quot;);
    Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#directory-traversal" id="directory-traversal">Directory Traversal</a></h1>
<h2><a class="header" href="#file-names-that-have-been-modified-in-the-last-24-hours" id="file-names-that-have-been-modified-in-the-last-24-hours">File names that have been modified in the last 24 hours</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Gets the current working directory by calling <a href="https://doc.rust-lang.org/std/env/fn.current_dir.html"><code>env::current_dir</code></a>,
then for each entries in <a href="https://doc.rust-lang.org/std/fs/fn.read_dir.html"><code>fs::read_dir</code></a>, extracts the
<a href="https://doc.rust-lang.org/std/fs/struct.DirEntry.html#method.path"><code>DirEntry::path</code></a> and gets the metadata via <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html"><code>fs::Metadata</code></a>. The
<a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html#method.modified"><code>Metadata::modified</code></a> returns the <a href="https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.elapsed"><code>SystemTime::elapsed</code></a> time since
last modification. <a href="https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs"><code>Duration::as_secs</code></a> converts the time to seconds and
compared with 24 hours (24 * 60 * 60 seconds). <a href="https://doc.rust-lang.org/std/fs/struct.Metadata.html#method.is_file"><code>Metadata::is_file</code></a> filters
out directories.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span><span class="boring">
</span>use std::{env, fs};

<span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        SystemTimeError(std::time::SystemTimeError);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run() -&gt; Result&lt;()&gt; {
    let current_dir = env::current_dir()?;
    println!(
        &quot;Entries modified in the last 24 hours in {:?}:&quot;,
        current_dir
    );

    for entry in fs::read_dir(current_dir)? {
        let entry = entry?;
        let path = entry.path();

        let metadata = fs::metadata(&amp;path)?;
        let last_modified = metadata.modified()?.elapsed()?.as_secs();

        if last_modified &lt; 24 * 3600 &amp;&amp; metadata.is_file() {
            println!(
                &quot;Last modified: {:?} seconds, is read only: {:?}, size: {:?} bytes, filename: {:?}&quot;,
                last_modified,
                metadata.permissions().readonly(),
                metadata.len(),
                path.file_name().ok_or(&quot;No filename&quot;)?
            );
        }
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#find-loops-for-a-given-path" id="find-loops-for-a-given-path">Find loops for a given path</a></h2>
<p><a href="https://docs.rs/same-file/"><img src="https://badge-cache.kominick.com/crates/v/same_file.svg?label=same_file" alt="same_file-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Use <a href="https://docs.rs/same-file/*/same_file/fn.is_same_file.html"><code>same_file::is_same_file</code></a> to detect loops for a given path.
For example, a loop could be created on a Unix system via symlinks:</p>
<pre><code class="language-bash">mkdir -p /tmp/foo/bar/baz
ln -s /tmp/foo/  /tmp/foo/bar/baz/qux
</code></pre>
<p>The following would assert that a loop exists.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate same_file;

use std::io;
use std::path::{Path, PathBuf};
use same_file::is_same_file;

fn contains_loop&lt;P: AsRef&lt;Path&gt;&gt;(path: P) -&gt; io::Result&lt;Option&lt;(PathBuf, PathBuf)&gt;&gt; {
    let path = path.as_ref();
    let mut path_buf = path.to_path_buf();
    while path_buf.pop() {
        if is_same_file(&amp;path_buf, path)? {
            return Ok(Some((path_buf, path.to_path_buf())));
        } else if let Some(looped_paths) = contains_loop(&amp;path_buf)? {
            return Ok(Some(looped_paths));
        }
    }
    return Ok(None);
}

fn main() {
    assert_eq!(
        contains_loop(&quot;/tmp/foo/bar/baz/qux/bar/baz&quot;).unwrap(),
        Some((
            PathBuf::from(&quot;/tmp/foo&quot;),
            PathBuf::from(&quot;/tmp/foo/bar/baz/qux&quot;)
        ))
    );
}
</code></pre></pre>
<h2><a class="header" href="#recursively-find-duplicate-file-names" id="recursively-find-duplicate-file-names">Recursively find duplicate file names</a></h2>
<p><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Find recursively in the current directory duplicate filenames,
printing them only once.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate walkdir;

use std::collections::HashMap;
use walkdir::WalkDir;

fn main() {
    let mut filenames = HashMap::new();

    for entry in WalkDir::new(&quot;.&quot;)
            .into_iter()
            .filter_map(Result::ok)
            .filter(|e| !e.file_type().is_dir()) {
        let f_name = String::from(entry.file_name().to_string_lossy());
        let counter = filenames.entry(f_name.clone()).or_insert(0);
        *counter += 1;

        if *counter == 2 {
            println!(&quot;{}&quot;, f_name);
        }
    }
}
</code></pre></pre>
<h2><a class="header" href="#recursively-find-all-files-with-given-predicate" id="recursively-find-all-files-with-given-predicate">Recursively find all files with given predicate</a></h2>
<p><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Find JSON files modified within the last day in the current directory.
Using <a href="https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.follow_links"><code>follow_links</code></a> ensures symbolic links are followed like they were
normal directories and files.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate walkdir;

use walkdir::WalkDir;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        WalkDir(walkdir::Error);
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        SystemTime(std::time::SystemTimeError);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    for entry in WalkDir::new(&quot;.&quot;)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok()) {
        let f_name = entry.file_name().to_string_lossy();
        let sec = entry.metadata()?.modified()?;

        if f_name.ends_with(&quot;.json&quot;) &amp;&amp; sec.elapsed()?.as_secs() &lt; 86400 {
            println!(&quot;{}&quot;, f_name);
        }
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#traverse-directories-while-skipping-dotfiles" id="traverse-directories-while-skipping-dotfiles">Traverse directories while skipping dotfiles</a></h2>
<p><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Uses <a href="https://docs.rs/walkdir/*/walkdir/struct.IntoIter.html#method.filter_entry"><code>filter_entry</code></a> to descend recursively into entries passing the
<code>is_not_hidden</code> predicate thus skipping hidden files and directories.
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.filter"><code>Iterator::filter</code></a> applies to each <a href="https://docs.rs/walkdir/*/walkdir/struct.DirEntry.html"><code>WalkDir::DirEntry</code></a> even if the parent
is a hidden directory.</p>
<p>Root dir <code>&quot;.&quot;</code> yields through <a href="https://docs.rs/walkdir/*/walkdir/struct.DirEntry.html#method.depth"><code>WalkDir::depth</code></a> usage in <code>is_not_hidden</code>
predicate.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate walkdir;

use walkdir::{DirEntry, WalkDir};

fn is_not_hidden(entry: &amp;DirEntry) -&gt; bool {
    entry
         .file_name()
         .to_str()
         .map(|s| entry.depth() == 0 || !s.starts_with(&quot;.&quot;))
         .unwrap_or(false)
}

fn main() {
    WalkDir::new(&quot;.&quot;)
        .into_iter()
        .filter_entry(|e| is_not_hidden(e))
        .filter_map(|v| v.ok())
        .for_each(|x| println!(&quot;{}&quot;, x.path().display()));
}
</code></pre></pre>
<h2><a class="header" href="#recursively-calculate-file-sizes-at-given-depth" id="recursively-calculate-file-sizes-at-given-depth">Recursively calculate file sizes at given depth</a></h2>
<p><a href="https://docs.rs/walkdir/"><img src="https://badge-cache.kominick.com/crates/v/walkdir.svg?label=walkdir" alt="walkdir-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Recursion depth can be flexibly set by <a href="https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.min_depth"><code>WalkDir::min_depth</code></a> &amp; <a href="https://docs.rs/walkdir/*/walkdir/struct.WalkDir.html#method.max_depth"><code>WalkDir::max_depth</code></a> methods.
Calculates sum of all file sizes to 3 subfolders depth, ignoring files in the root folder.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate walkdir;

use walkdir::WalkDir;

fn main() {
    let total_size = WalkDir::new(&quot;.&quot;)
        .min_depth(1)
        .max_depth(3)
        .into_iter()
        .filter_map(|entry| entry.ok())
        .filter_map(|entry| entry.metadata().ok())
        .filter(|metadata| metadata.is_file())
        .fold(0, |acc, m| acc + m.len());

    println!(&quot;Total size: {} bytes.&quot;, total_size);
}
</code></pre></pre>
<h2><a class="header" href="#find-all-png-files-recursively" id="find-all-png-files-recursively">Find all png files recursively</a></h2>
<p><a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Recursively find all PNG files in the current directory.
In this case, the <code>**</code> pattern matches the current directory and all subdirectories.</p>
<p>Use the <code>**</code> pattern in any path portion. For example, <code>/media/**/*.png</code>
matches all PNGs in <code>media</code> and it's subdirectories.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate glob;

use glob::glob;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Glob(glob::GlobError);
</span><span class="boring">        Pattern(glob::PatternError);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    for entry in glob(&quot;**/*.png&quot;)? {
        println!(&quot;{}&quot;, entry?.display());
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#find-all-files-with-given-pattern-ignoring-filename-case" id="find-all-files-with-given-pattern-ignoring-filename-case">Find all files with given pattern ignoring filename case.</a></h2>
<p><a href="https://docs.rs/glob/"><img src="https://badge-cache.kominick.com/crates/v/glob.svg?label=glob" alt="glob-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Find all image files in the <code>/media/</code> directory matching the <code>img_[0-9]*.png</code> pattern.</p>
<p>A custom <a href="https://docs.rs/glob/*/glob/struct.MatchOptions.html"><code>MatchOptions</code></a> struct is passed to the <a href="https://docs.rs/glob/*/glob/fn.glob_with.html"><code>glob_with</code></a> function making the glob pattern case insensitive while keeping the other options <a href="https://doc.rust-lang.org/std/default/trait.Default.html"><code>Default</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate glob;

use glob::{glob_with, MatchOptions};
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Glob(glob::GlobError);
</span><span class="boring">        Pattern(glob::PatternError);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let options = MatchOptions {
        case_sensitive: false,
        ..Default::default()
    };

    for entry in glob_with(&quot;/media/img_[0-9]*.png&quot;, &amp;options)? {
        println!(&quot;{}&quot;, entry?.display());
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#hardware-support-1" id="hardware-support-1">Hardware Support</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/hardware/processor.html#check-number-of-logical-cpu-cores">Check number of logical cpu cores</a></td><td><a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a></td><td><a href="https://crates.io/categories/hardware-support"><img src="https://badge-cache.kominick.com/badge/hardware_support--x.svg?style=social" alt="cat-hardware-support-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#processor" id="processor">Processor</a></h1>
<h2><a class="header" href="#check-number-of-logical-cpu-cores" id="check-number-of-logical-cpu-cores">Check number of logical cpu cores</a></h2>
<p><a href="https://docs.rs/num_cpus/"><img src="https://badge-cache.kominick.com/crates/v/num_cpus.svg?label=num_cpus" alt="num_cpus-badge" /></a> <a href="https://crates.io/categories/hardware-support"><img src="https://badge-cache.kominick.com/badge/hardware_support--x.svg?style=social" alt="cat-hardware-support-badge" /></a></p>
<p>Shows the number of logical CPU cores in current machine using [<code>num_cpus::get</code>].</p>
<pre><pre class="playpen"><code class="language-rust">extern crate num_cpus;

fn main() {
    println!(&quot;Number of logical cores is {}&quot;, num_cpus::get());
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#memory-management-1" id="memory-management-1">Memory Management</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/mem/global_static.html#declare-lazily-evaluated-constant">Declare lazily evaluated constant</a></td><td><a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/caching"><img src="https://badge-cache.kominick.com/badge/caching--x.svg?style=social" alt="cat-caching-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#constants-2" id="constants-2">Constants</a></h1>
<h2><a class="header" href="#declare-lazily-evaluated-constant" id="declare-lazily-evaluated-constant">Declare lazily evaluated constant</a></h2>
<p><a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/caching"><img src="https://badge-cache.kominick.com/badge/caching--x.svg?style=social" alt="cat-caching-badge" /></a> <a href="https://crates.io/categories/rust-patterns"><img src="https://badge-cache.kominick.com/badge/rust_patterns--x.svg?style=social" alt="cat-rust-patterns-badge" /></a></p>
<p>Declares a lazily evaluated constant <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a>. The <a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code>HashMap</code></a> will
be evaluated once and stored behind a global static reference.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate lazy_static;

use std::collections::HashMap;

lazy_static! {
    static ref PRIVILEGES: HashMap&lt;&amp;'static str, Vec&lt;&amp;'static str&gt;&gt; = {
        let mut map = HashMap::new();
        map.insert(&quot;James&quot;, vec![&quot;user&quot;, &quot;admin&quot;]);
        map.insert(&quot;Jim&quot;, vec![&quot;user&quot;]);
        map
    };
}

fn show_access(name: &amp;str) {
    let access = PRIVILEGES.get(name);
    println!(&quot;{}: {:?}&quot;, name, access);
}

fn main() {
    let access = PRIVILEGES.get(&quot;James&quot;);
    println!(&quot;James: {:?}&quot;, access);

    show_access(&quot;Jim&quot;);
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#networking-1" id="networking-1">Networking</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/net/server.html#listen-on-unused-port-tcpip">Listen on unused port TCP/IP</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#server" id="server">Server</a></h1>
<h2><a class="header" href="#listen-on-unused-port-tcpip" id="listen-on-unused-port-tcpip">Listen on unused port TCP/IP</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>In this example, the port is displayed on the console, and the program will
listen until a request is made.  <code>SocketAddrV4</code> assigns a random port when
setting port to 0.</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::net::{SocketAddrV4, Ipv4Addr, TcpListener};
use std::io::{Read, Error};

fn main() -&gt; Result&lt;(), Error&gt; {
    let loopback = Ipv4Addr::new(127, 0, 0, 1);
    let socket = SocketAddrV4::new(loopback, 0);
    let listener = TcpListener::bind(socket)?;
    let port = listener.local_addr()?;
    println!(&quot;Listening on {}, access this port to end the program&quot;, port);
    let (mut tcp_stream, addr) = listener.accept()?; //block  until requested
    println!(&quot;Connection received! {:?} is sending data.&quot;, addr);
    let mut input = String::new();
    let _ = tcp_stream.read_to_string(&amp;mut input)?;
    println!(&quot;{:?} says {}&quot;, addr, input);
    Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#operating-system-1" id="operating-system-1">Operating System</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/os/external.html#run-an-external-command-and-process-stdout">Run an external command and process stdout</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/os/external.html#run-an-external-command-passing-it-stdin-and-check-for-an-error-code">Run an external command passing it stdin and check for an error code</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/os/external.html#run-piped-external-commands">Run piped external commands</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/os/external.html#redirect-both-stdout-and-stderr-of-child-process-to-the-same-file">Redirect both stdout and stderr of child process to the same file</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/os/external.html#continuously-process-child-process-outputs">Continuously process child process' outputs</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#external-command" id="external-command">External Command</a></h1>
<h2><a class="header" href="#run-an-external-command-and-process-stdout" id="run-an-external-command-and-process-stdout">Run an external command and process stdout</a></h2>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Runs <code>git log --oneline</code> as an external <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a> and inspects its <a href="https://doc.rust-lang.org/std/process/struct.Output.html"><code>Output</code></a>
using <a href="https://docs.rs/regex/*/regex/struct.Regex.html"><code>Regex</code></a> to get the hash and message of the last 5 commits.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate regex;

use std::process::Command;
use regex::Regex;
<span class="boring">
</span><span class="boring">error_chain!{
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        Regex(regex::Error);
</span><span class="boring">        Utf8(std::string::FromUtf8Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
#[derive(PartialEq, Default, Clone, Debug)]
struct Commit {
    hash: String,
    message: String,
}

fn run() -&gt; Result&lt;()&gt; {
    let output = Command::new(&quot;git&quot;).arg(&quot;log&quot;).arg(&quot;--oneline&quot;).output()?;

    if !output.status.success() {
        bail!(&quot;Command executed with failing error code&quot;);
    }

    let pattern = Regex::new(r&quot;(?x)
                               ([0-9a-fA-F]+) # commit hash
                               (.*)           # The commit message&quot;)?;

    String::from_utf8(output.stdout)?
        .lines()
        .filter_map(|line| pattern.captures(line))
        .map(|cap| {
                 Commit {
                     hash: cap[1].to_string(),
                     message: cap[2].trim().to_string(),
                 }
             })
        .take(5)
        .for_each(|x| println!(&quot;{:?}&quot;, x));

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#run-an-external-command-passing-it-stdin-and-check-for-an-error-code" id="run-an-external-command-passing-it-stdin-and-check-for-an-error-code">Run an external command passing it stdin and check for an error code</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Opens the <code>python</code> interpreter using an external <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a> and passes it a
python statement for execution. <a href="https://doc.rust-lang.org/std/process/struct.Output.html"><code>Output</code></a> of statement is then parsed.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span><span class="boring">
</span>use std::collections::HashSet;
use std::io::Write;
use std::process::{Command, Stdio};
<span class="boring">
</span><span class="boring">error_chain!{
</span><span class="boring">    errors { CmdError }
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        Utf8(std::string::FromUtf8Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let mut child = Command::new(&quot;python&quot;).stdin(Stdio::piped())
        .stderr(Stdio::piped())
        .stdout(Stdio::piped())
        .spawn()?;

    child.stdin
        .as_mut()
        .ok_or(&quot;Child process stdin has not been captured!&quot;)?
        .write_all(b&quot;import this; copyright(); credits(); exit()&quot;)?;

    let output = child.wait_with_output()?;

    if output.status.success() {
        let raw_output = String::from_utf8(output.stdout)?;
        let words = raw_output.split_whitespace()
            .map(|s| s.to_lowercase())
            .collect::&lt;HashSet&lt;_&gt;&gt;();
        println!(&quot;Found {} unique words:&quot;, words.len());
        println!(&quot;{:#?}&quot;, words);
        Ok(())
    } else {
        let err = String::from_utf8(output.stderr)?;
        bail!(&quot;External command failed:\n {}&quot;, err)
    }
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#run-piped-external-commands" id="run-piped-external-commands">Run piped external commands</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Shows up to the 10<sup>th</sup> biggest files and subdirectories in
the current working directory. It is equivalent to running: <code>du -ah . | sort -hr | head -n 10</code>.</p>
<p><a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a>s represent a process. Output of a child process is captured with a
<a href="https://doc.rust-lang.org/std/process/struct.Stdio.html"><code>Stdio::piped</code></a> between parent and child.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span><span class="boring">
</span>use std::process::{Command, Stdio};
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        Utf8(std::string::FromUtf8Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let directory = std::env::current_dir()?;
    let mut du_output_child = Command::new(&quot;du&quot;)
        .arg(&quot;-ah&quot;)
        .arg(&amp;directory)
        .stdout(Stdio::piped())
        .spawn()?;

    if let Some(du_output) = du_output_child.stdout.take() {
        let mut sort_output_child = Command::new(&quot;sort&quot;)
            .arg(&quot;-hr&quot;)
            .stdin(du_output)
            .stdout(Stdio::piped())
            .spawn()?;

        du_output_child.wait()?;

        if let Some(sort_output) = sort_output_child.stdout.take() {
            let head_output_child = Command::new(&quot;head&quot;)
                .args(&amp;[&quot;-n&quot;, &quot;10&quot;])
                .stdin(sort_output)
                .stdout(Stdio::piped())
                .spawn()?;

            let head_stdout = head_output_child.wait_with_output()?;

            sort_output_child.wait()?;

            println!(
                &quot;Top 10 biggest files and directories in '{}':\n{}&quot;,
                directory.display(),
                String::from_utf8(head_stdout.stdout).unwrap()
            );
        }
    }

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#redirect-both-stdout-and-stderr-of-child-process-to-the-same-file" id="redirect-both-stdout-and-stderr-of-child-process-to-the-same-file">Redirect both stdout and stderr of child process to the same file</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>Spawns a child process and redirects <code>stdout</code> and <code>stderr</code> to the same
file. It follows the same idea as <a href="rustcookbook/os/external.html#run-piped-external-commands">run piped external
commands</a>, however <a href="https://doc.rust-lang.org/std/process/struct.Stdio.html"><code>process::Stdio</code></a>
writes to a specified file.  <a href="https://doc.rust-lang.org/std/fs/struct.File.html#method.try_clone"><code>File::try_clone</code></a> references the same file handle
for <code>stdout</code> and <code>stderr</code>. It will ensure that both handles write with the same
cursor position.</p>
<p>The below recipe is equivalent to run the Unix shell command <code>ls . oops &gt;out.txt 2&gt;&amp;1</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::fs::File;
use std::io::Error;
use std::process::{Command, Stdio};

fn main() -&gt; Result&lt;(), Error&gt; {
    let outputs = File::create(&quot;out.txt&quot;)?;
    let errors = outputs.try_clone()?;

    Command::new(&quot;ls&quot;)
        .args(&amp;[&quot;.&quot;, &quot;oops&quot;])
        .stdout(Stdio::from(outputs))
        .stderr(Stdio::from(errors))
        .spawn()?
        .wait_with_output()?;

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#continuously-process-child-process-outputs" id="continuously-process-child-process-outputs">Continuously process child process' outputs</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/os"><img src="https://badge-cache.kominick.com/badge/OS--x.svg?style=social" alt="cat-os-badge" /></a></p>
<p>In <a href="rustcookbook/os/external.html#run-an-external-command-and-process-stdout">Run an external command and process stdout</a>,
processing doesn't start until external <a href="https://doc.rust-lang.org/std/process/struct.Command.html"><code>Command</code></a> is finished.
The recipe below calls <a href="https://doc.rust-lang.org/std/process/struct.Stdio.html"><code>Stdio::piped</code></a> to create a pipe, and reads
<code>stdout</code> continuously as soon as the <a href="https://doc.rust-lang.org/std/io/struct.BufReader.html"><code>BufReader</code></a> is updated.</p>
<p>The below recipe is equivalent to the Unix shell command
<code>journalctl | grep usb</code>.</p>
<pre><pre class="playpen"><code class="language-rust no_run">use std::process::{Command, Stdio};
use std::io::{BufRead, BufReader, Error, ErrorKind};

fn main() -&gt; Result&lt;(), Error&gt; {
    let stdout = Command::new(&quot;journalctl&quot;)
        .stdout(Stdio::piped())
        .spawn()?
        .stdout
        .ok_or_else(|| Error::new(ErrorKind::Other,&quot;Could not capture standard output.&quot;))?;

    let reader = BufReader::new(stdout);

    reader
        .lines()
        .filter_map(|line| line.ok())
        .filter(|line| line.find(&quot;usb&quot;).is_some())
        .for_each(|line| println!(&quot;{}&quot;, line));

     Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#science-1" id="science-1">Science</a></h1>
<h2><a class="header" href="#mathematics-1" id="mathematics-1">Mathematics</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#vector-sum">Vector Sum</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#vector-norm">Vector Norm</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#adding-matrices">Adding matrices</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#multiplying-matrices">Multiplying matrices</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#multiply-a-scalar-with-a-vector-with-a-matrix">Multiply a scalar with a vector with a matrix</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/linear_algebra.html#invert-matrix">Invert marix</a></td><td><a href="https://docs.rs/nalgebra"><img src="https://badge-cache.kominick.com/crate/nalgebra.svg?label=nalgebra" alt="nalgebra-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/trigonometry.html#calculating-the-side-length-of-a-triangle">Calculating the side length of a triangle</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/trigonometry.html#verifying-tan-is-equal-to-sin-divided-by-cos">Verifying tan is equal to sin divided by cos</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/trigonometry.html#distance-between-two-points-on-the-earth">Distance between two points on the Earth</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/complex_numbers.html#creating-complex-numbers">Creating complex numbers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/complex_numbers.html#adding-complex-numbers">Adding complex numbers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/complex_numbers.html#mathematical-functions">Mathematical functions on complex numbers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/statistics.html#measures-of-central-tendency">Measures of central tendency</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/statistics.html#standard-deviation">Computing standard deviation</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/mathematics/miscellaneous.html#big-integers">Big integers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h2><a class="header" href="#mathematics-2" id="mathematics-2">Mathematics</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/science/science/mathematics/linear_algebra.html#vector-sum">Vector Sum</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/linear_algebra.html#vector-norm">Vector Norm</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/linear_algebra.html#adding-matrices">Adding matrices</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/linear_algebra.html#multiplying-matrices">Multiplying matrices</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/linear_algebra.html#multiply-a-scalar-with-a-vector-with-a-matrix">Multiply a scalar with a vector with a matrix</a></td><td><a href="https://docs.rs/ndarray"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/linear_algebra.html#invert-matrix">Invert marix</a></td><td><a href="https://docs.rs/nalgebra"><img src="https://badge-cache.kominick.com/crate/nalgebra.svg?label=nalgebra" alt="nalgebra-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/trigonometry.html#calculating-the-side-length-of-a-triangle">Calculating the side length of a triangle</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/trigonometry.html#verifying-tan-is-equal-to-sin-divided-by-cos">Verifying tan is equal to sin divided by cos</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/trigonometry.html#distance-between-two-points-on-the-earth">Distance between two points on the Earth</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/complex_numbers.html#creating-complex-numbers">Creating complex numbers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/complex_numbers.html#adding-complex-numbers">Adding complex numbers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/complex_numbers.html#mathematical-functions">Mathematical functions on complex numbers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/statistics.html#measures-of-central-tendency">Measures of central tendency</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/statistics.html#standard-deviation">Computing standard deviation</a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/science/science/mathematics/miscellaneous.html#big-integers">Big integers</a></td><td><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a></td><td><a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#linear-algebra" id="linear-algebra">Linear Algebra</a></h1>
<h2><a class="header" href="#vector-sum" id="vector-sum">Vector Sum</a></h2>
<p><a href="https://docs.rs/crate/ndarray/*"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></p>
<p>The <a href="https://docs.rs/crate/ndarray/*">ndarray</a> crate supports a number of ways to create arrays -- this recipe
focuses on creating <a href="https://docs.rs/ndarray/*/ndarray/struct.ArrayBase.html"><code>ndarray::Array</code></a>s from <code>std::Vec</code> via <a href="https://docs.rs/ndarray/*/ndarray/struct.ArrayBase.html#method.from_vec"><code>from_vec</code></a>. Adding two
arrays together is no different than adding two numbers together. Using the <code>&amp;</code>
operand on the arrays within an arithmetic operation prevents the operation from
consuming the arrays. Without <code>&amp;</code>, the arrays are consumed.</p>
<p>In the first example, arrays <code>a</code> and <code>b</code> are moved in the let-statement <code>z = a + b</code>. In the second example, the arrays <code>c</code> and <code>d</code> are not moved and instead, a
new array is created for <code>w</code>. Updating either of <code>c</code> or <code>d</code> after the vector sum
has no effect the value of <code>w</code>. Additionally, while printing <code>c</code> works as
expected, it would be an error to print <code>b</code> due to the move. See <a href="https://docs.rs/ndarray/*/ndarray/struct.ArrayBase.html#binary-operators-with-two-arrays">Binary
Operators With Two Arrays</a> for additional detail.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate ndarray;
use ndarray::Array;

fn main() {
  let a = Array::from_vec(vec![1., 2., 3., 4., 5.]);
  let b = Array::from_vec(vec![5., 4., 3., 2., 1.]);
  let mut c = Array::from_vec(vec![1., 2., 3., 4., 5.]);
  let mut d = Array::from_vec(vec![5., 4., 3., 2., 1.]);

  let z = a + b;
  let w =  &amp;c + &amp;d;

  let epsilon = 1e-8;
  for elem in z.iter() {
    let diff: f32 = *elem - 6.;
    assert!(diff.abs() &lt; epsilon);
  }

  println!(&quot;c = {}&quot;, c);
  c[0] = 10.;
  d[1] = 10.;

  for elem in w.iter() {
    let diff: f32 = *elem - 6.;
    assert!(diff.abs() &lt; epsilon);
  }

}
</code></pre></pre>
<h2><a class="header" href="#vector-norm" id="vector-norm">Vector Norm</a></h2>
<p><a href="https://docs.rs/crate/ndarray/*"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a></p>
<p>This recipe demonstrates use of the <a href="https://docs.rs/ndarray/*/ndarray/type.Array1.html"><code>Array1</code></a> type, <a href="https://docs.rs/ndarray/*/ndarray/type.ArrayView1.html"><code>ArrayView1</code></a> type,
<a href="https://docs.rs/ndarray/*/ndarray/struct.ArrayBase.html#method.fold"><code>fold</code></a> method, and <a href="https://docs.rs/ndarray/*/ndarray/struct.ArrayBase.html#method.dot"><code>dot</code></a> method in computing the <a href="http://mathworld.wolfram.com/L1-Norm.html">l1</a> and <a href="http://mathworld.wolfram.com/L2-Norm.html">l2</a> norms of a
given vector. The l2 norm calculation is the simpler of the two, as it is the
square root of the dot product of a vector with itself, shown in the function
<code>l2_norm</code>. The l1 norm, shown in the function <code>l1_norm</code>, is computed by a <code>fold</code>
operation that sums the absolute values of the elements. (This could also be
performed with <code>x.mapv(f64::abs).scalar_sum()</code>, but that would allocate a new
array for the result of the <code>mapv</code>.)</p>
<p>Note that both <code>l1_norm</code> and <code>l2_norm</code> take the <a href="https://docs.rs/ndarray/*/ndarray/type.ArrayView1.html"><code>ArrayView1</code></a> type. This recipe
considers vector norms, so the norm functions only need to accept one
dimensional views (hence <a href="https://docs.rs/ndarray/*/ndarray/type.ArrayView1.html"><code>ArrayView1</code></a>). While the functions could take a
parameter of type <code>&amp;Array1&lt;f64&gt;</code> instead, that would require the caller to have
a reference to an owned array, which is more restrictive than just having access
to a view (since a view can be created from any array or view, not just an owned
array). The most convenient argument type for the caller would be
<code>&amp;ArrayBase&lt;S, Ix1&gt; where S: Data</code>, because then the caller could use <code>&amp;array</code>
or <code>&amp;view</code> instead of <code>x.view()</code>. If the function is part of your public API,
that may be a better choice for the benefit of your users, but for internal
functions, the more concise <code>ArrayView1&lt;f64&gt;</code> may be preferable.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use(array)]
extern crate ndarray;

use ndarray::{Array1, ArrayView1};

fn l1_norm(x: ArrayView1&lt;f64&gt;) -&gt; f64 {
    x.fold(0., |acc, elem| acc + elem.abs())
}

fn l2_norm(x: ArrayView1&lt;f64&gt;) -&gt; f64 {
    x.dot(&amp;x).sqrt()
}

fn normalize(mut x: Array1&lt;f64&gt;) -&gt; Array1&lt;f64&gt; {
    let norm = l2_norm(x.view());
    x.mapv_inplace(|e| e/norm);
    x
}

fn main() {
    let x = array![1., 2., 3., 4., 5.];
    println!(&quot;||x||_2 = {}&quot;, l2_norm(x.view()));
    println!(&quot;||x||_1 = {}&quot;, l1_norm(x.view()));
    println!(&quot;Normalizing x yields {:?}&quot;, normalize(x));
}
</code></pre></pre>
<h2><a class="header" href="#adding-matrices" id="adding-matrices">Adding matrices</a></h2>
<p><a href="https://docs.rs/crate/ndarray/*"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Creates two matrices with <a href="https://docs.rs/ndarray/*/ndarray/fn.arr2.html"><code>ndarray::arr2</code></a> and adds them together.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate ndarray;

use ndarray::arr2;

fn main() {
    let a = arr2(&amp;[[1, 2, 3],
                   [4, 5, 6]]);

    let b = arr2(&amp;[[6, 5, 4],
                   [3, 2, 1]]);

    println!(&quot;Sum: {}&quot;, a + b);
}
</code></pre></pre>
<h2><a class="header" href="#multiplying-matrices" id="multiplying-matrices">Multiplying matrices</a></h2>
<p><a href="https://docs.rs/crate/ndarray/*"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Creates two matrices with <a href="https://docs.rs/ndarray/*/ndarray/fn.arr2.html"><code>ndarray::arr2</code></a> and performs matrix multiplication on them with <a href="https://docs.rs/ndarray/*/ndarray/struct.ArrayBase.html#method.dot-1"><code>ndarray::ArrayBase::dot</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate ndarray;

use ndarray::arr2;

fn main() {
    let a = arr2(&amp;[[1, 2, 3],
                   [4, 5, 6]]);

    let b = arr2(&amp;[[6, 3],
                   [5, 2],
                   [4, 1]]);

    println!(&quot;{}&quot;, a.dot(&amp;b));
}
</code></pre></pre>
<h2><a class="header" href="#multiply-a-scalar-with-a-vector-with-a-matrix" id="multiply-a-scalar-with-a-vector-with-a-matrix">Multiply a scalar with a vector with a matrix</a></h2>
<p><a href="https://docs.rs/crate/ndarray/*"><img src="https://badge-cache.kominick.com/crate/ndarray.svg?label=ndarray" alt="ndarray-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Creates a 1-D array (vector) with <a href="https://docs.rs/ndarray/*/ndarray/fn.arr1.html"><code>ndarray::arr1</code></a> and a 2-D array (matrix)
with <a href="https://docs.rs/ndarray/*/ndarray/fn.arr2.html"><code>ndarray::arr2</code></a>. First, a scalar is multiplied by the vector to get
another vector. Then, the matrix is multiplied by the new vector with
<a href="https://docs.rs/ndarray/*/ndarray/struct.ArrayBase.html#method.dot-1"><code>ndarray::Array2::dot</code></a>. (<code>dot</code> performs matrix multiplication, while the <code>*</code>
operator performs element-wise multiplication.) In <code>ndarray</code>, 1-D arrays can be
interpreted as either row or column vectors depending on context. If
representing the orientation of a vector is important, a 2-D array with one row
or one column must be used instead. In this example, the vector is a 1-D array
on the right-hand side, so <code>dot</code> handles it as a column vector.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate ndarray;

use ndarray::{arr1, arr2, Array1};

fn main() {
    let scalar = 4;

    let vector = arr1(&amp;[1, 2, 3]);

    let matrix = arr2(&amp;[[4, 5, 6],
                        [7, 8, 9]]);

    let new_vector: Array1&lt;_&gt; = scalar * vector;
    println!(&quot;{}&quot;, new_vector);

    let new_matrix = matrix.dot(&amp;new_vector);
    println!(&quot;{}&quot;, new_matrix);
}
</code></pre></pre>
<h2><a class="header" href="#invert-matrix" id="invert-matrix">Invert matrix</a></h2>
<p><a href="https://docs.rs/nalgebra"><img src="https://badge-cache.kominick.com/crate/nalgebra.svg?label=nalgebra" alt="nalgebra-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Creates a 3x3 matrix with <a href="https://docs.rs/nalgebra/*/nalgebra/base/type.Matrix3.html"><code>nalgebra::Matrix3</code></a> and inverts it, if possible.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate nalgebra;

use nalgebra::Matrix3;

fn main() {
    let m1 = Matrix3::new(2.0, 1.0, 1.0, 3.0, 2.0, 1.0, 2.0, 1.0, 2.0);
    println!(&quot;m1 = {}&quot;, m1);
    match m1.try_inverse() {
        Some(inv) =&gt; {
            println!(&quot;The inverse of m1 is: {}&quot;, inv);
        }
        None =&gt; {
            println!(&quot;m1 is not invertible!&quot;);
        }
    }
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#trigonometry" id="trigonometry">Trigonometry</a></h1>
<h2><a class="header" href="#calculating-the-side-length-of-a-triangle" id="calculating-the-side-length-of-a-triangle">Calculating the side length of a triangle</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Calculates the length of the hypotenuse of a right-angle triangle with an angle of 2 radians and opposite side length of 80.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let angle: f64 = 2.0;
    let side_length = 80.0;

    let hypotenuse = side_length / angle.sin();

    println!(&quot;Hypotenuse: {}&quot;, hypotenuse);
}
</code></pre></pre>
<h2><a class="header" href="#verifying-tan-is-equal-to-sin-divided-by-cos" id="verifying-tan-is-equal-to-sin-divided-by-cos">Verifying tan is equal to sin divided by cos</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Verifies tan(x) is equal to sin(x)/cos(x) for x = 6.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: f64 = 6.0;

    let a = x.tan();
    let b = x.sin() / x.cos();

    assert_eq!(a, b);
}
</code></pre></pre>
<h2><a class="header" href="#distance-between-two-points-on-the-earth" id="distance-between-two-points-on-the-earth">Distance between two points on the Earth</a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></p>
<p>By default, Rust provides mathematical <a href="https://doc.rust-lang.org/std/primitive.f64.html#methods">float methods</a> such as
trigonometric functions, square root, conversion functions between
radians and degrees, and so forth.</p>
<p>The following example computes the distance in kilometers between two
points on the Earth with the <a href="https://en.wikipedia.org/wiki/Haversine_formula">Haversine formula</a>. Points are expressed
as pairs of latitude and longitude in degrees. Then, <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.to_radians"><code>to_radians</code></a>
converts them in radian. <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.sin"><code>sin</code></a>, <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.cos"><code>cos</code></a>, <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.powi"><code>powi</code></a> and <a href="https://doc.rust-lang.org/std/primitive.f64.html#method.sqrt"><code>sqrt</code></a>
compute the central angle. Finally, it's possible to calculate the
distance.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let earth_radius_kilometer = 6371.0_f64;
    let (paris_latitude_degrees, paris_longitude_degrees) = (48.85341_f64, -2.34880_f64);
    let (london_latitude_degrees, london_longitude_degrees) = (51.50853_f64, -0.12574_f64);

    let paris_latitude = paris_latitude_degrees.to_radians();
    let london_latitude = london_latitude_degrees.to_radians();

    let delta_latitude = (paris_latitude_degrees - london_latitude_degrees).to_radians();
    let delta_longitude = (paris_longitude_degrees - london_longitude_degrees).to_radians();

    let central_angle_inner = (delta_latitude / 2.0).sin().powi(2)
        + paris_latitude.cos() * london_latitude.cos() * (delta_longitude / 2.0).sin().powi(2);
    let central_angle = 2.0 * central_angle_inner.sqrt().asin();

    let distance = earth_radius_kilometer * central_angle;

    println!(
        &quot;Distance between Paris and London on the surface of Earth is {:.1} kilometers&quot;,
        distance
    );
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#complex-numbers" id="complex-numbers">Complex numbers</a></h1>
<h2><a class="header" href="#creating-complex-numbers" id="creating-complex-numbers">Creating complex numbers</a></h2>
<p><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Creates complex numbers of type <a href="https://autumnai.github.io/cuticula/num/complex/struct.Complex.html"><code>num::complex::Complex</code></a>. Both the real and
imaginary part of the complex number must be of the same type.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate num;

fn main() {
    let complex_integer = num::complex::Complex::new(10, 20);
    let complex_float = num::complex::Complex::new(10.1, 20.1);

    println!(&quot;Complex integer: {}&quot;, complex_integer);
    println!(&quot;Complex float: {}&quot;, complex_float);
}
</code></pre></pre>
<h2><a class="header" href="#adding-complex-numbers" id="adding-complex-numbers">Adding complex numbers</a></h2>
<p><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Performing mathematical operations on complex numbers is the same as on
built in types: the numbers in question must be of the same type (i.e. floats
or integers).</p>
<pre><pre class="playpen"><code class="language-rust">extern crate num;

fn main() {
    let complex_num1 = num::complex::Complex::new(10.0, 20.0); // Must use floats
    let complex_num2 = num::complex::Complex::new(3.1, -4.2);

    let sum = complex_num1 + complex_num2;

    println!(&quot;Sum: {}&quot;, sum);
}
</code></pre></pre>
<h2><a class="header" href="#mathematical-functions" id="mathematical-functions">Mathematical functions</a></h2>
<p><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Complex numbers have a range of interesting properties when it comes to
how they interact with other mathematical functions, most notibly the family
of sine functions as well as the number e. To use these functions with
complex numbers, the Complex type has a few built in
functions, all of which can be found here: <a href="https://autumnai.github.io/cuticula/num/complex/struct.Complex.html"><code>num::complex::Complex</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate num;

use std::f64::consts::PI;
use num::complex::Complex;

fn main() {
    let x = Complex::new(0.0, 2.0*PI);

    println!(&quot;e^(2i * pi) = {}&quot;, x.exp()); // =~1
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#statistics" id="statistics">Statistics</a></h1>
<h3><a class="header" href="#measures-of-central-tendency" id="measures-of-central-tendency">Measures of central tendency</a></h3>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>These examples calculate measures of central tendency for a data set contained within a Rust array. There may be no mean, median or mode to calculate for an empty set of data, so each function returns an [<code>Option</code>] to be handled by the caller.</p>
<p>The first example calculates the mean (the sum of all measurements divided by the number of measurements in the set) by producing an iterator of references over the data, and using [<code>sum</code>] and [<code>len</code>] to determine the total value and count of values respectively.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let data = [3, 1, 6, 1, 5, 8, 1, 8, 10, 11];

    let sum = data.iter().sum::&lt;i32&gt;() as f32;
    let count = data.len();

    let mean = match count {
       positive if positive &gt; 0 =&gt; Some(sum  / count as f32),
       _ =&gt; None
    };

    println!(&quot;Mean of the data is {:?}&quot;, mean);
}
</code></pre></pre>
<p>The second example calculates the median using the quickselect algorithm, which avoids a full [<code>sort</code>] by sorting only partitions of the data set known to possibly contain the median. This uses [<code>cmp</code>] and [<code>Ordering</code>] to succinctly decide the next partition to examine, and [<code>split_at</code>] to choose an arbitrary pivot for the next partition at each step.</p>
<pre><pre class="playpen"><code class="language-rust">use std::cmp::Ordering;

fn partition(data: &amp;[i32]) -&gt; Option&lt;(Vec&lt;i32&gt;, i32, Vec&lt;i32&gt;)&gt; {
    match data.len() {
        0 =&gt; None,
        _ =&gt; {
            let (pivot_slice, tail) = data.split_at(1);
            let pivot = pivot_slice[0];
            let (left, right) = tail.iter()
                .fold((vec![], vec![]), |mut splits, next| {
                    {
                        let (ref mut left, ref mut right) = &amp;mut splits;
                        if next &lt; &amp;pivot {
                            left.push(*next);
                        } else {
                            right.push(*next);
                        }
                    }
                    splits
                });

            Some((left, pivot, right))
        }
    }
}

fn select(data: &amp;[i32], k: usize) -&gt; Option&lt;i32&gt; {
    let part = partition(data);

    match part {
        None =&gt; None,
        Some((left, pivot, right)) =&gt; {
            let pivot_idx = left.len();

            match pivot_idx.cmp(&amp;k) {
                Ordering::Equal =&gt; Some(pivot),
                Ordering::Greater =&gt; select(&amp;left, k),
                Ordering::Less =&gt; select(&amp;right, k - (pivot_idx + 1)),
            }
        },
    }
}

fn median(data: &amp;[i32]) -&gt; Option&lt;f32&gt; {
    let size = data.len();

    match size {
        even if even % 2 == 0 =&gt; {
            let fst_med = select(data, (even / 2) - 1);
            let snd_med = select(data, even / 2);

            match (fst_med, snd_med) {
                (Some(fst), Some(snd)) =&gt; Some((fst + snd) as f32 / 2.0),
                _ =&gt; None
            }
        },
        odd =&gt; select(data, odd / 2).map(|x| x as f32)
    }
}

fn main() {
    let data = [3, 1, 6, 1, 5, 8, 1, 8, 10, 11];

    let part = partition(&amp;data);
    println!(&quot;Partition is {:?}&quot;, part);

    let sel = select(&amp;data, 5);
    println!(&quot;Selection at ordered index {} is {:?}&quot;, 5, sel);

    let med = median(&amp;data);
    println!(&quot;Median is {:?}&quot;, med);
}
</code></pre></pre>
<p>The final example calculates the  mode using a mutable [<code>HashMap</code>] to collect counts of each distinct integer from the set, using a [<code>fold</code>] and the [<code>entry</code>] API. The most frequent value in the [<code>HashMap</code>] surfaces with [<code>max_by_key</code>].</p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let data = [3, 1, 6, 1, 5, 8, 1, 8, 10, 11];

    let frequencies = data.iter().fold(HashMap::new(), |mut freqs, value| {
        *freqs.entry(value).or_insert(0) += 1;
        freqs
    });

    let mode = frequencies
        .into_iter()
        .max_by_key(|&amp;(_, count)| count)
        .map(|(value, _)| *value);

    println!(&quot;Mode of the data is {:?}&quot;, mode);
}
</code></pre></pre>
<h3><a class="header" href="#standard-deviation" id="standard-deviation">Standard deviation</a></h3>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>This example calculates the standard deviation and z-score of a set of measurements.</p>
<p>The standard deviation is defined as the square root of the variance (here calculated with f32's [<code>sqrt</code>], where the variance is the [<code>sum</code>] of the squared difference between each measurement and the [<code>mean</code>], divided by the number of measurements.</p>
<p>The z-score is the number of standard deviations a single measurement spans away from the [<code>mean</code>] of the data set.</p>
<pre><pre class="playpen"><code class="language-rust">fn mean(data: &amp;[i32]) -&gt; Option&lt;f32&gt; {
    let sum = data.iter().sum::&lt;i32&gt;() as f32;
    let count = data.len();

    match count {
        positive if positive &gt; 0 =&gt; Some(sum / count as f32),
        _ =&gt; None,
    }
}

fn std_deviation(data: &amp;[i32]) -&gt; Option&lt;f32&gt; {
    match (mean(data), data.len()) {
        (Some(data_mean), count) if count &gt; 0 =&gt; {
            let variance = data.iter().map(|value| {
                let diff = data_mean - (*value as f32);

                diff * diff
            }).sum::&lt;f32&gt;() / count as f32;

            Some(variance.sqrt())
        },
        _ =&gt; None
    }
}

fn main() {
    let data = [3, 1, 6, 1, 5, 8, 1, 8, 10, 11];

    let data_mean = mean(&amp;data);
    println!(&quot;Mean is {:?}&quot;, data_mean);

    let data_std_deviation = std_deviation(&amp;data);
    println!(&quot;Standard deviation is {:?}&quot;, data_std_deviation);

    let zscore = match (data_mean, data_std_deviation) {
        (Some(mean), Some(std_deviation)) =&gt; {
            let diff = data[4] as f32 - mean;

            Some(diff / std_deviation)
        },
        _ =&gt; None
    };
    println!(&quot;Z-score of data at index 4 (with value {}) is {:?}&quot;, data[4], zscore);
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#miscellaneous" id="miscellaneous">Miscellaneous</a></h1>
<h2><a class="header" href="#big-integers" id="big-integers">Big integers</a></h2>
<p><a href="https://docs.rs/num/"><img src="https://badge-cache.kominick.com/crates/v/num.svg?label=num" alt="num-badge" /></a> <a href="https://crates.io/categories/science"><img src="https://badge-cache.kominick.com/badge/science--x.svg?style=social" alt="cat-science-badge" /></a></p>
<p>Calculation for integers exceeding 128 bits are possible with <a href="https://docs.rs/num/0.2.0/num/struct.BigInt.html"><code>BigInt</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate num;

use num::bigint::{BigInt, ToBigInt};

fn factorial(x: i32) -&gt; BigInt {
    if let Some(mut factorial) = 1.to_bigint() {
        for i in 1..(x+1) {
            factorial = factorial * i;
        }
        factorial
    }
    else {
        panic!(&quot;Failed to calculate factorial!&quot;);
    }
}

fn main() {
    println!(&quot;{}! equals {}&quot;, 100, factorial(100));
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#text-processing-1" id="text-processing-1">Text Processing</a></h1>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/text/string_parsing.html#collect-unicode-graphemes">Collect Unicode Graphemes</a></td><td><a href="https://docs.rs/unicode-segmentation/"><img src="https://badge-cache.kominick.com/crates/v/unicode-segmentation.svg?label=unicode-segmentation" alt="unicode-segmentation-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#verify-and-extract-login-from-an-email-address">Verify and extract login from an email address</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#extract-a-list-of-unique-hashtags-from-a-text">Extract a list of unique #Hashtags from a text</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#extract-phone-numbers-from-text">Extract phone numbers from text</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#filter-a-log-file-by-matching-multiple-regular-expressions">Filter a log file by matching multiple regular expressions</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/regex.html#replace-all-occurrences-of-one-text-pattern-with-another-pattern">Replace all occurrences of one text pattern with another pattern.</a></td><td><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/text/string_parsing.html#implement-the-fromstr-trait-for-a-custom-struct">Implement the <code>FromStr</code> trait for a custom <code>struct</code></a></td><td><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a></td><td><a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#regular-expressions" id="regular-expressions">Regular Expressions</a></h1>
<h2><a class="header" href="#verify-and-extract-login-from-an-email-address" id="verify-and-extract-login-from-an-email-address">Verify and extract login from an email address</a></h2>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Validates that an email address is formatted correctly, and extracts everything
before the @ symbol.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate lazy_static;
extern crate regex;

use regex::Regex;

fn extract_login(input: &amp;str) -&gt; Option&lt;&amp;str&gt; {
    lazy_static! {
        static ref RE: Regex = Regex::new(r&quot;(?x)
            ^(?P&lt;login&gt;[^@\s]+)@
            ([[:word:]]+\.)*
            [[:word:]]+$
            &quot;).unwrap();
    }
    RE.captures(input).and_then(|cap| {
        cap.name(&quot;login&quot;).map(|login| login.as_str())
    })
}

fn main() {
    assert_eq!(extract_login(r&quot;I❤email@example.com&quot;), Some(r&quot;I❤email&quot;));
    assert_eq!(
        extract_login(r&quot;sdf+sdsfsd.as.sdsd@jhkk.d.rl&quot;),
        Some(r&quot;sdf+sdsfsd.as.sdsd&quot;)
    );
    assert_eq!(extract_login(r&quot;More@Than@One@at.com&quot;), None);
    assert_eq!(extract_login(r&quot;Not an email@email&quot;), None);
}
</code></pre></pre>
<h2><a class="header" href="#extract-a-list-of-unique-hashtags-from-a-text" id="extract-a-list-of-unique-hashtags-from-a-text">Extract a list of unique #Hashtags from a text</a></h2>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Extracts, sorts, and deduplicates list of hashtags from text.</p>
<p>The hashtag regex given here only catches Latin hashtags that start with a
letter. The complete <a href="https://github.com/twitter/twitter-text/blob/c9fc09782efe59af4ee82855768cfaf36273e170/java/src/com/twitter/Regex.java#L255">twitter hashtag regex</a> is much more complicated.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate regex;
#[macro_use]
extern crate lazy_static;

use regex::Regex;
use std::collections::HashSet;

fn extract_hashtags(text: &amp;str) -&gt; HashSet&lt;&amp;str&gt; {
    lazy_static! {
        static ref HASHTAG_REGEX : Regex = Regex::new(
                r&quot;\#[a-zA-Z][0-9a-zA-Z_]*&quot;
            ).unwrap();
    }
    HASHTAG_REGEX.find_iter(text).map(|mat| mat.as_str()).collect()
}

fn main() {
    let tweet = &quot;Hey #world, I just got my new #dog, say hello to Till. #dog #forever #2 #_ &quot;;
    let tags = extract_hashtags(tweet);
    assert!(tags.contains(&quot;#dog&quot;) &amp;&amp; tags.contains(&quot;#forever&quot;) &amp;&amp; tags.contains(&quot;#world&quot;));
    assert_eq!(tags.len(), 3);
}
</code></pre></pre>
<h2><a class="header" href="#extract-phone-numbers-from-text" id="extract-phone-numbers-from-text">Extract phone numbers from text</a></h2>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Processes a string of text using <a href="https://docs.rs/regex/*/regex/struct.Regex.html#method.captures_iter"><code>Regex::captures_iter</code></a> to capture multiple
phone numbers.  The example here is for US convention phone numbers.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate regex;

use regex::Regex;
use std::fmt;
<span class="boring">
</span><span class="boring">error_chain!{
</span><span class="boring">    foreign_links {
</span><span class="boring">        Regex(regex::Error);
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
struct PhoneNumber&lt;'a&gt; {
    area: &amp;'a str,
    exchange: &amp;'a str,
    subscriber: &amp;'a str,
}

impl&lt;'a&gt; fmt::Display for PhoneNumber&lt;'a&gt; {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;1 ({}) {}-{}&quot;, self.area, self.exchange, self.subscriber)
    }
}

fn run() -&gt; Result&lt;()&gt; {
    let phone_text = &quot;
    +1 505 881 9292 (v) +1 505 778 2212 (c) +1 505 881 9297 (f)
    (202) 991 9534
    Alex 5553920011
    1 (800) 233-2010
    1.299.339.1020&quot;;

    let re = Regex::new(
        r#&quot;(?x)
          (?:\+?1)?                       # Country Code Optional
          [\s\.]?
          (([2-9]\d{2})|\(([2-9]\d{2})\)) # Area Code
          [\s\.\-]?
          ([2-9]\d{2})                    # Exchange Code
          [\s\.\-]?
          (\d{4})                         # Subscriber Number&quot;#,
    )?;

    let phone_numbers = re.captures_iter(phone_text).filter_map(|cap| {
        let groups = (cap.get(2).or(cap.get(3)), cap.get(4), cap.get(5));
        match groups {
            (Some(area), Some(ext), Some(sub)) =&gt; Some(PhoneNumber {
                area: area.as_str(),
                exchange: ext.as_str(),
                subscriber: sub.as_str(),
            }),
            _ =&gt; None,
        }
    });

    assert_eq!(
        phone_numbers.map(|m| m.to_string()).collect::&lt;Vec&lt;_&gt;&gt;(),
        vec![
            &quot;1 (505) 881-9292&quot;,
            &quot;1 (505) 778-2212&quot;,
            &quot;1 (505) 881-9297&quot;,
            &quot;1 (202) 991-9534&quot;,
            &quot;1 (555) 392-0011&quot;,
            &quot;1 (800) 233-2010&quot;,
            &quot;1 (299) 339-1020&quot;,
        ]
    );

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#filter-a-log-file-by-matching-multiple-regular-expressions" id="filter-a-log-file-by-matching-multiple-regular-expressions">Filter a log file by matching multiple regular expressions</a></h2>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Reads a file named <code>application.log</code> and only outputs the lines
containing “version X.X.X”, some IP address followed by port 443
(e.g. “192.168.0.1:443”), or a specific warning.</p>
<p>A <a href="https://docs.rs/regex/*/regex/struct.RegexSetBuilder.html"><code>regex::RegexSetBuilder</code></a> composes a <a href="https://docs.rs/regex/*/regex/struct.RegexSet.html"><code>regex::RegexSet</code></a>.
Since backslashes are very common in regular expressions, using
<a href="https://doc.rust-lang.org/reference/tokens.html#raw-string-literals">raw string literals</a> makes them more readable.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate regex;

use std::fs::File;
use std::io::{BufReader, BufRead};
use regex::RegexSetBuilder;

<span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        Regex(regex::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run() -&gt; Result&lt;()&gt; {
    let log_path = &quot;application.log&quot;;
    let buffered = BufReader::new(File::open(log_path)?);

    let set = RegexSetBuilder::new(&amp;[
        r#&quot;version &quot;\d\.\d\.\d&quot;&quot;#,
        r#&quot;\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:443&quot;#,
        r#&quot;warning.*timeout expired&quot;#,
    ]).case_insensitive(true)
        .build()?;

    buffered
        .lines()
        .filter_map(|line| line.ok())
        .filter(|line| set.is_match(line.as_str()))
        .for_each(|x| println!(&quot;{}&quot;, x));

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#replace-all-occurrences-of-one-text-pattern-with-another-pattern" id="replace-all-occurrences-of-one-text-pattern-with-another-pattern">Replace all occurrences of one text pattern with another pattern.</a></h2>
<p><a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://docs.rs/lazy_static/"><img src="https://badge-cache.kominick.com/crates/v/lazy_static.svg?label=lazy_static" alt="lazy_static-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Replaces all occurrences of the standard ISO 8601 <em>YYYY-MM-DD</em> date pattern
with the equivalent American English date with slashes.
For example <code>2013-01-15</code> becomes <code>01/15/2013</code>.</p>
<p>The method <a href="https://docs.rs/regex/*/regex/struct.Regex.html#method.replace_all"><code>Regex::replace_all</code></a> replaces all occurrences of the whole regex.
<code>&amp;str</code> implements the <code>Replacer</code> trait which allows variables like <code>$abcde</code> to
refer to corresponding named capture groups <code>(?P&lt;abcde&gt;REGEX)</code> from the search
regex. See the <a href="https://docs.rs/regex/*/regex/struct.Regex.html#replacement-string-syntax">replacement string syntax</a> for examples and escaping detail.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate regex;
#[macro_use]
extern crate lazy_static;

use std::borrow::Cow;
use regex::Regex;

fn reformat_dates(before: &amp;str) -&gt; Cow&lt;str&gt; {
    lazy_static! {
        static ref ISO8601_DATE_REGEX : Regex = Regex::new(
            r&quot;(?P&lt;y&gt;\d{4})-(?P&lt;m&gt;\d{2})-(?P&lt;d&gt;\d{2})&quot;
            ).unwrap();
    }
    ISO8601_DATE_REGEX.replace_all(before, &quot;$m/$d/$y&quot;)
}

fn main() {
    let before = &quot;2012-03-14, 2013-01-15 and 2014-07-05&quot;;
    let after = reformat_dates(before);
    assert_eq!(after, &quot;03/14/2012, 01/15/2013 and 07/05/2014&quot;);
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#string-parsing" id="string-parsing">String Parsing</a></h1>
<h2><a class="header" href="#collect-unicode-graphemes" id="collect-unicode-graphemes">Collect Unicode Graphemes</a></h2>
<p><a href="https://docs.rs/unicode-segmentation/1.2.1/unicode_segmentation/"><img src="https://badge-cache.kominick.com/crates/v/unicode-segmentation.svg?label=unicode-segmentation" alt="unicode-segmentation-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Collect individual Unicode graphemes from UTF-8 string using the 
<a href="https://docs.rs/unicode-segmentation/*/unicode_segmentation/trait.UnicodeSegmentation.html#tymethod.graphemes"><code>UnicodeSegmentation::graphemes</code></a> function from the <a href="https://docs.rs/unicode-segmentation/1.2.1/unicode_segmentation/"><code>unicode-segmentation</code></a> crate.</p>
<pre><pre class="playpen"><code class="language-rust">#[macro_use]
extern crate unicode_segmentation;
use unicode_segmentation::UnicodeSegmentation;

fn main() {
    let name = &quot;José Guimarães\r\n&quot;;
    let graphemes = UnicodeSegmentation::graphemes(name, true)
    	.collect::&lt;Vec&lt;&amp;str&gt;&gt;();
	assert_eq!(graphemes[3], &quot;é&quot;);
}
</code></pre></pre>
<h2><a class="header" href="#implement-the-fromstr-trait-for-a-custom-struct" id="implement-the-fromstr-trait-for-a-custom-struct">Implement the <code>FromStr</code> trait for a custom <code>struct</code></a></h2>
<p><a href="https://doc.rust-lang.org/std"><img src="https://badge-cache.kominick.com/badge/std-1.29.1-blue.svg" alt="std-badge" /></a> <a href="https://crates.io/categories/text-processing"><img src="https://badge-cache.kominick.com/badge/text_processing--x.svg?style=social" alt="cat-text-processing-badge" /></a></p>
<p>Creates a custom struct <code>RGB</code> and implements the <code>FromStr</code> trait to convert a provided color hex code into its RGB color code.</p>
<pre><pre class="playpen"><code class="language-rust">use std::str::FromStr;

#[derive(Debug, PartialEq)]
struct RGB {
    r: u8,
    g: u8,
    b: u8,
}

impl FromStr for RGB {
    type Err = std::num::ParseIntError;

    // Parses a color hex code of the form '#rRgGbB..' into an
    // instance of 'RGB'
    fn from_str(hex_code: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
	
        // u8::from_str_radix(src: &amp;str, radix: u32) converts a string
        // slice in a given base to u8
        let r: u8 = u8::from_str_radix(&amp;hex_code[1..3], 16)?;
        let g: u8 = u8::from_str_radix(&amp;hex_code[3..5], 16)?;
        let b: u8 = u8::from_str_radix(&amp;hex_code[5..7], 16)?;

        Ok(RGB { r, g, b })
    }
}

fn main() {
    let code: &amp;str = &amp;r&quot;#fa7268&quot;;
    match RGB::from_str(code) {
        Ok(rgb) =&gt; {
            println!(
                r&quot;The RGB color code is: R: {} G: {} B: {}&quot;,
                rgb.r, rgb.g, rgb.b
            );
        }
        Err(_) =&gt; {
            println!(&quot;{} is not a valid color hex code!&quot;, code);
        }
    }

    // test whether from_str performs as expected
    assert_eq!(
        RGB::from_str(&amp;r&quot;#fa7268&quot;).unwrap(),
        RGB {
            r: 250,
            g: 114,
            b: 104
        }
    );
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#web-programming-1" id="web-programming-1">Web Programming</a></h1>
<h2><a class="header" href="#scraping-web-pages-1" id="scraping-web-pages-1">Scraping Web Pages</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/web/scraping.html#extract-all-links-from-a-webpage-html">Extract all links from a webpage HTML</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/scraping.html#check-a-webpage-for-broken-links">Check webpage for broken links</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/scraping.html#extract-all-unique-links-from-a-mediawiki-markup">Extract all unique links from a MediaWiki markup</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
</tbody></table>
<h2><a class="header" href="#uniform-resource-locations-url-1" id="uniform-resource-locations-url-1">Uniform Resource Locations (URL)</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/web/url.html#parse-a-url-from-a-string-to-a-url-type">Parse a URL from a string to a <code>Url</code> type</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/url.html#create-a-base-url-by-removing-path-segments">Create a base URL by removing path segments</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/url.html#create-new-urls-from-a-base-url">Create new URLs from a base URL</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/url.html#extract-the-url-origin-scheme--host--port">Extract the URL origin (scheme / host / port)</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/url.html#remove-fragment-identifiers-and-query-pairs-from-a-url">Remove fragment identifiers and query pairs from a URL</a></td><td><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
</tbody></table>
<h2><a class="header" href="#media-types-mime-1" id="media-types-mime-1">Media Types (MIME)</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/web/mime.html#get-mime-type-from-string">Get MIME type from string</a></td><td><a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/mime.html#get-mime-type-from-filename">Get MIME type from filename</a></td><td><a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a></td><td><a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/mime.html#parse-the-mime-type-of-a-http-response">Parse the MIME type of a HTTP response</a></td><td><a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> <a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
</tbody></table>
<h2><a class="header" href="#clients-1" id="clients-1">Clients</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/web/clients/requests.html#make-a-http-get-request">Make a HTTP GET request</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/apis.html#query-the-github-api">Query the GitHub API</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/apis.html#check-if-an-api-resource-exists">Check if an API resource exists</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/apis.html#create-and-delete-gist-with-github-api">Create and delete Gist with GitHub API</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/apis.html#consume-a-paginated-restful-api">Consume a paginated RESTful API</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/download.html#download-a-file-to-a-temporary-directory">Download a file to a temporary directory</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://badge-cache.kominick.com/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/download.html#make-a-partial-download-with-http-range-headers">Make a partial download with HTTP range headers</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/clients/download.html#post-a-file-to-paste-rs">POST a file to paste-rs</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#extracting-links" id="extracting-links">Extracting Links</a></h1>
<h2><a class="header" href="#extract-all-links-from-a-webpage-html" id="extract-all-links-from-a-webpage-html">Extract all links from a webpage HTML</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Use <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> to perform a HTTP GET request and then use
<a href="https://docs.rs/select/*/select/document/struct.Document.html#method.from_read"><code>Document::from_read</code></a> to parse the response into a HTML document.
<a href="https://docs.rs/select/*/select/document/struct.Document.html#method.find"><code>find</code></a> with the criteria of <a href="https://docs.rs/select/*/select/predicate/struct.Name.html"><code>Name</code></a> is &quot;a&quot; retrieves all links.
Call <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html#method.filter_map"><code>filter_map</code></a> on the <a href="https://docs.rs/select/*/select/selection/struct.Selection.html"><code>Selection</code></a> retrieves URLs
from links that have the &quot;href&quot; <a href="https://docs.rs/select/*/select/node/struct.Node.html#method.attr"><code>attr</code></a> (attribute).</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate reqwest;
extern crate select;

use select::document::Document;
use select::predicate::Name;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">   foreign_links {
</span><span class="boring">       ReqError(reqwest::Error);
</span><span class="boring">       IoError(std::io::Error);
</span><span class="boring">   }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let res = reqwest::get(&quot;https://www.rust-lang.org/en-US/&quot;)?;

    Document::from_read(res)?
        .find(Name(&quot;a&quot;))
        .filter_map(|n| n.attr(&quot;href&quot;))
        .for_each(|x| println!(&quot;{}&quot;, x));

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#check-a-webpage-for-broken-links" id="check-a-webpage-for-broken-links">Check a webpage for broken links</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/select/"><img src="https://badge-cache.kominick.com/crates/v/select.svg?label=select" alt="select-badge" /></a> <a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Call <code>get_base_url</code> to retrieve the base URL. If the document has a base tag,
get the href <a href="https://docs.rs/select/*/select/node/struct.Node.html#method.attr"><code>attr</code></a> from base tag. <a href="https://docs.rs/url/*/url/enum.Position.html#variant.BeforePath"><code>Position::BeforePath</code></a> of the original
URL acts as a default.</p>
<p>Iterate through links in the document and parse with <a href="https://docs.rs/url/*/url/struct.ParseOptions.html"><code>url::ParseOptions</code></a>
and <a href="https://docs.rs/url/*/url/struct.Url.html#method.parse"><code>Url::parse</code></a>). Makes a request to the links with reqwest and verifies
<a href="https://docs.rs/reqwest/*/reqwest/struct.StatusCode.html"><code>StatusCode</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate reqwest;
extern crate select;
extern crate url;

use std::collections::HashSet;

use url::{Url, Position};
use reqwest::StatusCode;
use select::document::Document;
use select::predicate::Name;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">  foreign_links {
</span><span class="boring">      ReqError(reqwest::Error);
</span><span class="boring">      IoError(std::io::Error);
</span><span class="boring">      UrlParseError(url::ParseError);
</span><span class="boring">  }
</span><span class="boring">}
</span>
fn get_base_url(url: &amp;Url, doc: &amp;Document) -&gt; Result&lt;Url&gt; {
    let base_tag_href = doc.find(Name(&quot;base&quot;)).filter_map(|n| n.attr(&quot;href&quot;)).nth(0);

    let base_url = base_tag_href.map_or_else(
        || Url::parse(&amp;url[..Position::BeforePath]),
        Url::parse,
    )?;

    Ok(base_url)
}

fn check_link(url: &amp;Url) -&gt; Result&lt;bool&gt; {
    let res = reqwest::get(url.as_ref())?;

    Ok(res.status() != StatusCode::NOT_FOUND)
}

fn run() -&gt; Result&lt;()&gt; {
    let url = Url::parse(&quot;https://www.rust-lang.org/en-US/&quot;)?;

    let res = reqwest::get(url.as_ref())?;
    let document = Document::from_read(res)?;

    let base_url = get_base_url(&amp;url, &amp;document)?;

    let base_parser = Url::options().base_url(Some(&amp;base_url));

    let links: HashSet&lt;Url&gt; = document
        .find(Name(&quot;a&quot;))
        .filter_map(|n| n.attr(&quot;href&quot;))
        .filter_map(|link| base_parser.parse(link).ok())
        .collect();

    links
        .iter()
        .filter(|link| check_link(link).ok() == Some(false))
        .for_each(|x| println!(&quot;{} is broken.&quot;, x));

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#extract-all-unique-links-from-a-mediawiki-markup" id="extract-all-unique-links-from-a-mediawiki-markup">Extract all unique links from a MediaWiki markup</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/regex/"><img src="https://badge-cache.kominick.com/crates/v/regex.svg?label=regex" alt="regex-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Pull the source of a MediaWiki page using <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> and then
look for all entries of internal and external links with
<a href="https://docs.rs/regex/*/regex/struct.Regex.html#method.captures_iter"><code>Regex::captures_iter</code></a>. Using <a href="https://doc.rust-lang.org/std/borrow/enum.Cow.html"><code>Cow</code></a> avoids excessive <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a> allocations.</p>
<p>MediaWiki link syntax is described <a href="https://www.mediawiki.org/wiki/Help:Links">here</a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>#[macro_use]
extern crate lazy_static;
extern crate reqwest;
extern crate regex;

use std::io::Read;
use std::collections::HashSet;
use std::borrow::Cow;
use regex::Regex;

<span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        Reqwest(reqwest::Error);
</span><span class="boring">        Regex(regex::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn extract_links(content: &amp;str) -&gt; Result&lt;HashSet&lt;Cow&lt;str&gt;&gt;&gt; {
    lazy_static! {
        static ref WIKI_REGEX: Regex =
            Regex::new(r&quot;(?x)
                \[\[(?P&lt;internal&gt;[^\[\]|]*)[^\[\]]*\]\]    # internal links
                |
                (url=|URL\||\[)(?P&lt;external&gt;http.*?)[ \|}] # external links
            &quot;).unwrap();
    }

    let links: HashSet&lt;_&gt; = WIKI_REGEX
        .captures_iter(content)
        .map(|c| match (c.name(&quot;internal&quot;), c.name(&quot;external&quot;)) {
            (Some(val), None) =&gt; Cow::from(val.as_str().to_lowercase()),
            (None, Some(val)) =&gt; Cow::from(val.as_str()),
            _ =&gt; unreachable!(),
        })
        .collect();

    Ok(links)
}

fn run() -&gt; Result&lt;()&gt; {
    let mut content = String::new();
    reqwest::get(
        &quot;https://en.wikipedia.org/w/index.php?title=Rust_(programming_language)&amp;action=raw&quot;,
    )?
        .read_to_string(&amp;mut content)?;

    println!(&quot;{:#?}&quot;, extract_links(&amp;content)?);

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#uniform-resource-location" id="uniform-resource-location">Uniform Resource Location</a></h1>
<h2><a class="header" href="#parse-a-url-from-a-string-to-a-url-type" id="parse-a-url-from-a-string-to-a-url-type">Parse a URL from a string to a <code>Url</code> type</a></h2>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/*/url/struct.Url.html#method.parse"><code>parse</code></a> method from the <code>url</code> crate validates and parses a <code>&amp;str</code> into a
<a href="https://docs.rs/url/*/url/struct.Url.html"><code>Url</code></a> struct. The input string may be malformed so this method returns
<code>Result&lt;Url, ParseError&gt;</code>.</p>
<p>Once the URL has been parsed, it can be used with all of the methods in the
<code>Url</code> type.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;

use url::{Url, ParseError};

fn main() -&gt; Result&lt;(), ParseError&gt; {
    let s = &quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;;

    let parsed = Url::parse(s)?;
    println!(&quot;The path part of the URL is: {}&quot;, parsed.path());

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#create-a-base-url-by-removing-path-segments" id="create-a-base-url-by-removing-path-segments">Create a base URL by removing path segments</a></h2>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>A base URL includes a protocol and a domain.  Base URLs have no folders,
files or query strings.  Each of those items are stripped out of the given
URL.  <a href="https://docs.rs/url/*/url/struct.PathSegmentsMut.html#method.clear"><code>PathSegmentsMut::clear</code></a> removes paths and <a href="https://docs.rs/url/*/url/struct.Url.html#method.set_query"><code>Url::set_query</code></a> removes
query string.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate url;

use url::Url;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        UrlParse(url::ParseError);
</span><span class="boring">    }
</span><span class="boring">    errors {
</span><span class="boring">        CannotBeABase
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let full = &quot;https://github.com/rust-lang/cargo?asdf&quot;;

    let url = Url::parse(full)?;
    let base = base_url(url)?;

    assert_eq!(base.as_str(), &quot;https://github.com/&quot;);
    println!(&quot;The base of the URL is: {}&quot;, base);

    Ok(())
}

fn base_url(mut url: Url) -&gt; Result&lt;Url&gt; {
    match url.path_segments_mut() {
        Ok(mut path) =&gt; {
            path.clear();
        }
        Err(_) =&gt; {
            return Err(Error::from_kind(ErrorKind::CannotBeABase));
        }
    }

    url.set_query(None);

    Ok(url)
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#create-new-urls-from-a-base-url" id="create-new-urls-from-a-base-url">Create new URLs from a base URL</a></h2>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/*/url/struct.Url.html#method.join"><code>join</code></a> method creates a new URL from a base and relative path.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;

use url::{Url, ParseError};

fn main() -&gt; Result&lt;(), ParseError&gt; {
    let path = &quot;/rust-lang/cargo&quot;;

    let gh = build_github_url(path)?;

    assert_eq!(gh.as_str(), &quot;https://github.com/rust-lang/cargo&quot;);
    println!(&quot;The joined URL is: {}&quot;, gh);

    Ok(())
}

fn build_github_url(path: &amp;str) -&gt; Result&lt;Url, ParseError&gt; {
    const GITHUB: &amp;'static str = &quot;https://github.com&quot;;

    let base = Url::parse(GITHUB).expect(&quot;hardcoded URL is known to be valid&quot;);
    let joined = base.join(path)?;

    Ok(joined)
}
</code></pre></pre>
<h2><a class="header" href="#extract-the-url-origin-scheme--host--port" id="extract-the-url-origin-scheme--host--port">Extract the URL origin (scheme / host / port)</a></h2>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>The <a href="https://docs.rs/url/*/url/struct.Url.html"><code>Url</code></a> struct exposes various methods to extract information about the URL
it represents.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate url;

use url::{Url, Host, ParseError};

fn main() -&gt; Result&lt;(), ParseError&gt; {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    let url = Url::parse(s)?;

    assert_eq!(url.scheme(), &quot;ftp&quot;);
    assert_eq!(url.host(), Some(Host::Domain(&quot;rust-lang.org&quot;)));
    assert_eq!(url.port_or_known_default(), Some(21));
    println!(&quot;The origin is as expected!&quot;);

    Ok(())
}
</code></pre></pre>
<p><a href="https://docs.rs/url/*/url/struct.Url.html#method.origin"><code>origin</code></a> produces the same result.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate url;

use url::{Url, Origin, Host};

<span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        UrlParse(url::ParseError);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn run() -&gt; Result&lt;()&gt; {
    let s = &quot;ftp://rust-lang.org/examples&quot;;

    let url = Url::parse(s)?;

    let expected_scheme = &quot;ftp&quot;.to_owned();
    let expected_host = Host::Domain(&quot;rust-lang.org&quot;.to_owned());
    let expected_port = 21;
    let expected = Origin::Tuple(expected_scheme, expected_host, expected_port);

    let origin = url.origin();
    assert_eq!(origin, expected);
    println!(&quot;The origin is as expected!&quot;);

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#remove-fragment-identifiers-and-query-pairs-from-a-url" id="remove-fragment-identifiers-and-query-pairs-from-a-url">Remove fragment identifiers and query pairs from a URL</a></h2>
<p><a href="https://docs.rs/url/"><img src="https://badge-cache.kominick.com/crates/v/url.svg?label=url" alt="url-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Parses <a href="https://docs.rs/url/*/url/struct.Url.html"><code>Url</code></a> and slices it with <a href="https://docs.rs/url/*/url/enum.Position.html"><code>url::Position</code></a> to strip unneeded URL parts.</p>
<pre><pre class="playpen"><code class="language-rust">
extern crate url;

use url::{Url, Position, ParseError};

fn main() -&gt; Result&lt;(), ParseError&gt; {
    let parsed = Url::parse(&quot;https://github.com/rust-lang/rust/issues?labels=E-easy&amp;state=open&quot;)?;
    let cleaned: &amp;str = &amp;parsed[..Position::AfterPath];
    println!(&quot;cleaned: {}&quot;, cleaned);
    Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#media-types" id="media-types">Media Types</a></h1>
<h2><a class="header" href="#get-mime-type-from-string" id="get-mime-type-from-string">Get MIME type from string</a></h2>
<p><a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The following example shows how to parse a <a href="https://docs.rs/mime/*/mime/struct.Mime.html"><code>MIME</code></a> type from a string using the
<a href="https://docs.rs/mime/">mime</a> crate. <a href="https://docs.rs/mime/*/mime/struct.FromStrError.html"><code>FromStrError</code></a> produces a default <a href="https://docs.rs/mime/*/mime/struct.Mime.html"><code>MIME</code></a> type in an
<code>unwrap_or</code> clause.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate mime;
use mime::{Mime, APPLICATION_OCTET_STREAM};

fn main() {
    let invalid_mime_type = &quot;i n v a l i d&quot;;
    let default_mime = invalid_mime_type
        .parse::&lt;Mime&gt;()
        .unwrap_or(APPLICATION_OCTET_STREAM);

    println!(
        &quot;MIME for {:?} used default value {:?}&quot;,
        invalid_mime_type, default_mime
    );

    let valid_mime_type = &quot;TEXT/PLAIN&quot;;
    let parsed_mime = valid_mime_type
        .parse::&lt;Mime&gt;()
        .unwrap_or(APPLICATION_OCTET_STREAM);

    println!(
        &quot;MIME for {:?} was parsed as {:?}&quot;,
        valid_mime_type, parsed_mime
    );
}
</code></pre></pre>
<h2><a class="header" href="#get-mime-type-from-filename" id="get-mime-type-from-filename">Get MIME type from filename</a></h2>
<p><a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>The following example shows how to return the correct MIME type from a given
filename using the <a href="https://docs.rs/mime/">mime</a> crate.  The program will check for file extensions
and match against a known list.  The return value is <a href="https://docs.rs/mime/*/mime/struct.Mime.html"><code>mime:Mime</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust">extern crate mime;
use mime::Mime;

fn find_mimetype (filename : &amp;String) -&gt; Mime{

    let parts : Vec&lt;&amp;str&gt; = filename.split('.').collect();

    let res = match parts.last() {
            Some(v) =&gt;
                match *v {
                    &quot;png&quot; =&gt; mime::IMAGE_PNG,
                    &quot;jpg&quot; =&gt; mime::IMAGE_JPEG,
                    &quot;json&quot; =&gt; mime::APPLICATION_JSON,
                    &amp;_ =&gt; mime::TEXT_PLAIN,
                },
            None =&gt; mime::TEXT_PLAIN,
        };
    return res;
}

fn main() {
    let filenames = vec!(&quot;foobar.jpg&quot;, &quot;foo.bar&quot;, &quot;foobar.png&quot;);
    for file in filenames {
	    let mime = find_mimetype(&amp;file.to_owned());
	 	println!(&quot;MIME for {}: {}&quot;, file, mime);
	 }

}
</code></pre></pre>
<h2><a class="header" href="#parse-the-mime-type-of-a-http-response" id="parse-the-mime-type-of-a-http-response">Parse the MIME type of a HTTP response</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/mime/"><img src="https://badge-cache.kominick.com/crates/v/csv.svg?label=mime" alt="mime-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>When receiving a HTTP reponse from <code>reqwest</code> the <a href="https://developer.mozilla.org/docs/Web/HTTP/Basics_of_HTTP/MIME_types">MIME type</a> or media type may be
found in the <a href="https://developer.mozilla.org/docs/Web/HTTP/Headers/Content-Type">Content-Type</a> header. <a href="https://docs.rs/reqwest/*/reqwest/header/struct.HeaderMap.html#method.get"><code>reqwest::header::HeaderMap::get</code></a> retrieves
the header as a <a href="https://docs.rs/reqwest/*/reqwest/header/struct.HeaderValue.html"><code>reqwest::header::HeaderValue</code></a>, which can be converted to a
string. The <code>mime</code> crate can then parse that, yielding a <a href="https://docs.rs/mime/*/mime/struct.Mime.html"><code>mime::Mime</code></a> value.</p>
<p>The <code>mime</code> crate also defines some commonly used MIME types.</p>
<p>Note that the <a href="https://docs.rs/reqwest/*/reqwest/header/index.html"><code>reqwest::header</code></a> module is exported from the <a href="https://docs.rs/http/*/http/"><code>http</code></a> crate.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate mime;
extern crate reqwest;

use mime::Mime;
use std::str::FromStr;
use reqwest::header::CONTENT_TYPE;

<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">   foreign_links {
</span><span class="boring">       Reqwest(reqwest::Error);
</span><span class="boring">       Header(reqwest::header::ToStrError);
</span><span class="boring">       Mime(mime::FromStrError);
</span><span class="boring">   }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let response = reqwest::get(&quot;https://www.rust-lang.org/logos/rust-logo-32x32.png&quot;)?;
    let headers = response.headers();

    match headers.get(CONTENT_TYPE) {
        None =&gt; {
            println!(&quot;The response does not contain a Content-Type header.&quot;);
        }
        Some(content_type) =&gt; {
            let content_type = Mime::from_str(content_type.to_str()?)?;
            let media_type = match (content_type.type_(), content_type.subtype()) {
                (mime::TEXT, mime::HTML) =&gt; &quot;a HTML document&quot;,
                (mime::TEXT, _) =&gt; &quot;a text document&quot;,
                (mime::IMAGE, mime::PNG) =&gt; &quot;a PNG image&quot;,
                (mime::IMAGE, _) =&gt; &quot;an image&quot;,
                _ =&gt; &quot;neither text nor image&quot;,
            };

            println!(&quot;The reponse contains {}.&quot;, media_type);
        }
    };

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h2><a class="header" href="#clients-2" id="clients-2">Clients</a></h2>
<table><thead><tr><th>Recipe</th><th>Crates</th><th>Categories</th></tr></thead><tbody>
<tr><td><a href="rustcookbook/web/web/clients/requests.html#make-a-http-get-request">Make a HTTP GET request</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/web/clients/apis.html#query-the-github-api">Query the GitHub API</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/web/clients/apis.html#check-if-an-api-resource-exists">Check if an API resource exists</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/web/clients/apis.html#create-and-delete-gist-with-github-api">Create and delete Gist with GitHub API</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/web/clients/apis.html#consume-a-paginated-restful-api">Consume a paginated RESTful API</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/web/clients/download.html#download-a-file-to-a-temporary-directory">Download a file to a temporary directory</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://badge-cache.kominick.com/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/web/clients/download.html#make-a-partial-download-with-http-range-headers">Make a partial download with HTTP range headers</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
<tr><td><a href="rustcookbook/web/web/clients/download.html#post-a-file-to-paste-rs">POST a file to paste-rs</a></td><td><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a></td><td><a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></td></tr>
</tbody></table>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#making-requests" id="making-requests">Making Requests</a></h1>
<h2><a class="header" href="#make-a-http-get-request" id="make-a-http-get-request">Make a HTTP GET request</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Parses the supplied URL and makes a synchronous HTTP GET request
with <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a>. Prints obtained <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html"><code>reqwest::Response</code></a>
status and headers. Reads HTTP response body into an allocated <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a>
using <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate reqwest;

use std::io::Read;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        HttpRequest(reqwest::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let mut res = reqwest::get(&quot;http://httpbin.org/get&quot;)?;
    let mut body = String::new();
    res.read_to_string(&amp;mut body)?;

    println!(&quot;Status: {}&quot;, res.status());
    println!(&quot;Headers:\n{:#?}&quot;, res.headers());
    println!(&quot;Body:\n{}&quot;, body);

    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#calling-a-web-api" id="calling-a-web-api">Calling a Web API</a></h1>
<h2><a class="header" href="#query-the-github-api" id="query-the-github-api">Query the GitHub API</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Queries GitHub <a href="https://developer.github.com/v3/activity/starring/#list-stargazers">stargazers API v3</a>
with <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a> to get list of all users who have marked a GitHub project with a star. <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html"><code>reqwest::Response</code></a> is deserialized with <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html#method.json"><code>Response::json</code></a> into <code>User</code> objects implementing <a href="https://docs.rs/serde/*/serde/trait.Deserialize.html"><code>serde::Deserialize</code></a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run">#[macro_use]
extern crate serde_derive;
extern crate reqwest;
use reqwest::Error;

#[derive(Deserialize, Debug)]
struct User {
    login: String,
    id: u32,
}

fn main() -&gt; Result&lt;(), Error&gt; {
    let request_url = format!(&quot;https://api.github.com/repos/{owner}/{repo}/stargazers&quot;,
                              owner = &quot;rust-lang-nursery&quot;,
                              repo = &quot;rust-cookbook&quot;);
    println!(&quot;{}&quot;, request_url);
    let mut response = reqwest::get(&amp;request_url)?;

    let users: Vec&lt;User&gt; = response.json()?;
    println!(&quot;{:?}&quot;, users);
    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#check-if-an-api-resource-exists" id="check-if-an-api-resource-exists">Check if an API resource exists</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Query the GitHub Users Endpoint using a HEAD
request (<a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.head"><code>Client::head</code></a>) and then inspect the response code to determine
success. This is a quick way to query a rest resource without needing to receive
a body. <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a> cofigured with <a href="https://docs.rs/reqwest/*/reqwest/struct.ClientBuilder.html#method.timeout"><code>ClientBuilder::timeout</code></a> ensures
a request will not last longer than a timeout.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate reqwest;

use reqwest::Error;
use std::time::Duration;
use reqwest::ClientBuilder;


fn main() -&gt; Result&lt;(), Error&gt; {
    let user = &quot;ferris-the-crab&quot;;
    let request_url = format!(&quot;https://api.github.com/users/{}&quot;, user);
    println!(&quot;{}&quot;, request_url);

    let timeout = Duration::new(5, 0);
    let client = ClientBuilder::new().timeout(timeout).build()?;
    let response = client.head(&amp;request_url).send()?;

    if response.status().is_success() {
        println!(&quot;{} is a user!&quot;, user);
    } else {
        println!(&quot;{} is not a user!&quot;, user);
    }

    Ok(())
}
</code></pre></pre>
<h2><a class="header" href="#create-and-delete-gist-with-github-api" id="create-and-delete-gist-with-github-api">Create and delete Gist with GitHub API</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Creates a gist with POST request to GitHub <a href="https://developer.github.com/v3/gists/">gists API v3</a>
using <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.post"><code>Client::post</code></a> and removes it with DELETE request using <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.delete"><code>Client::delete</code></a>.</p>
<p>The <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a> is responsible for details of both requests including
URL, body and authentication. The POST body from <a href="https://docs.rs/serde_json/*/serde_json/macro.json.html"><code>serde_json::json!</code></a> macro
provides arbitrary JSON body. Call to <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.json"><code>RequestBuilder::json</code></a> sets the request
body. <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.basic_auth"><code>RequestBuilder::basic_auth</code></a> handles authentication. The call to
<a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.send"><code>RequestBuilder::send</code></a> synchronously executes the requests.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate reqwest;
#[macro_use]
extern crate serde_derive;
#[macro_use]
extern crate serde_json;

use std::env;
use reqwest::Client;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        EnvVar(env::VarError);
</span><span class="boring">        HttpRequest(reqwest::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
#[derive(Deserialize, Debug)]
struct Gist {
    id: String,
    html_url: String,
}

fn run() -&gt; Result&lt;()&gt; {
    let gh_user = env::var(&quot;GH_USER&quot;)?;
    let gh_pass = env::var(&quot;GH_PASS&quot;)?;

    let gist_body = json!({
        &quot;description&quot;: &quot;the description for this gist&quot;,
        &quot;public&quot;: true,
        &quot;files&quot;: {
             &quot;main.rs&quot;: {
             &quot;content&quot;: r#&quot;fn main() { println!(&quot;hello world!&quot;);}&quot;#
            }
        }});

    let request_url = &quot;https://api.github.com/gists&quot;;
    let mut response = Client::new()
        .post(request_url)
        .basic_auth(gh_user.clone(), Some(gh_pass.clone()))
        .json(&amp;gist_body)
        .send()?;

    let gist: Gist = response.json()?;
    println!(&quot;Created {:?}&quot;, gist);

    let request_url = format!(&quot;{}/{}&quot;,request_url, gist.id);
    let response = Client::new()
        .delete(&amp;request_url)
        .basic_auth(gh_user, Some(gh_pass))
        .send()?;

    println!(&quot;Gist {} deleted! Status code: {}&quot;,gist.id, response.status());
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<p>The example uses <a href="https://tools.ietf.org/html/rfc2617">HTTP Basic Auth</a> in order to authorize access to <a href="https://developer.github.com/v3/auth/">GitHub API</a>.
Typical use case would employ one of the much more complex <a href="https://oauth.net/getting-started/">OAuth</a> authorization
flows.</p>
<h2><a class="header" href="#consume-a-paginated-restful-api" id="consume-a-paginated-restful-api">Consume a paginated RESTful API</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/serde/"><img src="https://badge-cache.kominick.com/crates/v/serde.svg?label=serde" alt="serde-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/encoding"><img src="https://badge-cache.kominick.com/badge/encoding--x.svg?style=social" alt="cat-encoding-badge" /></a></p>
<p>Wraps a paginated web API in a convenient Rust iterator. The iterator lazily
fetches the next page of results from the remote server as it arrives at the end
of each page.</p>
<pre><pre class="playpen"><code class="language-rust no_run">#[macro_use]
extern crate serde_derive;
extern crate reqwest;
use reqwest::Error;

#[derive(Deserialize)]
struct ApiResponse {
    dependencies: Vec&lt;Dependency&gt;,
    meta: Meta,
}

#[derive(Deserialize)]
struct Dependency {
    crate_id: String,
}

#[derive(Deserialize)]
struct Meta {
    total: u32,
}

struct ReverseDependencies {
    crate_id: String,
    dependencies: &lt;Vec&lt;Dependency&gt; as IntoIterator&gt;::IntoIter,
    client: reqwest::Client,
    page: u32,
    per_page: u32,
    total: u32,
}

impl ReverseDependencies {
    fn of(crate_id: &amp;str) -&gt; Result&lt;Self, Error&gt; {
        Ok(ReverseDependencies {
               crate_id: crate_id.to_owned(),
               dependencies: vec![].into_iter(),
               client: reqwest::Client::new(),
               page: 0,
               per_page: 100,
               total: 0,
           })
    }

    fn try_next(&amp;mut self) -&gt; Result&lt;Option&lt;Dependency&gt;, Error&gt; {
        if let Some(dep) = self.dependencies.next() {
            return Ok(Some(dep));
        }

        if self.page &gt; 0 &amp;&amp; self.page * self.per_page &gt;= self.total {
            return Ok(None);
        }

        self.page += 1;
        let url = format!(&quot;https://crates.io/api/v1/crates/{}/reverse_dependencies?page={}&amp;per_page={}&quot;,
                          self.crate_id,
                          self.page,
                          self.per_page);

        let response = self.client.get(&amp;url).send()?.json::&lt;ApiResponse&gt;()?;
        self.dependencies = response.dependencies.into_iter();
        self.total = response.meta.total;
        Ok(self.dependencies.next())
    }
}

impl Iterator for ReverseDependencies {
    type Item = Result&lt;Dependency, Error&gt;;

    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        match self.try_next() {
            Ok(Some(dep)) =&gt; Some(Ok(dep)),
            Ok(None) =&gt; None,
            Err(err) =&gt; Some(Err(err)),
        }
    }
}

fn main() -&gt; Result&lt;(), Error&gt; {
    for dep in ReverseDependencies::of(&quot;serde&quot;)? {
        println!(&quot;reverse dependency: {}&quot;, dep?.crate_id);
    }
    Ok(())
}
</code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->
<h1><a class="header" href="#downloads" id="downloads">Downloads</a></h1>
<h2><a class="header" href="#download-a-file-to-a-temporary-directory" id="download-a-file-to-a-temporary-directory">Download a file to a temporary directory</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://docs.rs/tempdir/"><img src="https://badge-cache.kominick.com/crates/v/tempdir.svg?label=tempdir" alt="tempdir-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a> <a href="https://crates.io/categories/filesystem"><img src="https://badge-cache.kominick.com/badge/filesystem--x.svg?style=social" alt="cat-filesystem-badge" /></a></p>
<p>Creates a temporary directory with <a href="https://docs.rs/tempdir/*/tempdir/struct.TempDir.html#method.new"><code>TempDir::new</code></a> and synchronously downloads
a file over HTTP using <a href="https://docs.rs/reqwest/*/reqwest/fn.get.html"><code>reqwest::get</code></a>.</p>
<p>Creates a target <a href="https://doc.rust-lang.org/std/fs/struct.File.html"><code>File</code></a> with name obtained from <a href="https://docs.rs/reqwest/*/reqwest/struct.Response.html#method.url"><code>Response::url</code></a> within
<a href="https://docs.rs/tempdir/*/tempdir/struct.TempDir.html#method.path"><code>TempDir::path</code></a> and copies downloaded data into it with <a href="https://doc.rust-lang.org/std/io/fn.copy.html"><code>io::copy</code></a>.
The temporary directory is automatically removed on <code>run</code> function return.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate reqwest;
extern crate tempdir;

use std::io::copy;
use std::fs::File;
use tempdir::TempDir;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        HttpRequest(reqwest::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let tmp_dir = TempDir::new(&quot;example&quot;)?;
    let target = &quot;https://www.rust-lang.org/logos/rust-logo-512x512.png&quot;;
    let mut response = reqwest::get(target)?;

    let mut dest = {
        let fname = response
            .url()
            .path_segments()
            .and_then(|segments| segments.last())
            .and_then(|name| if name.is_empty() { None } else { Some(name) })
            .unwrap_or(&quot;tmp.bin&quot;);

        println!(&quot;file to download: '{}'&quot;, fname);
        let fname = tmp_dir.path().join(fname);
        println!(&quot;will be located under: '{:?}'&quot;, fname);
        File::create(fname)?
    };
    copy(&amp;mut response, &amp;mut dest)?;
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#post-a-file-to-paste-rs" id="post-a-file-to-paste-rs">POST a file to paste-rs</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p><a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html"><code>reqwest::Client</code></a> establishes a connection to https://paste.rs
following the <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html"><code>reqwest::RequestBuilder</code></a> pattern.  Calling <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.post"><code>Client::post</code></a>
with a URL establishes the destination, <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.body"><code>RequestBuilder::body</code></a> sets the
content to send by reading the file, and <a href="https://docs.rs/reqwest/*/reqwest/struct.RequestBuilder.html#method.send"><code>RequestBuilder::send</code></a> blocks until
the file uploads and the response returns.  <a href="https://doc.rust-lang.org/std/io/trait.Read.html#method.read_to_string"><code>read_to_string</code></a> returns the
response and displays in the console.</p>
<pre><pre class="playpen"><code class="language-rust no_run">extern crate reqwest;

<span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span><span class="boring">
</span>use std::fs::File;
use std::io::Read;
use reqwest::Client;
<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        HttpRequest(reqwest::Error);
</span><span class="boring">        IoError(::std::io::Error);
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let paste_api = &quot;https://paste.rs&quot;;
    let file = File::open(&quot;message&quot;)?;

    let mut response = Client::new().post(paste_api).body(file).send()?;
    let mut response_body = String::new();
    response.read_to_string(&amp;mut response_body)?;
    println!(&quot;Your paste is located at: {}&quot;, response_body);
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<h2><a class="header" href="#make-a-partial-download-with-http-range-headers" id="make-a-partial-download-with-http-range-headers">Make a partial download with HTTP range headers</a></h2>
<p><a href="https://docs.rs/reqwest/"><img src="https://badge-cache.kominick.com/crates/v/reqwest.svg?label=reqwest" alt="reqwest-badge" /></a> <a href="https://crates.io/categories/network-programming"><img src="https://badge-cache.kominick.com/badge/net--x.svg?style=social" alt="cat-net-badge" /></a></p>
<p>Uses <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.head"><code>reqwest::Client::head</code></a> to get the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length">Content-Length</a> of the response.</p>
<p>The code then uses <a href="https://docs.rs/reqwest/*/reqwest/struct.Client.html#method.get"><code>reqwest::Client::get</code></a> to download the content in
chunks of 10240 bytes, while printing progress messages. The <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range">Range</a> header specifies the chunk size and position.</p>
<p>The Range header is defined in <a href="https://tools.ietf.org/html/rfc7233#section-3.1">RFC7233</a>.</p>
<pre><pre class="playpen"><code class="language-rust no_run"><span class="boring">#[macro_use]
</span><span class="boring">extern crate error_chain;
</span>extern crate reqwest;

use std::fs::File;
use std::str::FromStr;
use reqwest::header::{HeaderValue, CONTENT_LENGTH, RANGE};
use reqwest::StatusCode;

<span class="boring">
</span><span class="boring">error_chain! {
</span><span class="boring">    foreign_links {
</span><span class="boring">        Io(std::io::Error);
</span><span class="boring">        Reqwest(reqwest::Error);
</span><span class="boring">        Header(reqwest::header::ToStrError);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct PartialRangeIter {
</span><span class="boring">    start: u64,
</span><span class="boring">    end: u64,
</span><span class="boring">    buffer_size: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl PartialRangeIter {
</span><span class="boring">    pub fn new(start: u64, end: u64, buffer_size: u32) -&gt; Result&lt;Self&gt; {
</span><span class="boring">        if buffer_size == 0 {
</span><span class="boring">            Err(&quot;invalid buffer_size, give a value greater than zero.&quot;)?;
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        Ok(PartialRangeIter {
</span><span class="boring">            start,
</span><span class="boring">            end,
</span><span class="boring">            buffer_size,
</span><span class="boring">        })
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Iterator for PartialRangeIter {
</span><span class="boring">    type Item = HeaderValue;
</span><span class="boring">
</span><span class="boring">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
</span><span class="boring">        if self.start &gt; self.end {
</span><span class="boring">            None
</span><span class="boring">        } else {
</span><span class="boring">            let prev_start = self.start;
</span><span class="boring">            self.start += std::cmp::min(self.buffer_size as u64, self.end - self.start + 1);
</span><span class="boring">            // NOTE(unwrap): `HeaderValue::from_str` will fail only if the value is not made
</span><span class="boring">            // of visible ASCII characters. Since the format string is static and the two
</span><span class="boring">            // values are integers, that can't happen.
</span><span class="boring">            Some(HeaderValue::from_str(&amp;format!(&quot;bytes={}-{}&quot;, prev_start, self.start - 1)).unwrap())
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span>
fn run() -&gt; Result&lt;()&gt; {
    let url = &quot;https://httpbin.org/range/102400?duration=2&quot;;
    const CHUNK_SIZE: u32 = 10240;

    let client = reqwest::Client::new();
    let response = client.head(url).send()?;
    let length = response
        .headers()
        .get(CONTENT_LENGTH)
        .ok_or(&quot;response doesn't include the content length&quot;)?;
    let length = u64::from_str(length.to_str()?).map_err(|_| &quot;invalid Content-Length header&quot;)?;

    let mut output_file = File::create(&quot;download.bin&quot;)?;

    println!(&quot;starting download...&quot;);
    for range in PartialRangeIter::new(0, length - 1, CHUNK_SIZE)? {
        println!(&quot;range {:?}&quot;, range);
        let mut response = client.get(url).header(RANGE, range).send()?;

        let status = response.status();
        if !(status == StatusCode::OK || status == StatusCode::PARTIAL_CONTENT) {
            bail!(&quot;Unexpected server response: {}&quot;, status)
        }

        std::io::copy(&amp;mut response, &amp;mut output_file)?;
    }

    println!(&quot;Finished with success!&quot;);
    Ok(())
}
<span class="boring">
</span><span class="boring">quick_main!(run);
</span></code></pre></pre>
<!--
Links, in a few categories. Follow the existing structure.
Keep lines sorted.
-->
<!-- Categories -->
<!-- Crates -->

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        
        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3001");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload(true); // force reload from server (not from cache)
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
